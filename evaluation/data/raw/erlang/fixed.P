-file("test/lib/orber/src/fixed.erl", 1).

-module(fixed).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/orber-3.6.24/include/corba.hrl",
      1).

-record(orb_ImplDef,{node,module,typename,start = start,args = [[]],pid}).

-record(any,{typecode,value}).

-record(fixed,{digits,scale,value}).

-record('IOP_ServiceContext',{context_id,context_data}).

-record('InvalidName',{'OE_ID' = "IDL:omg.org/CORBA/ORB/InvalidName:1.0"}).

-record('UNKNOWN',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('BAD_PARAM',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('NO_MEMORY',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('IMP_LIMIT',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('COMM_FAILURE',{'OE_ID' = "",
                        minor = 1163001856,
                        completion_status}).

-record('INV_OBJREF',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('NO_PERMISSION',{'OE_ID' = "",
                         minor = 1163001856,
                         completion_status}).

-record('INTERNAL',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('MARSHAL',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('INITIALIZE',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('NO_IMPLEMENT',{'OE_ID' = "",
                        minor = 1163001856,
                        completion_status}).

-record('BAD_TYPECODE',{'OE_ID' = "",
                        minor = 1163001856,
                        completion_status}).

-record('BAD_OPERATION',{'OE_ID' = "",
                         minor = 1163001856,
                         completion_status}).

-record('NO_RESOURCES',{'OE_ID' = "",
                        minor = 1163001856,
                        completion_status}).

-record('NO_RESPONSE',{'OE_ID' = "",
                       minor = 1163001856,
                       completion_status}).

-record('PERSIST_STORE',{'OE_ID' = "",
                         minor = 1163001856,
                         completion_status}).

-record('BAD_INV_ORDER',{'OE_ID' = "",
                         minor = 1163001856,
                         completion_status}).

-record('TRANSIENT',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('FREE_MEM',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('INV_IDENT',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('INV_FLAG',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('INTF_REPOS',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('BAD_CONTEXT',{'OE_ID' = "",
                       minor = 1163001856,
                       completion_status}).

-record('OBJ_ADAPTER',{'OE_ID' = "",
                       minor = 1163001856,
                       completion_status}).

-record('DATA_CONVERSION',{'OE_ID' = "",
                           minor = 1163001856,
                           completion_status}).

-record('OBJECT_NOT_EXIST',{'OE_ID' = "",
                            minor = 1163001856,
                            completion_status}).

-record('TRANSACTION_REQUIRED',{'OE_ID' = "",
                                minor = 1163001856,
                                completion_status}).

-record('TRANSACTION_ROLLEDBACK',{'OE_ID' = "",
                                  minor = 1163001856,
                                  completion_status}).

-record('INVALID_TRANSACTION',{'OE_ID' = "",
                               minor = 1163001856,
                               completion_status}).

-record('INV_POLICY',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('CODESET_INCOMPATIBLE',{'OE_ID' = "",
                                minor = 1163001856,
                                completion_status}).

-record('REBIND',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('TIMEOUT',{'OE_ID' = "",minor = 1163001856,completion_status}).

-record('TRANSACTION_UNAVAILABLE',{'OE_ID' = "",
                                   minor = 1163001856,
                                   completion_status}).

-record('TRANSACTION_MODE',{'OE_ID' = "",
                            minor = 1163001856,
                            completion_status}).

-record('BAD_QOS',{'OE_ID' = "",minor = 1163001856,completion_status}).

-file("test/lib/orber/src/fixed.erl", 29).

-export([create/3,
         add/2,
         subtract/2,
         divide/2,
         multiply/2,
         unary_minus/1,
         get_typecode/1]).

-export([]).

create(Digits, Scale, Value)
    when
        is_integer(Digits)
        andalso
        Digits >= 0
        andalso
        Digits < 32
        andalso
        is_integer(Scale)
        andalso
        Scale >= 0
        andalso
        Digits >= Scale
        andalso
        is_integer(Value)
        andalso
        Value =< 9999999999999999999999999999999
        andalso
        Value >= - 9999999999999999999999999999999 ->
    case count_digits(abs(Value)) of
        Dig when Dig =< Digits ->
            #fixed{digits = Digits,scale = Scale,value = Value};
        Overflow ->
            orber:dbg("[~p] fixed:create(~p, ~p, ~p).~nThe Value exceed"
                      "s the Digits limit: ~p, ~p",
                      [66,Digits,Scale,Value,Digits,Overflow],
                      5),
            corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'})
    end;
create(Digits, Scale, Value) ->
    orber:dbg("[~p] fixed:add(~p, ~p, ~p).~nAt least one of the supplie"
              "d arguments is incorrect.~nDigits and Scale must be a po"
              "sitive integer with the following~nlimits:~n * 0 =< Digi"
              "ts < 32~n * Digits >= Scale~n * Value range +/- 99999999"
              "99999999999999999999999",
              [77,Digits,Scale,Value],
              5),
    corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'}).

get_typecode(#fixed{digits = Digits,scale = Scale}) ->
    {tk_fixed,Digits,Scale};
get_typecode(Other) ->
    orber:dbg("[~p] fixed:get_typecode(~p).\nThe supplied argument is n"
              "ot a Fixed Type.",
              [85,Other],
              5),
    corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'}).

add(#fixed{digits = D1,scale = S1,value = V1},
    #fixed{digits = D2,scale = S2,value = V2}) ->
    Scale =
        if
            S1 > S2 ->
                S1;
            true ->
                S2
        end,
    Digits =
        if
            D1 - S1 > D2 - S2 ->
                D1 - S1;
            true ->
                D2 - S2
        end
        +
        Scale
        +
        1,
    {PV1,PV2} = normalize(S1, V1, S2, V2),
    check_fixed_overflow(#fixed{digits = Digits,
                                scale = Scale,
                                value = PV1 + PV2});
add(F1, F2) ->
    orber:dbg("[~p] fixed:add(~p, ~p).~nAt least one of the supplied ar"
              "guments is not a Fixed Type.",
              [102,F1,F2],
              5),
    corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'}).

subtract(#fixed{digits = D1,scale = S1,value = V1},
         #fixed{digits = D2,scale = S2,value = V2}) ->
    Scale =
        if
            S1 > S2 ->
                S1;
            true ->
                S2
        end,
    Digits =
        if
            D1 - S1 > D2 - S2 ->
                D1 - S1;
            true ->
                D2 - S2
        end
        +
        Scale
        +
        1,
    {PV1,PV2} = normalize(S1, V1, S2, V2),
    check_fixed_overflow(#fixed{digits = Digits,
                                scale = Scale,
                                value = PV1 - PV2});
subtract(F1, F2) ->
    orber:dbg("[~p] fixed:subtract(~p, ~p).~nAt least one of the suppli"
              "ed arguments is not a Fixed Type.",
              [117,F1,F2],
              5),
    corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'}).

divide(#fixed{digits = D1,scale = S1,value = V1},
       #fixed{digits = _D2,scale = S2,value = V2}) ->
    {PV1,PV2} = normalize(S1, V1, S2, V2),
    DigitsMin = D1 - S1 + S2,
    R1 = PV1 div PV2,
    R2 =
        R1 * 100000000000000000000000000000000
        +
        PV1 rem PV2 * (100000000000000000000000000000000 div PV2),
    {Result2,Sinf} = delete_zeros_value(R2, 0, R1),
    check_fixed_overflow(#fixed{digits = DigitsMin + Sinf,
                                scale = Sinf,
                                value = Result2});
divide(F1, F2) ->
    orber:dbg("[~p] fixed:divide(~p, ~p).~nAt least one of the supplied"
              " arguments is not a Fixed Type.",
              [132,F1,F2],
              5),
    corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'}).

multiply(#fixed{digits = D1,scale = S1,value = V1},
         #fixed{digits = D2,scale = S2,value = V2}) ->
    check_fixed_overflow(#fixed{digits = D1 + D2,
                                scale = S1 + S2,
                                value = V1 * V2});
multiply(F1, F2) ->
    orber:dbg("[~p] fixed:multiply(~p, ~p).~nAt least one of the suppli"
              "ed arguments is not a Fixed Type.",
              [144,F1,F2],
              5),
    corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'}).

unary_minus(Fixed) when is_record(Fixed, fixed) ->
    Fixed#fixed{value = - Fixed#fixed.value};
unary_minus(Fixed) ->
    orber:dbg("[~p] fixed:unary_minus(~p).~nThe supplied argument is no"
              "t a Fixed Type.",
              [152,Fixed],
              5),
    corba:raise(#'BAD_PARAM'{completion_status = 'COMPLETED_NO'}).

power(0) ->
    1;
power(1) ->
    10;
power(2) ->
    100;
power(3) ->
    1000;
power(4) ->
    10000;
power(5) ->
    100000;
power(6) ->
    1000000;
power(7) ->
    10000000;
power(8) ->
    100000000;
power(9) ->
    1000000000;
power(10) ->
    10000000000;
power(11) ->
    100000000000;
power(12) ->
    1000000000000;
power(13) ->
    10000000000000;
power(14) ->
    100000000000000;
power(15) ->
    1000000000000000;
power(16) ->
    10000000000000000;
power(17) ->
    100000000000000000;
power(18) ->
    1000000000000000000;
power(19) ->
    10000000000000000000;
power(20) ->
    100000000000000000000;
power(21) ->
    1000000000000000000000;
power(22) ->
    10000000000000000000000;
power(23) ->
    100000000000000000000000;
power(24) ->
    1000000000000000000000000;
power(25) ->
    10000000000000000000000000;
power(26) ->
    100000000000000000000000000;
power(27) ->
    1000000000000000000000000000;
power(28) ->
    10000000000000000000000000000;
power(29) ->
    100000000000000000000000000000;
power(30) ->
    1000000000000000000000000000000;
power(31) ->
    10000000000000000000000000000000;
power(_) ->
    10000000000000000000000000000000.

check_fixed_overflow(#fixed{digits = Digits,scale = Scale,value = Value}) ->
    case count_digits(abs(Value)) of
        overflow ->
            {N,NewVal} = cut_overflow(0, Value),
            if
                N > Scale ->
                    #fixed{digits = 31,scale = 0,value = NewVal};
                true ->
                    NewScale = Scale - N,
                    {NewVal2,Removed} = delete_zeros(NewVal, NewScale),
                    #fixed{digits = 31,
                           scale = NewScale - Removed,
                           value = NewVal2}
            end;
        Count when Count > Digits ->
            Diff = Count - Digits,
            if
                Diff > Scale ->
                    #fixed{digits = Digits,
                           scale = 0,
                           value = Value div power(Diff)};
                true ->
                    NewScale = Scale - Diff,
                    {NewVal,Removed} =
                        delete_zeros(Value div power(Diff), NewScale),
                    #fixed{digits = Digits - Removed,
                           scale = NewScale - Removed,
                           value = NewVal}
            end;
        Count ->
            {NewVal,Removed} = delete_zeros(Value, Scale),
            #fixed{digits = Count - Removed,
                   scale = Scale - Removed,
                   value = NewVal}
    end.

normalize(S, V1, S, V2) ->
    {V1,V2};
normalize(S1, V1, S2, V2) when S1 > S2 ->
    {V1,V2 * power(S1 - S2)};
normalize(S1, V1, S2, V2) ->
    {V1 * power(S2 - S1),V2}.

delete_zeros_value(0, N, _) ->
    {0,32 - N};
delete_zeros_value(X, N, M) when X > M, X rem 10 == 0 ->
    delete_zeros_value(X div 10, N + 1, M);
delete_zeros_value(X, N, _) ->
    {X,32 - N}.

delete_zeros(0, _) ->
    {0,0};
delete_zeros(X, Max) ->
    delete_zeros(X, 0, Max).

delete_zeros(X, Max, Max) ->
    {X,Max};
delete_zeros(X, N, Max) when X rem 10 == 0 ->
    delete_zeros(X div 10, N + 1, Max);
delete_zeros(X, N, _) ->
    {X,N}.

cut_overflow(N, X) when X > 9999999999999999999999999999999 ->
    cut_overflow(N + 1, X div 10);
cut_overflow(N, X) ->
    {N,X}.

count_digits(X) when X > 9999999999999999999999999999999 ->
    overflow;
count_digits(X) when X >= 1000000000000000000000000000000 ->
    31;
count_digits(X) when X >= 100000000000000000000000000000 ->
    30;
count_digits(X) when X >= 10000000000000000000000000000 ->
    29;
count_digits(X) when X >= 1000000000000000000000000000 ->
    28;
count_digits(X) when X >= 100000000000000000000000000 ->
    27;
count_digits(X) when X >= 10000000000000000000000000 ->
    26;
count_digits(X) when X >= 1000000000000000000000000 ->
    25;
count_digits(X) when X >= 100000000000000000000000 ->
    24;
count_digits(X) when X >= 10000000000000000000000 ->
    23;
count_digits(X) when X >= 1000000000000000000000 ->
    22;
count_digits(X) when X >= 100000000000000000000 ->
    21;
count_digits(X) when X >= 10000000000000000000 ->
    20;
count_digits(X) when X >= 1000000000000000000 ->
    19;
count_digits(X) when X >= 100000000000000000 ->
    18;
count_digits(X) when X >= 10000000000000000 ->
    17;
count_digits(X) when X >= 1000000000000000 ->
    16;
count_digits(X) when X >= 100000000000000 ->
    15;
count_digits(X) when X >= 10000000000000 ->
    14;
count_digits(X) when X >= 1000000000000 ->
    13;
count_digits(X) when X >= 100000000000 ->
    12;
count_digits(X) when X >= 10000000000 ->
    11;
count_digits(X) when X >= 1000000000 ->
    10;
count_digits(X) when X >= 100000000 ->
    9;
count_digits(X) when X >= 10000000 ->
    8;
count_digits(X) when X >= 1000000 ->
    7;
count_digits(X) when X >= 100000 ->
    6;
count_digits(X) when X >= 10000 ->
    5;
count_digits(X) when X >= 1000 ->
    4;
count_digits(X) when X >= 100 ->
    3;
count_digits(X) when X >= 10 ->
    2;
count_digits(_X) ->
    1.



