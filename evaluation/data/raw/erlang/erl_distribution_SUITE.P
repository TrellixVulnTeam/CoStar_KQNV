-file("test/lib/kernel/test/erl_distribution_SUITE.erl", 1).

-module(erl_distribution_SUITE).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/kernel/test/erl_distribution_SUITE.erl", 23).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2]).

-export([tick/1,
         tick_change/1,
         illegal_nodenames/1,
         hidden_node/1,
         table_waste/1,
         net_setuptime/1,
         monitor_nodes_nodedown_reason/1,
         monitor_nodes_complex_nodedown_reason/1,
         monitor_nodes_node_type/1,
         monitor_nodes_misc/1,
         monitor_nodes_otp_6481/1,
         monitor_nodes_errors/1,
         monitor_nodes_combinations/1,
         monitor_nodes_cleanup/1,
         monitor_nodes_many/1]).

-export([tick_cli_test/1,
         tick_cli_test1/1,
         tick_serv_test/2,
         tick_serv_test1/1,
         keep_conn/1,
         time_ping/1]).

-export([init_per_testcase/2,end_per_testcase/2]).

-export([start_node/2]).

-export([pinger/1]).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [tick,
     tick_change,
     illegal_nodenames,
     hidden_node,
     table_waste,
     net_setuptime,
     {group,monitor_nodes}].

groups() ->
    [{monitor_nodes,
      [],
      [monitor_nodes_nodedown_reason,
       monitor_nodes_complex_nodedown_reason,
       monitor_nodes_node_type,
       monitor_nodes_misc,
       monitor_nodes_otp_6481,
       monitor_nodes_errors,
       monitor_nodes_combinations,
       monitor_nodes_cleanup,
       monitor_nodes_many]}].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

init_per_testcase(Func, Config) when is_atom(Func), is_list(Config) ->
    Dog = test_server:timetrap(test_server:minutes(4)),
    [{watchdog,Dog}|Config].

end_per_testcase(_Func, Config) ->
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog).

tick(suite) ->
    [];
tick(doc) ->
    [];
tick(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(120)),
    PaDir = filename:dirname(code:which(erl_distribution_SUITE)),
    {ok,Node} = start_node(dist_test, "-pa " ++ PaDir),
    rpc:call(Node, erl_distribution_SUITE, tick_cli_test, [node()]),
    monitor_node(Node, true),
    receive
        {nodedown,Node} ->
            test_server:fail("nodedown from other node")
    after
        30000 ->
            monitor_node(Node, false),
            stop_node(Node)
    end,
    {ok,ServNode} =
        start_node(dist_test_server,
                   "-kernel net_ticktime 100 -pa " ++ PaDir),
    rpc:call(ServNode,
             erl_distribution_SUITE,
             tick_serv_test,
             [Node,node()]),
    {ok,_} =
        start_node(dist_test, "-kernel net_ticktime 12 -pa " ++ PaDir),
    rpc:call(Node, erl_distribution_SUITE, tick_cli_test, [ServNode]),
    spawn_link(erl_distribution_SUITE, keep_conn, [Node]),
    {tick_serv,ServNode} ! {i_want_the_result,self()},
    monitor_node(ServNode, true),
    monitor_node(Node, true),
    receive
        {tick_test,T} when is_integer(T) ->
            stop_node(ServNode),
            stop_node(Node),
            T;
        {tick_test,Error} ->
            stop_node(ServNode),
            stop_node(Node),
            test_server:fail(Error);
        {nodedown,Node} ->
            stop_node(ServNode),
            test_server:fail("client node died");
        {nodedown,ServNode} ->
            stop_node(Node),
            test_server:fail("server node died")
    end,
    test_server:timetrap_cancel(Dog),
    ok.

table_waste(doc) ->
    ["Checks that pinging nonexistyent nodes does not waste space in di"
     "stribution table"];
table_waste(suite) ->
    [];
table_waste(Config) when is_list(Config) ->
    {ok,HName} = inet:gethostname(),
    F = fun(0, _F) ->
               [];
           (N, F) ->
               Name =
                   list_to_atom("erl_distribution_"
                                ++
                                integer_to_list(N) ++ "@" ++ HName),
               pang = net_adm:ping(Name),
               F(N - 1, F)
        end,
    F(256, F),
    {ok,N} = start_node(erl_distribution_300, ""),
    stop_node(N),
    ok.

illegal_nodenames(doc) ->
    ["Test that pinging an illegal nodename does not kill the node"];
illegal_nodenames(suite) ->
    [];
illegal_nodenames(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:minutes(2)),
    PaDir = filename:dirname(code:which(erl_distribution_SUITE)),
    {ok,Node} = start_node(illegal_nodenames, "-pa " ++ PaDir),
    monitor_node(Node, true),
    RPid =
        rpc:call(Node,
                 erlang,
                 spawn,
                 [erl_distribution_SUITE,pinger,[self()]]),
    receive
        {RPid,pinged} ->
            ok;
        {nodedown,Node} ->
            test_server:fail("Remote node died.")
    end,
    stop_node(Node),
    test_server:timetrap_cancel(Dog),
    ok.

pinger(Starter) ->
    io:format("Starter:~p~n", [Starter]),
    net_adm:ping(a@b@c),
    Starter ! {self(),pinged},
    ok.

net_setuptime(doc) ->
    ["Test that you can set the net_setuptime properly"];
net_setuptime(Config) when is_list(Config) ->
    Res0 = do_test_setuptime("2"),
    io:format("Res0 = ~p", [Res0]),
    true = Res0 =< 4000,
    Res1 = do_test_setuptime("0.3"),
    io:format("Res1 = ~p", [Res1]),
    true = Res1 =< 500,
    ok.

do_test_setuptime(Setuptime) when is_list(Setuptime) ->
    PaDir = filename:dirname(code:which(erl_distribution_SUITE)),
    {ok,Node} =
        start_node(dist_setuptime_test,
                   "-pa "
                   ++
                   PaDir ++ " -kernel net_setuptime " ++ Setuptime),
    Res =
        rpc:call(Node,
                 erl_distribution_SUITE,
                 time_ping,
                 [dummy@test01]),
    stop_node(Node),
    Res.

time_ping(Node) ->
    T0 = now(),
    pang = net_adm:ping(Node),
    T1 = now(),
    time_diff(T0, T1).

keep_conn(Node) ->
    sleep(1),
    rpc:cast(Node, erlang, time, []),
    keep_conn(Node).

tick_serv_test(Node, MasterNode) ->
    spawn(erl_distribution_SUITE, keep_conn, [MasterNode]),
    spawn(erl_distribution_SUITE, tick_serv_test1, [Node]).

tick_serv_test1(Node) ->
    register(tick_serv, self()),
    TestServer =
        receive
            {i_want_the_result,TS} ->
                TS
        end,
    monitor_node(Node, true),
    receive
        {nodedown,Node} ->
            net_adm:ping(Node),
            {tick_test,Node} ! {whats_the_result,self()},
            receive
                {tick_test,Res} ->
                    TestServer ! {tick_test,Res}
            end
    end.

tick_cli_test(Node) ->
    spawn(erl_distribution_SUITE, tick_cli_test1, [Node]).

tick_cli_test1(Node) ->
    register(tick_test, self()),
    monitor_node(Node, true),
    sleep(2),
    rpc:call(Node, erlang, time, []),
    T1 = now(),
    receive
        {nodedown,Node} ->
            T2 = now(),
            receive
                {whats_the_result,From} ->
                    case time_diff(T1, T2) of
                        T when T > 8000, T < 16000 ->
                            From ! {tick_test,T};
                        T ->
                            From
                            !
                            {tick_test,
                             {"T not in interval 8000 < T < 16000",T}}
                    end
            end
    end.

tick_change(doc) ->
    ["OTP-4255"];
tick_change(suite) ->
    [];
tick_change(Config) when is_list(Config) ->
    PaDir = filename:dirname(code:which(erl_distribution_SUITE)),
    [BN,CN] = get_nodenames(2, tick_change),
    DefaultTT = net_kernel:get_net_ticktime(),
    unchanged = net_kernel:set_net_ticktime(DefaultTT, 60),
    case DefaultTT of
        I when is_integer(I) ->
            ok;
        _ ->
            test_server:fail(DefaultTT)
    end,
    case nodes(connected) of
        [] ->
            net_kernel:set_net_ticktime(10, 0);
        _ ->
            rpc:multicall(nodes([this,connected]),
                          net_kernel,
                          set_net_ticktime,
                          [10,5])
    end,
    wait_until(fun() ->
                      10 == net_kernel:get_net_ticktime()
               end),
    {ok,B} = start_node(BN, "-kernel net_ticktime 10 -pa " ++ PaDir),
    {ok,C} =
        start_node(CN, "-kernel net_ticktime 10 -hidden -pa " ++ PaDir),
    OTE = process_flag(trap_exit, true),
    case
        catch
            begin
                run_tick_change_test(B, C, 10, 1, PaDir),
                run_tick_change_test(B, C, 1, 10, PaDir)
            end
    of
        {'EXIT',Reason} ->
            stop_node(B),
            stop_node(C),
            case nodes(connected) of
                [] ->
                    net_kernel:set_net_ticktime(DefaultTT, 0);
                _ ->
                    rpc:multicall(nodes([this,connected]),
                                  net_kernel,
                                  set_net_ticktime,
                                  [DefaultTT,10])
            end,
            wait_until(fun() ->
                              DefaultTT == net_kernel:get_net_ticktime()
                       end),
            process_flag(trap_exit, OTE),
            test_server:fail(Reason);
        _ ->
            ok
    end,
    process_flag(trap_exit, OTE),
    stop_node(B),
    stop_node(C),
    case nodes(connected) of
        [] ->
            net_kernel:set_net_ticktime(DefaultTT, 0);
        _ ->
            rpc:multicall(nodes([this,connected]),
                          net_kernel,
                          set_net_ticktime,
                          [DefaultTT,5])
    end,
    wait_until(fun() ->
                      DefaultTT == net_kernel:get_net_ticktime()
               end),
    ok.

wait_for_nodedowns(Tester, Ref) ->
    receive
        {nodedown,Node} ->
            test_server:format("~p~n", [{node(),{nodedown,Node}}]),
            Tester ! {Ref,{node(),{nodedown,Node}}}
    end,
    wait_for_nodedowns(Tester, Ref).

run_tick_change_test(B, C, PrevTT, TT, PaDir) ->
    [DN,EN] = get_nodenames(2, tick_change),
    Tester = self(),
    Ref = make_ref(),
    MonitorNodes =
        fun(Nodes) ->
               lists:foreach(fun(N) ->
                                    monitor_node(N, true)
                             end,
                             Nodes),
               wait_for_nodedowns(Tester, Ref)
        end,
    {ok,D} =
        start_node(DN,
                   "-kernel net_ticktime "
                   ++
                   integer_to_list(PrevTT) ++ " -pa " ++ PaDir),
    NMA =
        spawn_link(fun() ->
                          MonitorNodes([B,C,D])
                   end),
    NMB =
        spawn_link(B,
                   fun() ->
                          MonitorNodes([node(),C,D])
                   end),
    NMC =
        spawn_link(C,
                   fun() ->
                          MonitorNodes([node(),B,D])
                   end),
    MaxTT =
        case PrevTT > TT of
            true ->
                PrevTT;
            false ->
                TT
        end,
    CheckResult = make_ref(),
    spawn_link(fun() ->
                      receive
                      after
                          (25 + MaxTT) * 1000 -> Tester ! CheckResult
                      end
               end),
    case nodes(connected) -- [B,C,D] of
        [] ->
            ok;
        OtherNodes ->
            rpc:multicall(OtherNodes,
                          net_kernel,
                          set_net_ticktime,
                          [TT,20])
    end,
    change_initiated = net_kernel:set_net_ticktime(TT, 20),
    {ongoing_change_to,_} = net_kernel:set_net_ticktime(TT, 20),
    sleep(3),
    change_initiated =
        rpc:call(B, net_kernel, set_net_ticktime, [TT,15]),
    sleep(7),
    change_initiated =
        rpc:call(C, net_kernel, set_net_ticktime, [TT,10]),
    {ok,E} =
        start_node(EN,
                   "-kernel net_ticktime "
                   ++
                   integer_to_list(TT) ++ " -pa " ++ PaDir),
    NME =
        spawn_link(E,
                   fun() ->
                          MonitorNodes([node(),B,C,D])
                   end),
    NMA2 =
        spawn_link(fun() ->
                          MonitorNodes([E])
                   end),
    NMB2 =
        spawn_link(B,
                   fun() ->
                          MonitorNodes([E])
                   end),
    NMC2 =
        spawn_link(C,
                   fun() ->
                          MonitorNodes([E])
                   end),
    receive
        CheckResult ->
            ok
    end,
    unlink(NMA),
    exit(NMA, kill),
    unlink(NMB),
    exit(NMB, kill),
    unlink(NMC),
    exit(NMC, kill),
    unlink(NME),
    exit(NME, kill),
    unlink(NMA2),
    exit(NMA2, kill),
    unlink(NMB2),
    exit(NMB2, kill),
    unlink(NMC2),
    exit(NMC2, kill),
    receive
        {Ref,{Node,{nodedown,D}}} when Node == node() ->
            ok
    after
        0 -> exit({431,no_nodedown})
    end,
    receive
        {Ref,{B,{nodedown,D}}} ->
            ok
    after
        0 -> exit({434,no_nodedown})
    end,
    receive
        {Ref,{C,{nodedown,D}}} ->
            ok
    after
        0 -> exit({437,no_nodedown})
    end,
    receive
        {Ref,{E,{nodedown,D}}} ->
            ok
    after
        0 -> exit({440,no_nodedown})
    end,
    receive
        {Ref,Reason} ->
            stop_node(E),
            exit({447,Reason});
        {'EXIT',Pid,Reason}
            when
                Pid == NMA;
                Pid == NMB;
                Pid == NMC;
                Pid == NME;
                Pid == NMA2;
                Pid == NMB2;
                Pid == NMC2 ->
            stop_node(E),
            exit({457,{node(Pid),Reason}})
    after
        0 ->
            TT = net_kernel:get_net_ticktime(),
            TT = rpc:call(B, net_kernel, get_net_ticktime, []),
            TT = rpc:call(C, net_kernel, get_net_ticktime, []),
            TT = rpc:call(E, net_kernel, get_net_ticktime, []),
            stop_node(E),
            ok
    end.

hidden_node(doc) ->
    ["Basic test of hidden node"];
hidden_node(suite) ->
    [];
hidden_node(Config) when is_list(Config) ->
    Dog = test_server:timetrap(test_server:seconds(40)),
    PaDir = filename:dirname(code:which(erl_distribution_SUITE)),
    VArgs = "-pa " ++ PaDir,
    HArgs = "-hidden -pa " ++ PaDir,
    {ok,V} = start_node(visible_node, VArgs),
    VMN = start_monitor_nodes_proc(V),
    {ok,H} = start_node(hidden_node, HArgs),
    connect_nodes(V, H),
    test_nodes(V, H),
    stop_node(H),
    sleep(5),
    check_monitor_nodes_res(VMN, H),
    stop_node(V),
    {ok,H} = start_node(hidden_node, HArgs),
    HMN = start_monitor_nodes_proc(H),
    {ok,V} = start_node(visible_node, VArgs),
    connect_nodes(H, V),
    test_nodes(V, H),
    stop_node(V),
    sleep(5),
    check_monitor_nodes_res(HMN, V),
    stop_node(H),
    test_server:timetrap_cancel(Dog),
    ok.

connect_nodes(A, B) ->
    false = lists:member(A, rpc:call(B, erlang, nodes, [connected])),
    false = lists:member(B, rpc:call(A, erlang, nodes, [connected])),
    pong = rpc:call(A, net_adm, ping, [B]).

test_nodes(V, H) ->
    [] = rpc:call(H, erlang, nodes, []),
    true = lists:member(V, rpc:call(H, erlang, nodes, [hidden])),
    false = lists:member(H, rpc:call(V, erlang, nodes, [])),
    true = lists:member(H, rpc:call(V, erlang, nodes, [hidden])).

mn_loop(MNs) ->
    receive
        {nodeup,N} ->
            mn_loop([{nodeup,N}|MNs]);
        {nodedown,N} ->
            mn_loop([{nodedown,N}|MNs]);
        {monitor_nodes_result,Ref,From} ->
            From ! {Ref,MNs};
        _ ->
            mn_loop(MNs)
    end.

start_monitor_nodes_proc(Node) ->
    Ref = make_ref(),
    Starter = self(),
    Pid =
        spawn(Node,
              fun() ->
                     net_kernel:monitor_nodes(true),
                     Starter ! Ref,
                     mn_loop([])
              end),
    receive
        Ref ->
            ok
    end,
    Pid.

check_monitor_nodes_res(Pid, Node) ->
    Ref = make_ref(),
    Pid ! {monitor_nodes_result,Ref,self()},
    receive
        {Ref,MNs} ->
            false = lists:keysearch(Node, 2, MNs)
    end.

monitor_nodes_nodedown_reason(doc) ->
    [];
monitor_nodes_nodedown_reason(suite) ->
    [];
monitor_nodes_nodedown_reason(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    ok = net_kernel:monitor_nodes(true),
    ok = net_kernel:monitor_nodes(true, [nodedown_reason]),
    Names = get_numbered_nodenames(5, node),
    [NN1,NN2,NN3,NN4,NN5] = Names,
    {ok,N1} = start_node(NN1),
    {ok,N2} = start_node(NN2),
    {ok,N3} = start_node(NN3),
    {ok,N4} = start_node(NN4, "-hidden"),
    receive
        {nodeup,N1} ->
            ok
    end,
    receive
        {nodeup,N2} ->
            ok
    end,
    receive
        {nodeup,N3} ->
            ok
    end,
    receive
        {nodeup,N1,[]} ->
            ok
    end,
    receive
        {nodeup,N2,[]} ->
            ok
    end,
    receive
        {nodeup,N3,[]} ->
            ok
    end,
    stop_node(N1),
    stop_node(N4),
    true = net_kernel:disconnect(N2),
    TickTime = net_kernel:get_net_ticktime(),
    SleepTime = TickTime + TickTime div 4,
    spawn(N3,
          fun() ->
                 block_emu(SleepTime * 1000),
                 halt()
          end),
    receive
        {nodedown,N1} ->
            ok
    end,
    receive
        {nodedown,N2} ->
            ok
    end,
    receive
        {nodedown,N3} ->
            ok
    end,
    receive
        {nodedown,N1,[{nodedown_reason,R1}]} ->
            connection_closed = R1
    end,
    receive
        {nodedown,N2,[{nodedown_reason,R2}]} ->
            disconnect = R2
    end,
    receive
        {nodedown,N3,[{nodedown_reason,R3}]} ->
            net_tick_timeout = R3
    end,
    ok = net_kernel:monitor_nodes(false, [nodedown_reason]),
    {ok,N5} = start_node(NN5),
    stop_node(N5),
    receive
        {nodeup,N5} ->
            ok
    end,
    receive
        {nodedown,N5} ->
            ok
    end,
    print_my_messages(),
    ok = check_no_nodedown_nodeup(1000),
    ok = net_kernel:monitor_nodes(false),
    MonNodeState = monitor_node_state(),
    ok.

monitor_nodes_complex_nodedown_reason(doc) ->
    [];
monitor_nodes_complex_nodedown_reason(suite) ->
    [];
monitor_nodes_complex_nodedown_reason(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    Me = self(),
    ok = net_kernel:monitor_nodes(true, [nodedown_reason]),
    [Name] = get_nodenames(1, monitor_nodes_complex_nodedown_reason),
    {ok,Node} = start_node(Name, ""),
    Pid =
        spawn(Node,
              fun() ->
                     Me
                     !
                     {stuff,
                      self(),
                      [make_ref(),{processes(),erlang:ports()}]}
              end),
    receive
        {nodeup,Node,[]} ->
            ok
    end,
    {ok,NodeInfo} = net_kernel:node_info(Node),
    {value,{owner,Owner}} = lists:keysearch(owner, 1, NodeInfo),
    ComplexTerm =
        receive
            {stuff,Pid,_} = Msg ->
                {Msg,term_to_binary(Msg)}
        end,
    exit(Owner, ComplexTerm),
    receive
        {nodedown,Node,[{nodedown_reason,NodeDownReason}]} ->
            ok
    end,
    garbage_collect(),
    garbage_collect(),
    garbage_collect(),
    ComplexTerm = NodeDownReason,
    ok = net_kernel:monitor_nodes(false, [nodedown_reason]),
    no_msgs(),
    MonNodeState = monitor_node_state(),
    ok.

monitor_nodes_node_type(doc) ->
    [];
monitor_nodes_node_type(suite) ->
    [];
monitor_nodes_node_type(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    ok = net_kernel:monitor_nodes(true),
    ok = net_kernel:monitor_nodes(true, [{node_type,all}]),
    Names = get_numbered_nodenames(9, node),
    [NN1,NN2,NN3,NN4,NN5,NN6,NN7,NN8,NN9] = Names,
    {ok,N1} = start_node(NN1),
    {ok,N2} = start_node(NN2),
    {ok,N3} = start_node(NN3, "-hidden"),
    {ok,N4} = start_node(NN4, "-hidden"),
    receive
        {nodeup,N1} ->
            ok
    end,
    receive
        {nodeup,N2} ->
            ok
    end,
    receive
        {nodeup,N1,[{node_type,visible}]} ->
            ok
    end,
    receive
        {nodeup,N2,[{node_type,visible}]} ->
            ok
    end,
    receive
        {nodeup,N3,[{node_type,hidden}]} ->
            ok
    end,
    receive
        {nodeup,N4,[{node_type,hidden}]} ->
            ok
    end,
    stop_node(N1),
    stop_node(N2),
    stop_node(N3),
    stop_node(N4),
    receive
        {nodedown,N1} ->
            ok
    end,
    receive
        {nodedown,N2} ->
            ok
    end,
    receive
        {nodedown,N1,[{node_type,visible}]} ->
            ok
    end,
    receive
        {nodedown,N2,[{node_type,visible}]} ->
            ok
    end,
    receive
        {nodedown,N3,[{node_type,hidden}]} ->
            ok
    end,
    receive
        {nodedown,N4,[{node_type,hidden}]} ->
            ok
    end,
    ok = net_kernel:monitor_nodes(false, [{node_type,all}]),
    {ok,N5} = start_node(NN5),
    receive
        {nodeup,N5} ->
            ok
    end,
    stop_node(N5),
    receive
        {nodedown,N5} ->
            ok
    end,
    ok = net_kernel:monitor_nodes(true, [{node_type,hidden}]),
    {ok,N6} = start_node(NN6),
    {ok,N7} = start_node(NN7, "-hidden"),
    receive
        {nodeup,N6} ->
            ok
    end,
    receive
        {nodeup,N7,[{node_type,hidden}]} ->
            ok
    end,
    stop_node(N6),
    stop_node(N7),
    receive
        {nodedown,N6} ->
            ok
    end,
    receive
        {nodedown,N7,[{node_type,hidden}]} ->
            ok
    end,
    ok = net_kernel:monitor_nodes(true, [{node_type,visible}]),
    ok = net_kernel:monitor_nodes(false, [{node_type,hidden}]),
    ok = net_kernel:monitor_nodes(false),
    {ok,N8} = start_node(NN8),
    {ok,N9} = start_node(NN9, "-hidden"),
    receive
        {nodeup,N8,[{node_type,visible}]} ->
            ok
    end,
    stop_node(N8),
    stop_node(N9),
    receive
        {nodedown,N8,[{node_type,visible}]} ->
            ok
    end,
    print_my_messages(),
    ok = check_no_nodedown_nodeup(1000),
    ok = net_kernel:monitor_nodes(false, [{node_type,visible}]),
    MonNodeState = monitor_node_state(),
    ok.

monitor_nodes_misc(doc) ->
    [];
monitor_nodes_misc(suite) ->
    [];
monitor_nodes_misc(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    ok = net_kernel:monitor_nodes(true),
    ok =
        net_kernel:monitor_nodes(true,
                                 [{node_type,all},nodedown_reason]),
    ok =
        net_kernel:monitor_nodes(true,
                                 [nodedown_reason,{node_type,all}]),
    Names = get_numbered_nodenames(3, node),
    [NN1,NN2,NN3] = Names,
    {ok,N1} = start_node(NN1),
    {ok,N2} = start_node(NN2, "-hidden"),
    receive
        {nodeup,N1} ->
            ok
    end,
    receive
        {nodeup,N1,[{node_type,visible}]} ->
            ok
    end,
    receive
        {nodeup,N1,[{node_type,visible}]} ->
            ok
    end,
    receive
        {nodeup,N2,[{node_type,hidden}]} ->
            ok
    end,
    receive
        {nodeup,N2,[{node_type,hidden}]} ->
            ok
    end,
    stop_node(N1),
    stop_node(N2),
    VisbleDownInfo =
        lists:sort([{node_type,visible},
                    {nodedown_reason,connection_closed}]),
    HiddenDownInfo =
        lists:sort([{node_type,hidden},
                    {nodedown_reason,connection_closed}]),
    receive
        {nodedown,N1} ->
            ok
    end,
    receive
        {nodedown,N1,Info1A} ->
            VisbleDownInfo = lists:sort(Info1A)
    end,
    receive
        {nodedown,N1,Info1B} ->
            VisbleDownInfo = lists:sort(Info1B)
    end,
    receive
        {nodedown,N2,Info2A} ->
            HiddenDownInfo = lists:sort(Info2A)
    end,
    receive
        {nodedown,N2,Info2B} ->
            HiddenDownInfo = lists:sort(Info2B)
    end,
    ok =
        net_kernel:monitor_nodes(false,
                                 [{node_type,all},nodedown_reason]),
    {ok,N3} = start_node(NN3),
    receive
        {nodeup,N3} ->
            ok
    end,
    stop_node(N3),
    receive
        {nodedown,N3} ->
            ok
    end,
    print_my_messages(),
    ok = check_no_nodedown_nodeup(1000),
    ok = net_kernel:monitor_nodes(false),
    MonNodeState = monitor_node_state(),
    ok.

monitor_nodes_otp_6481(doc) ->
    ["Tests that {nodeup, Node} messages are received before messages f"
     "rom Node and that {nodedown, Node} messages arereceived after mes"
     "sages from Node"];
monitor_nodes_otp_6481(suite) ->
    [];
monitor_nodes_otp_6481(Config) when is_list(Config) ->
    test_server:format("Testing nodedown...~n"),
    monitor_nodes_otp_6481_test(Config, nodedown),
    test_server:format("ok~n"),
    test_server:format("Testing nodeup...~n"),
    monitor_nodes_otp_6481_test(Config, nodeup),
    test_server:format("ok~n"),
    ok.

monitor_nodes_otp_6481_test(Config, TestType) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    NodeMsg = make_ref(),
    Me = self(),
    [Name] = get_nodenames(1, monitor_nodes_otp_6481),
    case TestType of
        nodedown ->
            ok = net_kernel:monitor_nodes(true);
        nodeup ->
            ok
    end,
    Seq = lists:seq(1, 10000),
    MN =
        spawn_link(fun() ->
                          lists:foreach(fun(_) ->
                                               ok =
                                                   net_kernel:monitor_nodes(true)
                                        end,
                                        Seq),
                          Me ! {mon_set,self()},
                          receive after infinity -> ok end
                   end),
    receive
        {mon_set,MN} ->
            ok
    end,
    case TestType of
        nodedown ->
            ok;
        nodeup ->
            ok = net_kernel:monitor_nodes(true)
    end,
    TestMonNodeState = monitor_node_state(),
    TestMonNodeState =
        MonNodeState
        ++
        case TestType of
            nodedown ->
                [{self(),[]}];
            nodeup ->
                []
        end
        ++
        lists:map(fun(_) ->
                         {MN,[]}
                  end,
                  Seq)
        ++
        case TestType of
            nodedown ->
                [];
            nodeup ->
                [{self(),[]}]
        end,
    {ok,Node} = start_node(Name, "", this),
    receive
        {nodeup,Node} ->
            ok
    end,
    RemotePid =
        spawn(Node,
              fun() ->
                     receive after 1500 -> ok end,
                     _ = spawn(fun() ->
                                      node_loop_send(Me, NodeMsg, 1)
                               end),
                     receive
                         {Me,kill_it} ->
                             ok
                     end,
                     halt()
              end),
    net_kernel:disconnect(Node),
    receive
        {nodedown,Node} ->
            ok
    end,
    no_msgs(500),
    {nodeup,Node} =
        receive
            Msg1 ->
                Msg1
        end,
    {NodeMsg,1} =
        receive
            Msg2 ->
                Msg2
        end,
    RemotePid ! {self(),kill_it},
    {nodedown,Node} = flush_node_msgs(NodeMsg, 2),
    no_msgs(500),
    Mon = monitor(process, MN),
    unlink(MN),
    exit(MN, bang),
    receive
        {'DOWN',Mon,process,MN,bang} ->
            ok
    end,
    ok = net_kernel:monitor_nodes(false),
    MonNodeState = monitor_node_state(),
    ok.

flush_node_msgs(NodeMsg, No) ->
    case
        receive
            Msg ->
                Msg
        end
    of
        {NodeMsg,No} ->
            flush_node_msgs(NodeMsg, No + 1);
        OtherMsg ->
            OtherMsg
    end.

node_loop_send(Pid, Msg, No) ->
    Pid ! {Msg,No},
    node_loop_send(Pid, Msg, No + 1).

monitor_nodes_errors(doc) ->
    [];
monitor_nodes_errors(suite) ->
    [];
monitor_nodes_errors(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    error = net_kernel:monitor_nodes(asdf),
    {error,{unknown_options,[gurka]}} =
        net_kernel:monitor_nodes(true, [gurka]),
    {error,{options_not_a_list,gurka}} =
        net_kernel:monitor_nodes(true, gurka),
    {error,
     {option_value_mismatch,[{node_type,visible},{node_type,hidden}]}} =
        net_kernel:monitor_nodes(true,
                                 [{node_type,hidden},
                                  {node_type,visible}]),
    {error,
     {option_value_mismatch,[{node_type,visible},{node_type,all}]}} =
        net_kernel:monitor_nodes(true,
                                 [{node_type,all},{node_type,visible}]),
    {error,{bad_option_value,{node_type,blaha}}} =
        net_kernel:monitor_nodes(true, [{node_type,blaha}]),
    MonNodeState = monitor_node_state(),
    ok.

monitor_nodes_combinations(doc) ->
    [];
monitor_nodes_combinations(suite) ->
    [];
monitor_nodes_combinations(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    monitor_nodes_all_comb(true),
    [VisibleName,HiddenName] =
        get_nodenames(2, monitor_nodes_combinations),
    {ok,Visible} = start_node(VisibleName, ""),
    receive_all_comb_nodeup_msgs(visible, Visible),
    no_msgs(),
    stop_node(Visible),
    receive_all_comb_nodedown_msgs(visible, Visible, connection_closed),
    no_msgs(),
    {ok,Hidden} = start_node(HiddenName, "-hidden"),
    receive_all_comb_nodeup_msgs(hidden, Hidden),
    no_msgs(),
    stop_node(Hidden),
    receive_all_comb_nodedown_msgs(hidden, Hidden, connection_closed),
    no_msgs(),
    monitor_nodes_all_comb(false),
    MonNodeState = monitor_node_state(),
    no_msgs(),
    ok.

monitor_nodes_all_comb(Flag) ->
    ok = net_kernel:monitor_nodes(Flag),
    ok = net_kernel:monitor_nodes(Flag, [nodedown_reason]),
    ok = net_kernel:monitor_nodes(Flag, [{node_type,hidden}]),
    ok = net_kernel:monitor_nodes(Flag, [{node_type,visible}]),
    ok = net_kernel:monitor_nodes(Flag, [{node_type,all}]),
    ok =
        net_kernel:monitor_nodes(Flag,
                                 [nodedown_reason,{node_type,hidden}]),
    ok =
        net_kernel:monitor_nodes(Flag,
                                 [nodedown_reason,{node_type,visible}]),
    ok =
        net_kernel:monitor_nodes(Flag,
                                 [nodedown_reason,{node_type,all}]),
    8.

receive_all_comb_nodeup_msgs(visible, Node) ->
    test_server:format("Receive nodeup visible...~n"),
    Exp =
        [{nodeup,Node},{nodeup,Node,[]}]
        ++
        mk_exp_mn_all_comb_nodeup_msgs_common(visible, Node),
    receive_mn_msgs(Exp),
    test_server:format("ok~n"),
    ok;
receive_all_comb_nodeup_msgs(hidden, Node) ->
    test_server:format("Receive nodeup hidden...~n"),
    Exp = mk_exp_mn_all_comb_nodeup_msgs_common(hidden, Node),
    receive_mn_msgs(Exp),
    test_server:format("ok~n"),
    ok.

mk_exp_mn_all_comb_nodeup_msgs_common(Type, Node) ->
    InfoNt = [{node_type,Type}],
    [{nodeup,Node,InfoNt},
     {nodeup,Node,InfoNt},
     {nodeup,Node,InfoNt},
     {nodeup,Node,InfoNt}].

receive_all_comb_nodedown_msgs(visible, Node, Reason) ->
    test_server:format("Receive nodedown visible...~n"),
    Exp =
        [{nodedown,Node},{nodedown,Node,[{nodedown_reason,Reason}]}]
        ++
        mk_exp_mn_all_comb_nodedown_msgs_common(visible, Node, Reason),
    receive_mn_msgs(Exp),
    test_server:format("ok~n"),
    ok;
receive_all_comb_nodedown_msgs(hidden, Node, Reason) ->
    test_server:format("Receive nodedown hidden...~n"),
    Exp = mk_exp_mn_all_comb_nodedown_msgs_common(hidden, Node, Reason),
    receive_mn_msgs(Exp),
    test_server:format("ok~n"),
    ok.

mk_exp_mn_all_comb_nodedown_msgs_common(Type, Node, Reason) ->
    InfoNt = [{node_type,Type}],
    InfoNdrNt = lists:sort([{nodedown_reason,Reason}] ++ InfoNt),
    [{nodedown,Node,InfoNt},
     {nodedown,Node,InfoNt},
     {nodedown,Node,InfoNdrNt},
     {nodedown,Node,InfoNdrNt}].

receive_mn_msgs([]) ->
    ok;
receive_mn_msgs(Msgs) ->
    test_server:format("Expecting msgs: ~p~n", [Msgs]),
    receive
        {_Dir,_Node} = Msg ->
            test_server:format("received ~p~n", [Msg]),
            case lists:member(Msg, Msgs) of
                true ->
                    receive_mn_msgs(lists:delete(Msg, Msgs));
                false ->
                    test_server:fail({unexpected_message,
                                      Msg,
                                      expected_messages,
                                      Msgs})
            end;
        {Dir,Node,Info} ->
            Msg = {Dir,Node,lists:sort(Info)},
            test_server:format("received ~p~n", [Msg]),
            case lists:member(Msg, Msgs) of
                true ->
                    receive_mn_msgs(lists:delete(Msg, Msgs));
                false ->
                    test_server:fail({unexpected_message,
                                      Msg,
                                      expected_messages,
                                      Msgs})
            end;
        Msg ->
            test_server:format("received ~p~n", [Msg]),
            test_server:fail({unexpected_message,
                              Msg,
                              expected_messages,
                              Msgs})
    end.

monitor_nodes_cleanup(doc) ->
    [];
monitor_nodes_cleanup(suite) ->
    [];
monitor_nodes_cleanup(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    Me = self(),
    No = monitor_nodes_all_comb(true),
    Inf =
        spawn(fun() ->
                     monitor_nodes_all_comb(true),
                     Me ! {mons_set,self()},
                     receive after infinity -> ok end
              end),
    TO =
        spawn(fun() ->
                     monitor_nodes_all_comb(true),
                     Me ! {mons_set,self()},
                     receive after 500 -> ok end
              end),
    receive
        {mons_set,Inf} ->
            ok
    end,
    receive
        {mons_set,TO} ->
            ok
    end,
    MNLen = length(MonNodeState) + No * 3,
    MNLen = length(monitor_node_state()),
    MonInf = monitor(process, Inf),
    MonTO = monitor(process, TO),
    exit(Inf, bang),
    No = monitor_nodes_all_comb(false),
    receive
        {'DOWN',MonInf,process,Inf,bang} ->
            ok
    end,
    receive
        {'DOWN',MonTO,process,TO,normal} ->
            ok
    end,
    MonNodeState = monitor_node_state(),
    no_msgs(),
    ok.

monitor_nodes_many(doc) ->
    [];
monitor_nodes_many(suite) ->
    [];
monitor_nodes_many(Config) when is_list(Config) ->
    MonNodeState = monitor_node_state(),
    [Name] = get_nodenames(1, monitor_nodes_many),
    No = 1 bsl 16 + 17,
    repeat(fun() ->
                  ok = net_kernel:monitor_nodes(true)
           end,
           No),
    No = length(monitor_node_state()) - length(MonNodeState),
    {ok,Node} = start_node(Name),
    repeat(fun() ->
                  receive
                      {nodeup,Node} ->
                          ok
                  end
           end,
           No),
    stop_node(Node),
    repeat(fun() ->
                  receive
                      {nodedown,Node} ->
                          ok
                  end
           end,
           No),
    ok = net_kernel:monitor_nodes(false),
    no_msgs(10),
    MonNodeState = monitor_node_state(),
    ok.

monitor_node_state() ->
    erts_debug:set_internal_state(available_internal_state, true),
    MonitoringNodes = erts_debug:get_internal_state(monitoring_nodes),
    erts_debug:set_internal_state(available_internal_state, false),
    MonitoringNodes.

check_no_nodedown_nodeup(TimeOut) ->
    receive
        {nodeup,_,_} = Msg ->
            test_server:fail({unexpected_nodeup,Msg});
        {nodeup,_} = Msg ->
            test_server:fail({unexpected_nodeup,Msg});
        {nodedown,_,_} = Msg ->
            test_server:fail({unexpected_nodedown,Msg});
        {nodedown,_} = Msg ->
            test_server:fail({unexpected_nodedown,Msg})
    after
        TimeOut -> ok
    end.

print_my_messages() ->
    {messages,Messages} = process_info(self(), messages),
    test_server:format("Messages: ~p~n", [Messages]),
    ok.

time_diff({TimeM,TimeS,TimeU}, {CurM,CurS,CurU}) when CurM > TimeM ->
    (CurM - TimeM) * 1000000000 + sec_diff({TimeS,TimeU}, {CurS,CurU});
time_diff({_,TimeS,TimeU}, {_,CurS,CurU}) ->
    sec_diff({TimeS,TimeU}, {CurS,CurU}).

sec_diff({TimeS,TimeU}, {CurS,CurU}) when CurS > TimeS ->
    (CurS - TimeS) * 1000 + micro_diff(TimeU, CurU);
sec_diff({_,TimeU}, {_,CurU}) ->
    micro_diff(TimeU, CurU).

micro_diff(TimeU, CurU) ->
    trunc(CurU / 1000) - trunc(TimeU / 1000).

sleep(T) ->
    receive after T * 1000 -> ok end.

start_node(Name, Param, this) ->
    NewParam =
        Param
        ++
        " -pa " ++ filename:dirname(code:which(erl_distribution_SUITE)),
    test_server:start_node(Name, peer, [{args,NewParam},{erl,[this]}]);
start_node(Name, Param, "this") ->
    NewParam =
        Param
        ++
        " -pa " ++ filename:dirname(code:which(erl_distribution_SUITE)),
    test_server:start_node(Name, peer, [{args,NewParam},{erl,[this]}]);
start_node(Name, Param, Rel) when is_atom(Rel) ->
    NewParam =
        Param
        ++
        " -pa " ++ filename:dirname(code:which(erl_distribution_SUITE)),
    test_server:start_node(Name,
                           peer,
                           [{args,NewParam},
                            {erl,[{release,atom_to_list(Rel)}]}]);
start_node(Name, Param, Rel) when is_list(Rel) ->
    NewParam =
        Param
        ++
        " -pa " ++ filename:dirname(code:which(erl_distribution_SUITE)),
    test_server:start_node(Name,
                           peer,
                           [{args,NewParam},{erl,[{release,Rel}]}]).

start_node(Name, Param) ->
    NewParam =
        Param
        ++
        " -pa " ++ filename:dirname(code:which(erl_distribution_SUITE)),
    test_server:start_node(Name, slave, [{args,NewParam}]).

start_node(Name) ->
    start_node(Name, "").

stop_node(Node) ->
    test_server:stop_node(Node).

get_nodenames(N, T) ->
    get_nodenames(N, T, []).

get_nodenames(0, _, Acc) ->
    Acc;
get_nodenames(N, T, Acc) ->
    {A,B,C} = now(),
    get_nodenames(N - 1,
                  T,
                  [list_to_atom(atom_to_list(T)
                                ++
                                "-"
                                ++
                                atom_to_list(erl_distribution_SUITE)
                                ++
                                "-"
                                ++
                                integer_to_list(A)
                                ++
                                "-"
                                ++
                                integer_to_list(B)
                                ++
                                "-" ++ integer_to_list(C))|
                   Acc]).

get_numbered_nodenames(N, T) ->
    get_numbered_nodenames(N, T, []).

get_numbered_nodenames(0, _, Acc) ->
    Acc;
get_numbered_nodenames(N, T, Acc) ->
    {A,B,C} = now(),
    NL =
        [list_to_atom(atom_to_list(T)
                      ++
                      integer_to_list(N)
                      ++
                      "-"
                      ++
                      atom_to_list(erl_distribution_SUITE)
                      ++
                      "-"
                      ++
                      integer_to_list(A)
                      ++
                      "-"
                      ++
                      integer_to_list(B) ++ "-" ++ integer_to_list(C))|
         Acc],
    get_numbered_nodenames(N - 1, T, NL).

wait_until(Fun) ->
    case Fun() of
        true ->
            ok;
        _ ->
            receive after 100 -> wait_until(Fun) end
    end.

repeat(Fun, 0) when is_function(Fun) ->
    ok;
repeat(Fun, N) when is_function(Fun), is_integer(N), N > 0 ->
    Fun(),
    repeat(Fun, N - 1).

no_msgs(Wait) ->
    receive after Wait -> no_msgs() end.

no_msgs() ->
    {messages,[]} = process_info(self(), messages).

block_emu(Ms) ->
    erts_debug:set_internal_state(available_internal_state, true),
    Res = erts_debug:set_internal_state(block, Ms),
    erts_debug:set_internal_state(available_internal_state, false),
    Res.



