-file("test/lib/edoc/src/edoc_scanner.erl", 1).

-module(edoc_scanner).

-export([string/1,string/2,format_error/1]).

-import(lists, [reverse/1]).

string(Cs) ->
    string(Cs, 1).

string(Cs, StartPos) ->
    case scan(Cs, StartPos) of
        {ok,Toks} ->
            {ok,Toks,StartPos};
        {error,E} ->
            {error,E,StartPos}
    end.

format_error({string,Quote,Head}) ->
    ["unterminated string starting with "
     ++
     io_lib:write_string(Head, Quote)];
format_error({illegal,Type}) ->
    io_lib:fwrite("illegal ~w", [Type]);
format_error(char) ->
    "unterminated character";
format_error(scan) ->
    "premature end";
format_error({base,Base}) ->
    io_lib:fwrite("illegal base '~w'", [Base]);
format_error(float) ->
    "bad float";
format_error(Other) ->
    io_lib:write(Other).

reserved(where) ->
    true;
reserved(_) ->
    false.

scan(Cs, Pos) ->
    scan1(Cs, [], Pos).

scan1([$\n|Cs], Toks, Pos) ->
    scan1(Cs, Toks, Pos + 1);
scan1([C|Cs], Toks, Pos) when C >= 0, C =< $\s ->
    scan1(Cs, Toks, Pos);
scan1([C|Cs], Toks, Pos) when C >= $a, C =< $z ->
    scan_atom(C, Cs, Toks, Pos);
scan1([C|Cs], Toks, Pos) when C >= $0, C =< $9 ->
    scan_number(C, Cs, Toks, Pos);
scan1([$-,C|Cs], Toks, Pos) when C >= $0, C =< $9 ->
    scan_signed_number($-, C, Cs, Toks, Pos);
scan1([$+,C|Cs], Toks, Pos) when C >= $0, C =< $9 ->
    scan_signed_number($+, C, Cs, Toks, Pos);
scan1([C|Cs], Toks, Pos) when C >= $A, C =< $Z ->
    scan_variable(C, Cs, Toks, Pos);
scan1([$_|Cs], Toks, Pos) ->
    scan_variable($_, Cs, Toks, Pos);
scan1([$$|Cs], Toks, Pos) ->
    case scan_char_const(Cs, Toks, Pos) of
        {ok,Result} ->
            {ok,Result};
        {error,truncated_char} ->
            scan_error(char, Pos);
        {error,illegal_character} ->
            scan_error({illegal,char}, Pos)
    end;
scan1([$'|Cs0], Toks, Pos) ->
    case scan_string(Cs0, $', Pos) of
        {S,Cs1,Pos1} ->
            case catch list_to_atom(S) of
                A when is_atom(A) ->
                    scan1(Cs1, [{atom,Pos,A}|Toks], Pos1);
                _Error ->
                    scan_error({illegal,atom}, Pos)
            end;
        {error,premature_end} ->
            scan_error({string,$',Cs0}, Pos);
        {error,truncated_char} ->
            scan_error(char, Pos);
        {error,illegal_character} ->
            scan_error({illegal,atom}, Pos)
    end;
scan1([$"|Cs0], Toks, Pos) ->
    case scan_string(Cs0, $", Pos) of
        {S,Cs1,Pos1} ->
            case Toks of
                [{string,Pos0,S0}|Toks1] ->
                    scan1(Cs1, [{string,Pos0,S0 ++ S}|Toks1], Pos1);
                _ ->
                    scan1(Cs1, [{string,Pos,S}|Toks], Pos1)
            end;
        {error,premature_end} ->
            scan_error({string,$",Cs0}, Pos);
        {error,truncated_char} ->
            scan_error(char, Pos);
        {error,illegal_character} ->
            scan_error({illegal,string}, Pos)
    end;
scan1([$<,$<|Cs], Toks, Pos) ->
    scan1(Cs, [{'<<',Pos}|Toks], Pos);
scan1([$>,$>|Cs], Toks, Pos) ->
    scan1(Cs, [{'>>',Pos}|Toks], Pos);
scan1([$-,$>|Cs], Toks, Pos) ->
    scan1(Cs, [{'->',Pos}|Toks], Pos);
scan1([$:,$:|Cs], Toks, Pos) ->
    scan1(Cs, [{'::',Pos}|Toks], Pos);
scan1([$/,$/|Cs], Toks, Pos) ->
    scan1(Cs, [{'//',Pos}|Toks], Pos);
scan1([$.,$.,$.|Cs], Toks, Pos) ->
    scan1(Cs, [{'...',Pos}|Toks], Pos);
scan1([$.,$.|Cs], Toks, Pos) ->
    scan1(Cs, [{'..',Pos}|Toks], Pos);
scan1([C|Cs], Toks, Pos) ->
    P = list_to_atom([C]),
    scan1(Cs, [{P,Pos}|Toks], Pos);
scan1([], Toks0, _Pos) ->
    Toks = reverse(Toks0),
    {ok,Toks}.

scan_variable(C, Cs, Toks, Pos) ->
    {Wcs,Cs1} = scan_name(Cs, []),
    W = [C|reverse(Wcs)],
    case W of
        "_" ->
            scan1(Cs1, [{an_var,Pos,'_'}|Toks], Pos);
        _ ->
            case catch list_to_atom(W) of
                A when is_atom(A) ->
                    scan1(Cs1, [{var,Pos,A}|Toks], Pos);
                _ ->
                    scan_error({illegal,variable}, Pos)
            end
    end.

scan_atom(C, Cs, Toks, Pos) ->
    {Wcs,Cs1} = scan_name(Cs, []),
    W = [C|reverse(Wcs)],
    case catch list_to_atom(W) of
        A when is_atom(A) ->
            case reserved(A) of
                true ->
                    scan1(Cs1, [{A,Pos}|Toks], Pos);
                false ->
                    scan1(Cs1, [{atom,Pos,A}|Toks], Pos)
            end;
        _ ->
            scan_error({illegal,token}, Pos)
    end.

scan_name([C|Cs], Ncs) ->
    case name_char(C) of
        true ->
            scan_name(Cs, [C|Ncs]);
        false ->
            {Ncs,[C|Cs]}
    end;
scan_name([], Ncs) ->
    {Ncs,[]}.

name_char(C) when C >= $a, C =< $z ->
    true;
name_char(C) when C >= $ß, C =< $ÿ, C /= $÷ ->
    true;
name_char(C) when C >= $A, C =< $Z ->
    true;
name_char(C) when C >= $À, C =< $Þ, C /= $× ->
    true;
name_char(C) when C >= $0, C =< $9 ->
    true;
name_char($_) ->
    true;
name_char($@) ->
    true;
name_char(_) ->
    false.

scan_string(Cs, Quote, Pos) ->
    scan_string(Cs, [], Quote, Pos).

scan_string([Quote|Cs], Scs, Quote, Pos) ->
    {reverse(Scs),Cs,Pos};
scan_string([], _Scs, _Quote, _Pos) ->
    {error,premature_end};
scan_string(Cs0, Scs, Quote, Pos) ->
    case scan_char(Cs0, Pos) of
        {C,Cs,Pos1} ->
            scan_string(Cs, [C|Scs], Quote, Pos1);
        Error ->
            Error
    end.

scan_char_const([$\s|_Cs0], _Toks, _Pos) ->
    {error,illegal_character};
scan_char_const(Cs0, Toks, Pos) ->
    case scan_char(Cs0, Pos) of
        {C,Cs,Pos1} ->
            scan1(Cs, [{char,Pos,C}|Toks], Pos1);
        Error ->
            Error
    end.

scan_char([$\\|Cs], Pos) ->
    scan_escape(Cs, Pos);
scan_char([C|_Cs], _Pos) when C =< 31 ->
    {error,illegal_character};
scan_char([C|Cs], Pos) ->
    {C,Cs,Pos};
scan_char([], _Pos) ->
    {error,truncated_char}.

scan_escape([O1,O2,O3|Cs], Pos)
    when O1 >= $0, O1 =< $3, O2 >= $0, O2 =< $7, O3 >= $0, O3 =< $7 ->
    Val = (O1 * 8 + O2) * 8 + O3 - 73 * $0,
    {Val,Cs,Pos};
scan_escape([O1,O2|Cs], Pos) when O1 >= $0, O1 =< $7, O2 >= $0, O2 =< $7 ->
    Val = O1 * 8 + O2 - 9 * $0,
    {Val,Cs,Pos};
scan_escape([O1|Cs], Pos) when O1 >= $0, O1 =< $7 ->
    {O1 - $0,Cs,Pos};
scan_escape([$^,C|Cs], Pos) ->
    if
        C >= $@, C =< $_ ->
            {C - $@,Cs,Pos};
        true ->
            {error,illegal_control_character}
    end;
scan_escape([C|Cs], Pos) ->
    case escape_char(C) of
        C1 when C1 > $\000 ->
            {C1,Cs,Pos};
        _ ->
            {error,undefined_escape_sequence}
    end;
scan_escape([], _Pos) ->
    {error,truncated_char}.

escape_char($b) ->
    $\b;
escape_char($d) ->
    $\d;
escape_char($e) ->
    $\e;
escape_char($f) ->
    $\f;
escape_char($n) ->
    $\n;
escape_char($r) ->
    $\r;
escape_char($s) ->
    $\s;
escape_char($t) ->
    $\t;
escape_char($v) ->
    $\v;
escape_char($\\) ->
    $\\;
escape_char($') ->
    $';
escape_char($") ->
    $";
escape_char(_C) ->
    $\000.

scan_number(C, Cs0, Toks, Pos) ->
    {Ncs,Cs,Pos1} = scan_integer(Cs0, [C], Pos),
    scan_after_int(Cs, Ncs, Toks, Pos, Pos1).

scan_signed_number(S, C, Cs0, Toks, Pos) ->
    {Ncs,Cs,Pos1} = scan_integer(Cs0, [C,S], Pos),
    scan_after_int(Cs, Ncs, Toks, Pos, Pos1).

scan_integer([C|Cs], Stack, Pos) when C >= $0, C =< $9 ->
    scan_integer(Cs, [C|Stack], Pos);
scan_integer(Cs, Stack, Pos) ->
    {Stack,Cs,Pos}.

scan_after_int([$.,C|Cs0], Ncs0, Toks, SPos, CPos) when C >= $0, C =< $9 ->
    {Ncs,Cs,CPos1} = scan_integer(Cs0, [C,$.|Ncs0], CPos),
    scan_after_fraction(Cs, Ncs, Toks, SPos, CPos1);
scan_after_int(Cs, Ncs, Toks, SPos, CPos) ->
    N = list_to_integer(reverse(Ncs)),
    scan1(Cs, [{integer,SPos,N}|Toks], CPos).

scan_after_fraction([$E|Cs], Ncs, Toks, SPos, CPos) ->
    scan_exponent(Cs, [$E|Ncs], Toks, SPos, CPos);
scan_after_fraction([$e|Cs], Ncs, Toks, SPos, CPos) ->
    scan_exponent(Cs, [$e|Ncs], Toks, SPos, CPos);
scan_after_fraction(Cs, Ncs, Toks, SPos, CPos) ->
    case catch list_to_float(reverse(Ncs)) of
        N when is_float(N) ->
            scan1(Cs, [{float,SPos,N}|Toks], CPos);
        _Error ->
            scan_error({illegal,float}, SPos)
    end.

scan_exponent([$+|Cs], Ncs, Toks, SPos, CPos) ->
    scan_exponent1(Cs, [$+|Ncs], Toks, SPos, CPos);
scan_exponent([$-|Cs], Ncs, Toks, SPos, CPos) ->
    scan_exponent1(Cs, [$-|Ncs], Toks, SPos, CPos);
scan_exponent(Cs, Ncs, Toks, SPos, CPos) ->
    scan_exponent1(Cs, Ncs, Toks, SPos, CPos).

scan_exponent1([C|Cs0], Ncs0, Toks, SPos, CPos) when C >= $0, C =< $9 ->
    {Ncs,Cs,CPos1} = scan_integer(Cs0, [C|Ncs0], CPos),
    case catch list_to_float(reverse(Ncs)) of
        N when is_float(N) ->
            scan1(Cs, [{float,SPos,N}|Toks], CPos1);
        _Error ->
            scan_error({illegal,float}, SPos)
    end;
scan_exponent1(_, _, _, _, CPos) ->
    scan_error(float, CPos).

scan_error(In, Pos) ->
    {error,{Pos,edoc_scanner,In}}.



