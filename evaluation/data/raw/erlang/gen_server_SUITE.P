-file("test/lib/stdlib/test/gen_server_SUITE.erl", 1).

-module(gen_server_SUITE).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/stdlib/test/gen_server_SUITE.erl", 22).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/kernel-2.15.3/include/inet.hrl",
      1).

-record(hostent,{h_name :: undefined | inet:hostname(),
                 h_aliases = [] :: [inet:hostname()],
                 h_addrtype :: undefined | inet | inet6,
                 h_length :: undefined | non_neg_integer(),
                 h_addr_list = [] :: [inet:ip_address()]}).

-file("test/lib/stdlib/test/gen_server_SUITE.erl", 23).

-export([init_per_testcase/2,end_per_testcase/2]).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2]).

-export([start/1,
         crash/1,
         call/1,
         cast/1,
         cast_fast/1,
         info/1,
         abcast/1,
         multicall/1,
         multicall_down/1,
         call_remote1/1,
         call_remote2/1,
         call_remote3/1,
         call_remote_n1/1,
         call_remote_n2/1,
         call_remote_n3/1,
         spec_init/1,
         spec_init_local_registered_parent/1,
         spec_init_global_registered_parent/1,
         otp_5854/1,
         hibernate/1,
         otp_7669/1,
         call_format_status/1,
         error_format_status/1,
         get_state/1,
         replace_state/1,
         call_with_huge_message_queue/1]).

-export([spec_init_local/2,
         spec_init_global/2,
         spec_init_via/2,
         spec_init_default_timeout/2,
         spec_init_global_default_timeout/2,
         spec_init_anonymous/1,
         spec_init_anonymous_default_timeout/1,
         spec_init_not_proc_lib/1,
         cast_fast_messup/0]).

-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         format_status/2]).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [start,
     crash,
     call,
     cast,
     cast_fast,
     info,
     abcast,
     multicall,
     multicall_down,
     call_remote1,
     call_remote2,
     call_remote3,
     call_remote_n1,
     call_remote_n2,
     call_remote_n3,
     spec_init,
     spec_init_local_registered_parent,
     spec_init_global_registered_parent,
     otp_5854,
     hibernate,
     otp_7669,
     call_format_status,
     error_format_status,
     get_state,
     replace_state,
     call_with_huge_message_queue].

groups() ->
    [].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

init_per_testcase(Case, Config)
    when
        Case == call_remote1;
        Case == call_remote2;
        Case == call_remote3;
        Case == call_remote_n1;
        Case == call_remote_n2;
        Case == call_remote_n3 ->
    {ok,N} = start_node(hubba),
    Dog = test_server:timetrap(test_server:minutes(1)),
    [{node,N},{watchdog,Dog}|Config];
init_per_testcase(_Case, Config) ->
    Dog = test_server:timetrap(test_server:minutes(1)),
    [{watchdog,Dog}|Config].

end_per_testcase(_Case, Config) ->
    case proplists:get_value(node, Config) of
        undefined ->
            ok;
        N ->
            test_server:stop_node(N)
    end,
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog),
    ok.

start(suite) ->
    [];
start(Config) when is_list(Config) ->
    OldFl = process_flag(trap_exit, true),
    {ok,Pid0} = gen_server:start(gen_server_SUITE, [], []),
    ok = gen_server:call(Pid0, started_p),
    ok = gen_server:call(Pid0, stop),
    busy_wait_for_process(Pid0, 600),
    {'EXIT',{noproc,_}} = (catch gen_server:call(Pid0, started_p, 1)),
    {ok,Pid00} =
        gen_server:start(gen_server_SUITE, [], [{timeout,1000}]),
    ok = gen_server:call(Pid00, started_p),
    ok = gen_server:call(Pid00, stop),
    {error,timeout} =
        gen_server:start(gen_server_SUITE, sleep, [{timeout,100}]),
    ignore = gen_server:start(gen_server_SUITE, ignore, []),
    {error,stopped} = gen_server:start(gen_server_SUITE, stop, []),
    {ok,Pid1} = gen_server:start_link(gen_server_SUITE, [], []),
    ok = gen_server:call(Pid1, started_p),
    ok = gen_server:call(Pid1, stop),
    receive
        {'EXIT',Pid1,stopped} ->
            ok
    after
        5000 -> test_server:fail(not_stopped)
    end,
    {ok,Pid2} =
        gen_server:start({local,my_test_name}, gen_server_SUITE, [], []),
    ok = gen_server:call(my_test_name, started_p),
    {error,{already_started,Pid2}} =
        gen_server:start({local,my_test_name}, gen_server_SUITE, [], []),
    ok = gen_server:call(my_test_name, stop),
    busy_wait_for_process(Pid2, 600),
    {'EXIT',{noproc,_}} = (catch gen_server:call(Pid2, started_p, 10)),
    {ok,Pid3} =
        gen_server:start_link({local,my_test_name},
                              gen_server_SUITE,
                              [],
                              []),
    ok = gen_server:call(my_test_name, started_p),
    {error,{already_started,Pid3}} =
        gen_server:start({local,my_test_name}, gen_server_SUITE, [], []),
    ok = gen_server:call(my_test_name, stop),
    receive
        {'EXIT',Pid3,stopped} ->
            ok
    after
        5000 -> test_server:fail(not_stopped)
    end,
    {ok,Pid4} =
        gen_server:start({global,my_test_name},
                         gen_server_SUITE,
                         [],
                         []),
    ok = gen_server:call({global,my_test_name}, started_p),
    {error,{already_started,Pid4}} =
        gen_server:start({global,my_test_name},
                         gen_server_SUITE,
                         [],
                         []),
    ok = gen_server:call({global,my_test_name}, stop),
    test_server:sleep(1),
    {'EXIT',{noproc,_}} = (catch gen_server:call(Pid4, started_p, 10)),
    {ok,Pid5} =
        gen_server:start_link({global,my_test_name},
                              gen_server_SUITE,
                              [],
                              []),
    ok = gen_server:call({global,my_test_name}, started_p),
    {error,{already_started,Pid5}} =
        gen_server:start({global,my_test_name},
                         gen_server_SUITE,
                         [],
                         []),
    ok = gen_server:call({global,my_test_name}, stop),
    receive
        {'EXIT',Pid5,stopped} ->
            ok
    after
        5000 -> test_server:fail(not_stopped)
    end,
    dummy_via:reset(),
    {ok,Pid6} =
        gen_server:start({via,dummy_via,my_test_name},
                         gen_server_SUITE,
                         [],
                         []),
    ok = gen_server:call({via,dummy_via,my_test_name}, started_p),
    {error,{already_started,Pid6}} =
        gen_server:start({via,dummy_via,my_test_name},
                         gen_server_SUITE,
                         [],
                         []),
    ok = gen_server:call({via,dummy_via,my_test_name}, stop),
    test_server:sleep(1),
    {'EXIT',{noproc,_}} = (catch gen_server:call(Pid6, started_p, 10)),
    dummy_via:reset(),
    {ok,Pid7} =
        gen_server:start_link({via,dummy_via,my_test_name},
                              gen_server_SUITE,
                              [],
                              []),
    ok = gen_server:call({via,dummy_via,my_test_name}, started_p),
    {error,{already_started,Pid7}} =
        gen_server:start({via,dummy_via,my_test_name},
                         gen_server_SUITE,
                         [],
                         []),
    ok = gen_server:call({via,dummy_via,my_test_name}, stop),
    receive
        {'EXIT',Pid7,stopped} ->
            ok
    after
        5000 -> test_server:fail(not_stopped)
    end,
    test_server:messages_get(),
    process_flag(trap_exit, OldFl),
    ok.

crash(Config) when is_list(Config) ->
    error_logger_forwarder:register(),
    process_flag(trap_exit, true),
    {ok,Pid0} = gen_server:start_link(gen_server_SUITE, [], []),
    {'EXIT',{{shutdown,reason},_}} =
        (catch gen_server:call(Pid0, shutdown_reason)),
    receive
        {'EXIT',Pid0,{shutdown,reason}} ->
            ok
    end,
    {ok,Pid1} =
        gen_server:start_link(gen_server_SUITE, {state,state1}, []),
    {'EXIT',{{shutdown,stop_reason},_}} =
        (catch gen_server:call(Pid1, stop_shutdown_reason)),
    receive
        {'EXIT',Pid1,{shutdown,stop_reason}} ->
            ok
    end,
    {ok,Pid2} = gen_server:start_link(gen_server_SUITE, [], []),
    {'EXIT',{shutdown,_}} = (catch gen_server:call(Pid2, exit_shutdown)),
    receive
        {'EXIT',Pid2,shutdown} ->
            ok
    end,
    {ok,Pid3} =
        gen_server:start_link(gen_server_SUITE, {state,state3}, []),
    {'EXIT',{shutdown,_}} = (catch gen_server:call(Pid3, stop_shutdown)),
    receive
        {'EXIT',Pid3,shutdown} ->
            ok
    end,
    process_flag(trap_exit, false),
    {ok,Pid4} = gen_server:start(gen_server_SUITE, {state,state4}, []),
    {'EXIT',{crashed,_}} = (catch gen_server:call(Pid4, crash)),
    receive
        {error,
         _GroupLeader4,
         {Pid4,"** Generic server" ++ _,[Pid4,crash,state4,crashed]}} ->
            ok;
        Other4a ->
            io:format("Unexpected: ~p", [Other4a]),
            test_server:fail()
    end,
    receive
        {error_report,_,{Pid4,crash_report,[List4|_]}} ->
            {exit,crashed,_} = proplists:get_value(error_info, List4),
            Pid4 = proplists:get_value(pid, List4);
        Other4 ->
            io:format("Unexpected: ~p", [Other4]),
            test_server:fail()
    end,
    receive
        Any ->
            io:format("Unexpected: ~p", [Any]),
            test_server:fail()
    after
        500 -> ok
    end,
    ok.

call(suite) ->
    [];
call(Config) when is_list(Config) ->
    OldFl = process_flag(trap_exit, true),
    {ok,_Pid} =
        gen_server:start_link({local,my_test_name},
                              gen_server_SUITE,
                              [],
                              []),
    ok = gen_server:call(my_test_name, started_p),
    delayed = gen_server:call(my_test_name, {delayed_answer,1}),
    ok = gen_server:call(my_test_name, {call_within,1000}),
    test_server:sleep(500),
    ok = gen_server:call(my_test_name, next_call),
    ok = gen_server:call(my_test_name, {call_within,1000}),
    test_server:sleep(1500),
    false = gen_server:call(my_test_name, next_call),
    delayed = gen_server:call(my_test_name, {delayed_answer,1}, 30),
    {'EXIT',{timeout,_}} =
        (catch gen_server:call(my_test_name, {delayed_answer,30}, 1)),
    {'EXIT',{{bad_return_value,badreturn},_}} =
        (catch gen_server:call(my_test_name, badreturn)),
    process_flag(trap_exit, OldFl),
    ok.

start_node(Name) ->
    Pa = filename:dirname(code:which(gen_server_SUITE)),
    N = test_server:start_node(Name, slave, [{args," -pa " ++ Pa}]),
    global:sync(),
    N.

call_remote1(suite) ->
    [];
call_remote1(Config) when is_list(Config) ->
    N = hubba,
    Node = proplists:get_value(node, Config),
    {ok,Pid} =
        rpc:call(Node,
                 gen_server,
                 start,
                 [{global,N},gen_server_SUITE,[],[]]),
    ok = (catch gen_server:call({global,N}, started_p, infinity)),
    exit(Pid, boom),
    {'EXIT',{Reason,_}} =
        (catch gen_server:call({global,N}, started_p, infinity)),
    true =
        Reason == noproc
        orelse
        Reason == boom,
    ok.

call_remote2(suite) ->
    [];
call_remote2(Config) when is_list(Config) ->
    N = hubba,
    Node = proplists:get_value(node, Config),
    {ok,Pid} =
        rpc:call(Node,
                 gen_server,
                 start,
                 [{global,N},gen_server_SUITE,[],[]]),
    ok = (catch gen_server:call(Pid, started_p, infinity)),
    exit(Pid, boom),
    {'EXIT',{Reason,_}} =
        (catch gen_server:call(Pid, started_p, infinity)),
    true =
        Reason == noproc
        orelse
        Reason == boom,
    ok.

call_remote3(suite) ->
    [];
call_remote3(Config) when is_list(Config) ->
    Node = proplists:get_value(node, Config),
    {ok,Pid} =
        rpc:call(Node,
                 gen_server,
                 start,
                 [{local,piller},gen_server_SUITE,[],[]]),
    ok = (catch gen_server:call({piller,Node}, started_p, infinity)),
    exit(Pid, boom),
    {'EXIT',{Reason,_}} =
        (catch gen_server:call({piller,Node}, started_p, infinity)),
    true =
        Reason == noproc
        orelse
        Reason == boom,
    ok.

call_remote_n1(suite) ->
    [];
call_remote_n1(Config) when is_list(Config) ->
    N = hubba,
    Node = proplists:get_value(node, Config),
    {ok,_Pid} =
        rpc:call(Node,
                 gen_server,
                 start,
                 [{global,N},gen_server_SUITE,[],[]]),
    _ = test_server:stop_node(Node),
    {'EXIT',{noproc,_}} =
        (catch gen_server:call({global,N}, started_p, infinity)),
    ok.

call_remote_n2(suite) ->
    [];
call_remote_n2(Config) when is_list(Config) ->
    N = hubba,
    Node = proplists:get_value(node, Config),
    {ok,Pid} =
        rpc:call(Node,
                 gen_server,
                 start,
                 [{global,N},gen_server_SUITE,[],[]]),
    _ = test_server:stop_node(Node),
    {'EXIT',{{nodedown,Node},_}} =
        (catch gen_server:call(Pid, started_p, infinity)),
    ok.

call_remote_n3(suite) ->
    [];
call_remote_n3(Config) when is_list(Config) ->
    Node = proplists:get_value(node, Config),
    {ok,_Pid} =
        rpc:call(Node,
                 gen_server,
                 start,
                 [{local,piller},gen_server_SUITE,[],[]]),
    _ = test_server:stop_node(Node),
    {'EXIT',{{nodedown,Node},_}} =
        (catch gen_server:call({piller,Node}, started_p, infinity)),
    ok.

cast(suite) ->
    [];
cast(Config) when is_list(Config) ->
    {ok,Pid} =
        gen_server:start({local,my_test_name}, gen_server_SUITE, [], []),
    ok = gen_server:call(my_test_name, started_p),
    ok = gen_server:cast(my_test_name, {self(),handle_cast}),
    receive
        {Pid,handled_cast} ->
            ok
    after
        1000 -> test_server:fail(handle_cast)
    end,
    ok = gen_server:cast(my_test_name, {self(),delayed_cast,1}),
    receive
        {Pid,delayed} ->
            ok
    after
        1000 -> test_server:fail(delayed_cast)
    end,
    ok = gen_server:cast(my_test_name, {self(),stop}),
    receive
        {Pid,stopped} ->
            ok
    after
        1000 -> test_server:fail(stop)
    end,
    ok.

cast_fast(suite) ->
    [];
cast_fast(doc) ->
    ["Test that cast really return immediately"];
cast_fast(Config) when is_list(Config) ->
    {ok,Node} = start_node(hubba),
    {_,"@" ++ Host} =
        lists:splitwith(fun($@) ->
                               false;
                           (_) ->
                               true
                        end,
                        atom_to_list(Node)),
    FalseNode = list_to_atom("hopp@" ++ Host),
    true = rpc:cast(Node, gen_server_SUITE, cast_fast_messup, []),
    test_server:sleep(1000),
    [Node] = nodes(),
    {Time,ok} =
        test_server:timecall(gen_server, cast, [{hopp,FalseNode},hopp]),
    true = test_server:stop_node(Node),
    if
        Time > 1.0 ->
            test_server:fail(hanging_cast);
        true ->
            ok
    end.

cast_fast_messup() ->
    unregister(erl_epmd),
    erl_epmd:start_link(),
    {ok,S} = gen_tcp:listen(0, []),
    {ok,P} = inet:port(S),
    {ok,_Creation} = erl_epmd:register_node(hopp, P),
    receive after infinity -> ok end.

info(suite) ->
    [];
info(Config) when is_list(Config) ->
    {ok,Pid} =
        gen_server:start({local,my_test_name}, gen_server_SUITE, [], []),
    ok = gen_server:call(my_test_name, started_p),
    Pid ! {self(),handle_info},
    receive
        {Pid,handled_info} ->
            ok
    after
        1000 -> test_server:fail(handle_info)
    end,
    Pid ! {self(),delayed_info,1},
    receive
        {Pid,delayed_info} ->
            ok
    after
        1000 -> test_server:fail(delayed_info)
    end,
    Pid ! {self(),stop},
    receive
        {Pid,stopped_info} ->
            ok
    after
        1000 -> test_server:fail(stop_info)
    end,
    ok.

hibernate(suite) ->
    [];
hibernate(Config) when is_list(Config) ->
    OldFl = process_flag(trap_exit, true),
    {ok,Pid0} =
        gen_server:start_link({local,my_test_name_hibernate0},
                              gen_server_SUITE,
                              hibernate,
                              []),
    receive after 1000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid0, current_function),
    ok = gen_server:call(my_test_name_hibernate0, stop),
    receive
        {'EXIT',Pid0,stopped} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,Pid} =
        gen_server:start_link({local,my_test_name_hibernate},
                              gen_server_SUITE,
                              [],
                              []),
    ok = gen_server:call(my_test_name_hibernate, started_p),
    true = gen_server:call(my_test_name_hibernate, hibernate),
    receive after 1000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    Parent = self(),
    Fun =
        fun() ->
               receive
                   go ->
                       ok
               end,
               receive after 1000 -> ok end,
               X = process_info(Pid, current_function),
               Pid ! continue,
               Parent ! {result,X}
        end,
    Pid2 = spawn_link(Fun),
    true =
        gen_server:call(my_test_name_hibernate,
                        {hibernate_noreply,Pid2}),
    gen_server:cast(my_test_name_hibernate, hibernate_later),
    true =
        {current_function,{erlang,hibernate,3}}
        =/=
        process_info(Pid, current_function),
    receive after 2000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    ok = gen_server:call(my_test_name_hibernate, started_p),
    true =
        {current_function,{erlang,hibernate,3}}
        =/=
        process_info(Pid, current_function),
    gen_server:cast(my_test_name_hibernate, hibernate_now),
    receive after 1000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    ok = gen_server:call(my_test_name_hibernate, started_p),
    true =
        {current_function,{erlang,hibernate,3}}
        =/=
        process_info(Pid, current_function),
    Pid ! hibernate_later,
    true =
        {current_function,{erlang,hibernate,3}}
        =/=
        process_info(Pid, current_function),
    receive after 2000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    ok = gen_server:call(my_test_name_hibernate, started_p),
    true =
        {current_function,{erlang,hibernate,3}}
        =/=
        process_info(Pid, current_function),
    Pid ! hibernate_now,
    receive after 1000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    ok = gen_server:call(my_test_name_hibernate, started_p),
    true =
        {current_function,{erlang,hibernate,3}}
        =/=
        process_info(Pid, current_function),
    receive
        {result,R} ->
            {current_function,{erlang,hibernate,3}} = R
    end,
    true = gen_server:call(my_test_name_hibernate, hibernate),
    receive after 1000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    sys:suspend(my_test_name_hibernate),
    receive after 1000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    sys:resume(my_test_name_hibernate),
    receive after 1000 -> ok end,
    {current_function,{erlang,hibernate,3}} =
        process_info(Pid, current_function),
    ok = gen_server:call(my_test_name_hibernate, started_p),
    true =
        {current_function,{erlang,hibernate,3}}
        =/=
        process_info(Pid, current_function),
    ok = gen_server:call(my_test_name_hibernate, stop),
    receive
        {'EXIT',Pid,stopped} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    process_flag(trap_exit, OldFl),
    ok.

abcast(suite) ->
    [];
abcast(Config) when is_list(Config) ->
    {ok,Pid} =
        gen_server:start({local,my_test_name}, gen_server_SUITE, [], []),
    ok = gen_server:call(my_test_name, started_p),
    abcast = gen_server:abcast(my_test_name, {self(),handle_cast}),
    receive
        {Pid,handled_cast} ->
            ok
    after
        1000 -> test_server:fail(abcast)
    end,
    abcast =
        gen_server:abcast([node()],
                          my_test_name,
                          {self(),delayed_cast,1}),
    receive
        {Pid,delayed} ->
            ok
    after
        1000 -> test_server:fail(delayed_abcast)
    end,
    abcast = gen_server:abcast(my_test_name, {self(),stop}),
    receive
        {Pid,stopped} ->
            ok
    after
        1000 -> test_server:fail(abcast_stop)
    end,
    ok.

multicall(suite) ->
    [];
multicall(Config) when is_list(Config) ->
    OldFl = process_flag(trap_exit, true),
    {ok,Pid} =
        gen_server:start_link({local,my_test_name},
                              gen_server_SUITE,
                              [],
                              []),
    ok = gen_server:call(my_test_name, started_p),
    Nodes = nodes(),
    Node = node(),
    {[{Node,delayed}],Nodes} =
        gen_server:multi_call(my_test_name, {delayed_answer,1}),
    {[{Node,ok}],[]} =
        gen_server:multi_call([Node], my_test_name, {call_within,1000}),
    test_server:sleep(500),
    {[{Node,ok}],[]} =
        gen_server:multi_call([Node], my_test_name, next_call),
    {[{Node,ok}],[]} =
        gen_server:multi_call([Node], my_test_name, {call_within,1000}),
    test_server:sleep(1500),
    {[{Node,false}],[]} =
        gen_server:multi_call([Node], my_test_name, next_call),
    {[{Node,ok}],[]} = gen_server:multi_call([Node], my_test_name, stop),
    receive
        {'EXIT',Pid,stopped} ->
            ok
    after
        1000 -> test_server:fail(multicall_stop)
    end,
    process_flag(trap_exit, OldFl),
    ok.

multicall_down(suite) ->
    [];
multicall_down(Config) when is_list(Config) ->
    Name = node@test01,
    {Good,Bad} =
        gen_server:multi_call([Name,node()],
                              global_name_server,
                              info,
                              3000),
    io:format("good = ~p, bad = ~p~n", [Good,Bad]),
    [Name] = Bad,
    ok.

busy_wait_for_process(Pid, N) ->
    case is_process_alive(Pid) of
        true ->
            receive after 100 -> ok end,
            busy_wait_for_process(Pid, N - 1);
        _ ->
            ok
    end.

spec_init(doc) ->
    ["Test gen_server:enter_loop/[3,4,5]. Used when you want to write y"
     "our own special init-phase."];
spec_init(suite) ->
    [];
spec_init(Config) when is_list(Config) ->
    OldFlag = process_flag(trap_exit, true),
    {ok,Pid0} = start_link(spec_init_local, [{ok,my_server},[]]),
    ok = gen_server:call(Pid0, started_p),
    ok = gen_server:call(Pid0, stop),
    receive
        {'EXIT',Pid0,stopped} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,Pid01} = start_link(spec_init_local, [{not_ok,my_server},[]]),
    receive
        {'EXIT',Pid01,process_not_registered} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,Pid1} = start_link(spec_init_global, [{ok,my_server},[]]),
    ok = gen_server:call(Pid1, started_p),
    ok = gen_server:call(Pid1, stop),
    receive
        {'EXIT',Pid1,stopped} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,Pid11} = start_link(spec_init_global, [{not_ok,my_server},[]]),
    receive
        {'EXIT',Pid11,process_not_registered_globally} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,Pid2} = start_link(spec_init_anonymous, [[]]),
    ok = gen_server:call(Pid2, started_p),
    ok = gen_server:call(Pid2, stop),
    receive
        {'EXIT',Pid2,stopped} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,Pid3} = start_link(spec_init_anonymous_default_timeout, [[]]),
    ok = gen_server:call(Pid3, started_p),
    ok = gen_server:call(Pid3, stop),
    receive
        {'EXIT',Pid3,stopped} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,Pid4} =
        start_link(spec_init_default_timeout, [{ok,my_server},[]]),
    ok = gen_server:call(Pid4, started_p),
    ok = gen_server:call(Pid4, stop),
    receive
        {'EXIT',Pid4,stopped} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    {ok,_PidHurra} =
        start_link(spec_init_global_default_timeout, [{ok,hurra},[]]),
    timer:sleep(1000),
    ok = gen_server:call(_PidHurra, started_p),
    Pid5 = spawn_link(gen_server_SUITE, spec_init_not_proc_lib, [[]]),
    receive
        {'EXIT',Pid5,process_was_not_started_by_proc_lib} ->
            ok
    after
        5000 -> test_server:fail(gen_server_did_not_die)
    end,
    process_flag(trap_exit, OldFlag),
    ok.

spec_init_local_registered_parent(doc) ->
    ["Test that terminate is run when the parent is a locally registere"
     "d process OTP-4820"];
spec_init_local_registered_parent(suite) ->
    [];
spec_init_local_registered_parent(Config) when is_list(Config) ->
    register(foobar, self()),
    process_flag(trap_exit, true),
    {ok,Pid} = start_link(spec_init_local, [{ok,my_server},[]]),
    ok = gen_server:cast(my_server, {self(),stop}),
    receive
        {Pid,stopped} ->
            ok
    after
        1000 -> test_server:fail(stop)
    end,
    unregister(foobar),
    ok.

spec_init_global_registered_parent(doc) ->
    ["Test that terminate is run when the parent is a global registered"
     " process OTP-4820"];
spec_init_global_registered_parent(suite) ->
    [];
spec_init_global_registered_parent(Config) when is_list(Config) ->
    global:register_name(foobar, self()),
    process_flag(trap_exit, true),
    {ok,Pid} = start_link(spec_init_global, [{ok,my_server},[]]),
    ok = gen_server:call(Pid, started_p),
    ok = gen_server:cast(Pid, {self(),stop}),
    receive
        {Pid,stopped} ->
            ok
    after
        1000 -> test_server:fail(stop)
    end,
    global:unregister_name(foobar),
    ok.

otp_5854(suite) ->
    [];
otp_5854(doc) ->
    ["Test check for registered name in enter_loop/3,4,5"];
otp_5854(Config) when is_list(Config) ->
    OldFlag = process_flag(trap_exit, true),
    dummy_via:reset(),
    register(armitage, self()),
    {ok,Pid1} = start_link(spec_init_local, [{not_ok,armitage},[]]),
    receive
        {'EXIT',Pid1,process_not_registered} ->
            ok
    after
        1000 -> test_server:fail(gen_server_started)
    end,
    unregister(armitage),
    global:register_name(armitage, self()),
    {ok,Pid2} = start_link(spec_init_global, [{not_ok,armitage},[]]),
    receive
        {'EXIT',Pid2,process_not_registered_globally} ->
            ok
    after
        1000 -> test_server:fail(gen_server_started)
    end,
    global:unregister_name(armitage),
    dummy_via:register_name(armitage, self()),
    {ok,Pid3} = start_link(spec_init_via, [{not_ok,armitage},[]]),
    receive
        {'EXIT',Pid3,{process_not_registered_via,dummy_via}} ->
            ok
    after
        1000 -> test_server:fail(gen_server_started)
    end,
    dummy_via:unregister_name(armitage),
    process_flag(trap_exit, OldFlag),
    ok.

otp_7669(Config) when is_list(Config) ->
    test_server:do_times(100, fun do_otp_7669_local_ignore/0),
    test_server:do_times(100, fun do_otp_7669_global_ignore/0),
    test_server:do_times(10, fun do_otp_7669_stop/0),
    ok.

do_otp_7669_local_ignore() ->
    ignore =
        gen_server:start({local,gen_server_SUITE},
                         gen_server_SUITE,
                         ignore,
                         []),
    undefined = whereis(gen_server_SUITE),
    ignore =
        gen_server:start({local,gen_server_SUITE},
                         gen_server_SUITE,
                         ignore,
                         []),
    undefined = whereis(gen_server_SUITE),
    ignore =
        gen_server:start_link({local,gen_server_SUITE},
                              gen_server_SUITE,
                              ignore,
                              []),
    undefined = whereis(gen_server_SUITE).

do_otp_7669_global_ignore() ->
    ignore =
        gen_server:start({global,gen_server_SUITE},
                         gen_server_SUITE,
                         ignore,
                         []),
    undefined = global:whereis_name(gen_server_SUITE),
    ignore =
        gen_server:start_link({global,gen_server_SUITE},
                              gen_server_SUITE,
                              ignore,
                              []),
    undefined = global:whereis_name(gen_server_SUITE).

do_otp_7669_stop() ->
    {error,stopped} =
        gen_server:start({local,gen_server_SUITE},
                         gen_server_SUITE,
                         stop,
                         []),
    undefined = whereis(gen_server_SUITE),
    {error,stopped} =
        gen_server:start({global,gen_server_SUITE},
                         gen_server_SUITE,
                         stop,
                         []),
    undefined = global:whereis_name(gen_server_SUITE).

call_format_status(suite) ->
    [];
call_format_status(doc) ->
    ["Test that sys:get_status/1,2 calls format_status/2"];
call_format_status(Config) when is_list(Config) ->
    {ok,Pid} =
        gen_server:start_link({local,call_format_status},
                              gen_server_SUITE,
                              [],
                              []),
    Status1 = sys:get_status(call_format_status),
    {status,Pid,_Mod,[_PDict,running,_Parent,_,Data1]} = Status1,
    [format_status_called|_] = lists:reverse(Data1),
    Status2 = sys:get_status(call_format_status, 5000),
    {status,Pid,_Mod,[_PDict,running,_Parent,_,Data2]} = Status2,
    [format_status_called|_] = lists:reverse(Data2),
    {ok,Pid3} = gen_server:start_link(gen_server_SUITE, [], []),
    Status3 = sys:get_status(Pid3),
    {status,Pid3,_Mod,[_PDict3,running,_Parent,_,Data3]} = Status3,
    [format_status_called|_] = lists:reverse(Data3),
    GlobalName1 = {global,"CallFormatStatus"},
    {ok,Pid4} =
        gen_server:start_link(GlobalName1, gen_server_SUITE, [], []),
    Status4 = sys:get_status(Pid4),
    {status,Pid4,_Mod,[_PDict4,running,_Parent,_,Data4]} = Status4,
    [format_status_called|_] = lists:reverse(Data4),
    GlobalName2 = {global,{name,"term"}},
    {ok,Pid5} =
        gen_server:start_link(GlobalName2, gen_server_SUITE, [], []),
    Status5 = sys:get_status(GlobalName2),
    {status,Pid5,_Mod,[_PDict5,running,_Parent,_,Data5]} = Status5,
    [format_status_called|_] = lists:reverse(Data5),
    ok.

error_format_status(suite) ->
    [];
error_format_status(doc) ->
    ["Test that an error termination calls format_status/2"];
error_format_status(Config) when is_list(Config) ->
    error_logger_forwarder:register(),
    OldFl = process_flag(trap_exit, true),
    State = "called format_status",
    {ok,Pid} =
        gen_server:start_link(gen_server_SUITE, {state,State}, []),
    {'EXIT',{crashed,_}} = (catch gen_server:call(Pid, crash)),
    receive
        {'EXIT',Pid,crashed} ->
            ok
    end,
    receive
        {error,
         _GroupLeader,
         {Pid,"** Generic server" ++ _,[Pid,crash,State,crashed]}} ->
            ok;
        Other ->
            io:format("Unexpected: ~p", [Other]),
            test_server:fail()
    end,
    test_server:messages_get(),
    process_flag(trap_exit, OldFl),
    ok.

get_state(suite) ->
    [];
get_state(doc) ->
    ["Test that sys:get_state/1,2 return the gen_server state"];
get_state(Config) when is_list(Config) ->
    State = self(),
    {ok,_Pid} =
        gen_server:start_link({local,get_state},
                              gen_server_SUITE,
                              {state,State},
                              []),
    State = sys:get_state(get_state),
    State = sys:get_state(get_state, 5000),
    {ok,Pid} =
        gen_server:start_link(gen_server_SUITE, {state,State}, []),
    State = sys:get_state(Pid),
    State = sys:get_state(Pid, 5000),
    ok.

replace_state(suite) ->
    [];
replace_state(doc) ->
    ["Test that sys:replace_state/1,2 replace the gen_server state"];
replace_state(Config) when is_list(Config) ->
    State = self(),
    {ok,_Pid} =
        gen_server:start_link({local,replace_state},
                              gen_server_SUITE,
                              {state,State},
                              []),
    State = sys:get_state(replace_state),
    NState1 = "replaced",
    Replace1 =
        fun(_) ->
               NState1
        end,
    NState1 = sys:replace_state(replace_state, Replace1),
    NState1 = sys:get_state(replace_state),
    {ok,Pid} =
        gen_server:start_link(gen_server_SUITE, {state,NState1}, []),
    NState1 = sys:get_state(Pid),
    Suffix = " again",
    NState2 = NState1 ++ Suffix,
    Replace2 =
        fun(S) ->
               S ++ Suffix
        end,
    NState2 = sys:replace_state(Pid, Replace2, 5000),
    NState2 = sys:get_state(Pid, 5000),
    Replace3 =
        fun(_) ->
               throw(fail)
        end,
    NState2 = sys:replace_state(Pid, Replace3),
    NState2 = sys:get_state(Pid, 5000),
    ok.

call_with_huge_message_queue(Config) when is_list(Config) ->
    case test_server:is_native(gen) of
        true ->
            {skip,
             "gen is native - huge message queue optimization is not im"
             "plemented"};
        false ->
            do_call_with_huge_message_queue()
    end.

do_call_with_huge_message_queue() ->
    Pid = spawn_link(fun echo_loop/0),
    {Time,ok} =
        tc(fun() ->
                  calls(10000, Pid)
           end),
    [ 
     self() ! {msg,N} ||
         N <- lists:seq(1, 500000)
    ],
    garbage_collect(),
    {NewTime,ok} =
        tc(fun() ->
                  calls(10000, Pid)
           end),
    io:format("Time for empty message queue: ~p", [Time]),
    io:format("Time for huge message queue: ~p", [NewTime]),
    IsCover = test_server:is_cover(),
    case (NewTime + 1) / (Time + 1) of
        Q when Q < 10; IsCover ->
            ok;
        Q ->
            io:format("Q = ~p", [Q]),
            test_server:fail()
    end,
    ok.

calls(0, _) ->
    ok;
calls(N, Pid) ->
    {ultimate_answer,42} = call(Pid, {ultimate_answer,42}),
    calls(N - 1, Pid).

call(Pid, Msg) ->
    gen_server:call(Pid, Msg, infinity).

tc(Fun) ->
    timer:tc(erlang, apply, [Fun,[]]).

echo_loop() ->
    receive
        {'$gen_call',{Pid,Ref},Msg} ->
            Pid ! {Ref,Msg},
            echo_loop()
    end.

start_link(Init, Options) ->
    proc_lib:start_link(gen_server_SUITE, Init, Options).

spec_init_local({ok,Name}, Options) ->
    process_flag(trap_exit, true),
    register(Name, self()),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE,
                          Options,
                          {},
                          {local,Name},
                          infinity);
spec_init_local({not_ok,Name}, Options) ->
    process_flag(trap_exit, true),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE,
                          Options,
                          {},
                          {local,Name},
                          infinity).

spec_init_global({ok,Name}, Options) ->
    process_flag(trap_exit, true),
    global:register_name(Name, self()),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE,
                          Options,
                          {},
                          {global,Name},
                          infinity);
spec_init_global({not_ok,Name}, Options) ->
    process_flag(trap_exit, true),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE,
                          Options,
                          {},
                          {global,Name},
                          infinity).

spec_init_via({ok,Name}, Options) ->
    process_flag(trap_exit, true),
    dummy_via:register_name(Name, self()),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE,
                          Options,
                          {},
                          {via,dummy_via,Name},
                          infinity);
spec_init_via({not_ok,Name}, Options) ->
    process_flag(trap_exit, true),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE,
                          Options,
                          {},
                          {via,dummy_via,Name},
                          infinity).

spec_init_default_timeout({ok,Name}, Options) ->
    process_flag(trap_exit, true),
    register(Name, self()),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE, Options, {}, {local,Name}).

spec_init_global_default_timeout({ok,Name}, Options) ->
    process_flag(trap_exit, true),
    global:register_name(Name, self()),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE, Options, {}, {global,Name}).

spec_init_anonymous(Options) ->
    process_flag(trap_exit, true),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE, Options, {}, infinity).

spec_init_anonymous_default_timeout(Options) ->
    process_flag(trap_exit, true),
    proc_lib:init_ack({ok,self()}),
    gen_server:enter_loop(gen_server_SUITE, Options, {}).

spec_init_not_proc_lib(Options) ->
    gen_server:enter_loop(gen_server_SUITE, Options, {}, infinity).

init([]) ->
    {ok,[]};
init(ignore) ->
    ignore;
init(stop) ->
    {stop,stopped};
init(hibernate) ->
    {ok,[],hibernate};
init(sleep) ->
    test_server:sleep(1000),
    {ok,[]};
init({state,State}) ->
    {ok,State}.

handle_call(started_p, _From, State) ->
    io:format("FROZ"),
    {reply,ok,State};
handle_call({delayed_answer,T}, From, _State) ->
    {noreply,{reply_to,From},T};
handle_call({call_within,T}, _From, _) ->
    {reply,ok,call_within,T};
handle_call(next_call, _From, call_within) ->
    {reply,ok,[]};
handle_call(next_call, _From, State) ->
    {reply,false,State};
handle_call(badreturn, _From, _State) ->
    badreturn;
handle_call(hibernate, _From, _State) ->
    {reply,true,[],hibernate};
handle_call({hibernate_noreply,Pid}, From, _State) ->
    Pid ! go,
    {noreply,From,hibernate};
handle_call(stop, _From, State) ->
    {stop,stopped,ok,State};
handle_call(crash, _From, _State) ->
    exit(crashed);
handle_call(exit_shutdown, _From, _State) ->
    exit(shutdown);
handle_call(stop_shutdown, _From, State) ->
    {stop,shutdown,State};
handle_call(shutdown_reason, _From, _State) ->
    exit({shutdown,reason});
handle_call(stop_shutdown_reason, _From, State) ->
    {stop,{shutdown,stop_reason},State}.

handle_cast({From,handle_cast}, State) ->
    From ! {self(),handled_cast},
    {noreply,State};
handle_cast({From,delayed_cast,T}, _State) ->
    {noreply,{delayed_cast,From},T};
handle_cast(hibernate_now, _State) ->
    {noreply,[],hibernate};
handle_cast(hibernate_later, _State) ->
    timer:send_after(1000, self(), hibernate_now),
    {noreply,[]};
handle_cast({From,stop}, State) ->
    io:format("BAZ"),
    {stop,{From,stopped},State}.

handle_info(timeout, {reply_to,From}) ->
    gen_server:reply(From, delayed),
    {noreply,[]};
handle_info(timeout, hibernate_me) ->
    {noreply,[],hibernate};
handle_info(hibernate_now, _State) ->
    {noreply,[],hibernate};
handle_info(hibernate_later, _State) ->
    {noreply,hibernate_me,1000};
handle_info(timeout, call_within) ->
    {noreply,[]};
handle_info(timeout, {delayed_cast,From}) ->
    From ! {self(),delayed},
    {noreply,[]};
handle_info(timeout, {delayed_info,From}) ->
    From ! {self(),delayed_info},
    {noreply,[]};
handle_info({From,handle_info}, _State) ->
    From ! {self(),handled_info},
    {noreply,[]};
handle_info({From,delayed_info,T}, _State) ->
    {noreply,{delayed_info,From},T};
handle_info(continue, From) ->
    gen_server:reply(From, true),
    {noreply,[]};
handle_info({From,stop}, State) ->
    {stop,{From,stopped_info},State};
handle_info(_Info, State) ->
    {noreply,State}.

terminate({From,stopped}, _State) ->
    io:format("FOOBAR"),
    From ! {self(),stopped},
    ok;
terminate({From,stopped_info}, _State) ->
    From ! {self(),stopped_info},
    ok;
terminate(_Reason, _State) ->
    ok.

format_status(terminate, [_PDict,State]) ->
    State;
format_status(normal, [_PDict,_State]) ->
    format_status_called.



