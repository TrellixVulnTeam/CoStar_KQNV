-file("test/lib/stdlib/src/erl_tar.erl", 1).

-module(erl_tar).

-export([create/2,
         create/3,
         extract/1,
         extract/2,
         table/1,
         table/2,
         open/2,
         close/1,
         add/3,
         add/4,
         t/1,
         tt/1,
         format_error/1]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/kernel-2.15.3/include/file.hrl",
      1).

-record(file_info,{size :: undefined | non_neg_integer(),
                   type :: undefined
                         | device
                         | directory
                         | other
                         | regular
                         | symlink,
                   access :: undefined
                           | read
                           | write
                           | read_write
                           | none,
                   atime :: undefined | file:date_time() | integer(),
                   mtime :: undefined | file:date_time() | integer(),
                   ctime :: undefined | file:date_time() | integer(),
                   mode :: undefined | integer(),
                   links :: undefined | non_neg_integer(),
                   major_device :: undefined | integer(),
                   minor_device :: undefined | integer(),
                   inode :: undefined | integer(),
                   uid :: undefined | integer(),
                   gid :: undefined | integer()}).

-record(file_descriptor,{module :: undefined | module(),
                         data :: undefined | term()}).

-file("test/lib/stdlib/src/erl_tar.erl", 30).

-record(add_opts,{read_info,verbose = false :: boolean()}).

open(Name, Mode) ->
    case open_mode(Mode) of
        {ok,Access,Raw,Opts} ->
            open1(Name, Access, Raw, Opts);
        {error,Reason} ->
            {error,{Name,Reason}}
    end.

open1({binary,Bin}, read, _Raw, Opts) ->
    case file:open(Bin, [ram,binary,read]) of
        {ok,File} ->
            case Opts of
                [compressed] ->
                    ram_file:uncompress(File);
                [] ->
                    ok
            end,
            {ok,{read,File}};
        Error ->
            Error
    end;
open1({file,Fd}, read, _Raw, _Opts) ->
    {ok,{read,Fd}};
open1(Name, Access, Raw, Opts) ->
    case file:open(Name, Raw ++ [binary,Access|Opts]) of
        {ok,File} ->
            {ok,{Access,File}};
        {error,Reason} ->
            {error,{Name,Reason}}
    end.

close({read,File}) ->
    ok = file:close(File);
close({write,File}) ->
    PadResult = pad_file(File),
    ok = file:close(File),
    PadResult;
close(_) ->
    {error,einval}.

add(File, Name, Options) ->
    add(File, Name, Name, Options).

add({write,File}, Name, NameInArchive, Options) ->
    Opts =
        #add_opts{read_info =
                      fun(F) ->
                             file:read_link_info(F)
                      end},
    add1(File, Name, NameInArchive, add_opts(Options, Opts));
add({read,_File}, _, _, _) ->
    {error,eacces};
add(_, _, _, _) ->
    {error,einval}.

add_opts([dereference|T], Opts) ->
    add_opts(T,
             Opts#add_opts{read_info =
                               fun(F) ->
                                      file:read_file_info(F)
                               end});
add_opts([verbose|T], Opts) ->
    add_opts(T, Opts#add_opts{verbose = true});
add_opts([_|T], Opts) ->
    add_opts(T, Opts);
add_opts([], Opts) ->
    Opts.

create(Name, Filenames) ->
    create(Name, Filenames, []).

create(Name, FileList, Options) ->
    Mode =
        lists:filter(fun(X) ->
                            (X =:= compressed) or (X =:= cooked)
                     end,
                     Options),
    case open(Name, [write|Mode]) of
        {ok,TarFile} ->
            Add =
                fun({NmInA,NmOrBin}) ->
                       add(TarFile, NmOrBin, NmInA, Options);
                   (Nm) ->
                       add(TarFile, Nm, Nm, Options)
                end,
            Result = foreach_while_ok(Add, FileList),
            case {Result,close(TarFile)} of
                {ok,Res} ->
                    Res;
                {Res,_} ->
                    Res
            end;
        Reason ->
            Reason
    end.

extract(Name) ->
    extract(Name, []).

extract(Name, Opts) ->
    foldl_read(Name, fun extract1/4, ok, extract_opts(Opts)).

table(Name) ->
    table(Name, []).

table(Name, Opts) ->
    foldl_read(Name, fun table1/4, [], table_opts(Opts)).

t(Name) ->
    case table(Name) of
        {ok,List} ->
            lists:foreach(fun(N) ->
                                 ok = io:format("~ts\n", [N])
                          end,
                          List);
        Error ->
            Error
    end.

tt(Name) ->
    case table(Name, [verbose]) of
        {ok,List} ->
            lists:foreach(fun print_header/1, List);
        Error ->
            Error
    end.

print_header({Name,Type,Size,Mtime,Mode,Uid,Gid}) ->
    io:format("~s~s ~4w/~-4w ~7w ~s ~s\n",
              [type_to_string(Type),
               mode_to_string(Mode),
               Uid,
               Gid,
               Size,
               time_to_string(Mtime),
               Name]).

type_to_string(regular) ->
    "-";
type_to_string(directory) ->
    "d";
type_to_string(link) ->
    "l";
type_to_string(symlink) ->
    "s";
type_to_string(char) ->
    "c";
type_to_string(block) ->
    "b";
type_to_string(fifo) ->
    "f";
type_to_string(_) ->
    "?".

mode_to_string(Mode) ->
    mode_to_string(Mode, "xwrxwrxwr", []).

mode_to_string(Mode, [C|T], Acc) when Mode band 1 =:= 1 ->
    mode_to_string(Mode bsr 1, T, [C|Acc]);
mode_to_string(Mode, [_|T], Acc) ->
    mode_to_string(Mode bsr 1, T, [$-|Acc]);
mode_to_string(_, [], Acc) ->
    Acc.

time_to_string({{Y,Mon,Day},{H,Min,_}}) ->
    io_lib:format("~s ~2w ~s:~s ~w",
                  [month(Mon),Day,two_d(H),two_d(Min),Y]).

two_d(N) ->
    tl(integer_to_list(N + 100)).

month(1) ->
    "Jan";
month(2) ->
    "Feb";
month(3) ->
    "Mar";
month(4) ->
    "Apr";
month(5) ->
    "May";
month(6) ->
    "Jun";
month(7) ->
    "Jul";
month(8) ->
    "Aug";
month(9) ->
    "Sep";
month(10) ->
    "Oct";
month(11) ->
    "Nov";
month(12) ->
    "Dec".

format_error(bad_header) ->
    "Bad directory header";
format_error(eof) ->
    "Unexpected end of file";
format_error(symbolic_link_too_long) ->
    "Symbolic link too long";
format_error({Name,Reason}) ->
    lists:flatten(io_lib:format("~ts: ~ts", [Name,format_error(Reason)]));
format_error(Atom) when is_atom(Atom) ->
    file:format_error(Atom);
format_error(Term) ->
    lists:flatten(io_lib:format("~tp", [Term])).

-record(tar_header,{name,
                    mode,
                    uid,
                    gid,
                    size,
                    mtime,
                    chksum,
                    typeflag = [],
                    linkname = [],
                    filler = [],
                    prefix}).

add1(TarFile, Bin, NameInArchive, Opts) when is_binary(Bin) ->
    Now = calendar:now_to_local_time(now()),
    Info =
        #file_info{size = byte_size(Bin),
                   type = regular,
                   access = read_write,
                   atime = Now,
                   mtime = Now,
                   ctime = Now,
                   mode = 33188,
                   links = 1,
                   major_device = 0,
                   minor_device = 0,
                   inode = 0,
                   uid = 0,
                   gid = 0},
    Header = create_header(NameInArchive, Info),
    add1(TarFile, NameInArchive, Header, Bin, Opts);
add1(TarFile, Name, NameInArchive, Opts) ->
    case read_file_and_info(Name, Opts) of
        {ok,Bin,Info} when Info#file_info.type =:= regular ->
            Header = create_header(NameInArchive, Info),
            add1(TarFile, Name, Header, Bin, Opts);
        {ok,PointsTo,Info} when Info#file_info.type =:= symlink ->
            if
                length(PointsTo) > 100 ->
                    {error,{PointsTo,symbolic_link_too_long}};
                true ->
                    Info2 = Info#file_info{size = 0},
                    Header =
                        create_header(NameInArchive, Info2, PointsTo),
                    add1(TarFile,
                         Name,
                         Header,
                         list_to_binary([]),
                         Opts)
            end;
        {ok,_,Info} when Info#file_info.type =:= directory ->
            add_directory(TarFile, Name, NameInArchive, Info, Opts);
        {ok,_,#file_info{type = Type}} ->
            {error,{bad_file_type,Name,Type}};
        {error,Reason} ->
            {error,{Name,Reason}}
    end.

add1(Tar, Name, Header, Bin, Options) ->
    add_verbose(Options, "a ~ts~n", [Name]),
    file:write(Tar, [Header,Bin,padding(byte_size(Bin), 512)]).

add_directory(TarFile, DirName, NameInArchive, Info, Options) ->
    case file:list_dir(DirName) of
        {ok,[]} ->
            add_verbose(Options, "a ~ts~n", [DirName]),
            Header = create_header(NameInArchive, Info),
            file:write(TarFile, Header);
        {ok,Files} ->
            Add =
                fun(File) ->
                       add1(TarFile,
                            filename:join(DirName, File),
                            filename:join(NameInArchive, File),
                            Options)
                end,
            foreach_while_ok(Add, Files);
        {error,Reason} ->
            {error,{DirName,Reason}}
    end.

create_header(Name, Info) ->
    create_header(Name, Info, []).

create_header(Name,
              #file_info{mode = Mode,
                         uid = Uid,
                         gid = Gid,
                         size = Size,
                         mtime = Mtime0,
                         type = Type},
              Linkname) ->
    Mtime = posix_time(erlang:localtime_to_universaltime(Mtime0)),
    {Prefix,Suffix} = split_filename(Name),
    H0 =
        [to_string(Suffix, 100),
         to_octal(Mode, 8),
         to_octal(Uid, 8),
         to_octal(Gid, 8),
         to_octal(Size, 12),
         to_octal(Mtime, 12),
         <<"        ">>,
         file_type(Type),
         to_string(Linkname, 100),
         "ustar",
         0,
         "00",
         zeroes(345 - 263 - 2),
         to_string(Prefix, 167)],
    H = list_to_binary(H0),
    512 = byte_size(H),
    ChksumString = to_octal(checksum(H), 6, [0,$\s]),
    <<Before:148/binary,_:8/binary,After/binary>> = H,
    [Before,ChksumString,After].

file_type(regular) ->
    $0;
file_type(symlink) ->
    $2;
file_type(directory) ->
    $5.

to_octal(Int, Count) when Count > 1 ->
    to_octal(Int, Count - 1, [0]).

to_octal(_, 0, Result) ->
    Result;
to_octal(Int, Count, Result) ->
    to_octal(Int div 8, Count - 1, [Int rem 8 + $0|Result]).

to_string(Str0, Count) ->
    Str = list_to_binary(Str0),
    case byte_size(Str) of
        Size when Size < Count ->
            [Str|zeroes(Count - Size)];
        _ ->
            Str
    end.

pad_file(File) ->
    {ok,Position} = file:position(File, {cur,0}),
    Zeros = zeroes(512 * 20 - Position rem (512 * 20)),
    file:write(File, Zeros).

split_filename(Name) when length(Name) =< 100 ->
    {"",Name};
split_filename(Name0) ->
    split_filename(lists:reverse(filename:split(Name0)), [], [], 0).

split_filename([Comp|Rest], Prefix, Suffix, Len)
    when Len + length(Comp) < 100 ->
    split_filename(Rest, Prefix, [Comp|Suffix], Len + length(Comp) + 1);
split_filename([Comp|Rest], Prefix, Suffix, Len) ->
    split_filename(Rest, [Comp|Prefix], Suffix, Len + length(Comp) + 1);
split_filename([], Prefix, Suffix, _) ->
    {filename:join(Prefix),filename:join(Suffix)}.

-record(read_opts,{cwd :: undefined | string(),
                   keep_old_files = false :: boolean(),
                   files = all,
                   output = file :: file | memory,
                   open_mode = [],
                   verbose = false :: boolean()}).

extract_opts(List) ->
    extract_opts(List, default_options()).

table_opts(List) ->
    read_opts(List, default_options()).

default_options() ->
    {ok,Cwd} = file:get_cwd(),
    #read_opts{cwd = Cwd}.

extract_opts([keep_old_files|Rest], Opts) ->
    extract_opts(Rest, Opts#read_opts{keep_old_files = true});
extract_opts([{cwd,Cwd}|Rest], Opts) ->
    extract_opts(Rest, Opts#read_opts{cwd = Cwd});
extract_opts([{files,Files}|Rest], Opts) ->
    Set = ordsets:from_list(Files),
    extract_opts(Rest, Opts#read_opts{files = Set});
extract_opts([memory|Rest], Opts) ->
    extract_opts(Rest, Opts#read_opts{output = memory});
extract_opts([compressed|Rest], Opts = #read_opts{open_mode = OpenMode}) ->
    extract_opts(Rest,
                 Opts#read_opts{open_mode = [compressed|OpenMode]});
extract_opts([cooked|Rest], Opts = #read_opts{open_mode = OpenMode}) ->
    extract_opts(Rest, Opts#read_opts{open_mode = [cooked|OpenMode]});
extract_opts([verbose|Rest], Opts) ->
    extract_opts(Rest, Opts#read_opts{verbose = true});
extract_opts([Other|Rest], Opts) ->
    extract_opts(Rest, read_opts([Other], Opts));
extract_opts([], Opts) ->
    Opts.

read_opts([compressed|Rest], Opts = #read_opts{open_mode = OpenMode}) ->
    read_opts(Rest, Opts#read_opts{open_mode = [compressed|OpenMode]});
read_opts([cooked|Rest], Opts = #read_opts{open_mode = OpenMode}) ->
    read_opts(Rest, Opts#read_opts{open_mode = [cooked|OpenMode]});
read_opts([verbose|Rest], Opts) ->
    read_opts(Rest, Opts#read_opts{verbose = true});
read_opts([_|Rest], Opts) ->
    read_opts(Rest, Opts);
read_opts([], Opts) ->
    Opts.

foldl_read(TarName, Fun, Accu, Opts) ->
    case open(TarName, [read|Opts#read_opts.open_mode]) of
        {ok,{read,File}} ->
            Result =
                case catch foldl_read1(Fun, Accu, File, Opts) of
                    {'EXIT',Reason} ->
                        exit(Reason);
                    {error,{Reason,Format,Args}} ->
                        read_verbose(Opts, Format, Args),
                        {error,Reason};
                    {error,Reason} ->
                        {error,Reason};
                    Ok ->
                        Ok
                end,
            ok = file:close(File),
            Result;
        Error ->
            Error
    end.

foldl_read1(Fun, Accu0, File, Opts) ->
    case get_header(File) of
        eof ->
            Fun(eof, File, Opts, Accu0);
        Header ->
            {ok,NewAccu} = Fun(Header, File, Opts, Accu0),
            foldl_read1(Fun, NewAccu, File, Opts)
    end.

table1(eof, _, _, Result) ->
    {ok,lists:reverse(Result)};
table1(Header = #tar_header{}, File, #read_opts{verbose = true}, Result) ->
    #tar_header{name = Name,
                size = Size,
                mtime = Mtime,
                typeflag = Type,
                mode = Mode,
                uid = Uid,
                gid = Gid} =
        Header,
    skip(File, Size),
    {ok,
     [{Name,Type,Size,posix_to_erlang_time(Mtime),Mode,Uid,Gid}|Result]};
table1(#tar_header{name = Name,size = Size}, File, _, Result) ->
    skip(File, Size),
    {ok,[Name|Result]}.

extract1(eof, _, _, Acc) ->
    if
        is_list(Acc) ->
            {ok,lists:reverse(Acc)};
        true ->
            Acc
    end;
extract1(Header, File, Opts, Acc) ->
    Name = Header#tar_header.name,
    case check_extract(Name, Opts) of
        true ->
            {ok,Bin} = get_element(File, Header),
            case write_extracted_element(Header, Bin, Opts) of
                ok ->
                    {ok,Acc};
                {ok,NameBin} when is_list(Acc) ->
                    {ok,[NameBin|Acc]};
                {ok,NameBin} when Acc =:= ok ->
                    {ok,[NameBin]}
            end;
        false ->
            ok = skip(File, Header#tar_header.size),
            {ok,Acc}
    end.

check_extract(_, #read_opts{files = all}) ->
    true;
check_extract(Name, #read_opts{files = Files}) ->
    ordsets:is_element(Name, Files).

get_header(File) ->
    case file:read(File, 512) of
        eof ->
            throw({error,eof});
        {ok,Bin} when is_binary(Bin) ->
            convert_header(Bin);
        {ok,List} ->
            convert_header(list_to_binary(List));
        {error,Reason} ->
            throw({error,Reason})
    end.

convert_header(Bin) when byte_size(Bin) =:= 512 ->
    case verify_checksum(Bin) of
        ok ->
            Hd =
                #tar_header{name = get_name(Bin),
                            mode = from_octal(Bin, 100, 8),
                            uid = from_octal(Bin, 108, 8),
                            gid = from_octal(Bin, 116, 8),
                            size = from_octal(Bin, 124, 12),
                            mtime = from_octal(Bin, 136, 12),
                            linkname = from_string(Bin, 157, 100),
                            typeflag = typeflag(Bin)},
            convert_header1(Hd);
        eof ->
            eof
    end;
convert_header(Bin) when byte_size(Bin) =:= 0 ->
    eof;
convert_header(_Bin) ->
    throw({error,eof}).

convert_header1(H)
    when H#tar_header.typeflag =:= symlink, H#tar_header.size =/= 0 ->
    convert_header1(H#tar_header{size = 0});
convert_header1(H)
    when H#tar_header.typeflag =:= directory, H#tar_header.size =/= 0 ->
    convert_header1(H#tar_header{size = 0});
convert_header1(Header) ->
    Header.

typeflag(Bin) ->
    [T] = binary_to_list(Bin, 156 + 1, 156 + 1),
    case T of
        0 ->
            regular;
        $0 ->
            regular;
        $1 ->
            link;
        $2 ->
            symlink;
        $3 ->
            char;
        $4 ->
            block;
        $5 ->
            directory;
        $6 ->
            fifo;
        $7 ->
            regular;
        _ ->
            unknown
    end.

get_name(Bin) ->
    Name = from_string(Bin, 0, 100),
    case binary_to_list(Bin, 345 + 1, 345 + 1) of
        [0] ->
            Name;
        [_] ->
            Prefix = binary_to_list(Bin, 345 + 1, byte_size(Bin)),
            lists:reverse(remove_nulls(Prefix), [$/|Name])
    end.

from_string(Bin, Pos, Len) ->
    lists:reverse(remove_nulls(binary_to_list(Bin, Pos + 1, Pos + Len))).

remove_nulls(List) ->
    remove_nulls(List, []).

remove_nulls([0|_], Result) ->
    remove_nulls([], Result);
remove_nulls([C|Rest], Result) ->
    remove_nulls(Rest, [C|Result]);
remove_nulls([], Result) ->
    Result.

from_octal(Bin, Pos, Len) ->
    from_octal(binary_to_list(Bin, Pos + 1, Pos + Len)).

from_octal([$\s|Rest]) ->
    from_octal(Rest);
from_octal([Digit|Rest]) when $0 =< Digit, Digit =< $7 ->
    from_octal(Rest, Digit - $0);
from_octal(Bin) when is_binary(Bin) ->
    from_octal(binary_to_list(Bin));
from_octal(Other) ->
    throw({error,{bad_header,"Bad octal number: ~p",[Other]}}).

from_octal([Digit|Rest], Result) when $0 =< Digit, Digit =< $7 ->
    from_octal(Rest, Result * 8 + Digit - $0);
from_octal([$\s|_], Result) ->
    Result;
from_octal([0|_], Result) ->
    Result;
from_octal(Other, _) ->
    throw({error,{bad_header,"Bad contents in octal field: ~p",[Other]}}).

get_element(File, #tar_header{size = 0}) ->
    skip_to_next(File),
    {ok,<<>>};
get_element(File, #tar_header{size = Size}) ->
    case file:read(File, Size) of
        {ok,Bin} = Res when byte_size(Bin) =:= Size ->
            skip_to_next(File),
            Res;
        {ok,List} when length(List) =:= Size ->
            skip_to_next(File),
            {ok,list_to_binary(List)};
        {ok,_} ->
            throw({error,eof});
        {error,Reason} ->
            throw({error,Reason});
        eof ->
            throw({error,eof})
    end.

verify_checksum(Bin) ->
    <<H1:148/binary,CheckStr:8/binary,H2/binary>> = Bin,
    case checksum(H1) + checksum(H2) of
        0 ->
            eof;
        Checksum0 ->
            Csum = from_octal(CheckStr),
            CsumInit = 8 * $\s,
            case Checksum0 + CsumInit of
                Csum ->
                    ok;
                Unsigned ->
                    verify_checksum(H1, H2, CsumInit, Csum, Unsigned)
            end
    end.

verify_checksum(H1, H2, Csum, ShouldBe, Unsigned) ->
    case
        signed_sum(binary_to_list(H1),
                   signed_sum(binary_to_list(H2), Csum))
    of
        ShouldBe ->
            ok;
        Signed ->
            throw({error,
                   {bad_header,
                    "Incorrect directory checksum ~w (~w), should be ~w",
                    [Signed,Unsigned,ShouldBe]}})
    end.

signed_sum([C|Rest], Sum) when C < 128 ->
    signed_sum(Rest, Sum + C);
signed_sum([C|Rest], Sum) ->
    signed_sum(Rest, Sum + C - 256);
signed_sum([], Sum) ->
    Sum.

write_extracted_element(Header, Bin, Opts)
    when Opts#read_opts.output =:= memory ->
    case Header#tar_header.typeflag of
        regular ->
            {ok,{Header#tar_header.name,Bin}};
        _ ->
            ok
    end;
write_extracted_element(Header, Bin, Opts) ->
    Name = filename:absname(Header#tar_header.name, Opts#read_opts.cwd),
    Created =
        case Header#tar_header.typeflag of
            regular ->
                write_extracted_file(Name, Bin, Opts);
            directory ->
                create_extracted_dir(Name, Opts);
            symlink ->
                create_symlink(Name, Header, Opts);
            Other ->
                read_verbose(Opts,
                             "x ~ts - unsupported type ~p~n",
                             [Name,Other]),
                not_written
        end,
    case Created of
        ok ->
            set_extracted_file_info(Name, Header);
        not_written ->
            ok
    end.

create_extracted_dir(Name, _Opts) ->
    case file:make_dir(Name) of
        ok ->
            ok;
        {error,enotsup} ->
            not_written;
        {error,eexist} ->
            not_written;
        {error,enoent} ->
            make_dirs(Name, dir);
        {error,Reason} ->
            throw({error,Reason})
    end.

create_symlink(Name, #tar_header{linkname = Linkname} = Header, Opts) ->
    case file:make_symlink(Linkname, Name) of
        ok ->
            ok;
        {error,enoent} ->
            ok = make_dirs(Name, file),
            create_symlink(Name, Header, Opts);
        {error,eexist} ->
            not_written;
        {error,enotsup} ->
            read_verbose(Opts,
                         "x ~ts - symbolic links not supported~n",
                         [Name]),
            not_written;
        {error,Reason} ->
            throw({error,Reason})
    end.

write_extracted_file(Name, Bin, Opts) ->
    Write =
        case Opts#read_opts.keep_old_files of
            true ->
                case file:read_file_info(Name) of
                    {ok,_} ->
                        false;
                    _ ->
                        true
                end;
            false ->
                true
        end,
    case Write of
        true ->
            read_verbose(Opts, "x ~ts~n", [Name]),
            write_file(Name, Bin);
        false ->
            read_verbose(Opts, "x ~ts - exists, not created~n", [Name]),
            not_written
    end.

write_file(Name, Bin) ->
    case file:write_file(Name, Bin) of
        ok ->
            ok;
        {error,enoent} ->
            ok = make_dirs(Name, file),
            write_file(Name, Bin);
        {error,Reason} ->
            throw({error,Reason})
    end.

set_extracted_file_info(_, #tar_header{typeflag = symlink}) ->
    ok;
set_extracted_file_info(Name, #tar_header{mode = Mode,mtime = Mtime}) ->
    Info = #file_info{mode = Mode,mtime = posix_to_erlang_time(Mtime)},
    file:write_file_info(Name, Info).

make_dirs(Name, file) ->
    filelib:ensure_dir(Name);
make_dirs(Name, dir) ->
    filelib:ensure_dir(filename:join(Name, "*")).

read_verbose(#read_opts{verbose = true}, Format, Args) ->
    io:format(Format, Args),
    io:nl();
read_verbose(_, _, _) ->
    ok.

checksum(Bin) ->
    checksum(Bin, 0).

checksum(<<A,B,C,D,E,F,G,H,T/binary>>, Sum) ->
    checksum(T, Sum + A + B + C + D + E + F + G + H);
checksum(<<A,T/binary>>, Sum) ->
    checksum(T, Sum + A);
checksum(<<>>, Sum) ->
    Sum.

padding(Size, BlockSize) ->
    zeroes(pad_size(Size, BlockSize)).

pad_size(Size, BlockSize) ->
    case Size rem BlockSize of
        0 ->
            0;
        Rem ->
            BlockSize - Rem
    end.

zeroes(0) ->
    [];
zeroes(1) ->
    [0];
zeroes(2) ->
    [0,0];
zeroes(Number) ->
    Half = zeroes(Number div 2),
    case Number rem 2 of
        0 ->
            [Half|Half];
        1 ->
            [Half,0|Half]
    end.

skip(File, Size) ->
    Amount = (Size + 512 - 1) div 512 * 512,
    {ok,_} = file:position(File, {cur,Amount}),
    ok.

skip_to_next(File) ->
    {ok,Position} = file:position(File, {cur,0}),
    NewPosition = (Position + 512 - 1) div 512 * 512,
    {ok,NewPosition} = file:position(File, NewPosition),
    ok.

add_verbose(#add_opts{verbose = true}, Format, Args) ->
    io:format(Format, Args);
add_verbose(_, _, _) ->
    ok.

posix_time(Time) ->
    EpochStart = {{1970,1,1},{0,0,0}},
    {Days,{Hour,Min,Sec}} = calendar:time_difference(EpochStart, Time),
    86400 * Days + 3600 * Hour + 60 * Min + Sec.

posix_to_erlang_time(Sec) ->
    OneMillion = 1000000,
    Time =
        calendar:now_to_datetime({Sec div OneMillion,
                                  Sec rem OneMillion,
                                  0}),
    erlang:universaltime_to_localtime(Time).

read_file_and_info(Name, Opts) ->
    ReadInfo = Opts#add_opts.read_info,
    case ReadInfo(Name) of
        {ok,Info} when Info#file_info.type =:= regular ->
            case file:read_file(Name) of
                {ok,Bin} ->
                    {ok,Bin,Info};
                Error ->
                    Error
            end;
        {ok,Info} when Info#file_info.type =:= symlink ->
            case file:read_link(Name) of
                {ok,PointsTo} ->
                    {ok,PointsTo,Info};
                Error ->
                    Error
            end;
        {ok,Info} ->
            {ok,[],Info};
        Error ->
            Error
    end.

foreach_while_ok(Fun, [First|Rest]) ->
    case Fun(First) of
        ok ->
            foreach_while_ok(Fun, Rest);
        Other ->
            Other
    end;
foreach_while_ok(_, []) ->
    ok.

open_mode(Mode) ->
    open_mode(Mode, false, [raw], []).

open_mode(read, _, Raw, _) ->
    {ok,read,Raw,[]};
open_mode(write, _, Raw, _) ->
    {ok,write,Raw,[]};
open_mode([read|Rest], false, Raw, Opts) ->
    open_mode(Rest, read, Raw, Opts);
open_mode([write|Rest], false, Raw, Opts) ->
    open_mode(Rest, write, Raw, Opts);
open_mode([compressed|Rest], Access, Raw, Opts) ->
    open_mode(Rest, Access, Raw, [compressed|Opts]);
open_mode([cooked|Rest], Access, _Raw, Opts) ->
    open_mode(Rest, Access, [], Opts);
open_mode([], Access, Raw, Opts) ->
    {ok,Access,Raw,Opts};
open_mode(_, _, _, _) ->
    {error,einval}.



