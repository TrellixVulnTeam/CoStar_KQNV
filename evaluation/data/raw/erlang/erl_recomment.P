-file("test/lib/syntax_tools/src/erl_recomment.erl", 1).

-module(erl_recomment).

-export([recomment_forms/2,quick_recomment_forms/2,recomment_tree/2]).

-spec quick_recomment_forms(erl_syntax:forms(),
                            [erl_comment_scan:comment()]) ->
                               erl_syntax:syntaxTree().

quick_recomment_forms(Tree, Cs) ->
    recomment_forms(Tree, Cs, false).

-spec recomment_forms(erl_syntax:forms(), [erl_comment_scan:comment()]) ->
                         erl_syntax:syntaxTree().

recomment_forms(Tree, Cs) ->
    recomment_forms(Tree, Cs, true).

recomment_forms(Tree, Cs, Insert) when is_list(Tree) ->
    recomment_forms(erl_syntax:form_list(Tree), Cs, Insert);
recomment_forms(Tree, Cs, Insert) ->
    case erl_syntax:type(Tree) of
        form_list ->
            Tree1 = erl_syntax:flatten_form_list(Tree),
            Node = build_tree(Tree1),
            [Node1] = node_subtrees(Node),
            List = filter_forms(node_subtrees(Node1)),
            List1 = recomment_forms_1(Cs, List, Insert),
            revert_tree(set_node_subtrees(Node,
                                          [set_node_subtrees(Node1,
                                                             List1)]));
        _ ->
            {Tree1,Cs1} = recomment_tree(Tree, Cs),
            revert_tree(append_comments(Cs1, Tree1))
    end.

append_comments([C|Cs], Tree) ->
    append_comments(Cs, node_add_postcomment(C, Tree));
append_comments([], Tree) ->
    Tree.

recomment_forms_1([C|Cs], Ns, Insert) ->
    Ns1 = recomment_forms_2(C, Ns, Insert),
    recomment_forms_1(Cs, Ns1, Insert);
recomment_forms_1([], Ns, _Insert) ->
    Ns.

recomment_forms_2(C, [N|Ns] = Nodes, Insert) ->
    {L,Col,Ind,Text} = C,
    Min = node_min(N),
    Max = node_max(N),
    Delta = comment_delta(Text),
    Trailing =
        case Ns of
            [] ->
                true;
            [Next|_] ->
                L + Delta < node_min(Next) - 2
        end,
    if
        L > Max + 1;L =:= Max + 1, not Trailing ->
            [N|recomment_forms_2(C, Ns, Insert)];
        L + Delta < Min - 1 ->
            [standalone_comment(C)|Nodes];
        L < Min ->
            [node_add_precomment(C, N)|Ns];
        Col =< 1, L =< Min, L + Delta >= Min ->
            N1 = standalone_comment(C),
            if
                L < Min ->
                    [N1|Nodes];
                true ->
                    [N,N1|Ns]
            end;
        Insert =:= true ->
            [insert(N, L, Col, Ind, C)|Ns];
        true ->
            Nodes
    end;
recomment_forms_2(C, [], _Top) ->
    [standalone_comment(C)].

standalone_comment({L,Col,_Ind,Text}) ->
    leaf_node(L,
              L + comment_delta(Text),
              erl_syntax:set_pos(erl_syntax:comment(Col - 1, Text), L)).

comment_delta(Text) ->
    case length(Text) of
        N when N > 0 ->
            N - 1;
        _ ->
            0
    end.

-record(filter,{file = undefined :: file:filename() | undefined,
                line = 0 :: integer()}).

filter_forms(Fs) ->
    filter_forms(Fs, false, #filter{}).

filter_forms([F|Fs], Kill, S) ->
    case check_file_attr(F) of
        {true,A1,A2} ->
            S1 =
                case S#filter.file of
                    undefined ->
                        S#filter{file = A1,line = A2};
                    _ ->
                        S
                end,
            if
                S1#filter.file =:= A1, S1#filter.line =< A2 ->
                    [F|filter_forms(Fs, false, S1#filter{line = A2})];
                Kill =:= true ->
                    [node_kill_range(F)|filter_forms(Fs, true, S1)];
                true ->
                    [F|filter_forms(Fs, true, S1)]
            end;
        false ->
            case Kill of
                true ->
                    [node_kill_range(F)|filter_forms(Fs, Kill, S)];
                false ->
                    [F|filter_forms(Fs, Kill, S)]
            end
    end;
filter_forms([], _, _) ->
    [].

check_file_attr(F) ->
    case node_type(F) of
        tree_node ->
            case tree_node_type(F) of
                attribute ->
                    case node_subtrees(F) of
                        [L1,L2|_] ->
                            check_file_attr_1(L1, L2);
                        _ ->
                            false
                    end;
                _ ->
                    false
            end;
        _ ->
            false
    end.

check_file_attr_1(L1, L2) ->
    case node_subtrees(L1) of
        [N1|_] ->
            N2 = leaf_node_value(N1),
            case erl_syntax:type(N2) of
                atom ->
                    case erl_syntax:atom_value(N2) of
                        file ->
                            check_file_attr_2(L2);
                        _ ->
                            false
                    end;
                _ ->
                    false
            end;
        _ ->
            false
    end.

check_file_attr_2(L) ->
    case node_subtrees(L) of
        [N1,N2|_] ->
            T1 = erl_syntax:concrete(revert_tree(N1)),
            T2 = erl_syntax:concrete(revert_tree(N2)),
            {true,T1,T2};
        _ ->
            false
    end.

-spec recomment_tree(erl_syntax:syntaxTree(),
                     [erl_comment_scan:comment()]) ->
                        {erl_syntax:syntaxTree(),
                         [erl_comment_scan:comment()]}.

recomment_tree(Tree, Cs) ->
    {Tree1,Cs1} = insert_comments(Cs, build_tree(Tree)),
    {revert_tree(Tree1),Cs1}.

insert_comments(Cs, Node) ->
    insert_comments(Cs, Node, []).

insert_comments([C|Cs], Node, Cs1) ->
    {L,Col,Ind,_Text} = C,
    Max = node_max(Node),
    if
        L =< Max ->
            insert_comments(Cs, insert(Node, L, Col, Ind, C), Cs1);
        true ->
            insert_comments(Cs, Node, [C|Cs1])
    end;
insert_comments([], Node, Cs) ->
    {Node,lists:reverse(Cs)}.

insert(Node, L, Col, Ind, C) ->
    case node_type(Node) of
        list_node ->
            set_node_subtrees(Node,
                              insert_in_list(node_subtrees(Node),
                                             L,
                                             Col,
                                             Ind,
                                             C));
        _ ->
            Min = node_min(Node),
            Max = node_max(Node),
            if
                L < Min ->
                    node_add_precomment(C, Node);
                Min =:= Max ->
                    node_add_postcomment(C, Node);
                true ->
                    insert_1(Node, L, Col, Ind, C)
            end
    end.

insert_1(Node, L, Col, Ind, C) ->
    case node_type(Node) of
        tree_node ->
            set_node_subtrees(Node,
                              insert_in_list(node_subtrees(Node),
                                             L,
                                             Col,
                                             Ind,
                                             C));
        leaf_node ->
            node_add_postcomment(C, Node)
    end.

insert_in_list([Node|Ns], L, Col, Ind, C) ->
    Max = node_max(Node),
    NextMin = next_min_in_list(Ns),
    if
        NextMin < 0 ->
            insert_here(Node, L, Col, Ind, C, Ns);
        L >= NextMin, NextMin >= Max ->
            insert_later(Node, L, Col, Ind, C, Ns);
        L =< Max ->
            insert_here(Node, L, Col, Ind, C, Ns);
        true ->
            insert_later(Node, L, Col, Ind, C, Ns)
    end;
insert_in_list([], L, Col, _, _) ->
    exit({bad_tree,L,Col}).

insert_here(Node, L, Col, Ind, C, Ns) ->
    [insert(Node, L, Col, Ind, C)|Ns].

insert_later(Node, L, Col, Ind, C, Ns) ->
    [Node|insert_in_list(Ns, L, Col, Ind, C)].

next_min_in_list(Ts) ->
    next_min_in_list(Ts, []).

next_min_in_list([T|Ts], Ack) ->
    next_min_in_node(T, [Ts|Ack]);
next_min_in_list([], [T|Ts]) ->
    next_min_in_list(T, Ts);
next_min_in_list([], []) ->
    - 1.

next_min_in_node(Node, Ack) ->
    case node_type(Node) of
        leaf_node ->
            node_min(Node);
        tree_node ->
            node_min(Node);
        list_node ->
            next_min_in_list(node_subtrees(Node), Ack)
    end.

build_tree(Node) ->
    L = get_line(Node),
    case erl_syntax:subtrees(Node) of
        [] ->
            leaf_node(L, L, Node);
        Ts ->
            {Subtrees,Min,Max} = build_list_list(Ts),
            tree_node(minpos(L, Min),
                      max(L, Max),
                      erl_syntax:type(Node),
                      erl_syntax:get_attrs(Node),
                      Subtrees)
    end.

build_list(Ts) ->
    build_list(Ts, 0, 0, []).

build_list([T|Ts], Min, Max, Ack) ->
    Node = build_tree(T),
    Min1 = minpos(node_min(Node), Min),
    Max1 = max(node_max(Node), Max),
    build_list(Ts, Min1, Max1, [Node|Ack]);
build_list([], Min, Max, Ack) ->
    list_node(Min, Max, lists:reverse(Ack)).

build_list_list(Ls) ->
    build_list_list(Ls, 0, 0, []).

build_list_list([L|Ls], Min, Max, Ack) ->
    Node = build_list(L),
    Min1 = minpos(node_min(Node), Min),
    Max1 = max(node_max(Node), Max),
    build_list_list(Ls, Min1, Max1, [Node|Ack]);
build_list_list([], Min, Max, Ack) ->
    {lists:reverse(Ack),Min,Max}.

revert_tree(Node) ->
    case node_type(Node) of
        leaf_node ->
            add_comments(Node, leaf_node_value(Node));
        tree_node ->
            add_comments(Node,
                         erl_syntax:set_attrs(erl_syntax:make_tree(tree_node_type(Node),
                                                                   revert_list(node_subtrees(Node))),
                                              tree_node_attrs(Node)));
        list_node ->
            revert_list(node_subtrees(Node))
    end.

revert_list([T|Ts]) ->
    [revert_tree(T)|revert_list(Ts)];
revert_list([]) ->
    [].

add_comments(Node, Tree) ->
    case node_precomments(Node) of
        [] ->
            add_comments_1(Node, Tree);
        Cs ->
            Cs1 = lists:reverse(expand_comments(Cs)),
            add_comments_1(Node, erl_syntax:add_precomments(Cs1, Tree))
    end.

add_comments_1(Node, Tree) ->
    case node_postcomments(Node) of
        [] ->
            Tree;
        Cs ->
            Cs1 = lists:reverse(expand_comments(Cs)),
            erl_syntax:add_postcomments(Cs1, Tree)
    end.

expand_comments([C|Cs]) ->
    [expand_comment(C)|expand_comments(Cs)];
expand_comments([]) ->
    [].

expand_comment(C) ->
    {L,_Col,Ind,Text} = C,
    erl_syntax:set_pos(erl_syntax:comment(Ind, Text), L).

-record(leaf,{min = 0 :: integer(),
              max = 0 :: integer(),
              precomments = [] :: [erl_syntax:syntaxTree()],
              postcomments = [] :: [erl_syntax:syntaxTree()],
              value :: undefined | erl_syntax:syntaxTree()}).

-record(tree,{min = 0 :: integer(),
              max = 0 :: integer(),
              type :: undefined | atom(),
              attrs :: undefined | erl_syntax:syntaxTreeAttributes(),
              precomments = [] :: [erl_syntax:syntaxTree()],
              postcomments = [] :: [erl_syntax:syntaxTree()],
              subtrees = [] :: [erl_syntax:syntaxTree()]}).

-record(list,{min = 0 :: integer(),
              max = 0 :: integer(),
              subtrees = [] :: [erl_syntax:syntaxTree()]}).

leaf_node(Min, Max, Value) ->
    #leaf{min = Min,max = Max,value = Value}.

tree_node(Min, Max, Type, Attrs, Subtrees) ->
    #tree{min = Min,
          max = Max,
          type = Type,
          attrs = Attrs,
          subtrees = Subtrees}.

list_node(Min, Max, Subtrees) ->
    #list{min = Min,max = Max,subtrees = Subtrees}.

node_type(#leaf{}) ->
    leaf_node;
node_type(#tree{}) ->
    tree_node;
node_type(#list{}) ->
    list_node.

node_min(#leaf{min = Min}) ->
    Min;
node_min(#tree{min = Min}) ->
    Min;
node_min(#list{min = Min}) ->
    Min.

node_max(#leaf{max = Max}) ->
    Max;
node_max(#tree{max = Max}) ->
    Max;
node_max(#list{max = Max}) ->
    Max.

node_kill_range(Node) ->
    case Node of
        #leaf{} ->
            Node#leaf{min = - 1,max = - 1};
        #tree{} ->
            Node#tree{min = - 1,max = - 1};
        #list{} ->
            Node#list{min = - 1,max = - 1}
    end.

node_precomments(#leaf{precomments = Cs}) ->
    Cs;
node_precomments(#tree{precomments = Cs}) ->
    Cs.

node_add_precomment(C, Node) ->
    case Node of
        #leaf{} ->
            Node#leaf{precomments = [C|Node#leaf.precomments]};
        #tree{} ->
            Node#tree{precomments = [C|Node#tree.precomments]}
    end.

node_postcomments(#leaf{postcomments = Cs}) ->
    Cs;
node_postcomments(#tree{postcomments = Cs}) ->
    Cs.

node_add_postcomment(C, Node) ->
    case Node of
        #leaf{} ->
            Node#leaf{postcomments = [C|Node#leaf.postcomments]};
        #tree{} ->
            Node#tree{postcomments = [C|Node#tree.postcomments]}
    end.

node_subtrees(#tree{subtrees = Subtrees}) ->
    Subtrees;
node_subtrees(#list{subtrees = Subtrees}) ->
    Subtrees.

leaf_node_value(#leaf{value = Value}) ->
    Value.

tree_node_type(#tree{type = Type}) ->
    Type.

set_node_subtrees(Node, Subtrees) ->
    case Node of
        #tree{} ->
            Node#tree{subtrees = Subtrees};
        #list{} ->
            Node#list{subtrees = Subtrees}
    end.

tree_node_attrs(#tree{attrs = Attrs}) ->
    Attrs.

minpos(X, Y) when X < Y ->
    minpos1(X, Y);
minpos(X, Y) ->
    minpos1(Y, X).

minpos1(X, Y) when X < 1 ->
    minpos2(Y);
minpos1(X, _) ->
    X.

minpos2(X) when X < 1 ->
    0;
minpos2(X) ->
    X.

get_line(Node) ->
    case erl_syntax:get_pos(Node) of
        L when is_integer(L) ->
            L;
        {L,_} when is_integer(L) ->
            L;
        {_,L} when is_integer(L) ->
            L;
        {L,_,_} when is_integer(L) ->
            L;
        {_,L,_} when is_integer(L) ->
            L;
        Pos ->
            exit({bad_position,Pos})
    end.



