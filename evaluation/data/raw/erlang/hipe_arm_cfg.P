-file("test/lib/hipe/arm/hipe_arm_cfg.erl", 1).

-module(hipe_arm_cfg).

-export([init/1,labels/1,start_label/1,succ/2,bb/2,bb_add/3]).

-export([postorder/1]).

-export([linearise/1]).

-export([params/1,reverse_postorder/1]).

-export([arity/1]).

-file("test/lib/hipe/arm/hipe_arm.hrl", 1).

-record(arm_mfa,{m :: undefined | atom(),
                 f :: undefined | atom(),
                 a :: undefined | arity()}).

-record(arm_prim,{prim}).

-record(arm_sdesc,{exnlab,fsize,arity :: undefined | arity(),live}).

-record(arm_temp,{reg,type,allocatable}).

-record(am2,{src,sign,offset}).

-record(am3,{src,sign,offset}).

-record(alu,{aluop,s,dst,src,am1}).

-record(b_fun,{'fun',linkage}).

-record(b_label,{'cond',label}).

-record(bl,{'fun',sdesc,linkage}).

-record(blx,{src,sdesc}).

-record(cmp,{cmpop,src,am1}).

-record(comment,{term}).

-record(label,{label}).

-record(load,{ldop,dst,am2}).

-record(ldrsb,{dst,am3}).

-record(move,{movop,s,dst,am1}).

-record(pseudo_bc,{'cond',true_label,false_label,pred}).

-record(pseudo_blr,{}).

-record(pseudo_bx,{src}).

-record(pseudo_call,{funv,sdesc,contlab,linkage}).

-record(pseudo_call_prepare,{nrstkargs}).

-record(pseudo_li,{dst,imm,label}).

-record(pseudo_move,{dst,src}).

-record(pseudo_switch,{jtab,index,labels}).

-record(pseudo_tailcall,{funv,arity,stkargs,linkage}).

-record(pseudo_tailcall_prepare,{}).

-record(smull,{dstlo,dsthi,src1,src2}).

-record(store,{stop,src,am2}).

-file("test/lib/hipe/arm/../misc/hipe_consttab.hrl", 1).

-type ct_alignment() :: 4 | 8.

-type hipe_constlbl() :: non_neg_integer().

-type hipe_consttab() :: {dict(), [hipe_constlbl()], hipe_constlbl()}.

-file("test/lib/hipe/arm/hipe_arm.hrl", 119).

-file([], 119).

-record(defun,{mfa :: undefined | mfa(),
               formals,
               code,
               data :: undefined | hipe_consttab(),
               isclosure :: undefined | boolean(),
               isleaf :: undefined | boolean(),
               var_range,
               label_range}).

-file("test/lib/hipe/arm/hipe_arm_cfg.erl", 39).

-file("test/lib/hipe/arm/../flow/cfg.hrl", 1).

-type cfg_lbl() :: non_neg_integer().

-record(cfg_info,{'fun' :: undefined | mfa(),
                  start_label :: undefined | cfg_lbl(),
                  is_closure :: undefined | boolean(),
                  closure_arity :: undefined | arity(),
                  is_leaf :: undefined | boolean(),
                  params,
                  info = []}).

-type cfg_data() :: {dict(), [cfg_lbl()], non_neg_integer()}.

-record(cfg,{table = gb_trees:empty() :: gb_tree(),
             info :: undefined | #cfg_info{},
             data :: undefined | cfg_data()}).

-type cfg() :: #cfg{}.

-file("test/lib/hipe/arm/hipe_arm_cfg.erl", 40).

-file("test/lib/hipe/arm/../flow/cfg.inc", 1).

-export([start_label_update/2]).

-export([breadthorder/1]).

-compile(inline).

-spec start_label(cfg()) -> cfg_lbl().

start_label(CFG) ->
    (CFG#cfg.info)#cfg_info.start_label.

-spec start_label_update(cfg(), cfg_lbl()) -> cfg().

start_label_update(CFG, NewStartLabel) ->
    Info = CFG#cfg.info,
    CFG#cfg{info = Info#cfg_info{start_label = NewStartLabel}}.

-spec function(cfg()) -> mfa().

function(CFG) ->
    (CFG#cfg.info)#cfg_info.'fun'.

-spec is_closure(cfg()) -> boolean().

is_closure(CFG) ->
    (CFG#cfg.info)#cfg_info.is_closure.

-spec is_leaf(cfg()) -> boolean().

is_leaf(CFG) ->
    (CFG#cfg.info)#cfg_info.is_leaf.

mk_empty_cfg(Fun, StartLbl, Data, Closure, Leaf, Params) ->
    Info =
        #cfg_info{'fun' = Fun,
                  start_label = StartLbl,
                  is_closure = Closure,
                  is_leaf = Leaf,
                  params = Params},
    #cfg{table = gb_trees:empty(),data = Data,info = Info}.

data(CFG) ->
    CFG#cfg.data.

params(CFG) ->
    (CFG#cfg.info)#cfg_info.params.

-spec other_entrypoints(cfg()) -> [cfg_lbl()].

other_entrypoints(CFG) ->
    hipe_consttab:referred_labels(data(CFG)).

bb(CFG, Label) ->
    HT = CFG#cfg.table,
    case gb_trees:lookup(Label, HT) of
        {value,{Block,_Succ,_Pred}} ->
            Block;
        none ->
            not_found
    end.

-spec remove_duplicates([cfg_lbl()]) -> [cfg_lbl()].

remove_duplicates(List) ->
    remove_duplicates(List, []).

-spec remove_duplicates([cfg_lbl()], [cfg_lbl()]) -> [cfg_lbl()].

remove_duplicates([H|T], Acc) ->
    NewAcc =
        case lists:member(H, Acc) of
            false ->
                [H|Acc];
            true ->
                Acc
        end,
    remove_duplicates(T, NewAcc);
remove_duplicates([], Acc) ->
    lists:reverse(Acc).

bb_add(CFG, Label, NewBB) ->
    Last = hipe_bb:last(NewBB),
    case is_branch(Last) of
        true ->
            ok;
        false ->
            throw({hipe_arm_cfg,
                   {"Basic block ends without branch",Last}})
    end,
    Succ = remove_duplicates(branch_successors(Last)),
    HT = CFG#cfg.table,
    {OldSucc,OldPred} =
        case gb_trees:lookup(Label, HT) of
            {value,{_Block,OSucc,OPred}} ->
                {OSucc,OPred};
            none ->
                {[],[]}
        end,
    HT1 = gb_trees:enter(Label, {NewBB,Succ,OldPred}, HT),
    HT2 =
        lists:foldl(fun(P, HTAcc) ->
                           add_pred(HTAcc, P, Label)
                    end,
                    HT1,
                    Succ -- OldSucc),
    HT3 =
        lists:foldl(fun(S, HTAcc) ->
                           remove_pred(HTAcc, S, Label)
                    end,
                    HT2,
                    OldSucc -- Succ),
    CFG#cfg{table = HT3}.

remove_pred(HT, FromL, PredL) ->
    case gb_trees:lookup(FromL, HT) of
        {value,{Block,Succ,Preds}} ->
            Code = hipe_bb:code(Block),
            NewCode = remove_pred_from_phis(Code, PredL, []),
            NewBlock = hipe_bb:code_update(Block, NewCode),
            gb_trees:update(FromL,
                            {NewBlock,Succ,lists:delete(PredL, Preds)},
                            HT);
        none ->
            HT
    end.

add_pred(HT, ToL, PredL) ->
    case gb_trees:lookup(ToL, HT) of
        {value,{Block,Succ,Preds}} ->
            gb_trees:update(ToL,
                            {Block,
                             Succ,
                             [PredL|lists:delete(PredL, Preds)]},
                            HT);
        none ->
            gb_trees:insert(ToL, {[],[],[PredL]}, HT)
    end.

remove_pred_from_phis(Code, _Label, _Acc) ->
    Code.

take_bbs([], CFG) ->
    CFG;
take_bbs(Xs, CFG) ->
    Lbl = hd(Xs),
    case is_label(Lbl) of
        true ->
            case take_bb(tl(Xs), []) of
                {Code,Rest} ->
                    NewCFG =
                        bb_add(CFG,
                               label_name(Lbl),
                               hipe_bb:mk_bb(Code)),
                    take_bbs(Rest, NewCFG)
            end;
        false ->
            error({hipe_arm_cfg,
                   "basic block doesn't start with a label",
                   Xs})
    end.

take_bb([], Code) ->
    {lists:reverse(Code),[]};
take_bb([X,Y|Xs], Code) ->
    case is_label(X) of
        true ->
            {[mk_goto(label_name(X))],[X,Y|Xs]};
        false ->
            case is_branch(X) of
                true ->
                    case is_label(Y) of
                        true ->
                            {lists:reverse([X|Code]),[Y|Xs]};
                        false ->
                            {lists:reverse([X|Code]),[Y|Xs]}
                    end;
                false ->
                    case is_label(Y) of
                        true ->
                            {lists:reverse([mk_goto(label_name(Y)),
                                            X|
                                            Code]),
                             [Y|Xs]};
                        false ->
                            take_bb([Y|Xs], [X|Code])
                    end
            end
    end;
take_bb([X], []) ->
    case is_label(X) of
        true ->
            {[X,mk_goto(label_name(X))],[]};
        false ->
            {[X],[]}
    end;
take_bb([X], Code) ->
    case is_label(X) of
        true ->
            {lists:reverse(Code),[X,mk_goto(label_name(X))]};
        false ->
            {lists:reverse([X|Code]),[]}
    end.

labels(CFG) ->
    HT = CFG#cfg.table,
    gb_trees:keys(HT).

postorder(CFG) ->
    lists:reverse(reverse_postorder(CFG)).

reverse_postorder(CFG) ->
    Start = start_label(CFG),
    {Ordering,_Visited} =
        depth_search([Start|other_entrypoints(CFG)],
                     none_visited(),
                     CFG,
                     []),
    Ordering.

depth_search([N|Ns], Visited, CFG, Acc) ->
    case is_visited(N, Visited) of
        true ->
            depth_search(Ns, Visited, CFG, Acc);
        false ->
            {Order,Vis} =
                depth_search(succ(CFG, N), visit(N, Visited), CFG, Acc),
            depth_search(Ns, Vis, CFG, [N|Order])
    end;
depth_search([], Visited, _, Ordering) ->
    {Ordering,Visited}.

breadthorder(CFG) ->
    lists:reverse(reverse_breadthorder(CFG)).

reverse_breadthorder(CFG) ->
    Start = start_label(CFG),
    {Vis,RBO1} = breadth_list([Start], none_visited(), CFG, []),
    {_Vis1,RBO2} = breadth_list(other_entrypoints(CFG), Vis, CFG, RBO1),
    RBO2.

breadth_list([X|Xs], Vis, CFG, BO) ->
    case is_visited(X, Vis) of
        true ->
            breadth_list(Xs, Vis, CFG, BO);
        false ->
            breadth_list(Xs ++ succ(CFG, X), visit(X, Vis), CFG, [X|BO])
    end;
breadth_list([], Vis, _CFG, BO) ->
    {Vis,BO}.

-spec none_visited() -> gb_set().

none_visited() ->
    gb_sets:empty().

visit(X, Vis) ->
    gb_sets:add(X, Vis).

is_visited(X, Vis) ->
    gb_sets:is_member(X, Vis).

succ(SuccMap, Label) ->
    HT = SuccMap#cfg.table,
    case gb_trees:lookup(Label, HT) of
        {value,{_Block,Succ,_Pred}} ->
            Succ;
        none ->
            error({"successor not found",Label,SuccMap})
    end.

fallthrough(CFG, Label) ->
    HT = CFG#cfg.table,
    case gb_trees:lookup(Label, HT) of
        {value,{_Block,Succ,_}} ->
            case Succ of
                [X|_] ->
                    X;
                _ ->
                    none
            end;
        none ->
            error({"fallthrough label not found",Label})
    end.

conditional(CFG, Label) ->
    HT = CFG#cfg.table,
    {value,{_Block,Succ,_}} = gb_trees:lookup(Label, HT),
    case Succ of
        [] ->
            none;
        [_] ->
            none;
        [_|Labels] ->
            Labels
    end.

linearize_cfg(CFG) ->
    Start = start_label(CFG),
    Vis = none_visited(),
    {Vis0,NestedCode} = lin_succ(Start, CFG, Vis),
    BlocksInData = hipe_consttab:referred_labels(data(CFG)),
    AllCode = lin_other_entries(NestedCode, CFG, BlocksInData, Vis0),
    lists:flatten(AllCode).

lin_succ(none, _CFG, Vis) ->
    {Vis,[]};
lin_succ([Label|Labels], CFG, Vis) ->
    {Vis1,Code1} = lin_succ(Label, CFG, Vis),
    {Vis2,Code2} = lin_succ(Labels, CFG, Vis1),
    {Vis2,[Code1,Code2]};
lin_succ([], _CFG, Vis) ->
    {Vis,[]};
lin_succ(Label, CFG, Vis) ->
    case is_visited(Label, Vis) of
        true ->
            {Vis,[]};
        false ->
            Vis0 = visit(Label, Vis),
            case bb(CFG, Label) of
                not_found ->
                    error({hipe_arm_cfg,
                           "No basic block with label",
                           Label});
                BB ->
                    Fallthrough = fallthrough(CFG, Label),
                    Cond = conditional(CFG, Label),
                    LblInstr = mk_label(Label),
                    {Vis1,Code1} = lin_succ(Fallthrough, CFG, Vis0),
                    {Vis2,Code2} = lin_succ(Cond, CFG, Vis1),
                    {Vis2,[[LblInstr|hipe_bb:code(BB)],Code1,Code2]}
            end
    end.

lin_other_entries(Code, _CFG, [], _Vis) ->
    Code;
lin_other_entries(Code, CFG, [E|Es], Vis) ->
    {Vis0,MoreCode} = lin_succ(E, CFG, Vis),
    lin_other_entries([Code,MoreCode], CFG, Es, Vis0).

-file("test/lib/hipe/arm/hipe_arm_cfg.erl", 41).

init(Defun) ->
    Code = hipe_arm:defun_code(Defun),
    StartLab = hipe_arm:label_label(hd(Code)),
    Data = hipe_arm:defun_data(Defun),
    IsClosure = hipe_arm:defun_is_closure(Defun),
    Name = hipe_arm:defun_mfa(Defun),
    IsLeaf = hipe_arm:defun_is_leaf(Defun),
    Formals = hipe_arm:defun_formals(Defun),
    CFG0 =
        mk_empty_cfg(Name, StartLab, Data, IsClosure, IsLeaf, Formals),
    take_bbs(Code, CFG0).

is_branch(I) ->
    case I of
        #b_fun{} ->
            true;
        #b_label{'cond' = al} ->
            true;
        #pseudo_bc{} ->
            true;
        #pseudo_blr{} ->
            true;
        #pseudo_bx{} ->
            true;
        #pseudo_call{} ->
            true;
        #pseudo_switch{} ->
            true;
        #pseudo_tailcall{} ->
            true;
        _ ->
            false
    end.

branch_successors(Branch) ->
    case Branch of
        #b_fun{} ->
            [];
        #b_label{'cond' = al,label = Label} ->
            [Label];
        #pseudo_bc{true_label = TrueLab,false_label = FalseLab} ->
            [FalseLab,TrueLab];
        #pseudo_blr{} ->
            [];
        #pseudo_bx{} ->
            [];
        #pseudo_call{contlab = ContLab,
                     sdesc = #arm_sdesc{exnlab = ExnLab}} ->
            case ExnLab of
                [] ->
                    [ContLab];
                _ ->
                    [ContLab,ExnLab]
            end;
        #pseudo_switch{labels = Labels} ->
            Labels;
        #pseudo_tailcall{} ->
            []
    end.

mk_goto(Label) ->
    hipe_arm:mk_b_label(Label).

is_label(I) ->
    hipe_arm:is_label(I).

label_name(Label) ->
    hipe_arm:label_label(Label).

mk_label(Name) ->
    hipe_arm:mk_label(Name).

linearise(CFG) ->
    MFA = function(CFG),
    Formals = params(CFG),
    Code = linearize_cfg(CFG),
    Data = data(CFG),
    VarRange = hipe_gensym:var_range(arm),
    LabelRange = hipe_gensym:label_range(arm),
    IsClosure = is_closure(CFG),
    IsLeaf = is_leaf(CFG),
    hipe_arm:mk_defun(MFA,
                      Formals,
                      IsClosure,
                      IsLeaf,
                      Code,
                      Data,
                      VarRange,
                      LabelRange).

arity(CFG) ->
    {_M,_F,A} = function(CFG),
    A.



