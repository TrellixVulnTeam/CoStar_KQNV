-file("test/lib/compiler/test/float_SUITE.erl", 1).

-module(float_SUITE).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2,
         pending/1,
         bif_calls/1,
         math_functions/1,
         mixed_float_and_int/1]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/compiler/test/float_SUITE.erl", 25).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    test_lib:recompile(float_SUITE),
    [pending,bif_calls,math_functions,mixed_float_and_int].

groups() ->
    [].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

pending(Config) when is_list(Config) ->
    case catch float_mul(1, 1.1e300, 3.14e300) of
        {'EXIT',{badarith,_}} ->
            ok;
        Other ->
            test_server:fail({expected_exception,Other})
    end,
    0.0 = float_sub(2.0).

float_sub(A) ->
    catch A - 2.0.

float_mul(0, _, _) ->
    ok;
float_mul(Iter, A, B) when is_float(A), is_float(B) ->
    _ = A * B,
    float_mul(Iter - 1, A, B).

bif_calls(Config) when is_list(Config) ->
    {'EXIT',{badarith,_}} = (catch bad_arith(2.0, 1.7)),
    {'EXIT',{badarith,_}} = (catch bad_arith_again(2.0, [])),
    {'EXIT',{badarith,_}} = (catch bad_arith_xor(2.0, [])),
    {'EXIT',{badarith,_}} = (catch bad_arith_hd(2.0, [])),
    {'EXIT',{badarith,_}} = (catch bad_negate(2.0, 1.7)),
    ok.

bad_arith(X, Y) when is_float(X) ->
    X1 = X * 1.7e308,
    X2 = X1 + 1.0,
    Y1 = Y * 2,
    {X2,Y1}.

bad_arith_xor(X, Y) when is_float(X) ->
    X1 = X * 1.7e308,
    Y1 = Y xor true,
    {X1 + 1.0,Y1}.

bad_arith_hd(X, Y) when is_float(X) ->
    X1 = X * 1.7e308,
    Y1 = hd(Y),
    {X1 + 1.0,Y1}.

bad_arith_again(X, Y) when is_float(X) ->
    X1 = X * 1.7e308,
    Y1 = element(1, Y),
    {X1 + 1.0,Y1}.

bad_negate(X, Y) when is_float(X) ->
    X1 = X * 1.7e308,
    X2 = X1 + 1.0,
    Y1 = - Y,
    {X2,Y1}.

math_functions(Config) when is_list(Config) ->
    0.0 = math:tan(0),
    0.0 = math:atan2(0, 1),
    0.0 = math:sinh(0),
    1.0 = math:cosh(0),
    0.0 = math:tanh(0),
    1.0 = math:log10(10),
    - 1.0 = math:cos(math:pi()),
    1.0 = math:exp(0),
    1.0 = math:pow(math:pi(), 0),
    0.0 = math:log(1),
    0.0 = math:asin(0),
    0.0 = math:acos(1),
    try
        0.0 = math:asinh(0)
    catch
        error:undef ->
            ok
    end,
    try
        0.0 = math:acosh(1)
    catch
        error:undef ->
            ok
    end,
    try
        0.0 = math:atanh(0)
    catch
        error:undef ->
            ok
    end,
    try
        0.0 = math:erf(0)
    catch
        error:undef ->
            ok
    end,
    try
        1.0 = math:erfc(0)
    catch
        error:undef ->
            ok
    end,
    0.0 = math:tan(id(0)),
    0.0 = math:atan2(id(0), 1),
    0.0 = math:sinh(id(0)),
    1.0 = math:cosh(id(0)),
    0.0 = math:tanh(id(0)),
    1.0 = math:log10(id(10)),
    1.0 = math:exp(id(0)),
    0.0 = math:log(id(1)),
    0.0 = math:asin(id(0)),
    0.0 = math:acos(id(1)),
    try
        0.0 = math:asinh(id(0))
    catch
        error:undef ->
            ok
    end,
    try
        0.0 = math:acosh(id(1))
    catch
        error:undef ->
            ok
    end,
    try
        0.0 = math:atanh(id(0))
    catch
        error:undef ->
            ok
    end,
    try
        0.0 = math:erf(id(0))
    catch
        error:undef ->
            ok
    end,
    try
        1.0 = math:erfc(id(0))
    catch
        error:undef ->
            ok
    end,
    {'EXIT',{undef,_}} = (catch math:fnurfla(0)),
    {'EXIT',{undef,_}} = (catch math:fnurfla(0, 0)),
    {'EXIT',{badarg,_}} = (catch float(kalle)),
    {'EXIT',{badarith,_}} = (catch name / 1),
    ok.

mixed_float_and_int(Config) when is_list(Config) ->
    129.0 = pc(77, 23, 5),
    ok.

pc(Cov, NotCov, X) ->
    round(Cov / (Cov + NotCov) * 100) + 42 + 2.0 * X.

id(I) ->
    I.



