-file("test/lib/diameter/src/base/diameter_peer.erl", 1).

-module(diameter_peer).

-behaviour(gen_server).

-export([recv/2,up/1,up/2,up/3,match/2]).

-export([start/1,send/2,close/1,abort/1,notify/3]).

-export([start_link/0]).

-export([init/1,
         terminate/2,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         code_change/3]).

-export([state/0,uptime/0]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/diameter-1.3/include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options = [{answer_errors,report}]}).

-file("test/lib/diameter/src/base/diameter_peer.erl", 54).

-file("test/lib/diameter/src/base/diameter_internal.hrl", 1).

-record(diameter_peer,{host_id,
                       statusT,
                       is_dynamic,
                       expiration,
                       tls_enabled}).

-record(diameter_realm,{name,
                        app_id,
                        local_action,
                        server_id,
                        is_dynamic,
                        expiration}).

-file("test/lib/diameter/src/base/diameter_peer.erl", 55).

-record(state,{id = now()}).

notify(Nodes, SvcName, T) ->
    rpc:abcast(Nodes, diameter_peer, {notify,SvcName,T}).

-spec start({T, [Opt], #diameter_service{}}) ->
               {TPid, [Addr], Tmo, Data} | {error, [term()]}
               when
                   is_subtype(T,
                              {connect | accept,
                               diameter:transport_ref()}),
                   is_subtype(Opt, diameter:transport_opt()),
                   is_subtype(TPid, pid()),
                   is_subtype(Addr, inet:ip_address()),
                   is_subtype(Tmo, non_neg_integer() | infinity),
                   is_subtype(Data,
                              {{T, Mod, Cfg},
                               [Mod],
                               [{T, [Mod], Cfg}],
                               [Err]}),
                   is_subtype(Mod, module()),
                   is_subtype(Cfg, term()),
                   is_subtype(Err, term());
           ({#diameter_service{}, Tmo, Data}) ->
               {TPid, [Addr], Tmo, Data} | {error, [term()]}
               when
                   is_subtype(TPid, pid()),
                   is_subtype(Addr, inet:ip_address()),
                   is_subtype(Tmo, non_neg_integer() | infinity),
                   is_subtype(Data,
                              {{T, Mod, Cfg},
                               [Mod],
                               [{T, [Mod], Cfg}],
                               [Err]}),
                   is_subtype(T,
                              {connect | accept,
                               diameter:transport_ref()}),
                   is_subtype(Mod, module()),
                   is_subtype(Cfg, term()),
                   is_subtype(Err, term()).

start({T,Opts,#diameter_service{} = Svc}) ->
    start(T, Svc, pair(Opts, [], []), []);
start({#diameter_service{} = Svc,Tmo,{{T,_,Cfg},Ms,Rest,Errs}}) ->
    start(T, Ms, Cfg, Svc, Tmo, Rest, Errs).

pair([{transport_module,M}|Rest], Mods, Acc) ->
    pair(Rest, [M|Mods], Acc);
pair([{transport_config = T,C}|Rest], Mods, Acc) ->
    pair([{T,C,infinity}|Rest], Mods, Acc);
pair([{transport_config,C,Tmo}|Rest], Mods, Acc) ->
    pair(Rest, [], acc({Mods,C,Tmo}, Acc));
pair([_|Rest], Mods, Acc) ->
    pair(Rest, Mods, Acc);
pair([], [], []) ->
    [{[diameter_tcp],[],infinity}];
pair([], [M], [{[],Cfg,Tmo}]) ->
    [{[M],Cfg,Tmo}];
pair([], [_|_] = Mods, Acc) ->
    lists:reverse(acc({Mods,[],infinity}, Acc));
pair([], [], Acc) ->
    lists:reverse(def(Acc)).

acc(T, Acc) ->
    [T|def(Acc)].

def([{[],Cfg,Tmo}|Acc]) ->
    [{[diameter_tcp],Cfg,Tmo}|Acc];
def(Acc) ->
    Acc.

start(T, Svc, [{Ms,Cfg,Tmo}|Rest], Errs) ->
    start(T, Ms, Cfg, Svc, Tmo, Rest, Errs);
start(_, _, [], Errs) ->
    {error,Errs}.

start(T, [], _, Svc, _, Rest, Errs) ->
    start(T, Svc, Rest, Errs);
start(T, [M|Ms], Cfg, Svc, Tmo, Rest, Errs) ->
    case start(M, [T,Svc,Cfg]) of
        {ok,TPid} ->
            {TPid,[],Tmo,{{T,M,Cfg},Ms,Rest,Errs}};
        {ok,TPid,[_|_] = Addrs} ->
            {TPid,Addrs,Tmo,{{T,M,Cfg},Ms,Rest,Errs}};
        E ->
            start(T, Ms, Cfg, Svc, Tmo, Rest, [E|Errs])
    end.

start(Mod, Args) ->
    apply(Mod, start, Args).

match(Addrs, Matches) when is_list(Addrs) ->
    lists:all(fun(A) ->
                     match1(A, Matches)
              end,
              Addrs).

match1(Addr, Matches) when not is_integer(hd(Matches)) ->
    lists:any(fun(M) ->
                     match1(Addr, M)
              end,
              Matches);
match1(Addr, Match) ->
    match(Addr, addr(Match), Match).

match(Addr, {ok,A}, _) ->
    Addr == A;
match(Addr, {error,_}, RE) ->
    match == re:run(inet_parse:ntoa(Addr), RE, [{capture,none}]).

addr([_|_] = A) ->
    inet_parse:address(A);
addr(A) ->
    {ok,A}.

up(Pid) ->
    ifc_send(Pid, {self(),connected}).

up(Pid, Remote) ->
    ifc_send(Pid, {self(),connected,Remote}).

up(Pid, Remote, LAddrs) ->
    ifc_send(Pid, {self(),connected,Remote,LAddrs}).

recv(Pid, Pkt) ->
    ifc_send(Pid, {recv,Pkt}).

send(Pid, #diameter_packet{transport_data = undefined,bin = Bin}) ->
    send(Pid, Bin);
send(Pid, Pkt) ->
    ifc_send(Pid, {send,Pkt}).

close(Pid) ->
    ifc_send(Pid, {close,self()}).

abort(Pid) ->
    exit(Pid, shutdown).

start_link() ->
    ServerName = {local,diameter_peer},
    Module = diameter_peer,
    Args = [],
    Options = [{spawn_opt,diameter_lib:spawn_opts(server, [])}],
    gen_server:start_link(ServerName, Module, Args, Options).

state() ->
    call(state).

uptime() ->
    call(uptime).

init([]) ->
    {ok,#state{}}.

handle_call(state, _, State) ->
    {reply,State,State};
handle_call(uptime, _, #state{id = Time} = State) ->
    {reply,diameter_lib:now_diff(Time),State};
handle_call(Req, From, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_peer,
                                 element(2,
                                         element(2,
                                                 process_info(self(),
                                                              current_function))),
                                 [Req,From]}),
    {reply,nok,State}.

handle_cast(Msg, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_peer,
                                 element(2,
                                         element(2,
                                                 process_info(self(),
                                                              current_function))),
                                 [Msg]}),
    {noreply,State}.

handle_info({notify,SvcName,T}, S) ->
    diameter_service:notify(SvcName, T),
    {noreply,S};
handle_info(Info, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_peer,
                                 element(2,
                                         element(2,
                                                 process_info(self(),
                                                              current_function))),
                                 [Info]}),
    {noreply,State}.

terminate(_Reason, _State) ->
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok,State}.

ifc_send(Pid, T) ->
    Pid ! {diameter,T}.

call(Request) ->
    gen_server:call(diameter_peer, Request, infinity).



