-file("test/lib/edoc/src/edoc.erl", 1).

-module(edoc).

-export([packages/1,
         packages/2,
         files/1,
         files/2,
         application/1,
         application/2,
         application/3,
         toc/1,
         toc/2,
         toc/3,
         run/3,
         file/1,
         file/2,
         read/1,
         read/2,
         layout/1,
         layout/2,
         get_doc/1,
         get_doc/2,
         get_doc/3,
         read_comments/1,
         read_comments/2,
         read_source/1,
         read_source/2]).

-compile({no_auto_import,[{error,1}]}).

-file("test/lib/edoc/src/edoc.hrl", 1).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/edoc/src/../include/edoc_doclet.hrl",
      1).

-record(context,{dir = "",env,opts = []}).

-record(doclet_gen,{sources = [],
                    app = [],
                    packages = [],
                    modules = [],
                    filemap}).

-record(doclet_toc,{paths,indir}).

-file("test/lib/edoc/src/edoc.hrl", 43).

-file([], 43).

-record(module,{name = [],
                parameters = none,
                functions = [],
                exports = [],
                attributes = [],
                records = [],
                encoding = latin1}).

-record(env,{module = [],
             package = [],
             root = "",
             file_suffix,
             package_summary,
             apps,
             modules,
             packages,
             app_default,
             macros = [],
             includes = []}).

-record(comment,{line = 0,text}).

-record(entry,{name,args = [],line = 0,export,data}).

-record(tag,{name,line = 0,origin = comment,data}).

-file("test/lib/edoc/src/edoc.erl", 62).

file(Name) ->
    file(Name, []).

file(Name, Options) ->
    Text = read(Name, Options),
    SrcSuffix = proplists:get_value(source_suffix, Options, ".erl"),
    BaseName = filename:basename(Name, SrcSuffix),
    Suffix = proplists:get_value(file_suffix, Options, ".html"),
    Dir = proplists:get_value(dir, Options, filename:dirname(Name)),
    Encoding = [{encoding,edoc_lib:read_encoding(Name, [])}],
    edoc_lib:write_file(Text, Dir, BaseName ++ Suffix, '', Encoding).

files(Files) ->
    files(Files, []).

files(Files, Options) ->
    run([], Files, Options).

packages(Packages) ->
    packages(Packages, []).

packages(Packages, Options) ->
    run(Packages, [], Options ++ [{source_path,["."]}]).

application(App) ->
    application(App, []).

application(App, Options) when is_atom(App) ->
    case code:lib_dir(App) of
        Dir when is_list(Dir) ->
            application(App, Dir, Options);
        _ ->
            edoc_report:report("cannot find application directory for '"
                               "~s'.",
                               [App]),
            exit(error)
    end.

application(App, Dir, Options) when is_atom(App) ->
    Src = edoc_lib:try_subdir(Dir, "src"),
    Overview =
        filename:join(edoc_lib:try_subdir(Dir, "doc"), "overview.edoc"),
    Opts =
        Options
        ++
        [{source_path,[Src]},
         subpackages,
         {title,io_lib:fwrite("The ~s application", [App])},
         {overview,Overview},
         {dir,filename:join(Dir, "doc")},
         {includes,[filename:join(Dir, "include")]}],
    Opts1 = set_app_default(App, Dir, Opts),
    run([''], [], [{application,App}|Opts1]).

set_app_default(App, Dir0, Opts) ->
    case proplists:get_value(app_default, Opts) of
        undefined ->
            AppName = atom_to_list(App),
            Dir = edoc_lib:simplify_path(filename:absname(Dir0)),
            AppDir =
                case filename:basename(Dir) of
                    AppName ->
                        filename:dirname(Dir);
                    _ ->
                        "http://www.erlang.org/edoc/doc"
                end,
            [{app_default,AppDir}|Opts];
        _ ->
            Opts
    end.

opt_defaults() ->
    [packages].

opt_negations() ->
    [{no_preprocess,preprocess},
     {no_subpackages,subpackages},
     {no_report_missing_types,report_missing_types},
     {no_packages,packages}].

run(Packages, Files, Opts0) ->
    Opts = expand_opts(Opts0),
    Ctxt = init_context(Opts),
    Dir = Ctxt#context.dir,
    Path = proplists:append_values(source_path, Opts),
    Ss = sources(Path, Packages, Opts),
    {Ss1,Ms} = expand_sources(expand_files(Files) ++ Ss, Opts),
    Ps =
        [ 
         P ||
             {_,P,_,_} <- Ss1
        ],
    App = proplists:get_value(application, Opts, []),
    {App1,Ps1,Ms1} = target_dir_info(Dir, App, Ps, Ms, Opts),
    Ps2 = edoc_lib:unique(lists:sort(Ps1)) -- [''],
    Ms2 = edoc_lib:unique(lists:sort(Ms1)),
    Fs = package_files(Path, Ps2),
    Env = edoc_lib:get_doc_env(App1, Ps2, Ms2, Opts),
    Ctxt1 = Ctxt#context{env = Env},
    Cmd =
        #doclet_gen{sources = Ss1,
                    app = App1,
                    packages = Ps2,
                    modules = Ms2,
                    filemap = Fs},
    F = fun(M) ->
               M:run(Cmd, Ctxt1)
        end,
    edoc_lib:run_doclet(F, Opts).

expand_opts(Opts0) ->
    proplists:substitute_negations(opt_negations(),
                                   Opts0 ++ opt_defaults()).

init_context(Opts) ->
    #context{dir = proplists:get_value(dir, Opts, "."),opts = Opts}.

sources(Path, Packages, Opts) ->
    lists:foldl(fun(P, Xs) ->
                       edoc_lib:find_sources(Path, P, Opts) ++ Xs
                end,
                [],
                Packages).

package_files(Path, Packages) ->
    Name = "package.edoc",
    D = lists:foldl(fun(P, D) ->
                           F = edoc_lib:find_file(Path, P, Name),
                           dict:store(P, F, D)
                    end,
                    dict:new(),
                    Packages),
    fun(P) ->
           case dict:find(P, D) of
               {ok,F} ->
                   F;
               error ->
                   ""
           end
    end.

expand_files([{P,Fs1}|Fs]) ->
    [ 
     {P,filename:basename(F),filename:dirname(F)} ||
         F <- Fs1
    ]
    ++
    expand_files(Fs);
expand_files([F|Fs]) ->
    [{'',filename:basename(F),filename:dirname(F)}|expand_files(Fs)];
expand_files([]) ->
    [].

expand_sources(Ss, Opts) ->
    Suffix = proplists:get_value(source_suffix, Opts, ".erl"),
    Ss1 =
        case proplists:get_bool(packages, Opts) of
            true ->
                Ss;
            false ->
                [ 
                 {'',F,D} ||
                     {_P,F,D} <- Ss
                ]
        end,
    expand_sources(Ss1, Suffix, sets:new(), [], []).

expand_sources([{'',F,D}|Fs], Suffix, S, As, Ms) ->
    M = list_to_atom(filename:rootname(F, Suffix)),
    case sets:is_element(M, S) of
        true ->
            expand_sources(Fs, Suffix, S, As, Ms);
        false ->
            S1 = sets:add_element(M, S),
            expand_sources(Fs, Suffix, S1, [{M,'',F,D}|As], [M|Ms])
    end;
expand_sources([], _Suffix, _S, As, Ms) ->
    {lists:reverse(As),lists:reverse(Ms)}.

target_dir_info(Dir, App, Ps, Ms, Opts) ->
    case proplists:get_bool(new, Opts) of
        true ->
            {App,Ps,Ms};
        false ->
            {App1,Ps1,Ms1} = edoc_lib:read_info_file(Dir),
            {if
                 App == [] ->
                     App1;
                 true ->
                     App
             end,
             Ps ++ Ps1,
             Ms ++ Ms1}
    end.

toc(Dir) ->
    toc(Dir, []).

toc(Dir, Opts) ->
    Paths =
        proplists:append_values(doc_path, Opts)
        ++
        edoc_lib:find_doc_dirs(),
    toc(Dir, Paths, Opts).

toc(Dir, Paths, Opts0) ->
    Opts = expand_opts(Opts0 ++ [{dir,Dir}]),
    Ctxt = init_context(Opts),
    Env = edoc_lib:get_doc_env('', [], [], Opts),
    Ctxt1 = Ctxt#context{env = Env},
    F = fun(M) ->
               M:run(#doclet_toc{paths = Paths}, Ctxt1)
        end,
    edoc_lib:run_doclet(F, Opts).

read(File) ->
    read(File, []).

read(File, Opts) ->
    {_ModuleName,Doc} = get_doc(File, Opts),
    layout(Doc, Opts).

layout(Doc) ->
    layout(Doc, []).

layout(Doc, Opts) ->
    F = fun(M) ->
               M:module(Doc, Opts)
        end,
    edoc_lib:run_layout(F, Opts).

read_comments(File) ->
    read_comments(File, []).

read_comments(File, _Opts) ->
    erl_comment_scan:file(File).

read_source(Name) ->
    read_source(Name, []).

read_source(Name, Opts0) ->
    Opts = expand_opts(Opts0),
    case read_source_1(Name, Opts) of
        {ok,Forms} ->
            check_forms(Forms, Name),
            Forms;
        {error,R} ->
            edoc_report:error({"error reading file '~ts'.",
                               [edoc_lib:filename(Name)]}),
            exit({error,R})
    end.

read_source_1(Name, Opts) ->
    case proplists:get_bool(preprocess, Opts) of
        true ->
            read_source_2(Name, Opts);
        false ->
            epp_dodger:quick_parse_file(Name, Opts ++ [{no_fail,false}])
    end.

read_source_2(Name, Opts) ->
    Includes =
        proplists:append_values(includes, Opts)
        ++
        [filename:dirname(Name)],
    Macros = proplists:append_values(macros, Opts),
    parse_file(Name, Includes, Macros).

parse_file(Name, Includes, Macros) ->
    case epp:open(Name, Includes, Macros) of
        {ok,Epp} ->
            try {ok,parse_file(Epp)} after _ = epp:close(Epp) end;
        Error ->
            Error
    end.

parse_file(Epp) ->
    case scan_and_parse(Epp) of
        {ok,Form} ->
            case Form of
                {attribute,La,record,{Record,Fields}} ->
                    case epp:normalize_typed_record_fields(Fields) of
                        {typed,NewFields} ->
                            [{attribute,La,record,{Record,NewFields}},
                             {attribute,
                              La,
                              type,
                              {{record,Record},Fields,[]}}|
                             parse_file(Epp)];
                        not_typed ->
                            [Form|parse_file(Epp)]
                    end;
                _ ->
                    [Form|parse_file(Epp)]
            end;
        {error,E} ->
            [{error,E}|parse_file(Epp)];
        {eof,Location} ->
            [{eof,Location}]
    end.

scan_and_parse(Epp) ->
    case epp:scan_erl_form(Epp) of
        {ok,Toks0} ->
            Toks = fix_last_line(Toks0),
            case erl_parse:parse_form(Toks) of
                {ok,Form} ->
                    {ok,Form};
                Else ->
                    Else
            end;
        Else ->
            Else
    end.

fix_last_line(Toks0) ->
    Toks1 = lists:reverse(Toks0),
    {line,LastLine} = erl_scan:token_info(hd(Toks1), line),
    fll(Toks1, LastLine, []).

fll([{Category,Attributes0,Symbol}|L], LastLine, Ts) ->
    F = fun(_OldLine) ->
               LastLine
        end,
    Attributes = erl_scan:set_attribute(line, Attributes0, F),
    lists:reverse(L, [{Category,Attributes,Symbol}|Ts]);
fll([T|L], LastLine, Ts) ->
    fll(L, LastLine, [T|Ts]);
fll(L, _LastLine, Ts) ->
    lists:reverse(L, Ts).

check_forms(Fs, Name) ->
    Fun =
        fun(F) ->
               case erl_syntax:type(F) of
                   error_marker ->
                       case erl_syntax:error_marker_info(F) of
                           {L,M,D} ->
                               edoc_report:error(L,
                                                 Name,
                                                 {format_error,M,D});
                           Other ->
                               edoc_report:report(Name,
                                                  "unknown error in sou"
                                                  "rce code: ~w.",
                                                  [Other])
                       end,
                       exit(error);
                   _ ->
                       ok
               end
        end,
    lists:foreach(Fun, Fs).

get_doc(File) ->
    get_doc(File, []).

get_doc(File, Opts) ->
    Env = edoc_lib:get_doc_env(Opts),
    get_doc(File, Env, Opts).

get_doc(File, Env, Opts) ->
    edoc_extract:source(File, Env, Opts).



