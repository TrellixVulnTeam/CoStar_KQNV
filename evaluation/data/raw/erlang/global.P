-file("test/lib/kernel/src/global.erl", 1).

-module(global).

-behaviour(gen_server).

-export([start/0,
         start_link/0,
         stop/0,
         sync/0,
         sync/1,
         whereis_name/1,
         register_name/2,
         register_name/3,
         register_name_external/2,
         register_name_external/3,
         unregister_name_external/1,
         re_register_name/2,
         re_register_name/3,
         unregister_name/1,
         registered_names/0,
         send/2,
         node_disconnected/1,
         set_lock/1,
         set_lock/2,
         set_lock/3,
         del_lock/1,
         del_lock/2,
         trans/2,
         trans/3,
         trans/4,
         random_exit_name/3,
         random_notify_name/3,
         notify_all_name/3]).

-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3,
         resolve_it/4]).

-export([info/0]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/stdlib-1.18.3/include/ms_transform.hrl",
      1).

-file("test/lib/kernel/src/global.erl", 47).

-record(state,{connect_all :: undefined | boolean(),
               known = [] :: [node()],
               synced = [] :: [node()],
               resolvers = [],
               syncers = [] :: [pid()],
               node_name = node() :: node(),
               the_locker,
               the_registrar,
               trace,
               global_lock_down = false :: boolean()}).

-type state() :: #state{}.

start() ->
    gen_server:start({local,global_name_server}, global, [], []).

start_link() ->
    gen_server:start_link({local,global_name_server}, global, [], []).

stop() ->
    gen_server:call(global_name_server, stop, infinity).

-spec sync() -> ok | {error, Reason :: term()}.

sync() ->
    case check_sync_nodes() of
        {error,_} = Error ->
            Error;
        SyncNodes ->
            gen_server:call(global_name_server,
                            {sync,SyncNodes},
                            infinity)
    end.

-spec sync([node()]) -> ok | {error, Reason :: term()}.

sync(Nodes) ->
    case check_sync_nodes(Nodes) of
        {error,_} = Error ->
            Error;
        SyncNodes ->
            gen_server:call(global_name_server,
                            {sync,SyncNodes},
                            infinity)
    end.

-spec send(Name, Msg) -> Pid
              when
                  is_subtype(Name, term()),
                  is_subtype(Msg, term()),
                  is_subtype(Pid, pid()).

send(Name, Msg) ->
    case whereis_name(Name) of
        Pid when is_pid(Pid) ->
            Pid ! Msg,
            Pid;
        undefined ->
            exit({badarg,{Name,Msg}})
    end.

-spec whereis_name(Name) -> pid() | undefined
                      when is_subtype(Name, term()).

whereis_name(Name) ->
    where(Name).

node_disconnected(Node) ->
    global_name_server ! {nodedown,Node}.

-spec register_name(Name, Pid) -> yes | no
                       when
                           is_subtype(Name, term()),
                           is_subtype(Pid, pid()).

register_name(Name, Pid) when is_pid(Pid) ->
    register_name(Name, Pid, fun random_exit_name/3).

-type method() ::
          fun((Name :: term(), Pid :: pid(), Pid2 :: pid()) ->
                  pid() | none).

-spec register_name(Name, Pid, Resolve) -> yes | no
                       when
                           is_subtype(Name, term()),
                           is_subtype(Pid, pid()),
                           is_subtype(Resolve, method()).

register_name(Name, Pid, Method0) when is_pid(Pid) ->
    Method = allow_tuple_fun(Method0),
    Fun =
        fun(Nodes) ->
               case
                   where(Name) =:= undefined
                   andalso
                   check_dupname(Name, Pid)
               of
                   true ->
                       gen_server:multi_call(Nodes,
                                             global_name_server,
                                             {register,Name,Pid,Method}),
                       yes;
                   _ ->
                       no
               end
        end,
    ok,
    gen_server:call(global_name_server, {registrar,Fun}, infinity).

check_dupname(Name, Pid) ->
    case ets:lookup(global_pid_names, Pid) of
        [] ->
            true;
        PidNames ->
            case
                application:get_env(kernel, global_multi_name_action)
            of
                {ok,allow} ->
                    true;
                _ ->
                    S = "global: ~w registered under several names: ~w"
                        "\n",
                    Names =
                        [Name|
                         [ 
                          Name1 ||
                              {_Pid,Name1} <- PidNames
                         ]],
                    error_logger:error_msg(S, [Pid,Names]),
                    false
            end
    end.

-spec unregister_name(Name) -> _ when is_subtype(Name, term()).

unregister_name(Name) ->
    case where(Name) of
        undefined ->
            ok;
        _ ->
            Fun =
                fun(Nodes) ->
                       gen_server:multi_call(Nodes,
                                             global_name_server,
                                             {unregister,Name}),
                       ok
                end,
            ok,
            gen_server:call(global_name_server,
                            {registrar,Fun},
                            infinity)
    end.

-spec re_register_name(Name, Pid) -> yes
                          when
                              is_subtype(Name, term()),
                              is_subtype(Pid, pid()).

re_register_name(Name, Pid) when is_pid(Pid) ->
    re_register_name(Name, Pid, fun random_exit_name/3).

-spec re_register_name(Name, Pid, Resolve) -> yes
                          when
                              is_subtype(Name, term()),
                              is_subtype(Pid, pid()),
                              is_subtype(Resolve, method()).

re_register_name(Name, Pid, Method0) when is_pid(Pid) ->
    Method = allow_tuple_fun(Method0),
    Fun =
        fun(Nodes) ->
               gen_server:multi_call(Nodes,
                                     global_name_server,
                                     {register,Name,Pid,Method}),
               yes
        end,
    ok,
    gen_server:call(global_name_server, {registrar,Fun}, infinity).

-spec registered_names() -> [Name] when is_subtype(Name, term()).

registered_names() ->
    MS = [{{'$1','$2','$3','$4','$5'},[],['$1']}],
    ets:select(global_names, MS).

register_name_external(Name, Pid) when is_pid(Pid) ->
    register_name_external(Name, Pid, fun random_exit_name/3).

register_name_external(Name, Pid, Method) when is_pid(Pid) ->
    Fun =
        fun(Nodes) ->
               case where(Name) of
                   undefined ->
                       gen_server:multi_call(Nodes,
                                             global_name_server,
                                             {register_ext,
                                              Name,
                                              Pid,
                                              Method,
                                              node()}),
                       yes;
                   _Pid ->
                       no
               end
        end,
    ok,
    gen_server:call(global_name_server, {registrar,Fun}, infinity).

unregister_name_external(Name) ->
    unregister_name(Name).

-type id() :: {ResourceId :: term(), LockRequesterId :: term()}.

-spec set_lock(Id) -> boolean() when is_subtype(Id, id()).

set_lock(Id) ->
    set_lock(Id, [node()|nodes()], infinity, 1).

-type retries() :: non_neg_integer() | infinity.

-spec set_lock(Id, Nodes) -> boolean()
                  when is_subtype(Id, id()), is_subtype(Nodes, [node()]).

set_lock(Id, Nodes) ->
    set_lock(Id, Nodes, infinity, 1).

-spec set_lock(Id, Nodes, Retries) -> boolean()
                  when
                      is_subtype(Id, id()),
                      is_subtype(Nodes, [node()]),
                      is_subtype(Retries, retries()).

set_lock(Id, Nodes, Retries) when is_integer(Retries), Retries >= 0 ->
    set_lock(Id, Nodes, Retries, 1);
set_lock(Id, Nodes, infinity) ->
    set_lock(Id, Nodes, infinity, 1).

set_lock({_ResourceId,_LockRequesterId}, [], _Retries, _Times) ->
    true;
set_lock({_ResourceId,_LockRequesterId} = Id, Nodes, Retries, Times) ->
    ok,
    case set_lock_on_nodes(Id, Nodes) of
        true ->
            ok,
            true;
        false = Reply when Retries =:= 0 ->
            Reply;
        false ->
            random_sleep(Times),
            set_lock(Id, Nodes, dec(Retries), Times + 1)
    end.

-spec del_lock(Id) -> true when is_subtype(Id, id()).

del_lock(Id) ->
    del_lock(Id, [node()|nodes()]).

-spec del_lock(Id, Nodes) -> true
                  when is_subtype(Id, id()), is_subtype(Nodes, [node()]).

del_lock({_ResourceId,_LockRequesterId} = Id, Nodes) ->
    ok,
    gen_server:multi_call(Nodes, global_name_server, {del_lock,Id}),
    true.

-type trans_fun() :: function() | {module(), atom()}.

-spec trans(Id, Fun) -> Res | aborted
               when
                   is_subtype(Id, id()),
                   is_subtype(Fun, trans_fun()),
                   is_subtype(Res, term()).

trans(Id, Fun) ->
    trans(Id, Fun, [node()|nodes()], infinity).

-spec trans(Id, Fun, Nodes) -> Res | aborted
               when
                   is_subtype(Id, id()),
                   is_subtype(Fun, trans_fun()),
                   is_subtype(Nodes, [node()]),
                   is_subtype(Res, term()).

trans(Id, Fun, Nodes) ->
    trans(Id, Fun, Nodes, infinity).

-spec trans(Id, Fun, Nodes, Retries) -> Res | aborted
               when
                   is_subtype(Id, id()),
                   is_subtype(Fun, trans_fun()),
                   is_subtype(Nodes, [node()]),
                   is_subtype(Retries, retries()),
                   is_subtype(Res, term()).

trans(Id, Fun, Nodes, Retries) ->
    case set_lock(Id, Nodes, Retries) of
        true ->
            try Fun() after del_lock(Id, Nodes) end;
        false ->
            aborted
    end.

info() ->
    gen_server:call(global_name_server, info, infinity).

-spec init([]) -> {ok, state()}.

init([]) ->
    process_flag(trap_exit, true),
    _ = ets:new(global_locks, [set,named_table,protected]),
    _ = ets:new(global_names, [set,named_table,protected]),
    _ = ets:new(global_names_ext, [set,named_table,protected]),
    _ = ets:new(global_pid_names, [bag,named_table,protected]),
    _ = ets:new(global_pid_ids, [bag,named_table,protected]),
    DoTrace = os:getenv("GLOBAL_HIGH_LEVEL_TRACE") =:= "TRUE",
    T0 =
        case DoTrace of
            true ->
                send_high_level_trace(),
                [];
            false ->
                no_trace
        end,
    S = #state{the_locker = start_the_locker(DoTrace),
               trace = T0,
               the_registrar = start_the_registrar()},
    S1 = trace_message(S, {init,node()}, []),
    case init:get_argument(connect_all) of
        {ok,[["false"]]} ->
            {ok,S1#state{connect_all = false}};
        _ ->
            {ok,S1#state{connect_all = true}}
    end.

-spec handle_call(term(), {pid(), term()}, state()) ->
                     {noreply, state()} |
                     {reply, term(), state()} |
                     {stop, normal, stopped, state()}.

handle_call({registrar,Fun}, From, S) ->
    S#state.the_registrar ! {trans_all_known,Fun,From},
    {noreply,S};
handle_call({register,Name,Pid,Method}, {FromPid,_Tag}, S0) ->
    S = ins_name(Name, Pid, Method, FromPid, [], S0),
    {reply,yes,S};
handle_call({unregister,Name}, _From, S0) ->
    S = delete_global_name2(Name, S0),
    {reply,ok,S};
handle_call({register_ext,Name,Pid,Method,RegNode}, {FromPid,_Tag}, S0) ->
    S = ins_name_ext(Name, Pid, Method, RegNode, FromPid, [], S0),
    {reply,yes,S};
handle_call({set_lock,Lock}, {Pid,_Tag}, S0) ->
    {Reply,S} = handle_set_lock(Lock, Pid, S0),
    {reply,Reply,S};
handle_call({del_lock,Lock}, {Pid,_Tag}, S0) ->
    S = handle_del_lock(Lock, Pid, S0),
    {reply,true,S};
handle_call(get_known, _From, S) ->
    {reply,S#state.known,S};
handle_call(get_synced, _From, S) ->
    {reply,S#state.synced,S};
handle_call({sync,Nodes}, From, S) ->
    Pid =
        start_sync(lists:delete(node(), Nodes) -- S#state.synced, From),
    {noreply,S#state{syncers = [Pid|S#state.syncers]}};
handle_call(get_protocol_version, _From, S) ->
    {reply,5,S};
handle_call(get_names_ext, _From, S) ->
    {reply,get_names_ext(),S};
handle_call(info, _From, S) ->
    {reply,S,S};
handle_call(high_level_trace_start, _From, S) ->
    S#state.the_locker ! {do_trace,true},
    send_high_level_trace(),
    {reply,ok,trace_message(S#state{trace = []}, {init,node()}, [])};
handle_call(high_level_trace_stop, _From, S) ->
    #state{the_locker = TheLocker,trace = Trace} = S,
    TheLocker ! {do_trace,false},
    wait_high_level_trace(),
    {reply,Trace,S#state{trace = no_trace}};
handle_call(high_level_trace_get, _From, #state{trace = Trace} = S) ->
    {reply,Trace,S#state{trace = []}};
handle_call(stop, _From, S) ->
    {stop,normal,stopped,S};
handle_call(Request, From, S) ->
    error_logger:warning_msg("The global_name_server received an unexpe"
                             "cted message:\nhandle_call(~p, ~p, _)\n",
                             [Request,From]),
    {noreply,S}.

-spec handle_cast(term(), state()) -> {noreply, state()}.

handle_cast({init_connect,Vsn,Node,InitMsg}, S) ->
    ok,
    case Vsn of
        {HisVsn,HisTag} when HisVsn > 5 ->
            init_connect(5, Node, InitMsg, HisTag, S#state.resolvers, S);
        {HisVsn,HisTag} ->
            init_connect(HisVsn,
                         Node,
                         InitMsg,
                         HisTag,
                         S#state.resolvers,
                         S);
        Tuple when is_tuple(Tuple) ->
            List = tuple_to_list(Tuple),
            [_HisVsn,HisTag|_] = List,
            init_connect(5, Node, InitMsg, HisTag, S#state.resolvers, S);
        _ ->
            Txt =
                io_lib:format("Illegal global protocol version ~p Node:"
                              " ~p\n",
                              [Vsn,Node]),
            error_logger:info_report(lists:flatten(Txt))
    end,
    {noreply,S};
handle_cast({lock_is_set,Node,MyTag,LockId}, S) ->
    ok,
    case get({sync_tag_my,Node}) of
        MyTag ->
            lock_is_set(Node, S#state.resolvers, LockId),
            {noreply,S};
        _ ->
            NewS = cancel_locker(Node, S, MyTag),
            {noreply,NewS}
    end;
handle_cast({exchange,Node,NameList,_NameExtList,MyTag}, S) ->
    case get({sync_tag_my,Node}) of
        MyTag ->
            exchange(Node, NameList, S#state.resolvers),
            {noreply,S};
        _ ->
            NewS = cancel_locker(Node, S, MyTag),
            {noreply,NewS}
    end;
handle_cast({exchange_ops,Node,MyTag,Ops,Resolved}, S0) ->
    ok,
    S = trace_message(S0, {exit_resolver,Node}, [MyTag]),
    case get({sync_tag_my,Node}) of
        MyTag ->
            Known = S#state.known,
            gen_server:cast({global_name_server,Node},
                            {resolved,
                             node(),
                             Resolved,
                             Known,
                             Known,
                             get_names_ext(),
                             get({sync_tag_his,Node})}),
            case get({save_ops,Node}) of
                {resolved,HisKnown,Names_ext,HisResolved} ->
                    put({save_ops,Node}, Ops),
                    NewS =
                        resolved(Node,
                                 HisResolved,
                                 HisKnown,
                                 Names_ext,
                                 S),
                    {noreply,NewS};
                undefined ->
                    put({save_ops,Node}, Ops),
                    {noreply,S}
            end;
        _ ->
            NewS = cancel_locker(Node, S, MyTag),
            {noreply,NewS}
    end;
handle_cast({resolved,
             Node,
             HisResolved,
             HisKnown,
             _HisKnown_v2,
             Names_ext,
             MyTag},
            S) ->
    ok,
    case get({sync_tag_my,Node}) of
        MyTag ->
            case get({save_ops,Node}) of
                Ops when is_list(Ops) ->
                    NewS =
                        resolved(Node,
                                 HisResolved,
                                 HisKnown,
                                 Names_ext,
                                 S),
                    {noreply,NewS};
                undefined ->
                    Resolved = {resolved,HisKnown,Names_ext,HisResolved},
                    put({save_ops,Node}, Resolved),
                    {noreply,S}
            end;
        _ ->
            NewS = cancel_locker(Node, S, MyTag),
            {noreply,NewS}
    end;
handle_cast({new_nodes,Node,Ops,Names_ext,Nodes,ExtraInfo}, S) ->
    ok,
    NewS = new_nodes(Ops, Node, Names_ext, Nodes, ExtraInfo, S),
    {noreply,NewS};
handle_cast({in_sync,Node,_IsKnown}, S) ->
    ok,
    lists:foreach(fun(Pid) ->
                         Pid ! {synced,[Node]}
                  end,
                  S#state.syncers),
    NewS = cancel_locker(Node, S, get({sync_tag_my,Node})),
    reset_node_state(Node),
    NSynced =
        case lists:member(Node, Synced = NewS#state.synced) of
            true ->
                Synced;
            false ->
                [Node|Synced]
        end,
    {noreply,NewS#state{synced = NSynced}};
handle_cast({async_del_name,_Name,_Pid}, S) ->
    {noreply,S};
handle_cast({async_del_lock,_ResourceId,_Pid}, S) ->
    {noreply,S};
handle_cast(Request, S) ->
    error_logger:warning_msg("The global_name_server received an unexpe"
                             "cted message:\nhandle_cast(~p, _)\n",
                             [Request]),
    {noreply,S}.

-spec handle_info(term(), state()) ->
                     {noreply, state()} | {stop, term(), state()}.

handle_info({'EXIT',Locker,_Reason} = Exit,
            #state{the_locker = Locker} = S) ->
    {stop,{locker_died,Exit},S#state{the_locker = undefined}};
handle_info({'EXIT',Registrar,_} = Exit,
            #state{the_registrar = Registrar} = S) ->
    {stop,{registrar_died,Exit},S#state{the_registrar = undefined}};
handle_info({'EXIT',Pid,_Reason}, S) when is_pid(Pid) ->
    ok,
    Syncers = lists:delete(Pid, S#state.syncers),
    {noreply,S#state{syncers = Syncers}};
handle_info({nodedown,Node}, S) when Node =:= S#state.node_name ->
    {noreply,change_our_node_name(node(), S)};
handle_info({nodedown,Node}, S0) ->
    ok,
    S1 = trace_message(S0, {nodedown,Node}, []),
    S = handle_nodedown(Node, S1),
    {noreply,S};
handle_info({extra_nodedown,Node}, S0) ->
    ok,
    S1 = trace_message(S0, {extra_nodedown,Node}, []),
    S = handle_nodedown(Node, S1),
    {noreply,S};
handle_info({nodeup,Node}, S) when Node =:= node() ->
    ok,
    {noreply,change_our_node_name(Node, S)};
handle_info({nodeup,_Node}, S) when not S#state.connect_all ->
    {noreply,S};
handle_info({nodeup,Node}, S0) when S0#state.connect_all ->
    IsKnown =
        lists:member(Node, S0#state.known)
        or
        lists:keymember(Node, 1, S0#state.resolvers),
    ok,
    S1 = trace_message(S0, {nodeup,Node}, []),
    case IsKnown of
        true ->
            {noreply,S1};
        false ->
            resend_pre_connect(Node),
            MyTag = now(),
            put({sync_tag_my,Node}, MyTag),
            ok,
            S1#state.the_locker ! {nodeup,Node,MyTag},
            NotAPid = no_longer_a_pid,
            Locker = {locker,NotAPid,S1#state.known,S1#state.the_locker},
            InitC = {init_connect,{5,MyTag},node(),Locker},
            Rs = S1#state.resolvers,
            ok,
            gen_server:cast({global_name_server,Node}, InitC),
            Resolver = start_resolver(Node, MyTag),
            S = trace_message(S1, {new_resolver,Node}, [MyTag,Resolver]),
            {noreply,S#state{resolvers = [{Node,MyTag,Resolver}|Rs]}}
    end;
handle_info({whereis,Name,From}, S) ->
    do_whereis(Name, From),
    {noreply,S};
handle_info(known, S) ->
    io:format(">>>> ~p\n", [S#state.known]),
    {noreply,S};
handle_info(high_level_trace, S) ->
    case S of
        #state{trace = [{Node,_Time,_M,Nodes,_X}|_]} ->
            send_high_level_trace(),
            CNode = node(),
            CNodes = nodes(),
            case {CNode,CNodes} of
                {Node,Nodes} ->
                    {noreply,S};
                _ ->
                    {New,_,Old} =
                        sofs:symmetric_partition(sofs:set([CNode|CNodes]),
                                                 sofs:set([Node|Nodes])),
                    M = {nodes_changed,
                         {sofs:to_external(New),sofs:to_external(Old)}},
                    {noreply,trace_message(S, M, [])}
            end;
        _ ->
            {noreply,S}
    end;
handle_info({trace_message,M}, S) ->
    {noreply,trace_message(S, M, [])};
handle_info({trace_message,M,X}, S) ->
    {noreply,trace_message(S, M, X)};
handle_info({'DOWN',MonitorRef,process,_Pid,_Info}, S0) ->
    S1 = delete_lock(MonitorRef, S0),
    S = del_name(MonitorRef, S1),
    {noreply,S};
handle_info(Message, S) ->
    error_logger:warning_msg("The global_name_server received an unexpe"
                             "cted message:\nhandle_info(~p, _)\n",
                             [Message]),
    {noreply,S}.

wait_high_level_trace() ->
    receive
        high_level_trace ->
            ok
    after
        500 + 1 -> ok
    end.

send_high_level_trace() ->
    erlang:send_after(500, self(), high_level_trace).

trans_all_known(Fun) ->
    Id = {global,self()},
    Nodes = set_lock_known(Id, 0),
    try Fun(Nodes) after delete_global_lock(Id, Nodes) end.

set_lock_known(Id, Times) ->
    Known = get_known(),
    Nodes = [node()|Known],
    Boss = the_boss(Nodes),
    case set_lock_on_nodes(Id, [Boss]) of
        true ->
            case lock_on_known_nodes(Id, Known, Nodes) of
                true ->
                    Nodes;
                false ->
                    del_lock(Id, [Boss]),
                    random_sleep(Times),
                    set_lock_known(Id, Times + 1)
            end;
        false ->
            random_sleep(Times),
            set_lock_known(Id, Times + 1)
    end.

lock_on_known_nodes(Id, Known, Nodes) ->
    case set_lock_on_nodes(Id, Nodes) of
        true ->
            get_known() -- Known =:= [];
        false ->
            false
    end.

set_lock_on_nodes(_Id, []) ->
    true;
set_lock_on_nodes(Id, Nodes) ->
    case local_lock_check(Id, Nodes) of
        true ->
            Msg = {set_lock,Id},
            {Replies,_} =
                gen_server:multi_call(Nodes, global_name_server, Msg),
            ok,
            check_replies(Replies, Id, Replies);
        false = Reply ->
            Reply
    end.

local_lock_check(_Id, [_] = _Nodes) ->
    true;
local_lock_check(Id, Nodes) ->
    not lists:member(node(), Nodes)
    orelse
    can_set_lock(Id) =/= false.

check_replies([{_Node,true}|T], Id, Replies) ->
    check_replies(T, Id, Replies);
check_replies([{_Node,false = Reply}|_T], _Id, [_]) ->
    Reply;
check_replies([{_Node,false = Reply}|_T], Id, Replies) ->
    TrueReplyNodes =
        [ 
         N ||
             {N,true} <- Replies
        ],
    ok,
    gen_server:multi_call(TrueReplyNodes,
                          global_name_server,
                          {del_lock,Id}),
    Reply;
check_replies([], _Id, _Replies) ->
    true.

init_connect(Vsn, Node, InitMsg, HisTag, Resolvers, S) ->
    put({prot_vsn,Node}, Vsn),
    put({sync_tag_his,Node}, HisTag),
    case lists:keyfind(Node, 1, Resolvers) of
        {Node,MyTag,_Resolver} ->
            MyTag = get({sync_tag_my,Node}),
            {locker,_NoLongerAPid,_HisKnown0,HisTheLocker} = InitMsg,
            ok,
            HisKnown = [],
            S#state.the_locker
            !
            {his_the_locker,HisTheLocker,{Vsn,HisKnown},S#state.known};
        false ->
            ok,
            put({pre_connect,Node}, {Vsn,InitMsg,HisTag})
    end.

lock_is_set(Node, Resolvers, LockId) ->
    gen_server:cast({global_name_server,Node},
                    {exchange,
                     node(),
                     get_names(),
                     _ExtNames = [],
                     get({sync_tag_his,Node})}),
    put({lock_id,Node}, LockId),
    case get({wait_lock,Node}) of
        {exchange,NameList} ->
            put({wait_lock,Node}, lock_is_set),
            exchange(Node, NameList, Resolvers);
        undefined ->
            put({wait_lock,Node}, lock_is_set)
    end.

exchange(Node, NameList, Resolvers) ->
    ok,
    case erase({wait_lock,Node}) of
        lock_is_set ->
            {Node,_Tag,Resolver} = lists:keyfind(Node, 1, Resolvers),
            Resolver ! {resolve,NameList,Node};
        undefined ->
            put({wait_lock,Node}, {exchange,NameList})
    end.

resolved(Node, HisResolved, HisKnown, Names_ext, S0) ->
    Ops = erase({save_ops,Node}) ++ HisResolved,
    Known = S0#state.known,
    Synced = S0#state.synced,
    NewNodes = [Node|HisKnown],
    sync_others(HisKnown),
    ExtraInfo = [{vsn,get({prot_vsn,Node})},{lock,get({lock_id,Node})}],
    S = do_ops(Ops, node(), Names_ext, ExtraInfo, S0),
    lists:foreach(fun(Pid) ->
                         Pid ! {synced,[Node]}
                  end,
                  S#state.syncers),
    S3 =
        lists:foldl(fun(Node1, S1) ->
                           F = fun(Tag) ->
                                      cancel_locker(Node1, S1, Tag)
                               end,
                           cancel_resolved_locker(Node1, F)
                    end,
                    S,
                    HisKnown),
    NewNodesF =
        fun() ->
               gen_server:abcast(Known,
                                 global_name_server,
                                 {new_nodes,
                                  node(),
                                  Ops,
                                  Names_ext,
                                  NewNodes,
                                  ExtraInfo})
        end,
    F = fun(Tag) ->
               cancel_locker(Node, S3, Tag, NewNodesF)
        end,
    S4 = cancel_resolved_locker(Node, F),
    AddedNodes = NewNodes -- Known,
    NewKnown = Known ++ AddedNodes,
    S4#state.the_locker ! {add_to_known,AddedNodes},
    NewS =
        trace_message(S4,
                      {added,AddedNodes},
                      [{new_nodes,NewNodes},{abcast,Known},{ops,Ops}]),
    NewS#state{known = NewKnown,synced = [Node|Synced]}.

cancel_resolved_locker(Node, CancelFun) ->
    Tag = get({sync_tag_my,Node}),
    ok,
    S = CancelFun(Tag),
    reset_node_state(Node),
    S.

new_nodes(Ops, ConnNode, Names_ext, Nodes, ExtraInfo, S0) ->
    Known = S0#state.known,
    AddedNodes = lists:delete(node(), Nodes -- Known),
    sync_others(AddedNodes),
    S = do_ops(Ops, ConnNode, Names_ext, ExtraInfo, S0),
    ok,
    S#state.the_locker ! {add_to_known,AddedNodes},
    S1 = trace_message(S, {added,AddedNodes}, [{ops,Ops}]),
    S1#state{known = Known ++ AddedNodes}.

do_whereis(Name, From) ->
    case is_global_lock_set() of
        false ->
            gen_server:reply(From, where(Name));
        true ->
            send_again({whereis,Name,From})
    end.

-spec terminate(term(), state()) -> ok.

terminate(_Reason, _S) ->
    true = ets:delete(global_names),
    true = ets:delete(global_names_ext),
    true = ets:delete(global_locks),
    true = ets:delete(global_pid_names),
    true = ets:delete(global_pid_ids),
    ok.

-spec code_change(term(), state(), term()) -> {ok, state()}.

code_change(_OldVsn, S, _Extra) ->
    {ok,S}.

start_resolver(Node, MyTag) ->
    spawn(fun() ->
                 resolver(Node, MyTag)
          end).

resolver(Node, Tag) ->
    receive
        {resolve,NameList,Node} ->
            ok,
            {Ops,Resolved} = exchange_names(NameList, Node, [], []),
            Exchange = {exchange_ops,Node,Tag,Ops,Resolved},
            gen_server:cast(global_name_server, Exchange),
            exit(normal);
        _ ->
            resolver(Node, Tag)
    end.

resend_pre_connect(Node) ->
    case erase({pre_connect,Node}) of
        {Vsn,InitMsg,HisTag} ->
            gen_server:cast(self(),
                            {init_connect,{Vsn,HisTag},Node,InitMsg});
        _ ->
            ok
    end.

ins_name(Name, Pid, Method, FromPidOrNode, ExtraInfo, S0) ->
    ok,
    S1 = delete_global_name_keep_pid(Name, S0),
    S = trace_message(S1, {ins_name,node(Pid)}, [Name,Pid]),
    insert_global_name(Name, Pid, Method, FromPidOrNode, ExtraInfo, S).

ins_name_ext(Name, Pid, Method, RegNode, FromPidOrNode, ExtraInfo, S0) ->
    ok,
    S1 = delete_global_name_keep_pid(Name, S0),
    dolink_ext(Pid, RegNode),
    S = trace_message(S1, {ins_name_ext,node(Pid)}, [Name,Pid]),
    true = ets:insert(global_names_ext, {Name,Pid,RegNode}),
    insert_global_name(Name, Pid, Method, FromPidOrNode, ExtraInfo, S).

where(Name) ->
    case ets:lookup(global_names, Name) of
        [{_Name,Pid,_Method,_RPid,_Ref}] ->
            if
                node(Pid) == node() ->
                    case is_process_alive(Pid) of
                        true ->
                            Pid;
                        false ->
                            undefined
                    end;
                true ->
                    Pid
            end;
        [] ->
            undefined
    end.

handle_set_lock(Id, Pid, S) ->
    ok,
    case can_set_lock(Id) of
        {true,PidRefs} ->
            case pid_is_locking(Pid, PidRefs) of
                true ->
                    {true,S};
                false ->
                    {true,insert_lock(Id, Pid, PidRefs, S)}
            end;
        false = Reply ->
            {Reply,S}
    end.

can_set_lock({ResourceId,LockRequesterId}) ->
    case ets:lookup(global_locks, ResourceId) of
        [{ResourceId,LockRequesterId,PidRefs}] ->
            {true,PidRefs};
        [{ResourceId,_LockRequesterId2,_PidRefs}] ->
            false;
        [] ->
            {true,[]}
    end.

insert_lock({ResourceId,LockRequesterId} = Id, Pid, PidRefs, S) ->
    {RPid,Ref} = do_monitor(Pid),
    true = ets:insert(global_pid_ids, {Pid,ResourceId}),
    true = ets:insert(global_pid_ids, {Ref,ResourceId}),
    Lock = {ResourceId,LockRequesterId,[{Pid,RPid,Ref}|PidRefs]},
    true = ets:insert(global_locks, Lock),
    trace_message(S, {ins_lock,node(Pid)}, [Id,Pid]).

is_global_lock_set() ->
    is_lock_set(global).

is_lock_set(ResourceId) ->
    ets:member(global_locks, ResourceId).

handle_del_lock({ResourceId,LockReqId}, Pid, S0) ->
    ok,
    case ets:lookup(global_locks, ResourceId) of
        [{ResourceId,LockReqId,PidRefs}] ->
            remove_lock(ResourceId, LockReqId, Pid, PidRefs, false, S0);
        _ ->
            S0
    end.

remove_lock(ResourceId,
            LockRequesterId,
            Pid,
            [{Pid,RPid,Ref}],
            Down,
            S0) ->
    ok,
    true = demonitor(Ref, [flush]),
    kill_monitor_proc(RPid, Pid),
    true = ets:delete(global_locks, ResourceId),
    true = ets:delete_object(global_pid_ids, {Pid,ResourceId}),
    true = ets:delete_object(global_pid_ids, {Ref,ResourceId}),
    S = case ResourceId of
            global ->
                S0#state{global_lock_down = Down};
            _ ->
                S0
        end,
    trace_message(S,
                  {rem_lock,node(Pid)},
                  [{ResourceId,LockRequesterId},Pid]);
remove_lock(ResourceId, LockRequesterId, Pid, PidRefs0, _Down, S) ->
    ok,
    PidRefs =
        case lists:keyfind(Pid, 1, PidRefs0) of
            {Pid,RPid,Ref} ->
                true = demonitor(Ref, [flush]),
                kill_monitor_proc(RPid, Pid),
                true =
                    ets:delete_object(global_pid_ids, {Ref,ResourceId}),
                lists:keydelete(Pid, 1, PidRefs0);
            false ->
                PidRefs0
        end,
    Lock = {ResourceId,LockRequesterId,PidRefs},
    true = ets:insert(global_locks, Lock),
    true = ets:delete_object(global_pid_ids, {Pid,ResourceId}),
    trace_message(S,
                  {rem_lock,node(Pid)},
                  [{ResourceId,LockRequesterId},Pid]).

kill_monitor_proc(Pid, Pid) ->
    ok;
kill_monitor_proc(RPid, _Pid) ->
    exit(RPid, kill).

do_ops(Ops, ConnNode, Names_ext, ExtraInfo, S0) ->
    ok,
    XInserts =
        [ 
         {Name,Pid,RegNode,Method} ||
             {Name2,Pid2,RegNode} <- Names_ext,
             {insert,{Name,Pid,Method}} <- Ops,
             Name =:= Name2,
             Pid =:= Pid2
        ],
    S1 =
        lists:foldl(fun({Name,Pid,RegNode,Method}, S1) ->
                           ins_name_ext(Name,
                                        Pid,
                                        Method,
                                        RegNode,
                                        ConnNode,
                                        ExtraInfo,
                                        S1)
                    end,
                    S0,
                    XInserts),
    XNames =
        [ 
         Name ||
             {Name,_Pid,_RegNode,_Method} <- XInserts
        ],
    Inserts =
        [ 
         {Name,Pid,node(Pid),Method} ||
             {insert,{Name,Pid,Method}} <- Ops,
             not lists:member(Name, XNames)
        ],
    S2 =
        lists:foldl(fun({Name,Pid,_RegNode,Method}, S2) ->
                           ins_name(Name,
                                    Pid,
                                    Method,
                                    ConnNode,
                                    ExtraInfo,
                                    S2)
                    end,
                    S1,
                    Inserts),
    DelNames =
        [ 
         Name ||
             {delete,Name} <- Ops
        ],
    lists:foldl(fun(Name, S) ->
                       delete_global_name2(Name, S)
                end,
                S2,
                DelNames).

sync_others(Nodes) ->
    N = case application:get_env(kernel, global_connect_retries) of
            {ok,NRetries} when is_integer(NRetries), NRetries >= 0 ->
                NRetries;
            _ ->
                5
        end,
    lists:foreach(fun(Node) ->
                         spawn(fun() ->
                                      sync_other(Node, N)
                               end)
                  end,
                  Nodes).

sync_other(Node, N) ->
    erlang:monitor_node(Node, true, [allow_passive_connect]),
    receive
        {nodedown,Node} when N > 0 ->
            sync_other(Node, N - 1);
        {nodedown,Node} ->
            ok,
            error_logger:warning_msg("global: ~w failed to connect to ~"
                                     "w\n",
                                     [node(),Node]),
            global_name_server ! {extra_nodedown,Node}
    after
        0 ->
            gen_server:cast({global_name_server,Node},
                            {in_sync,node(),true})
    end.

insert_global_name(Name, Pid, Method, FromPidOrNode, ExtraInfo, S) ->
    {RPid,Ref} = do_monitor(Pid),
    true = ets:insert(global_names, {Name,Pid,Method,RPid,Ref}),
    true = ets:insert(global_pid_names, {Pid,Name}),
    true = ets:insert(global_pid_names, {Ref,Name}),
    case lock_still_set(FromPidOrNode, ExtraInfo, S) of
        true ->
            S;
        false ->
            delete_global_name2(Name, S)
    end.

lock_still_set(PidOrNode, ExtraInfo, S) ->
    case ets:lookup(global_locks, global) of
        [{global,_LockReqId,PidRefs}] when is_pid(PidOrNode) ->
            lists:keymember(PidOrNode, 1, PidRefs);
        [{global,LockReqId,_PidRefs}] when is_atom(PidOrNode) ->
            {global,LockId} = extra_info(lock, ExtraInfo),
            LockReqId =:= LockId;
        [] ->
            not S#state.global_lock_down
    end.

extra_info(Tag, ExtraInfo) ->
    case catch lists:keyfind(Tag, 1, ExtraInfo) of
        {Tag,Info} ->
            Info;
        _ ->
            undefined
    end.

del_name(Ref, S) ->
    NameL =
        [ 
         Name ||
             {_,Name} <- ets:lookup(global_pid_names, Ref),
             {_,_Pid,_Method,_RPid,Ref1} <-
                 ets:lookup(global_names, Name),
             Ref1 =:= Ref
        ],
    case NameL of
        [Name] ->
            delete_global_name2(Name, S);
        [] ->
            S
    end.

delete_global_name_keep_pid(Name, S) ->
    case ets:lookup(global_names, Name) of
        [{Name,Pid,_Method,RPid,Ref}] ->
            delete_global_name2(Name, Pid, RPid, Ref, S);
        [] ->
            S
    end.

delete_global_name2(Name, S) ->
    case ets:lookup(global_names, Name) of
        [{Name,Pid,_Method,RPid,Ref}] ->
            true = ets:delete(global_names, Name),
            delete_global_name2(Name, Pid, RPid, Ref, S);
        [] ->
            S
    end.

delete_global_name2(Name, Pid, RPid, Ref, S) ->
    true = demonitor(Ref, [flush]),
    kill_monitor_proc(RPid, Pid),
    delete_global_name(Name, Pid),
    ok,
    true = ets:delete_object(global_pid_names, {Pid,Name}),
    true = ets:delete_object(global_pid_names, {Ref,Name}),
    case ets:lookup(global_names_ext, Name) of
        [{Name,Pid,RegNode}] ->
            true = ets:delete(global_names_ext, Name),
            ok,
            dounlink_ext(Pid, RegNode);
        [] ->
            ok,
            ok
    end,
    trace_message(S, {del_name,node(Pid)}, [Name,Pid]).

delete_global_name(_Name, _Pid) ->
    ok.

-record(multi,{local = [],
               remote = [],
               known = [],
               the_boss,
               just_synced = false,
               do_trace}).

-record(him,{node,locker,vsn,my_tag}).

start_the_locker(DoTrace) ->
    spawn_link(fun() ->
                      init_the_locker(DoTrace)
               end).

init_the_locker(DoTrace) ->
    process_flag(trap_exit, true),
    S0 = #multi{do_trace = DoTrace},
    S1 = update_locker_known({add,get_known()}, S0),
    loop_the_locker(S1),
    error(locker_exited).

loop_the_locker(S) ->
    ok,
    receive
        Message when element(1, Message) =/= nodeup ->
            the_locker_message(Message, S)
    after
        0 ->
            Timeout =
                case {S#multi.local,S#multi.remote} of
                    {[],[]} ->
                        infinity;
                    _ ->
                        if
                            S#multi.just_synced ->
                                0;
                            S#multi.known =:= [] ->
                                200;
                            true ->
                                min(1000 + 100 * length(S#multi.known),
                                    3000)
                        end
                end,
            S1 = S#multi{just_synced = false},
            receive
                Message when element(1, Message) =/= nodeup ->
                    the_locker_message(Message, S1)
            after
                Timeout ->
                    case is_global_lock_set() of
                        true ->
                            loop_the_locker(S1);
                        false ->
                            select_node(S1)
                    end
            end
    end.

the_locker_message({his_the_locker,HisTheLocker,HisKnown0,_MyKnown}, S) ->
    ok,
    {HisVsn,_HisKnown} = HisKnown0,
    true = HisVsn > 4,
    receive
        {nodeup,Node,MyTag} when node(HisTheLocker) =:= Node ->
            ok,
            Him =
                #him{node = node(HisTheLocker),
                     my_tag = MyTag,
                     locker = HisTheLocker,
                     vsn = HisVsn},
            loop_the_locker(add_node(Him, S));
        {cancel,Node,_Tag,no_fun} when node(HisTheLocker) =:= Node ->
            loop_the_locker(S)
    after
        60000 ->
            ok,
            error_logger:error_msg("global: nodeup never came ~w ~w\n",
                                   [node(),node(HisTheLocker)]),
            loop_the_locker(S#multi{just_synced = false})
    end;
the_locker_message({cancel,_Node,undefined,no_fun}, S) ->
    ok,
    loop_the_locker(S);
the_locker_message({cancel,Node,Tag,no_fun}, S) ->
    ok,
    receive
        {nodeup,Node,Tag} ->
            ok,
            ok
    after
        0 -> ok
    end,
    loop_the_locker(remove_node(Node, S));
the_locker_message({lock_set,_Pid,false,_}, S) ->
    ok,
    loop_the_locker(S);
the_locker_message({lock_set,Pid,true,_HisKnown}, S) ->
    Node = node(Pid),
    ok,
    case find_node_tag(Node, S) of
        {true,MyTag,HisVsn} ->
            LockId = locker_lock_id(Pid, HisVsn),
            {IsLockSet,S1} = lock_nodes_safely(LockId, [], S),
            Pid ! {lock_set,self(),IsLockSet,S1#multi.known},
            Known2 = [node()|S1#multi.known],
            ok,
            case IsLockSet of
                true ->
                    gen_server:cast(global_name_server,
                                    {lock_is_set,Node,MyTag,LockId}),
                    ok,
                    receive
                        {cancel,Node,_Tag,Fun} ->
                            ok,
                            call_fun(Fun),
                            delete_global_lock(LockId, Known2)
                    end,
                    S2 = S1#multi{just_synced = true},
                    loop_the_locker(remove_node(Node, S2));
                false ->
                    loop_the_locker(S1#multi{just_synced = false})
            end;
        false ->
            ok,
            Pid ! {lock_set,self(),false,S#multi.known},
            loop_the_locker(S)
    end;
the_locker_message({add_to_known,Nodes}, S) ->
    S1 = update_locker_known({add,Nodes}, S),
    loop_the_locker(S1);
the_locker_message({remove_from_known,Node}, S) ->
    S1 = update_locker_known({remove,Node}, S),
    loop_the_locker(S1);
the_locker_message({do_trace,DoTrace}, S) ->
    loop_the_locker(S#multi{do_trace = DoTrace});
the_locker_message(Other, S) ->
    unexpected_message(Other, locker),
    ok,
    loop_the_locker(S).

select_node(S) ->
    UseRemote = S#multi.local =:= [],
    Others1 =
        if
            UseRemote ->
                S#multi.remote;
            true ->
                S#multi.local
        end,
    Others2 = exclude_known(Others1, S#multi.known),
    S1 =
        if
            UseRemote ->
                S#multi{remote = Others2};
            true ->
                S#multi{local = Others2}
        end,
    if
        Others2 =:= [] ->
            loop_the_locker(S1);
        true ->
            Him = random_element(Others2),
            #him{locker = HisTheLocker,
                 vsn = HisVsn,
                 node = Node,
                 my_tag = MyTag} =
                Him,
            HisNode = [Node],
            Us = [node()|HisNode],
            LockId = locker_lock_id(HisTheLocker, HisVsn),
            ok,
            {IsLockSet,S2} = lock_nodes_safely(LockId, HisNode, S1),
            case IsLockSet of
                true ->
                    Known1 = Us ++ S2#multi.known,
                    ok,
                    HisTheLocker ! {lock_set,self(),true,S2#multi.known},
                    S3 = lock_is_set(S2, Him, MyTag, Known1, LockId),
                    loop_the_locker(S3);
                false ->
                    loop_the_locker(S2)
            end
    end.

locker_lock_id(Pid, Vsn) when Vsn > 4 ->
    {global,lists:sort([self(),Pid])}.

lock_nodes_safely(LockId, Extra, S0) ->
    First = delete_nonode([S0#multi.the_boss]),
    case
        [node()] =:= First
        orelse
        can_set_lock(LockId) =/= false
    of
        true ->
            case set_lock(LockId, First, 0) of
                true ->
                    S = update_locker_known(S0),
                    Second = delete_nonode([node()|Extra] -- First),
                    case set_lock(LockId, Second, 0) of
                        true ->
                            Known = S#multi.known,
                            case set_lock(LockId, Known -- First, 0) of
                                true ->
                                    _ = locker_trace(S,
                                                     ok,
                                                     {First,Known}),
                                    {true,S};
                                false ->
                                    SoFar = First ++ Second,
                                    del_lock(LockId, SoFar),
                                    _ = locker_trace(S,
                                                     not_ok,
                                                     {Known,SoFar}),
                                    {false,S}
                            end;
                        false ->
                            del_lock(LockId, First),
                            _ = locker_trace(S, not_ok, {Second,First}),
                            {false,S}
                    end;
                false ->
                    _ = locker_trace(S0, not_ok, {First,[]}),
                    {false,S0}
            end;
        false ->
            {false,S0}
    end.

delete_nonode(L) ->
    lists:delete(nonode@nohost, L).

locker_trace(#multi{do_trace = false}, _, _Nodes) ->
    ok;
locker_trace(#multi{do_trace = true}, ok, Ns) ->
    global_name_server ! {trace_message,{locker_succeeded,node()},Ns};
locker_trace(#multi{do_trace = true}, not_ok, Ns) ->
    global_name_server ! {trace_message,{locker_failed,node()},Ns};
locker_trace(#multi{do_trace = true}, rejected, Ns) ->
    global_name_server ! {trace_message,{lock_rejected,node()},Ns}.

update_locker_known(S) ->
    receive
        {add_to_known,Nodes} ->
            S1 = update_locker_known({add,Nodes}, S),
            update_locker_known(S1);
        {remove_from_known,Node} ->
            S1 = update_locker_known({remove,Node}, S),
            update_locker_known(S1)
    after
        0 -> S
    end.

update_locker_known(Upd, S) ->
    Known =
        case Upd of
            {add,Nodes} ->
                Nodes ++ S#multi.known;
            {remove,Node} ->
                lists:delete(Node, S#multi.known)
        end,
    TheBoss = the_boss([node()|Known]),
    S#multi{known = Known,the_boss = TheBoss}.

random_element(L) ->
    {A,B,C} = now(),
    E = (A + B + C) rem length(L),
    lists:nth(E + 1, L).

exclude_known(Others, Known) ->
    [ 
     N ||
         N <- Others,
         not lists:member(N#him.node, Known)
    ].

lock_is_set(S, Him, MyTag, Known1, LockId) ->
    Node = Him#him.node,
    receive
        {lock_set,P,true,_} when node(P) =:= Node ->
            gen_server:cast(global_name_server,
                            {lock_is_set,Node,MyTag,LockId}),
            ok,
            receive
                {cancel,Node,_,Fun} ->
                    ok,
                    call_fun(Fun),
                    delete_global_lock(LockId, Known1)
            end,
            S#multi{just_synced = true,
                    local = lists:delete(Him, S#multi.local),
                    remote = lists:delete(Him, S#multi.remote)};
        {lock_set,P,false,_} when node(P) =:= Node ->
            ok,
            _ = locker_trace(S, rejected, Known1),
            delete_global_lock(LockId, Known1),
            S;
        {cancel,Node,_,Fun} ->
            ok,
            call_fun(Fun),
            _ = locker_trace(S, rejected, Known1),
            delete_global_lock(LockId, Known1),
            remove_node(Node, S);
        {'EXIT',_,_} ->
            ok,
            _ = locker_trace(S, rejected, Known1),
            delete_global_lock(LockId, Known1),
            S
    end.

call_fun(no_fun) ->
    ok;
call_fun(Fun) ->
    Fun().

delete_global_lock(LockId, Nodes) ->
    TheBoss = the_boss(Nodes),
    del_lock(LockId, lists:delete(TheBoss, Nodes)),
    del_lock(LockId, [TheBoss]).

the_boss(Nodes) ->
    lists:max(Nodes).

find_node_tag(Node, S) ->
    case find_node_tag2(Node, S#multi.local) of
        false ->
            find_node_tag2(Node, S#multi.remote);
        Reply ->
            Reply
    end.

find_node_tag2(_Node, []) ->
    false;
find_node_tag2(Node, [#him{node = Node,my_tag = MyTag,vsn = HisVsn}|_]) ->
    {true,MyTag,HisVsn};
find_node_tag2(Node, [_E|Rest]) ->
    find_node_tag2(Node, Rest).

remove_node(Node, S) ->
    S#multi{local = remove_node2(Node, S#multi.local),
            remote = remove_node2(Node, S#multi.remote)}.

remove_node2(_Node, []) ->
    [];
remove_node2(Node, [#him{node = Node}|Rest]) ->
    Rest;
remove_node2(Node, [E|Rest]) ->
    [E|remove_node2(Node, Rest)].

add_node(Him, S) ->
    case is_node_local(Him#him.node) of
        true ->
            S#multi{local = [Him|S#multi.local]};
        false ->
            S#multi{remote = [Him|S#multi.remote]}
    end.

is_node_local(Node) ->
    {ok,Host} = inet:gethostname(),
    case catch split_node(atom_to_list(Node), $@, []) of
        [_,Host] ->
            true;
        _ ->
            false
    end.

split_node([Chr|T], Chr, Ack) ->
    [lists:reverse(Ack)|split_node(T, Chr, [])];
split_node([H|T], Chr, Ack) ->
    split_node(T, Chr, [H|Ack]);
split_node([], _, Ack) ->
    [lists:reverse(Ack)].

cancel_locker(Node, S, Tag) ->
    cancel_locker(Node, S, Tag, no_fun).

cancel_locker(Node, S, Tag, ToBeRunOnLockerF) ->
    S#state.the_locker ! {cancel,Node,Tag,ToBeRunOnLockerF},
    Resolvers = S#state.resolvers,
    ok,
    case lists:keyfind(Node, 1, Resolvers) of
        {_,Tag,Resolver} ->
            ok,
            exit(Resolver, kill),
            S1 = trace_message(S, {kill_resolver,Node}, [Tag,Resolver]),
            S1#state{resolvers = lists:keydelete(Node, 1, Resolvers)};
        _ ->
            S
    end.

reset_node_state(Node) ->
    ok,
    erase({wait_lock,Node}),
    erase({save_ops,Node}),
    erase({pre_connect,Node}),
    erase({prot_vsn,Node}),
    erase({sync_tag_my,Node}),
    erase({sync_tag_his,Node}),
    erase({lock_id,Node}).

exchange_names([{Name,Pid,Method}|Tail], Node, Ops, Res) ->
    case ets:lookup(global_names, Name) of
        [{Name,Pid,_Method,_RPid2,_Ref2}] ->
            exchange_names(Tail, Node, Ops, Res);
        [{Name,Pid2,Method2,_RPid2,_Ref2}] when node() < Node ->
            Node2 = node(Pid2),
            case
                rpc:call(Node2,
                         global,
                         resolve_it,
                         [Method2,Name,Pid,Pid2])
            of
                Pid ->
                    Op = {insert,{Name,Pid,Method}},
                    exchange_names(Tail, Node, [Op|Ops], Res);
                Pid2 ->
                    Op = {insert,{Name,Pid2,Method2}},
                    exchange_names(Tail, Node, Ops, [Op|Res]);
                none ->
                    Op = {delete,Name},
                    exchange_names(Tail, Node, [Op|Ops], [Op|Res]);
                {badrpc,Badrpc} ->
                    error_logger:info_msg("global: badrpc ~w received w"
                                          "hen conflicting name ~w was "
                                          "found\n",
                                          [Badrpc,Name]),
                    Op = {insert,{Name,Pid,Method}},
                    exchange_names(Tail, Node, [Op|Ops], Res);
                Else ->
                    error_logger:info_msg("global: Resolve method ~w fo"
                                          "r conflicting name ~w return"
                                          "ed ~w\n",
                                          [Method,Name,Else]),
                    Op = {delete,Name},
                    exchange_names(Tail, Node, [Op|Ops], [Op|Res])
            end;
        [{Name,_Pid2,_Method,_RPid,_Ref}] ->
            exchange_names(Tail, Node, Ops, Res);
        _ ->
            exchange_names(Tail,
                           Node,
                           [{insert,{Name,Pid,Method}}|Ops],
                           Res)
    end;
exchange_names([], _, Ops, Res) ->
    ok,
    {Ops,Res}.

resolve_it(Method, Name, Pid1, Pid2) ->
    catch Method(Name, Pid1, Pid2).

minmax(P1, P2) ->
    if
        node(P1) < node(P2) ->
            {P1,P2};
        true ->
            {P2,P1}
    end.

-spec random_exit_name(Name, Pid1, Pid2) -> pid()
                          when
                              is_subtype(Name, term()),
                              is_subtype(Pid1, pid()),
                              is_subtype(Pid2, pid()).

random_exit_name(Name, Pid, Pid2) ->
    {Min,Max} = minmax(Pid, Pid2),
    error_logger:info_msg("global: Name conflict terminating ~w\n",
                          [{Name,Max}]),
    exit(Max, kill),
    Min.

-spec random_notify_name(Name, Pid1, Pid2) -> pid()
                            when
                                is_subtype(Name, term()),
                                is_subtype(Pid1, pid()),
                                is_subtype(Pid2, pid()).

random_notify_name(Name, Pid, Pid2) ->
    {Min,Max} = minmax(Pid, Pid2),
    Max ! {global_name_conflict,Name},
    Min.

-spec notify_all_name(Name, Pid1, Pid2) -> none
                         when
                             is_subtype(Name, term()),
                             is_subtype(Pid1, pid()),
                             is_subtype(Pid2, pid()).

notify_all_name(Name, Pid, Pid2) ->
    Pid ! {global_name_conflict,Name,Pid2},
    Pid2 ! {global_name_conflict,Name,Pid},
    none.

dolink_ext(Pid, RegNode) when RegNode =:= node() ->
    link(Pid);
dolink_ext(_, _) ->
    ok.

dounlink_ext(Pid, RegNode) when RegNode =:= node() ->
    unlink_pid(Pid);
dounlink_ext(_Pid, _RegNode) ->
    ok.

unlink_pid(Pid) ->
    case ets:member(global_pid_names, Pid) of
        false ->
            case ets:member(global_pid_ids, Pid) of
                false ->
                    unlink(Pid);
                true ->
                    ok
            end;
        true ->
            ok
    end.

pid_is_locking(Pid, PidRefs) ->
    lists:keyfind(Pid, 1, PidRefs) =/= false.

delete_lock(Ref, S0) ->
    Locks = pid_locks(Ref),
    F = fun({ResourceId,LockRequesterId,PidRefs}, S) ->
               {Pid,_RPid,Ref} = lists:keyfind(Ref, 3, PidRefs),
               remove_lock(ResourceId,
                           LockRequesterId,
                           Pid,
                           PidRefs,
                           true,
                           S)
        end,
    lists:foldl(F, S0, Locks).

pid_locks(Ref) ->
    L = lists:flatmap(fun({_,ResourceId}) ->
                             ets:lookup(global_locks, ResourceId)
                      end,
                      ets:lookup(global_pid_ids, Ref)),
    [ 
     Lock ||
         Lock = {_Id,_Req,PidRefs} <- L,
         rpid_is_locking(Ref, PidRefs)
    ].

rpid_is_locking(Ref, PidRefs) ->
    lists:keyfind(Ref, 3, PidRefs) =/= false.

handle_nodedown(Node, S) ->
    #state{known = Known,synced = Syncs} = S,
    NewS = cancel_locker(Node, S, get({sync_tag_my,Node})),
    NewS#state.the_locker ! {remove_from_known,Node},
    reset_node_state(Node),
    NewS#state{known = lists:delete(Node, Known),
               synced = lists:delete(Node, Syncs)}.

get_names() ->
    ets:select(global_names,
               [{{'$1','$2','$3','$4','$5'},[],[{{'$1','$2','$3'}}]}]).

get_names_ext() ->
    ets:tab2list(global_names_ext).

get_known() ->
    gen_server:call(global_name_server, get_known, infinity).

random_sleep(Times) ->
    case Times rem 10 of
        0 ->
            erase(random_seed);
        _ ->
            ok
    end,
    case get(random_seed) of
        undefined ->
            {A1,A2,A3} = now(),
            random:seed(A1, A2, A3 + erlang:phash(node(), 100000));
        _ ->
            ok
    end,
    Tmax =
        if
            Times > 5 ->
                8000;
            true ->
                (1 bsl Times) * 1000 div 8
        end,
    T = random:uniform(Tmax),
    ok,
    receive after T -> ok end.

dec(infinity) ->
    infinity;
dec(N) ->
    N - 1.

send_again(Msg) ->
    Me = self(),
    spawn(fun() ->
                 timer(Me, Msg)
          end).

timer(Pid, Msg) ->
    random_sleep(5),
    Pid ! Msg.

change_our_node_name(NewNode, S) ->
    S1 = trace_message(S, {new_node_name,NewNode}, []),
    S1#state{node_name = NewNode}.

trace_message(#state{trace = no_trace} = S, _M, _X) ->
    S;
trace_message(S, M, X) ->
    S#state{trace = [trace_message(M, X)|S#state.trace]}.

trace_message(M, X) ->
    {node(),now(),M,nodes(),X}.

start_sync(Nodes, From) ->
    spawn_link(fun() ->
                      sync_init(Nodes, From)
               end).

sync_init(Nodes, From) ->
    lists:foreach(fun(Node) ->
                         monitor_node(Node, true)
                  end,
                  Nodes),
    sync_loop(Nodes, From).

sync_loop([], From) ->
    gen_server:reply(From, ok);
sync_loop(Nodes, From) ->
    receive
        {nodedown,Node} ->
            monitor_node(Node, false),
            sync_loop(lists:delete(Node, Nodes), From);
        {synced,SNodes} ->
            lists:foreach(fun(N) ->
                                 monitor_node(N, false)
                          end,
                          SNodes),
            sync_loop(Nodes -- SNodes, From)
    end.

check_sync_nodes() ->
    case get_own_nodes() of
        {ok,all} ->
            nodes();
        {ok,NodesNG} ->
            intersection(nodes(), NodesNG);
        {error,_} = Error ->
            Error
    end.

check_sync_nodes(SyncNodes) ->
    case get_own_nodes() of
        {ok,all} ->
            SyncNodes;
        {ok,NodesNG} ->
            OwnNodeGroup = intersection(nodes(), NodesNG),
            IllegalSyncNodes = SyncNodes -- [node()|OwnNodeGroup],
            case IllegalSyncNodes of
                [] ->
                    SyncNodes;
                _ ->
                    {error,
                     {"Trying to sync nodes not defined in the own glob"
                      "al group",
                      IllegalSyncNodes}}
            end;
        {error,_} = Error ->
            Error
    end.

get_own_nodes() ->
    case global_group:get_own_nodes_with_errors() of
        {error,Error} ->
            {error,{"global_groups definition error",Error}};
        OkTup ->
            OkTup
    end.

start_the_registrar() ->
    spawn_link(fun() ->
                      loop_the_registrar()
               end).

loop_the_registrar() ->
    receive
        {trans_all_known,Fun,From} ->
            ok,
            gen_server:reply(From, trans_all_known(Fun));
        Other ->
            unexpected_message(Other, register)
    end,
    loop_the_registrar().

unexpected_message({'EXIT',_Pid,_Reason}, _What) ->
    ok;
unexpected_message(Message, What) ->
    error_logger:warning_msg("The global_name_server ~w process receive"
                             "d an unexpected message:\n~p\n",
                             [What,Message]).

do_monitor(Pid) ->
    case
        node(Pid) =:= node()
        orelse
        lists:member(node(Pid), nodes())
    of
        true ->
            {Pid,monitor(process, Pid)};
        false ->
            F = fun() ->
                       Ref = monitor(process, Pid),
                       receive
                           {'DOWN',Ref,process,Pid,_Info} ->
                               exit(normal)
                       end
                end,
            spawn_monitor(F)
    end.

intersection(_, []) ->
    [];
intersection(L1, L2) ->
    L1 -- L1 -- L2.

allow_tuple_fun({M,F}) when is_atom(M), is_atom(F) ->
    fun M:F/3;
allow_tuple_fun(Fun) when is_function(Fun, 3) ->
    Fun.



