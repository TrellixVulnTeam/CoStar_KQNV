-file("test/lib/dialyzer/test/user_SUITE_data/src/gcpFlowControl.erl",
      1).

-module(gcpFlowControl).

-id('24/190 55-CNA 113 033 Ux').

-vsn('/main/R1A/14').

-date('2005-05-04').

-author(uabasve).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/megaco-3.16.0.2/include/megaco.hrl",
      1).

-record(megaco_receive_handle,{local_mid,
                               encoding_mod,
                               encoding_config,
                               send_mod,
                               protocol_version = dynamic}).

-record(megaco_conn_handle,{local_mid,remote_mid}).

-record(megaco_incr_timer,{wait_for = timer:seconds(7),
                           factor = 2,
                           incr = 0,
                           max_retries = infinity}).

-record(megaco_term_id,{contains_wildcards = false,id}).

-file("test/lib/dialyzer/test/user_SUITE_data/src/gcpFlowControl.erl",
      37).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/megaco-3.16.0.2/include/megaco_message_v1.hrl",
      1).

-record('MegacoMessage',{authHeader = asn1_NOVALUE,mess}).

-record('AuthenticationHeader',{secParmIndex,seqNum,ad}).

-record('Message',{version,mId,messageBody}).

-record('DomainName',{name,portNumber = asn1_NOVALUE}).

-record('IP4Address',{address,portNumber = asn1_NOVALUE}).

-record('IP6Address',{address,portNumber = asn1_NOVALUE}).

-record('TransactionRequest',{transactionId,actions = []}).

-record('TransactionPending',{transactionId}).

-record('TransactionReply',{transactionId,
                            immAckRequired = asn1_NOVALUE,
                            transactionResult}).

-record('TransactionAck',{firstAck,lastAck = asn1_NOVALUE}).

-record('ErrorDescriptor',{errorCode,errorText = asn1_NOVALUE}).

-record('ActionRequest',{contextId,
                         contextRequest = asn1_NOVALUE,
                         contextAttrAuditReq = asn1_NOVALUE,
                         commandRequests = []}).

-record('ActionReply',{contextId,
                       errorDescriptor = asn1_NOVALUE,
                       contextReply = asn1_NOVALUE,
                       commandReply = []}).

-record('ContextRequest',{priority = asn1_NOVALUE,
                          emergency = asn1_NOVALUE,
                          topologyReq = asn1_NOVALUE}).

-record('ContextAttrAuditRequest',{topology = asn1_NOVALUE,
                                   emergency = asn1_NOVALUE,
                                   priority = asn1_NOVALUE}).

-record('CommandRequest',{command,
                          optional = asn1_NOVALUE,
                          wildcardReturn = asn1_NOVALUE}).

-record('TopologyRequest',{terminationFrom,
                           terminationTo,
                           topologyDirection}).

-record('AmmRequest',{terminationID = [],descriptors = []}).

-record('AmmsReply',{terminationID = [],terminationAudit = asn1_NOVALUE}).

-record('SubtractRequest',{terminationID = [],
                           auditDescriptor = asn1_NOVALUE}).

-record('AuditRequest',{terminationID,auditDescriptor}).

-record('AuditResult',{terminationID,terminationAuditResult = []}).

-record('AuditDescriptor',{auditToken = asn1_NOVALUE}).

-record('NotifyRequest',{terminationID = [],
                         observedEventsDescriptor,
                         errorDescriptor = asn1_NOVALUE}).

-record('NotifyReply',{terminationID = [],
                       errorDescriptor = asn1_NOVALUE}).

-record('ObservedEventsDescriptor',{requestId,observedEventLst = []}).

-record('ObservedEvent',{eventName,
                         streamID = asn1_NOVALUE,
                         eventParList = [],
                         timeNotation = asn1_NOVALUE}).

-record(megaco_event_parameter,{name,value}).

-record('EventParameter',{eventParameterName,
                          value,
                          extraInfo = asn1_NOVALUE}).

-record('ServiceChangeRequest',{terminationID = [],serviceChangeParms}).

-record('ServiceChangeReply',{terminationID = [],
                              serviceChangeResult = []}).

-record('TerminationID',{wildcard,id}).

-record('MediaDescriptor',{termStateDescr = asn1_NOVALUE,
                           streams = asn1_NOVALUE}).

-record('StreamDescriptor',{streamID,streamParms}).

-record('StreamParms',{localControlDescriptor = asn1_NOVALUE,
                       localDescriptor = asn1_NOVALUE,
                       remoteDescriptor = asn1_NOVALUE}).

-record('LocalControlDescriptor',{streamMode = asn1_NOVALUE,
                                  reserveValue = asn1_NOVALUE,
                                  reserveGroup = asn1_NOVALUE,
                                  propertyParms = []}).

-record('PropertyParm',{name,value,extraInfo = asn1_NOVALUE}).

-record('LocalRemoteDescriptor',{propGrps = []}).

-record('TerminationStateDescriptor',{propertyParms = [],
                                      eventBufferControl = asn1_NOVALUE,
                                      serviceState = asn1_NOVALUE}).

-record('MuxDescriptor',{muxType,
                         termList = [],
                         nonStandardData = asn1_NOVALUE}).

-record('EventsDescriptor',{requestID = asn1_NOVALUE,eventList = []}).

-record('RequestedEvent',{pkgdName,
                          streamID = asn1_NOVALUE,
                          eventAction = asn1_NOVALUE,
                          evParList = []}).

-record('RequestedActions',{keepActive = asn1_NOVALUE,
                            eventDM = asn1_NOVALUE,
                            secondEvent = asn1_NOVALUE,
                            signalsDescriptor = asn1_NOVALUE}).

-record('SecondEventsDescriptor',{requestID = asn1_NOVALUE,
                                  eventList = []}).

-record('SecondRequestedEvent',{pkgdName,
                                streamID = asn1_NOVALUE,
                                eventAction = asn1_NOVALUE,
                                evParList = []}).

-record('SecondRequestedActions',{keepActive = asn1_NOVALUE,
                                  eventDM = asn1_NOVALUE,
                                  signalsDescriptor = asn1_NOVALUE}).

-record('EventSpec',{eventName,
                     streamID = asn1_NOVALUE,
                     eventParList = []}).

-record('SeqSigList',{id,signalList = []}).

-record('Signal',{signalName,
                  streamID = asn1_NOVALUE,
                  sigType = asn1_NOVALUE,
                  duration = asn1_NOVALUE,
                  notifyCompletion = asn1_NOVALUE,
                  keepActive = asn1_NOVALUE,
                  sigParList = []}).

-record('SigParameter',{sigParameterName,value,extraInfo = asn1_NOVALUE}).

-record('ModemDescriptor',{mtl,mpl,nonStandardData = asn1_NOVALUE}).

-record('DigitMapDescriptor',{digitMapName = asn1_NOVALUE,
                              digitMapValue = asn1_NOVALUE}).

-record('DigitMapValue',{startTimer = asn1_NOVALUE,
                         shortTimer = asn1_NOVALUE,
                         longTimer = asn1_NOVALUE,
                         digitMapBody}).

-record('ServiceChangeParm',{serviceChangeMethod,
                             serviceChangeAddress = asn1_NOVALUE,
                             serviceChangeVersion = asn1_NOVALUE,
                             serviceChangeProfile = asn1_NOVALUE,
                             serviceChangeReason,
                             serviceChangeDelay = asn1_NOVALUE,
                             serviceChangeMgcId = asn1_NOVALUE,
                             timeStamp = asn1_NOVALUE,
                             nonStandardData = asn1_NOVALUE}).

-record('ServiceChangeResParm',{serviceChangeMgcId = asn1_NOVALUE,
                                serviceChangeAddress = asn1_NOVALUE,
                                serviceChangeVersion = asn1_NOVALUE,
                                serviceChangeProfile = asn1_NOVALUE,
                                timeStamp = asn1_NOVALUE}).

-record('ServiceChangeProfile',{profileName,version}).

-record('PackagesItem',{packageName,packageVersion}).

-record('StatisticsParameter',{statName,statValue = asn1_NOVALUE}).

-record('TimeNotation',{date,time}).

-file("test/lib/dialyzer/test/user_SUITE_data/src/gcpFlowControl.erl",
      38).

-file("test/lib/dialyzer/test/user_SUITE_data/src/gcp.hrl", 1).

-hrl_id('9/190 55-CNA 113 033 Ux').

-hrl_vsn('/main/R1A/21').

-hrl_date('2005-05-31').

-hrl_author(uabasve).

-record(mg,{pref}).

-record(mgc,{mgid}).

-record(user_config,{reply_timer = 30000,
                     pending_timer = 10000,
                     sent_pending_limit = 5,
                     recv_pending_limit = infinity,
                     request_timer = 3000,
                     request_retries = 5,
                     long_request_timer = 15000,
                     long_request_retries = 5}).

-record(receive_handle,{megaco_receive_handle,receive_message}).

-record(gcpRegistrationTable,{key,
                              role,
                              mid,
                              version,
                              callback,
                              config = #user_config{}}).

-record(gcpLinkTable,{key,
                      endpoint,
                      user,
                      chid,
                      admin_state,
                      op_state,
                      restart = auto,
                      encoding_mod,
                      encoding_config,
                      transport_start,
                      transport_data,
                      send_message,
                      receive_message,
                      tried = false,
                      t95_period = 350000}).

-record(gcpActiveLinkTable,{key,
                            link,
                            chid,
                            node,
                            conn_handle,
                            send_handle,
                            version = 1}).

-record(gcpVariables,{key,value}).

-record(gcpReplyData,{callback,mgid,user_data,prio,timestamp}).

-file("test/lib/dialyzer/test/user_SUITE_data/src/gcpFlowControl.erl",
      39).

-export([send_request/4,receive_reply/2,init_ets_tables/1,init_data/2]).

-record(gcpFlowControlTable,{key,
                             window = 50,
                             available = 50,
                             bucket = 0,
                             q = 0,
                             sent = 0,
                             rejectable = 0,
                             t95,
                             errors = 0,
                             rejects = 0,
                             replies = 0}).

-record(gcpFlowControlBitmap,{key,count = 0}).

send_request(ActiveLink, TimerOptions, ActionRequests, UserData) ->
    #gcpActiveLinkTable{key = Key,conn_handle = ConnHandle} = ActiveLink,
    Prio = prio(ActionRequests),
    incr(Key, sent),
    case allow(Key, Prio) of
        {true,Timestamp} ->
            grant_request(user_data(ConnHandle),
                          Key,
                          Prio,
                          Timestamp,
                          ConnHandle,
                          TimerOptions,
                          ActionRequests,
                          UserData);
        false ->
            {error,rejected}
    end.

receive_reply(Key, Timestamp) ->
    incr(Key, available),
    incr(Key, replies),
    release(Key),
    report_time(Key, Timestamp).

init_ets_tables(Role) ->
    create_ets(Role, gcpFlowControlTable, #gcpFlowControlTable.key),
    create_ets(Role, gcpFlowControlBitmap, #gcpFlowControlBitmap.key),
    ok.

create_ets(Role, Table, Pos) when integer(Pos) ->
    create_ets(Role,
               Table,
               [named_table,ordered_set,public,{keypos,Pos}]);
create_ets(test, Table, ArgList) ->
    ets:new(Table, ArgList);
create_ets(Role, Table, ArgList) ->
    case ets:info(Table) of
        undefined ->
            sysCmd:ets_new(Table, ArgList);
        _ when Role == ch ->
            sysCmd:inherit_tables([Table]);
        _ when Role == om ->
            ok
    end.

init_data(Key, T95) ->
    ets:insert(gcpFlowControlTable,
               #gcpFlowControlTable{key = Key,t95 = T95}).

cntr(Key, Field) ->
    incr(Key, Field, 0).

incr(Key, Field) ->
    incr(Key, Field, 1).

incr(Key, sent, X) ->
    upd_c(Key, {#gcpFlowControlTable.sent,X});
incr(Key, replies, X) ->
    upd_c(Key, {#gcpFlowControlTable.replies,X});
incr(Key, q, X) ->
    upd_c(Key, {#gcpFlowControlTable.q,X});
incr(Key, t95, X) ->
    upd_c(Key, {#gcpFlowControlTable.t95,X});
incr(Key, errors, X) ->
    upd_c(Key, {#gcpFlowControlTable.errors,X});
incr(Key, rejects, X) ->
    upd_c(Key, {#gcpFlowControlTable.rejects,X});
incr(Key, rejectable, X) ->
    upd_c(Key, {#gcpFlowControlTable.rejectable,X});
incr(Key, window, X) ->
    upd_c(Key, {#gcpFlowControlTable.window,X});
incr(Key, available, X) ->
    upd_c(Key, {#gcpFlowControlTable.available,X});
incr(Key, bucket, X) ->
    upd_c(Key, {#gcpFlowControlTable.bucket,X,100,100}).

upd_c(Key, N) ->
    ets:update_counter(gcpFlowControlTable, Key, N).

decr(Key, available, X) ->
    upd_c(Key, {#gcpFlowControlTable.available,- X});
decr(Key, window, X) ->
    upd_c(Key, {#gcpFlowControlTable.window,- X});
decr(Key, bucket, X) ->
    upd_c(Key, {#gcpFlowControlTable.bucket,- X,0,0}).

decr(Key, Field) ->
    decr(Key, Field, 1).

allow(Key, 16) ->
    decr(Key, available),
    {true,now()};
allow(Key, Prio) ->
    incr(Key, rejectable),
    case decr(Key, available) of
        N when N > 0 ->
            {true,no_stamp};
        _ ->
            incr(Key, available),
            queue(Key, Prio)
    end.

queue(Key, Prio) ->
    incr(Key, q),
    T = {Key,Prio,now(),self()},
    ets:insert(gcpFlowControlBitmap, #gcpFlowControlBitmap{key = T}),
    wait(T).

wait({Key,_Prio,_When,_Self} = T) ->
    receive
        allow ->
            ets:delete(gcpFlowControlBitmap, T),
            decr(Key, available),
            {true,no_stamp}
    after
        1000 ->
            timeout(T),
            adjust_window(Key),
            incr(Key, rejects),
            false
    end.

timeout(T) ->
    case ets:update_counter(gcpFlowControlBitmap, T, 1) of
        1 ->
            ets:delete(gcpFlowControlBitmap, T),
            ok;
        _ ->
            ets:delete(gcpFlowControlBitmap, T),
            receive
                allow ->
                    ok
            after
                1000 ->
                    io:format("~p: errant allow: ~p~n",
                              [gcpFlowControl,T])
            end
    end.

adjust_window(Key) ->
    adjust_window(Key,
                  cntr(Key, bucket) < 20
                  andalso
                  cntr(Key, window) < 100).

adjust_window(Key, true) ->
    incr(Key, window),
    incr(Key, available),
    incr(Key, bucket, 20);
adjust_window(_, false) ->
    ok.

report_time(_, no_stamp) ->
    ok;
report_time(Key, {MS,S,Ms}) ->
    {MegaSecs,Secs,MicroSecs} = now(),
    p(Key,
      MicroSecs - Ms + 1000000 * (Secs - S + 1000000 * (MegaSecs - MS)),
      cntr(Key, t95)).

p(Key, Time, T95) when Time =< T95 ->
    decr(Key, bucket);
p(Key, _Time, _T95) ->
    case {cntr(Key, window),incr(Key, bucket, 20)} of
        {Window,Bucket} when Window > 10, Bucket > 80 ->
            decr(Key, window),
            decr(Key, available);
        _ ->
            ok
    end.

release(Key) ->
    release(Key, {Key,prio,queued,pid}).

release(Key, T) ->
    release(Key,
            cntr(Key, available),
            ets:prev(gcpFlowControlBitmap, T)).

release(Key, N, {Key,_Prio,_When,Pid} = T) when N > 0 ->
    case catch ets:update_counter(gcpFlowControlBitmap, T, 1) of
        1 ->
            Pid ! allow;
        _ ->
            release(Key, T)
    end;
release(_, _, _) ->
    ok.

user_data(ConnHandle) ->
    case catch megaco:conn_info(ConnHandle, reply_data) of
        {'EXIT',_Reason} ->
            false;
        Rec ->
            {value,Rec}
    end.

grant_request({value,Rec},
              Key,
              Prio,
              Time,
              ConnHandle,
              Options,
              ActionRequests,
              UserData) ->
    ReplyData =
        Rec#gcpReplyData{user_data = UserData,
                         prio = Prio,
                         timestamp = Time},
    cast_rc(megaco:cast(ConnHandle,
                        ActionRequests,
                        [{reply_data,ReplyData}|Options]),
            Key,
            ActionRequests);
grant_request(false, Key, _, _, _, _, _, _) ->
    incr(Key, available),
    {error,reply_data}.

cast_rc(ok = Ok, _, _) ->
    Ok;
cast_rc({error,Reason}, Key, ActionRequests) ->
    incr(Key, available),
    gcpLib:error_report(gcpFlowControl,
                        send_request,
                        [ActionRequests],
                        "send failed",
                        Reason),
    {error,{encode,Reason}}.

prio([ActionRequest|_]) ->
    #'ActionRequest'{contextId = ContextId,
                     contextRequest = ContextRequest} =
        ActionRequest,
    prio(ContextId, ContextRequest).

prio(4294967294, #'ContextRequest'{priority = Prio}) when integer(Prio) ->
    Prio;
prio(_, _) ->
    16.



