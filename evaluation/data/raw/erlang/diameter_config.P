-file("test/lib/diameter/src/base/diameter_config.erl", 1).

-module(diameter_config).

-compile({no_auto_import,[{monitor,2}]}).

-behaviour(gen_server).

-export([start_service/2,
         stop_service/1,
         add_transport/2,
         remove_transport/2,
         have_transport/2,
         lookup/1]).

-export([start_link/0]).

-export([init/1,
         terminate/2,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         code_change/3]).

-export([sync/1]).

-export([state/0,uptime/0]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/diameter-1.3/include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options = [{answer_errors,report}]}).

-file("test/lib/diameter/src/base/diameter_config.erl", 68).

-file("test/lib/diameter/src/base/diameter_internal.hrl", 1).

-record(diameter_peer,{host_id,
                       statusT,
                       is_dynamic,
                       expiration,
                       tls_enabled}).

-record(diameter_realm,{name,
                        app_id,
                        local_action,
                        server_id,
                        is_dynamic,
                        expiration}).

-file("test/lib/diameter/src/base/diameter_config.erl", 69).

-record(state,{id = now()}).

-type match(T) :: T | '_' | '$1' | '$2' | '$3' | '$4'.

-record(service,{name,
                 rec :: undefined | match(#diameter_service{}),
                 options :: undefined | match(list())}).

-record(transport,{service,
                   ref = make_ref() :: match(reference()),
                   type :: undefined | match(connect | listen),
                   options :: undefined | match(list())}).

-record(monitor,{mref = make_ref() :: reference(),service}).

-spec start_service(diameter:service_name(), [diameter:service_opt()]) ->
                       ok | {error, term()}.

start_service(SvcName, Opts) when is_list(Opts) ->
    start_rc(sync(SvcName, {start_service,SvcName,Opts})).

start_rc({ok = T,_Pid}) ->
    T;
start_rc({error,_} = No) ->
    No;
start_rc(timeout) ->
    {error,application_not_started}.

-spec stop_service(diameter:service_name()) -> ok.

stop_service(SvcName) ->
    sync(SvcName, {stop_service,SvcName}).

-spec add_transport(diameter:service_name(),
                    {connect | listen, [diameter:transport_opt()]}) ->
                       {ok, diameter:transport_ref()} | {error, term()}.

add_transport(SvcName, {T,Opts})
    when
        is_list(Opts),
        T == connect
        orelse
        T == listen ->
    sync(SvcName, {add,SvcName,T,Opts}).

-spec remove_transport(diameter:service_name(),
                       diameter:transport_pred()) ->
                          ok | {error, term()}.

remove_transport(SvcName, Pred) ->
    try
        sync(SvcName, {remove,SvcName,pred(Pred)})
    catch
        {{diameter_config},{Reason}} ->
            {error,Reason}
    end.

pred(Pred) when is_function(Pred, 3) ->
    Pred;
pred(Pred) when is_function(Pred, 2) ->
    fun(R, _, O) ->
           Pred(R, O)
    end;
pred(Pred) when is_function(Pred, 1) ->
    fun(_, _, O) ->
           Pred(O)
    end;
pred(Opts) when is_list(Opts) ->
    fun(_, _, O) ->
           [] == Opts -- O
    end;
pred(Ref) when is_reference(Ref) ->
    fun(R, _, _) ->
           R == Ref
    end;
pred({M,F,A}) when is_atom(M), is_atom(F), is_list(A) ->
    fun(R, T, O) ->
           apply(M, F, [R,T,O|A])
    end;
pred({Type,Pred}) ->
    P = pred(Pred),
    fun(R, T, O) ->
           T == Type
           andalso
           P(R, T, O)
    end;
pred(B) when is_boolean(B) ->
    fun(_, _, _) ->
           B
    end;
pred(_) ->
    throw({{diameter_config},{pred}}).

have_transport(SvcName, Ref) ->
    member([{#transport{service = '$1',ref = '$2',_ = '_'},
             [{'andalso',
               {'=:=','$1',{const,SvcName}},
               {'=:=','$2',{const,Ref}}}],
             [true]}]).

lookup(SvcName) ->
    select([{#service{name = '$1',rec = '$2',options = '$3'},
             [{'=:=','$1',{const,SvcName}}],
             [{{'$1','$2','$3'}}]},
            {#transport{service = '$1',
                        ref = '$2',
                        type = '$3',
                        options = '$4'},
             [{'=:=','$1',{const,SvcName}}],
             [{{'$2','$3','$4'}}]}]).

start_link() ->
    ServerName = {local,diameter_config},
    Module = diameter_config,
    Args = [],
    Options = [{spawn_opt,diameter_lib:spawn_opts(server, [])}],
    gen_server:start_link(ServerName, Module, Args, Options).

state() ->
    call(state).

uptime() ->
    call(uptime).

init([]) ->
    {ok,#state{}}.

handle_call(state, _, State) ->
    {reply,State,State};
handle_call(uptime, _, #state{id = Time} = State) ->
    {reply,diameter_lib:now_diff(Time),State};
handle_call(Req, From, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_config,
                                 element(2,
                                         element(2,
                                                 process_info(self(),
                                                              current_function))),
                                 [Req,From]}),
    Reply = {error,{bad_request,Req}},
    {reply,Reply,State}.

handle_cast(Msg, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_config,
                                 element(2,
                                         element(2,
                                                 process_info(self(),
                                                              current_function))),
                                 [Msg]}),
    {noreply,State}.

handle_info({'DOWN',MRef,process,_,Reason}, State) ->
    [#monitor{service = SvcName} = T] =
        select([{#monitor{mref = MRef,_ = '_'},[],['$_']}]),
    queue_restart(Reason, SvcName),
    delete_object(T),
    {noreply,State};
handle_info({monitor,SvcName,Pid}, State) ->
    monitor(Pid, SvcName),
    {noreply,State};
handle_info({restart,SvcName}, State) ->
    restart(SvcName),
    {noreply,State};
handle_info(restart, State) ->
    restart(),
    {noreply,State};
handle_info(Info, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_config,
                                 element(2,
                                         element(2,
                                                 process_info(self(),
                                                              current_function))),
                                 [Info]}),
    {noreply,State}.

terminate(_Reason, _State) ->
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok,State}.

insert(T) ->
    ets:insert(diameter_config, T).

have_service(SvcName) ->
    member([{#service{name = '$1',_ = '_'},
             [{'=:=','$1',{const,SvcName}}],
             [true]}]).

member(MatchSpec) ->
    '$end_of_table' =/= ets:select(diameter_config, MatchSpec, 1).

delete_object(T) ->
    ets:delete_object(diameter_config, T).

delete(Key) ->
    ets:delete(diameter_config, Key).

select(MatchSpec) ->
    ets:select(diameter_config, MatchSpec).

select_delete(MatchSpec) ->
    ets:select_delete(diameter_config, MatchSpec).

sync(SvcName, T) ->
    diameter_sync:call({diameter_config,SvcName},
                       {diameter_config,sync,[T]},
                       infinity,
                       infinity).

sync({restart,SvcName}) ->
    have_service(SvcName)
    andalso
    start(SvcName);
sync({start_service,SvcName,Opts}) ->
    try
        start(have_service(SvcName), SvcName, Opts)
    catch
        {{diameter_config},{Reason}} ->
            {error,Reason}
    end;
sync({stop_service,SvcName}) ->
    stop(SvcName);
sync({add,SvcName,Type,Opts}) ->
    try
        add(SvcName, Type, Opts)
    catch
        {{diameter_config},{Reason}} ->
            {error,Reason}
    end;
sync({remove,SvcName,Pred}) ->
    remove(select([{#transport{service = '$1',_ = '_'},
                    [{'=:=','$1',{const,SvcName}}],
                    ['$_']}]),
           SvcName,
           Pred).

start(true, _, _) ->
    {error,already_started};
start(false, SvcName, Opts) ->
    insert(make_config(SvcName, Opts)),
    start(SvcName).

start(SvcName) ->
    RC = diameter_service:start(SvcName),
    startmon(SvcName, RC),
    RC.

startmon(SvcName, {ok,Pid}) ->
    diameter_config ! {monitor,SvcName,Pid};
startmon(_, {error,_}) ->
    ok.

monitor(Pid, SvcName) ->
    MRef = monitor(process, Pid),
    insert(#monitor{mref = MRef,service = SvcName}).

queue_restart({shutdown,{monitor,_}}, SvcName) ->
    delete(SvcName);
queue_restart(shutdown, _) ->
    ok;
queue_restart(_, SvcName) ->
    erlang:send_after(2000, self(), {restart,SvcName}).

restart(SvcName) ->
    sync(SvcName, {restart,SvcName}).

restart() ->
    MatchSpec = [{#service{name = '$1',_ = '_'},[],['$1']}],
    lists:foreach(fun restart/1, select(MatchSpec)).

stop(SvcName) ->
    diameter_service:stop(SvcName),
    select_delete([{#service{name = '$1',_ = '_'},
                    [{'=:=','$1',{const,SvcName}}],
                    [true]}]),
    ok.

add(SvcName, Type, Opts) ->
    ok = transport_opts(Opts),
    Ref = make_ref(),
    T = {Ref,Type,Opts},
    case start_transport(SvcName, T) of
        ok ->
            insert(#transport{service = SvcName,
                              ref = Ref,
                              type = Type,
                              options = Opts}),
            {ok,Ref};
        {error,_} = No ->
            No
    end.

transport_opts(Opts) ->
    lists:foreach(fun(T) ->
                         opt(T)
                         orelse
                         throw({{diameter_config},{{invalid,T}}})
                  end,
                  Opts).

opt({transport_module,M}) ->
    is_atom(M);
opt({transport_config,_,Tmo}) ->
    is_integer(Tmo)
    andalso
    0 =< Tmo
    andalso
    0 == Tmo bsr 32
    orelse
    Tmo == infinity;
opt({applications,As}) ->
    is_list(As);
opt({capabilities,Os}) ->
    is_list(Os)
    andalso
    ok == encode_CER(Os);
opt({capx_timeout,Tmo}) ->
    is_integer(Tmo)
    andalso
    0 =< Tmo
    andalso
    0 == Tmo bsr 32;
opt({length_errors,T}) ->
    lists:member(T, [exit,handle,discard]);
opt({reconnect_timer,Tmo}) ->
    is_integer(Tmo)
    andalso
    0 =< Tmo
    andalso
    0 == Tmo bsr 32;
opt({watchdog_timer,{M,F,A}}) when is_atom(M), is_atom(F), is_list(A) ->
    true;
opt({watchdog_timer,Tmo}) ->
    is_integer(Tmo)
    andalso
    0 =< Tmo
    andalso
    0 == Tmo bsr 32;
opt({watchdog_config,L}) ->
    is_list(L)
    andalso
    lists:all(fun wdopt/1, L);
opt({spawn_opt,Opts}) ->
    is_list(Opts);
opt({K,_})
    when
        K == transport_config;
        K == capabilities_cb;
        K == disconnect_cb;
        K == private ->
    true;
opt(_) ->
    true.

wdopt({K,N}) ->
    (K == okay
     orelse
     K == suspect)
    andalso
    is_integer(N)
    andalso
    0 =< N;
wdopt(_) ->
    false.

start_transport(SvcName, T) ->
    case diameter_service:start_transport(SvcName, T) of
        {ok,_Pid} ->
            ok;
        {error,no_service} ->
            ok;
        {error,_} = No ->
            No
    end.

remove(L, SvcName, Pred) ->
    rm(SvcName,
       lists:filter(fun(#transport{ref = R,type = T,options = O}) ->
                           Pred(R, T, O)
                    end,
                    L)).

rm(_, []) ->
    ok;
rm(SvcName, L) ->
    Refs =
        lists:map(fun(#transport{ref = R}) ->
                         R
                  end,
                  L),
    case stop_transport(SvcName, Refs) of
        ok ->
            diameter_stats:flush(Refs),
            lists:foreach(fun delete_object/1, L);
        {error,_} = No ->
            No
    end.

stop_transport(SvcName, Refs) ->
    case diameter_service:stop_transport(SvcName, Refs) of
        ok ->
            ok;
        {error,no_service} ->
            ok;
        {error,_} = No ->
            No
    end.

make_config(SvcName, Opts) ->
    AppOpts =
        [ 
         T ||
             {application,_} = T <- Opts
        ],
    Apps = init_apps(AppOpts),
    [] == Apps
    andalso
    throw({{diameter_config},{no_apps}}),
    Fields =
        diameter_gen_base_rfc3588:'#info-'(diameter_base_CER) -- ['AVP'],
    CapOpts =
        [ 
         T ||
             {K,_} = T <- Opts,
             lists:member(K, Fields)
        ],
    Caps = make_caps(#diameter_caps{}, CapOpts),
    ok = encode_CER(CapOpts),
    SvcOpts =
        make_opts((Opts -- AppOpts) -- CapOpts,
                  [{false,share_peers},
                   {false,use_shared_peers},
                   {false,monitor},
                   {{0,32},sequence},
                   {nodes,restrict_connections},
                   {[],spawn_opt}]),
    #service{name = SvcName,
             rec =
                 #diameter_service{applications = Apps,
                                   capabilities = Caps},
             options = SvcOpts}.

make_opts(Opts, Defs) ->
    Known =
        [ 
         {K,get_opt(K, Opts, D)} ||
             {D,K} <- Defs
        ],
    Unknown = Opts -- Known,
    [] == Unknown
    orelse
    throw({{diameter_config},{{invalid,hd(Unknown)}}}),
    [ 
     {K,opt(K, V)} ||
         {K,V} <- Known
    ].

opt(spawn_opt, L) when is_list(L) ->
    L;
opt(K, false = B) when K /= sequence ->
    B;
opt(K, true = B) when K == share_peers; K == use_shared_peers ->
    B;
opt(restrict_connections, T) when T == node; T == nodes ->
    T;
opt(K, T)
    when
        K == share_peers
        orelse
        K == use_shared_peers
        orelse
        K == restrict_connections,
        [] == T
        orelse
        is_atom(hd(T)) ->
    T;
opt(monitor, P) when is_pid(P) ->
    P;
opt(K, F)
    when
        K == restrict_connections;
        K == share_peers;
        K == use_shared_peers ->
    try diameter_lib:eval(F) of
        Nodes when is_list(Nodes) ->
            F;
        V ->
            throw({{diameter_config},{{value,{K,V}}}})
    catch
        E:R ->
            throw({{diameter_config},
                   {{value,{K,E,R,erlang:get_stacktrace()}}}})
    end;
opt(sequence, {_,_} = T) ->
    sequence(T);
opt(sequence = K, F) ->
    try diameter_lib:eval(F) of
        T ->
            sequence(T)
    catch
        E:R ->
            throw({{diameter_config},
                   {{value,{K,E,R,erlang:get_stacktrace()}}}})
    end;
opt(K, _) ->
    throw({{diameter_config},{{value,K}}}).

sequence({H,N} = T) when 0 =< N, N =< 32, 0 =< H, 0 == H bsr (32 - N) ->
    T;
sequence(_) ->
    throw({{diameter_config},{{value,sequence}}}).

make_caps(Caps, Opts) ->
    case diameter_capx:make_caps(Caps, Opts) of
        {ok,T} ->
            T;
        {error,Reason} ->
            throw({{diameter_config},{Reason}})
    end.

encode_CER(Opts) ->
    {ok,CER} =
        diameter_capx:build_CER(make_caps(#diameter_caps{origin_host =
                                                             "TheHost",
                                                         origin_realm =
                                                             "TheRealm",
                                                         host_ip_address =
                                                             [{127,
                                                               0,
                                                               0,
                                                               1}],
                                                         vendor_id = 42,
                                                         product_name =
                                                             "TheProduc"
                                                             "t"},
                                          Opts),
                                diameter_gen_base_rfc3588),
    Hdr =
        #diameter_header{version = 1,
                         end_to_end_id = 0,
                         hop_by_hop_id = 0},
    try
        diameter_codec:encode(diameter_gen_base_rfc3588,
                              #diameter_packet{header = Hdr,msg = CER}),
        ok
    catch
        exit:Reason ->
            throw({{diameter_config},{Reason}})
    end.

init_apps(Opts) ->
    lists:foldl(fun app_acc/2, [], lists:reverse(Opts)).

app_acc({application,Opts} = T, Acc) ->
    is_list(Opts)
    orelse
    throw({{diameter_config},{T}}),
    [Dict,Mod] = get_opt([dictionary,module], Opts),
    Alias = get_opt(alias, Opts, Dict),
    ModS = get_opt(state, Opts, Alias),
    M = get_opt(call_mutates_state, Opts, false, [true]),
    A = get_opt(answer_errors, Opts, report, [callback,discard]),
    P = get_opt(request_errors, Opts, answer_3xxx, [answer,callback]),
    [#diameter_app{alias = Alias,
                   dictionary = Dict,
                   id = cb(Dict, id),
                   module = init_mod(Mod),
                   init_state = ModS,
                   mutable = M,
                   options = [{answer_errors,A},{request_errors,P}]}|
     Acc].

init_mod(#diameter_callback{} = R) ->
    init_mod([diameter_callback,R]);
init_mod([diameter_callback,#diameter_callback{}] = L) ->
    L;
init_mod([diameter_callback = M|L]) when is_list(L) ->
    [M,init_cb(L)];
init_mod(M) when is_atom(M) ->
    [M];
init_mod([M|_] = L) when is_atom(M) ->
    L;
init_mod(M) ->
    throw({{diameter_config},{{module,M}}}).

init_cb(List) ->
    Fields = record_info(fields, diameter_callback),
    Defaults =
        lists:zip(Fields, tl(tuple_to_list(#diameter_callback{}))),
    Values =
        [ 
         V ||
             F <- Fields,
             D <- [proplists:get_value(F, Defaults)],
             V <- [proplists:get_value(F, List, D)]
        ],
    #diameter_callback{} = list_to_tuple([diameter_callback|Values]).

get_opt(Key, List, Def, Other) ->
    init_opt(Key, get_opt(Key, List, Def), [Def|Other]).

init_opt(_, V, [V|_]) ->
    V;
init_opt(Name, V, [_|Vals]) ->
    init_opt(Name, V, Vals);
init_opt(Name, V, []) ->
    throw({{diameter_config},{{Name,V}}}).

get_opt(Keys, List) when is_list(Keys) ->
    [ 
     get_opt(K, List) ||
         K <- Keys
    ];
get_opt(Key, List) ->
    case
        [ 
         V ||
             {K,V} <- List,
             K == Key
        ]
    of
        [V] ->
            V;
        _ ->
            throw({{diameter_config},{{arity,Key}}})
    end.

get_opt(Key, List, Def) ->
    case
        [ 
         V ||
             {K,V} <- List,
             K == Key
        ]
    of
        [] ->
            Def;
        [V] ->
            V;
        _ ->
            throw({{diameter_config},{{arity,Key}}})
    end.

cb(M, F) ->
    try M:F() of
        V ->
            V
    catch
        E:Reason ->
            throw({{diameter_config},
                   {{callback,E,Reason,erlang:get_stacktrace()}}})
    end.

call(Request) ->
    gen_server:call(diameter_config, Request, infinity).



