-file("test/lib/et/src/et_collector.erl", 1).

-module(et_collector).

-behaviour(gen_server).

-export([start_link/1,
         stop/1,
         report/2,
         report_event/5,
         report_event/6,
         iterate/3,
         iterate/5,
         lookup/2,
         start_trace_client/3,
         start_trace_port/1,
         save_event_file/3,
         clear_table/1,
         get_global_pid/0,
         get_table_size/1,
         change_pattern/2,
         make_key/2,
         dict_insert/3,
         dict_delete/2,
         dict_lookup/2,
         dict_match/2,
         multicast/2]).

-export([monitor_trace_port/2]).

-export([init/1,
         terminate/2,
         code_change/3,
         handle_call/3,
         handle_cast/2,
         handle_info/2]).

-file("test/lib/et/src/et_internal.hrl", 1).

-record(filter,{name,function}).

-file("test/lib/et/src/et_collector.erl", 68).

-file("test/lib/et/src/../include/et.hrl", 1).

-record(event,{detail_level,trace_ts,event_ts,from,to,label,contents}).

-file("test/lib/et/src/et_collector.erl", 69).

-record(state,{parent_pid,
               auto_shutdown,
               event_tab_size,
               event_tab,
               dict_tab,
               event_order,
               subscribers,
               file,
               trace_pattern,
               trace_port,
               trace_max_queue,
               trace_nodes,
               trace_global}).

-record(file,{name,desc,event_opt,file_opt,table_opt}).

-record(table_handle,{collector_pid,event_tab,event_order,filter}).

-record(trace_ts,{trace_ts,event_ts}).

-record(event_ts,{event_ts,trace_ts}).

start_link(Options) ->
    case parse_opt(Options, default_state(), [], []) of
        {ok,S,Dict2,Clients} ->
            Res =
                case S#state.trace_global of
                    false ->
                        gen_server:start_link(et_collector,
                                              [S,Dict2],
                                              []);
                    true ->
                        gen_server:start_link({global,et_collector},
                                              et_collector,
                                              [S,Dict2],
                                              [])
                end,
            case Res of
                {ok,Pid} when S#state.parent_pid =/= self() ->
                    unlink(Pid),
                    start_clients(Pid, Clients);
                {ok,Pid} ->
                    start_clients(Pid, Clients);
                {error,Reason} ->
                    {error,Reason}
            end;
        {error,Reason} ->
            {error,Reason}
    end.

default_state() ->
    #state{parent_pid = self(),
           auto_shutdown = false,
           event_order = trace_ts,
           subscribers = [],
           trace_global = false,
           trace_pattern = undefined,
           trace_nodes = [],
           trace_port = 4711,
           trace_max_queue = 50}.

parse_opt([], S, Dict, Clients) ->
    {Mod,Pattern} = et_selector:make_pattern(S#state.trace_pattern),
    Fun =
        fun(E) ->
               et_selector:parse_event(Mod, E)
        end,
    Default = {dict_insert,{filter,all},Fun},
    {ok,S#state{trace_pattern = {Mod,Pattern}},[Default|Dict],Clients};
parse_opt([H|T], S, Dict, Clients) ->
    case H of
        {parent_pid,Parent} when Parent =:= undefined ->
            parse_opt(T, S#state{parent_pid = Parent}, Dict, Clients);
        {parent_pid,Parent} when is_pid(Parent) ->
            parse_opt(T, S#state{parent_pid = Parent}, Dict, Clients);
        {auto_shutdown,Bool} when Bool =:= true; Bool =:= false ->
            parse_opt(T, S#state{auto_shutdown = Bool}, Dict, Clients);
        {event_order,Order} when Order =:= trace_ts ->
            parse_opt(T, S#state{event_order = Order}, Dict, Clients);
        {event_order,Order} when Order =:= event_ts ->
            parse_opt(T, S#state{event_order = Order}, Dict, Clients);
        {dict_insert,{filter,Name},Fun} ->
            if
                is_atom(Name), is_function(Fun) ->
                    parse_opt(T, S, Dict ++ [H], Clients);
                true ->
                    {error,{bad_option,H}}
            end;
        {dict_insert,{subscriber,Pid},_Val} ->
            if
                is_pid(Pid) ->
                    parse_opt(T, S, Dict ++ [H], Clients);
                true ->
                    {error,{bad_option,H}}
            end;
        {dict_insert,_Key,_Val} ->
            parse_opt(T, S, Dict ++ [H], Clients);
        {dict_delete,_Key} ->
            parse_opt(T, S, Dict ++ [H], Clients);
        {trace_client,Client = {_,_}} ->
            parse_opt(T, S, Dict, Clients ++ [Client]);
        {trace_global,Bool} when Bool =:= false ->
            parse_opt(T, S#state{trace_global = Bool}, Dict, Clients);
        {trace_global,Bool} when Bool =:= true ->
            parse_opt(T, S#state{trace_global = Bool}, Dict, Clients);
        {trace_pattern,{Mod,_} = Pattern} when is_atom(Mod) ->
            parse_opt(T,
                      S#state{trace_pattern = Pattern},
                      Dict,
                      Clients);
        {trace_pattern,undefined = Pattern} ->
            parse_opt(T,
                      S#state{trace_pattern = Pattern},
                      Dict,
                      Clients);
        {trace_port,Port} when is_integer(Port) ->
            parse_opt(T, S#state{trace_port = Port}, Dict, Clients);
        {trace_max_queue,MaxQueue} when is_integer(MaxQueue) ->
            parse_opt(T, S#state{trace_port = MaxQueue}, Dict, Clients);
        Bad ->
            {error,{bad_option,Bad}}
    end;
parse_opt(BadList, _S, _Dict, _Clients) ->
    {error,{bad_option_list,BadList}}.

start_clients(CollectorPid, [{Type,Parameters}|T]) ->
    start_trace_client(CollectorPid, Type, Parameters),
    start_clients(CollectorPid, T);
start_clients(CollectorPid, []) ->
    {ok,CollectorPid}.

stop(CollectorPid) ->
    call(CollectorPid, stop).

save_event_file(CollectorPid, FileName, Options) ->
    call(CollectorPid, {save_event_file,FileName,Options}).

load_event_file(CollectorPid, FileName) ->
    Fd = make_ref(),
    Args = [{file,FileName},{name,Fd},{repair,true},{mode,read_only}],
    Fun =
        fun(Event, {ok,TH}) ->
               report(TH, Event)
        end,
    case disk_log:open(Args) of
        {ok,_} ->
            do_load_event_file(Fun,
                               Fd,
                               start,
                               {ok,CollectorPid},
                               FileName,
                               0);
        {repaired,_,_,BadBytes} ->
            do_load_event_file(Fun,
                               Fd,
                               start,
                               {ok,CollectorPid},
                               FileName,
                               BadBytes);
        {error,Reason} ->
            exit({disk_log_open,FileName,Reason})
    end.

do_load_event_file(Fun, Fd, Cont, Acc, FileName, BadBytes) ->
    case disk_log:chunk(Fd, Cont) of
        eof ->
            {ok,BadBytes};
        {error,Reason} ->
            exit({bad_disk_log_chunk,FileName,Reason});
        {Cont2,Events} ->
            Acc2 = lists:foldl(Fun, Acc, Events),
            do_load_event_file(Fun, Fd, Cont2, Acc2, FileName, BadBytes);
        {Cont2,Events,More} ->
            Acc2 = lists:foldl(Fun, Acc, Events),
            do_load_event_file(Fun,
                               Fd,
                               Cont2,
                               Acc2,
                               FileName,
                               BadBytes + More)
    end.

report(CollectorPid, TraceOrEvent) when is_pid(CollectorPid) ->
    case get_table_handle(CollectorPid) of
        {ok,TH} when is_record(TH, table_handle) ->
            report(TH, TraceOrEvent);
        {error,Reason} ->
            exit(Reason)
    end;
report(TH, TraceOrEvent) when is_record(TH, table_handle) ->
    Fun = TH#table_handle.filter,
    case Fun(TraceOrEvent) of
        false ->
            {ok,TH};
        true when is_record(TraceOrEvent, event) ->
            Key = make_key(TH, TraceOrEvent),
            case
                catch
                    ets:insert(TH#table_handle.event_tab,
                               {Key,TraceOrEvent})
            of
                true ->
                    {ok,TH};
                {'EXIT',_Reason} ->
                    report(TH#table_handle.collector_pid, TraceOrEvent)
            end;
        {true,Event} when is_record(Event, event) ->
            Key = make_key(TH, Event),
            case
                catch ets:insert(TH#table_handle.event_tab, {Key,Event})
            of
                true ->
                    {ok,TH};
                {'EXIT',_Reason} ->
                    report(TH#table_handle.collector_pid, TraceOrEvent)
            end;
        BadEvent ->
            TS = now(),
            Contents =
                [{trace,TraceOrEvent},{reason,BadEvent},{filter,Fun}],
            Event =
                #event{detail_level = 0,
                       trace_ts = TS,
                       event_ts = TS,
                       from = bad_filter,
                       to = bad_filter,
                       label = bad_filter,
                       contents = Contents},
            Key = make_key(TH, Event),
            case
                catch ets:insert(TH#table_handle.event_tab, {Key,Event})
            of
                true ->
                    {ok,TH};
                {'EXIT',_Reason} ->
                    report(TH#table_handle.collector_pid, TraceOrEvent)
            end
    end;
report(TH, end_of_trace) when is_record(TH, table_handle) ->
    {ok,TH};
report(_, Bad) ->
    exit({bad_event,Bad}).

report_event(CollectorPid, DetailLevel, FromTo, Label, Contents) ->
    report_event(CollectorPid,
                 DetailLevel,
                 FromTo,
                 FromTo,
                 Label,
                 Contents).

report_event(CollectorPid, DetailLevel, From, To, Label, Contents)
    when is_integer(DetailLevel), DetailLevel >= 0, DetailLevel =< 100 ->
    TS = now(),
    E = #event{detail_level = DetailLevel,
               trace_ts = TS,
               event_ts = TS,
               from = From,
               to = To,
               label = Label,
               contents = Contents},
    report(CollectorPid, E).

make_key(TH, Stuff) when is_record(TH, table_handle) ->
    make_key(TH#table_handle.event_order, Stuff);
make_key(trace_ts, Stuff) ->
    if
        is_record(Stuff, event) ->
            #event{trace_ts = R,event_ts = P} = Stuff,
            #trace_ts{trace_ts = R,event_ts = P};
        is_record(Stuff, trace_ts) ->
            Stuff;
        is_record(Stuff, event_ts) ->
            #event_ts{trace_ts = R,event_ts = P} = Stuff,
            #trace_ts{trace_ts = R,event_ts = P}
    end;
make_key(event_ts, Stuff) ->
    if
        is_record(Stuff, event) ->
            #event{trace_ts = R,event_ts = P} = Stuff,
            #event_ts{trace_ts = R,event_ts = P};
        is_record(Stuff, event_ts) ->
            Stuff;
        is_record(Stuff, trace_ts) ->
            #trace_ts{trace_ts = R,event_ts = P} = Stuff,
            #event_ts{trace_ts = R,event_ts = P}
    end.

get_table_size(CollectorPid) when is_pid(CollectorPid) ->
    call(CollectorPid, get_table_size).

get_table_handle(CollectorPid) when is_pid(CollectorPid) ->
    call(CollectorPid, get_table_handle).

get_global_pid() ->
    case global:whereis_name(et_collector) of
        CollectorPid when is_pid(CollectorPid) ->
            CollectorPid;
        undefined ->
            exit(global_collector_not_started)
    end.

change_pattern(CollectorPid, RawPattern) ->
    Pattern = et_selector:make_pattern(RawPattern),
    call(CollectorPid, {change_pattern,Pattern}).

dict_insert(CollectorPid, Key = {filter,Name}, Fun) ->
    if
        is_atom(Name), is_function(Fun) ->
            call(CollectorPid, {dict_insert,Key,Fun});
        true ->
            exit({badarg,Key})
    end;
dict_insert(CollectorPid, Key = {subscriber,Pid}, Val) ->
    if
        is_pid(Pid) ->
            call(CollectorPid, {dict_insert,Key,Val});
        true ->
            exit({badarg,Key})
    end;
dict_insert(CollectorPid, Key, Val) ->
    call(CollectorPid, {dict_insert,Key,Val}).

dict_lookup(CollectorPid, Key) ->
    call(CollectorPid, {dict_lookup,Key}).

dict_delete(CollectorPid, Key) ->
    call(CollectorPid, {dict_delete,Key}).

dict_match(CollectorPid, Pattern) ->
    call(CollectorPid, {dict_match,Pattern}).

multicast(_CollectorPid, Msg = {dict_insert,_Key,_Val}) ->
    exit({badarg,Msg});
multicast(_CollectorPid, Msg = {dict_delete,_Key}) ->
    exit({badarg,Msg});
multicast(CollectorPid, Msg) ->
    call(CollectorPid, {multicast,Msg}).

start_trace_client(CollectorPid, Type, FileName)
    when Type =:= event_file ->
    load_event_file(CollectorPid, FileName);
start_trace_client(CollectorPid, Type, FileName) when Type =:= file ->
    WaitFor = {make_ref(),end_of_trace},
    EventFun =
        fun(E, {ReplyTo,{ok,TH}}) ->
               {ReplyTo,report(TH, E)}
        end,
    EndFun =
        fun({ReplyTo,{ok,_TH}}) ->
               ReplyTo ! WaitFor,
               ReplyTo
        end,
    Spec =
        trace_spec_wrapper(EventFun, EndFun, {self(),{ok,CollectorPid}}),
    Pid = dbg:trace_client(Type, FileName, Spec),
    unlink(Pid),
    Ref = monitor(process, Pid),
    receive
        WaitFor ->
            demonitor(Ref, [flush]),
            file_loaded;
        {'DOWN',Ref,_,_,Reason} ->
            exit(Reason)
    end;
start_trace_client(CollectorPid, Type, Parameters) ->
    EventFun =
        fun(Event, {ok,TH}) ->
               report(TH, Event)
        end,
    EndFun =
        fun(Acc) ->
               Acc
        end,
    Spec = trace_spec_wrapper(EventFun, EndFun, {ok,CollectorPid}),
    Pid = dbg:trace_client(Type, Parameters, Spec),
    CollectorPid ! {register_trace_client,Pid},
    unlink(Pid),
    {trace_client_pid,Pid}.

trace_spec_wrapper(EventFun, EndFun, EventInitialAcc)
    when is_function(EventFun), is_function(EndFun) ->
    {fun(Trace, Acc) ->
            case Trace =:= end_of_trace of
                true ->
                    EndFun(Acc);
                false ->
                    EventFun(Trace, Acc)
            end
     end,
     EventInitialAcc}.

start_trace_port(Parameters) ->
    dbg:tracer(port, dbg:trace_port(ip, Parameters)).

monitor_trace_port(CollectorPid, Parameters) ->
    Res = start_trace_port(Parameters),
    spawn(fun() ->
                 MonitorRef = monitor(process, CollectorPid),
                 receive
                     {'DOWN',MonitorRef,_,_,_} ->
                         dbg:stop_clear()
                 end
          end),
    Res.

iterate(Handle, Prev, Limit) ->
    iterate(Handle, Prev, Limit, undefined, Prev).

iterate(_, _, Limit, _, Acc) when Limit =:= 0 ->
    Acc;
iterate(CollectorPid, Prev, Limit, Fun, Acc) when is_pid(CollectorPid) ->
    case get_table_handle(CollectorPid) of
        {ok,TH} when is_record(TH, table_handle) ->
            iterate(TH, Prev, Limit, Fun, Acc);
        {error,Reason} ->
            exit(Reason)
    end;
iterate(TH, Prev, Limit, Fun, Acc) when is_record(TH, table_handle) ->
    if
        Limit =:= infinity ->
            next_iterate(TH, Prev, Limit, Fun, Acc);
        is_integer(Limit), Limit > 0 ->
            next_iterate(TH, Prev, Limit, Fun, Acc);
        Limit =:= '-infinity' ->
            prev_iterate(TH, Prev, Limit, Fun, Acc);
        is_integer(Limit), Limit < 0 ->
            prev_iterate(TH, Prev, Limit, Fun, Acc)
    end.

next_iterate(TH, Prev = first, Limit, Fun, Acc) ->
    Tab = TH#table_handle.event_tab,
    case catch ets:first(Tab) of
        '$end_of_table' ->
            Acc;
        {'EXIT',_} = Error ->
            io:format("~p(~p): First ~p~n", [et_collector,754,Error]),
            iterate(TH#table_handle.collector_pid,
                    Prev,
                    Limit,
                    Fun,
                    Acc);
        First ->
            lookup_and_apply(TH, Prev, First, Limit, - 1, Fun, Acc)
    end;
next_iterate(TH, Prev = last, Limit, Fun, Acc) ->
    Tab = TH#table_handle.event_tab,
    case catch ets:last(Tab) of
        '$end_of_table' ->
            Acc;
        {'EXIT',_} = Error ->
            io:format("~p(~p): Last ~p~n", [et_collector,765,Error]),
            iterate(TH#table_handle.collector_pid,
                    Prev,
                    Limit,
                    Fun,
                    Acc);
        Last ->
            lookup_and_apply(TH, Prev, Last, Limit, - 1, Fun, Acc)
    end;
next_iterate(TH, Prev, Limit, Fun, Acc) ->
    Tab = TH#table_handle.event_tab,
    Key = make_key(TH, Prev),
    case catch ets:next(Tab, Key) of
        '$end_of_table' ->
            Acc;
        {'EXIT',_} = Error ->
            io:format("~p(~p): Next ~p -> ~p~n",
                      [et_collector,777,Key,Error]),
            iterate(TH#table_handle.collector_pid,
                    Prev,
                    Limit,
                    Fun,
                    Acc);
        Next ->
            lookup_and_apply(TH, Prev, Next, Limit, - 1, Fun, Acc)
    end.

prev_iterate(TH, Prev = first, Limit, Fun, Acc) ->
    Tab = TH#table_handle.event_tab,
    case catch ets:first(Tab) of
        '$end_of_table' ->
            Acc;
        {'EXIT',_} = Error ->
            io:format("~p(~p): First ~p~n", [et_collector,789,Error]),
            iterate(TH#table_handle.collector_pid,
                    Prev,
                    Limit,
                    Fun,
                    Acc);
        First ->
            lookup_and_apply(TH, Prev, First, Limit, 1, Fun, Acc)
    end;
prev_iterate(TH, Prev = last, Limit, Fun, Acc) ->
    Tab = TH#table_handle.event_tab,
    case catch ets:last(Tab) of
        '$end_of_table' ->
            Acc;
        {'EXIT',_} = Error ->
            io:format("~p(~p): Last ~p~n", [et_collector,800,Error]),
            iterate(TH#table_handle.collector_pid,
                    Prev,
                    Limit,
                    Fun,
                    Acc);
        Last ->
            lookup_and_apply(TH, Prev, Last, Limit, 1, Fun, Acc)
    end;
prev_iterate(TH, Prev, Limit, Fun, Acc) ->
    Tab = TH#table_handle.event_tab,
    Key = make_key(TH, Prev),
    case catch ets:prev(Tab, Key) of
        '$end_of_table' ->
            Acc;
        {'EXIT',_} = Error ->
            io:format("~p(~p): Prev ~p -> ~p~n",
                      [et_collector,812,Key,Error]),
            iterate(TH#table_handle.collector_pid,
                    Prev,
                    Limit,
                    Fun,
                    Acc);
        Next ->
            lookup_and_apply(TH, Prev, Next, Limit, 1, Fun, Acc)
    end.

lookup_and_apply(TH, _Prev, Next, Limit, Incr, Fun, _Acc)
    when Fun =:= undefined ->
    Limit2 = incr(Limit, Incr),
    iterate(TH, Next, Limit2, Fun, Next);
lookup_and_apply(TH, Prev, Next, Limit, Incr, Fun, Acc) ->
    Tab = TH#table_handle.event_tab,
    case catch ets:lookup_element(Tab, Next, 2) of
        {'EXIT',_} ->
            iterate(TH#table_handle.collector_pid,
                    Prev,
                    Limit,
                    Fun,
                    Acc);
        E when is_record(E, event) ->
            Acc2 = Fun(E, Acc),
            Limit2 = incr(Limit, Incr),
            iterate(TH, Next, Limit2, Fun, Acc2)
    end.

lookup(CollectorPid, Key) when is_pid(CollectorPid) ->
    case get_table_handle(CollectorPid) of
        {ok,TH} when is_record(TH, table_handle) ->
            lookup(TH, Key);
        {error,Reason} ->
            {error,Reason}
    end;
lookup(TH, Key) when is_record(TH, table_handle) ->
    Tab = TH#table_handle.event_tab,
    case catch ets:lookup_element(Tab, Key, 2) of
        {'EXIT',_} ->
            {error,enoent};
        E when is_record(E, event) ->
            {ok,E}
    end.

incr(Val, Incr) ->
    if
        Val =:= infinity ->
            Val;
        Val =:= '-infinity' ->
            Val;
        is_integer(Val) ->
            Val + Incr
    end.

clear_table(CollectorPid) when is_pid(CollectorPid) ->
    call(CollectorPid, clear_table);
clear_table(TH) when is_record(TH, table_handle) ->
    clear_table(TH#table_handle.collector_pid).

call(CollectorPid, Request) ->
    try
        gen_server:call(CollectorPid, Request, infinity)
    catch
        exit:{noproc,_} ->
            {error,no_collector}
    end.

init([InitialS,Dict]) ->
    process_flag(trap_exit, true),
    case InitialS#state.parent_pid of
        undefined ->
            ignore;
        Pid when is_pid(Pid) ->
            link(Pid)
    end,
    Funs =
        [fun init_tables/1,
         fun init_global/1,
         fun(S) ->
                lists:foldl(fun do_dict_insert/2, S, Dict)
         end],
    {ok,
     lists:foldl(fun(F, S) ->
                        F(S)
                 end,
                 InitialS,
                 Funs)}.

init_tables(S) ->
    EventTab = ets:new(et_events, [ordered_set,{keypos,1},public]),
    DictTab = ets:new(et_dict, [ordered_set,{keypos,1},public]),
    S#state{event_tab = EventTab,dict_tab = DictTab,event_tab_size = 0}.

init_global(S) ->
    case S#state.trace_global of
        true ->
            EventFun =
                fun(Event, {ok,TH}) ->
                       report(TH, Event)
                end,
            EndFun =
                fun(Acc) ->
                       Acc
                end,
            Spec = trace_spec_wrapper(EventFun, EndFun, {ok,self()}),
            dbg:tracer(process, Spec),
            et_selector:change_pattern(S#state.trace_pattern),
            net_kernel:monitor_nodes(true),
            lists:foreach(fun(N) ->
                                 self() ! {nodeup,N}
                          end,
                          nodes()),
            S#state{trace_nodes = [node()]};
        false ->
            S
    end.

handle_call({multicast,Msg}, _From, S) ->
    do_multicast(S#state.subscribers, Msg),
    reply(ok, S);
handle_call(Msg = {dict_insert,_Key,_Val}, _From, S) ->
    S2 = do_dict_insert(Msg, S),
    reply(ok, S2);
handle_call(Msg = {dict_delete,_Key}, _From, S) ->
    try
        S2 = do_dict_delete(Msg, S),
        reply(ok, S2)
    catch
        {stop,R} ->
            opt_unlink(S#state.parent_pid),
            {stop,R,S}
    end;
handle_call({dict_lookup,Key}, _From, S) ->
    Reply = ets:lookup(S#state.dict_tab, Key),
    reply(Reply, S);
handle_call({dict_match,Pattern}, _From, S) ->
    case catch ets:match_object(S#state.dict_tab, Pattern) of
        {'EXIT',_Reason} ->
            reply([], S);
        Matching ->
            reply(Matching, S)
    end;
handle_call(get_table_handle, _From, S) ->
    [{_,TableFilter}] = ets:lookup(S#state.dict_tab, {filter,all}),
    TH =
        #table_handle{collector_pid = self(),
                      event_tab = S#state.event_tab,
                      event_order = S#state.event_order,
                      filter = TableFilter},
    reply({ok,TH}, S);
handle_call(get_table_size, _From, S) ->
    Size = ets:info(S#state.event_tab, size),
    reply({ok,Size}, S);
handle_call(close, _From, S) ->
    case S#state.file of
        undefined ->
            reply({error,file_not_open}, S);
        F ->
            Reply = disk_log:close(F#file.desc),
            S2 = S#state{file = undefined},
            reply(Reply, S2)
    end;
handle_call({save_event_file,FileName,Options}, _From, S) ->
    Default =
        #file{name = FileName,
              event_opt = existing,
              file_opt = write,
              table_opt = keep},
    case parse_file_options(Default, Options) of
        {ok,F} when is_record(F, file) ->
            case file_open(F) of
                {ok,Fd} ->
                    F2 = F#file{desc = Fd},
                    {Reply2,S3} =
                        case F2#file.event_opt of
                            existing ->
                                Fun =
                                    fun({_,E}, A) ->
                                           ok = disk_log:log(Fd, E),
                                           A
                                    end,
                                Tab = S#state.event_tab,
                                Reply =
                                    tab_iterate(Fun,
                                                Tab,
                                                ets:first(Tab),
                                                ok),
                                disk_log:close(Fd),
                                {Reply,S}
                        end,
                    case F2#file.table_opt of
                        keep ->
                            reply(Reply2, S3);
                        clear ->
                            S4 = do_clear_table(S3),
                            reply(Reply2, S4)
                    end;
                {error,Reason} ->
                    reply({error,{file_open,Reason}}, S)
            end;
        {error,Reason} ->
            reply({error,Reason}, S)
    end;
handle_call({change_pattern,Pattern}, _From, S) ->
    Ns = S#state.trace_nodes,
    rpc:multicall(Ns, et_selector, change_pattern, [Pattern]),
    Reply = {old_pattern,S#state.trace_pattern},
    S2 = S#state{trace_pattern = Pattern},
    reply(Reply, S2);
handle_call(clear_table, _From, S) ->
    S2 = do_clear_table(S),
    reply(ok, S2);
handle_call(stop, _From, S) ->
    do_multicast(S#state.subscribers, close),
    case S#state.trace_global of
        true ->
            rpc:multicall(S#state.trace_nodes, dbg, stop_clear, []);
        false ->
            ignore
    end,
    {stop,shutdown,ok,S};
handle_call(Request, From, S) ->
    ok =
        error_logger:format("~p(~p): handle_call(~p, ~p, ~p)~n",
                            [et_collector,self(),Request,From,S]),
    reply({error,{bad_request,Request}}, S).

handle_cast(Msg, S) ->
    ok =
        error_logger:format("~p(~p): handle_cast(~p, ~p)~n",
                            [et_collector,self(),Msg,S]),
    noreply(S).

handle_info(timeout, S) ->
    S2 = check_size(S),
    noreply(S2);
handle_info({nodeup,Node}, S) ->
    Port = S#state.trace_port,
    MaxQueue = S#state.trace_max_queue,
    case
        rpc:call(Node,
                 et_collector,
                 monitor_trace_port,
                 [self(),{Port,MaxQueue}])
    of
        {ok,_} ->
            S2 = listen_on_trace_port(Node, Port, S),
            noreply(S2);
        {error,Reason} when Reason =:= already_started ->
            ok =
                error_logger:format("~p(~p): producer ignored(~p:~p):~n"
                                    "    ~p~n",
                                    [et_collector,
                                     self(),
                                     Node,
                                     Port,
                                     Reason]),
            S2 = S#state{trace_port = Port + 1},
            noreply(S2);
        {badrpc,Reason} ->
            ok =
                error_logger:format("~p(~p): producer ignored(~p:~p):~n"
                                    "    ~p~n",
                                    [et_collector,
                                     self(),
                                     Node,
                                     Port,
                                     Reason]),
            S2 = S#state{trace_port = Port + 1},
            noreply(S2);
        {error,Reason} ->
            self() ! {nodeup,Node},
            ok =
                error_logger:format("~p(~p): producer retry(~p:~p):~n  "
                                    "   ~p~n",
                                    [et_collector,
                                     self(),
                                     Node,
                                     Port,
                                     Reason]),
            S2 = S#state{trace_port = Port + 1},
            noreply(S2)
    end;
handle_info({nodedown,Node}, S) ->
    noreply(S#state{trace_nodes = S#state.trace_nodes -- [Node]});
handle_info({register_trace_client,Pid}, S) ->
    link(Pid),
    noreply(S);
handle_info({'EXIT',Pid,Reason}, S) when Pid =:= S#state.parent_pid ->
    {stop,Reason,S};
handle_info(Info = {'EXIT',Pid,Reason}, S) ->
    OldSubscribers = S#state.subscribers,
    case lists:member(Pid, OldSubscribers) of
        true when Reason =:= shutdown ->
            try
                S2 = do_dict_delete({dict_delete,{subscriber,Pid}}, S),
                noreply(S2)
            catch
                {stop,R} ->
                    opt_unlink(S#state.parent_pid),
                    {stop,R,S}
            end;
        true ->
            opt_unlink(S#state.parent_pid),
            {stop,Reason,S};
        false ->
            ok =
                error_logger:format("~p(~p): handle_info(~p, ~p)~n",
                                    [et_collector,self(),Info,S]),
            noreply(S)
    end;
handle_info(Info, S) ->
    ok =
        error_logger:format("~p(~p): handle_info(~p, ~p)~n",
                            [et_collector,self(),Info,S]),
    noreply(S).

listen_on_trace_port(Node, Port, S) ->
    [_Name,Host] = string:tokens(atom_to_list(Node), [$@]),
    case catch start_trace_client(self(), ip, {Host,Port}) of
        {trace_client_pid,RemotePid} ->
            rpc:call(Node,
                     et_selector,
                     change_pattern,
                     [S#state.trace_pattern]),
            link(RemotePid),
            S#state{trace_nodes = [Node|S#state.trace_nodes],
                    trace_port = Port + 1};
        {'EXIT',Reason} when Reason =:= already_started ->
            ok =
                error_logger:format("~p(~p): consumer ignored(~p:~p): ~"
                                    "p~n",
                                    [et_collector,
                                     self(),
                                     Node,
                                     Port,
                                     Reason]),
            S#state{trace_port = Port + 1};
        {'EXIT',Reason} ->
            self() ! {nodeup,Node},
            ok =
                error_logger:format("~p(~p): consumer retry(~p:~p):~n  "
                                    "   ~p~n",
                                    [et_collector,
                                     self(),
                                     Node,
                                     Port,
                                     Reason]),
            S#state{trace_port = Port + 1}
    end.

terminate(Reason, S) ->
    Fun =
        fun(Pid) ->
               exit(Pid, Reason)
        end,
    lists:foreach(Fun, S#state.subscribers).

code_change(_OldVsn, S, _Extra) ->
    {ok,S}.

do_clear_table(S) ->
    OldTab = S#state.event_tab,
    ets:delete(OldTab),
    NewTab = ets:new(et_events, [ordered_set,{keypos,1},public]),
    S#state{event_tab = NewTab}.

do_dict_insert(Msg = {dict_insert,Key = {subscriber,Pid},Val}, S)
    when is_pid(Pid) ->
    OldSubscribers = S#state.subscribers,
    NewSubscribers =
        case lists:member(Pid, OldSubscribers) of
            true ->
                OldSubscribers;
            false ->
                link(Pid),
                All = ets:match_object(S#state.dict_tab, '_'),
                lists:foreach(fun({K,V}) ->
                                     Pid ! {et,{dict_insert,K,V}}
                              end,
                              All),
                [Pid|OldSubscribers]
        end,
    do_multicast(NewSubscribers, Msg),
    Size = ets:info(S#state.event_tab, size),
    do_multicast(NewSubscribers, {more_events,Size}),
    ets:insert(S#state.dict_tab, {Key,Val}),
    S#state{subscribers = NewSubscribers};
do_dict_insert(Msg = {dict_insert,Key,Val}, S) ->
    do_multicast(S#state.subscribers, Msg),
    ets:insert(S#state.dict_tab, {Key,Val}),
    S.

do_dict_delete(Msg = {dict_delete,Key = {subscriber,Pid}}, S) ->
    OldSubscribers = S#state.subscribers,
    do_multicast(OldSubscribers, Msg),
    ets:delete(S#state.dict_tab, Key),
    case lists:member(Pid, OldSubscribers) of
        true ->
            unlink(Pid),
            S2 = S#state{subscribers = OldSubscribers -- [Pid]},
            if
                S2#state.auto_shutdown, S2#state.subscribers =:= [] ->
                    throw({stop,shutdown});
                true ->
                    S2
            end;
        false ->
            S
    end;
do_dict_delete({dict_delete,{filter,all}}, S) ->
    S;
do_dict_delete(Msg = {dict_delete,Key}, S) ->
    do_multicast(S#state.subscribers, Msg),
    ets:delete(S#state.dict_tab, Key),
    S.

tab_iterate(_Fun, _Tab, '$end_of_table', Acc) ->
    Acc;
tab_iterate(Fun, Tab, Key, Acc) ->
    Acc2 = lists:foldl(Fun, Acc, ets:lookup(Tab, Key)),
    tab_iterate(Fun, Tab, ets:next(Tab, Key), Acc2).

file_open(F) ->
    Fd = make_ref(),
    case F#file.file_opt of
        write ->
            file:rename(F#file.name, F#file.name ++ ".OLD");
        append ->
            ignore
    end,
    Args =
        [{file,F#file.name},{name,Fd},{repair,true},{mode,read_write}],
    case disk_log:open(Args) of
        {ok,_} ->
            {ok,Fd};
        {repaired,_,_,BadBytes} ->
            ok =
                error_logger:format("~p: Skipped ~p bad bytes in file: "
                                    "~p~n",
                                    [et_collector,BadBytes,F#file.name]),
            {ok,Fd};
        {error,Reason} ->
            {error,Reason}
    end.

parse_file_options(F, [H|T]) ->
    case H of
        existing ->
            parse_file_options(F#file{event_opt = existing}, T);
        all ->
            parse_file_options(F#file{event_opt = all}, T);
        write ->
            parse_file_options(F#file{file_opt = write}, T);
        append ->
            parse_file_options(F#file{file_opt = append}, T);
        keep ->
            parse_file_options(F#file{table_opt = keep}, T);
        clear ->
            parse_file_options(F#file{table_opt = clear}, T);
        Bad ->
            {error,{bad_file_option,Bad}}
    end;
parse_file_options(F, []) ->
    {ok,F}.

do_multicast([Pid|Pids], Msg) ->
    Pid ! {et,Msg},
    do_multicast(Pids, Msg);
do_multicast([], _Msg) ->
    ok.

opt_unlink(Pid) ->
    if
        Pid =:= undefined ->
            ignore;
        true ->
            unlink(Pid)
    end.

reply(Reply, #state{subscribers = []} = S) ->
    {reply,Reply,S};
reply(Reply, S) ->
    {reply,Reply,S,500}.

noreply(#state{subscribers = []} = S) ->
    {noreply,S};
noreply(S) ->
    {noreply,S,500}.

check_size(S) ->
    Size = ets:info(S#state.event_tab, size),
    if
        Size =:= S#state.event_tab_size ->
            S;
        true ->
            Msg = {more_events,Size},
            do_multicast(S#state.subscribers, Msg),
            S#state{event_tab_size = Size}
    end.



