-file("test/lib/stdlib/test/erl_expand_records_SUITE.erl", 1).

-module(erl_expand_records_SUITE).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/stdlib/test/erl_expand_records_SUITE.erl", 31).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2,
         init_per_testcase/2,
         end_per_testcase/2]).

-export([attributes/1,
         expr/1,
         guard/1,
         init/1,
         pattern/1,
         strict/1,
         update/1,
         otp_5915/1,
         otp_7931/1,
         otp_5990/1,
         otp_7078/1,
         otp_7101/1]).

init_per_testcase(_Case, Config) ->
    Dog = test_server:timetrap(test_server:minutes(1)),
    [{watchdog,Dog}|Config].

end_per_testcase(_Case, _Config) ->
    Dog = test_server:lookup_config(watchdog, _Config),
    test_server:timetrap_cancel(Dog),
    ok.

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [attributes,expr,guard,init,pattern,strict,update,{group,tickets}].

groups() ->
    [{tickets,[],[otp_5915,otp_7931,otp_5990,otp_7078,otp_7101]}].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

attributes(doc) ->
    "Import module and functions.";
attributes(suite) ->
    [];
attributes(Config) when is_list(Config) ->
    Ts =
        [<<"-import(lists, [append/2, reverse/1]).\n\n         -record("
           "r, {a,b}).\n\n         t() ->\n             [2,1] = reverse"
           "(append([1],[2])),\n             3 = length([1,2,3]),\n    "
           "         3 = record_info(size, r),\n             [a, b] = r"
           "ecord_info(fields, r),\n             [] = erl_expand_record"
           "s_SUITE:attributes(suite),\n             ok.\n      ">>],
    run(Config, Ts),
    ok.

expr(doc) ->
    "Some expressions.";
expr(suite) ->
    [];
expr(Config) when is_list(Config) ->
    Ts =
        [<<"\n         -record(r, {a,b,c}).\n\n         t() ->\n       "
           "      [1,2] = [R#r.a || R <- [#r{a = 1}, #r{a = 2}, #r{a = "
           "3}],\n                               R#r.a < 3],\n         "
           "    [1,2] = [R#r.a || R <- [#r{a = 1}, #r{a = 2}, #r{a = 3}"
           "],\n                               begin R#r.a < 3 end],\n "
           "            [1,2,3] = [R#r.a || R <- [#r{a = 1}, #r{a = 2},"
           " #r{a = 3}],\n                                 begin is_rec"
           "ord(R, r) end],\n             [1,2,3] = [R#r.a || R <- [#r{"
           "a = 1}, #r{a = 2}, #r{a = 3}],\n                           "
           "      begin erlang:is_record(R, r) end],\n             ok."
           "\n      ">>,
         <<"\n         -record(r, {a,b,c}).\n\n         f(X) -> X.\n\n "
           "        t() ->\n             A = {$c, 1, 3.14, a, \"hi\", ["
           "], [a,b]},\n             R = #r{a = element(6, A), b = #r.b"
           "},\n             3 = R#r.b,\n             <<1:8>> = <<(begi"
           "n erlang:element(2, A) end):8>>,\n             self() ! {a,"
           " message, []},\n             One = 1 = fun f/1(1),\n       "
           "      2 = fun(X) -> X end(One + One),\n             3 = fun"
           " exprec_test:f/1(3),\n             4 = exprec_test:f(4),\n "
           "            5 = f(5),\n             L = receive \n         "
           "            {a,message,L0} ->\n                         L0"
           "\n                 end,\n             case catch a:foo(bar)"
           " of\n                 {'EXIT', _} -> ok\n             end,"
           "\n             _ = receive \t\t\t%Suppress warning.\n      "
           "              noop ->\n                       1/(length(L) "
           "- 0)\n                 after 0 ->\n                    ok\n"
           "                 end,\n             if \n                 R"
           "#r.c =:= undefined ->\n                     ok;\n          "
           "       true ->\n                     not_ok\n             e"
           "nd.\n\n         is_record(_, _, _) ->\n             error(w"
           "rong_is_record).\n      ">>],
    run(Config, Ts, [no_strict_record_tests]),
    run(Config, Ts, [strict_record_tests]),
    ok.

guard(doc) ->
    "is_record in guards.";
guard(suite) ->
    [];
guard(Config) when is_list(Config) ->
    File = filename("guard.erl", Config),
    Beam = filename("guard.beam", Config),
    Test =
        <<"-module(guard).\n\n              -export([t/1]).\n\n        "
          "      -record(r, {a,b}).\n\n              t(_) when is_recor"
          "d(3, r) ->\n                  1;\n              t(_) when is"
          "_record(a, r) ->\n                  2;\n              t(_) w"
          "hen is_record(3.14, r) ->\n                  3;\n           "
          "   t(_) when is_record([], r) ->\n                  4;\n    "
          "          t(_) when is_record([a], r) ->\n                  "
          "5;\n              t(_) when is_record($a, r) ->\n           "
          "       6;\n              t(_) when is_record(\"foo\", r) ->"
          "\n                  7;\n              t(_) when is_record(#r"
          ".a, r) ->\n                  8;\n              t(_) when is_"
          "record(<<\"foo\">>, r) -> % line 23\n                  9;\n "
          "             t(_) when is_record(1 + 2, r) ->\n             "
          "     10;\n              t(_) when is_record(+ 3, r) ->\n    "
          "              11;\n              t(_) ->\n                  "
          "12.\n             ">>,
    ok = file:write_file(File, Test),
    {ok,guard,Ws} =
        compile:file(File,
                     [return,
                      {outdir,
                       test_server:lookup_config(priv_dir, Config)}]),
    Warnings =
        [ 
         L ||
             {_File,WL} <- Ws,
             {L,_M,nomatch_guard} <- WL
        ],
    [7,9,11,13,15,17,19,21,23,25,27] = Warnings,
    ok = file:delete(File),
    ok = file:delete(Beam),
    ok.

init(doc) ->
    "Wildcard initialisation.";
init(suite) ->
    [];
init(Config) when is_list(Config) ->
    Ts =
        [<<"\n         -record(r, {a,b,c,d = foo}).\n\n         t() ->"
           "\n             R = #r{_ = init, b = b},\n             #r{c "
           "= init, b = b, a = init} = R,\n             case R of\n    "
           "             #r{b = b, _ = init} -> ok;\n                 _"
           " -> not_ok\n             end.\n      ">>],
    run(Config, Ts),
    ok.

pattern(doc) ->
    "Some patterns.";
pattern(suite) ->
    [];
pattern(Config) when is_list(Config) ->
    Ts =
        [<<"-import(lists, [append/2, reverse/1]).\n\n         -record("
           "r, {a,b}).\n\n         t() ->\n             1 = t(#r{}),\n "
           "            2 = t($a),\n             3 = t(1000),\n        "
           "     4 = t({1000}),\n             5 = t(3),\n             6"
           " = t(-3.14),\n             7 = t({4.0}),\n             8 = "
           "t(3.14),\n             9 = t(\"str\"),\n             10 = t"
           "([]),\n             11 = t([a|b]),\n             12 = t(\"s"
           "tring\"),\n             13 = t({[]}),\n             14 = t("
           "{a,b}),\n             15 = t({{}}),\n             16 = t({t"
           "uple,tupel}),\n             17 = t(4),\n             18 = t"
           "(10),\n             19 = t({a}),\n             20 = t(<<100"
           ":8,220:8>>),\n             21 = t(#r{a = #r{}}),\n         "
           "    22 = t(2),\n             23 = t(#r{a = #r{}, b = b}),\n"
           "             24 = t(abc),\n             ok.\n\n         t(a"
           "bc) ->\n             24;\n         t($a) ->\n             2"
           ";\n         t(3) ->\n             5;\n         t(3.14) ->\n"
           "             8;\n         t(\"str\") ->\n             9;\n "
           "        t([]) ->\n             10;\n         t([a|b]) ->\n "
           "            11;\n         t(L) when is_list(L) ->\n        "
           "     12;\n         t({L}) when list(L) ->\n             13;"
           "\n         t({a,b}) ->\n             14;\n         t({T}) w"
           "hen is_tuple(T) ->\n             15;\n         t(+ 4) ->\n "
           "            17;\n         t(3+7) ->\n             18;\n    "
           "     t(<<A:8, (100+120):8>>) when A =:= 100 ->\n           "
           "  20;\n         t(#r{a = #r{}, b = undefined}) ->\n        "
           "     21;\n         t(#r.a) ->\n             22;\n         t"
           "(A) when is_record(A, r), record(element(2, A), r) ->\n    "
           "         23;\n         t(A) when is_record(A, r) ->\n      "
           "       1;\n         t(I) when is_integer(I) ->\n           "
           "  3;\n         t({I}) when integer(I) ->\n             4;\n"
           "         t({F}) when float(F) ->\n             7;\n        "
           " t({A} = B) when A < B ->\n             19;\n         t(F) "
           "when is_float(F) ->\n             6;\n         t(T) when tu"
           "ple(T) ->\n             16.\n      ">>],
    run(Config, Ts),
    ok.

strict(doc) ->
    "";
strict(suite) ->
    [];
strict(Config) when is_list(Config) ->
    Ts1 =
        [<<"-record(r1, {a,b}).\n         -record(r2, {a,b}).\n\n      "
           "   t() ->\n             A = #r1{a = 1, b = 2},\n           "
           "  ok = try \n                      {1, 2} = {A#r2.a, A#r2.b"
           "},\n                      not_ok\n                  catch e"
           "rror:{badrecord,r2} -> ok\n                  end,\n        "
           "     try\n                 case foo of\n                   "
           "  _ when A#r2.a =:= 1 -> not_ok\n                 end\n    "
           "         catch error:_ -> ok\n             end.\n         e"
           "lement(_, _) ->\n             error(wrong_element).\n      ">>],
    run(Config, Ts1, [strict_record_tests]),
    Ts2 =
        [<<"-record(r1, {a,b}).\n         -record(r2, {a,b}).\n\n      "
           "   t() ->\n             A = #r1{a = 1, b = 2},\n           "
           "  {1, 2} = {A#r2.a, A#r2.b},\n             case foo of\n   "
           "              _ when A#r2.a =:= 1 -> ok\n             end."
           "\n         element(_, _) ->\n             error(wrong_eleme"
           "nt).\n      ">>],
    run(Config, Ts2, [no_strict_record_tests]),
    ok.

update(doc) ->
    "Record updates.";
update(suite) ->
    [];
update(Config) when is_list(Config) ->
    Ts =
        [<<"-record(r, {a,b,c,d,e,f}).\n\n         t() ->\n            "
           " R0 = #r{},\n             R1 = R0#r{a = #r.a, e = {x,y}},\n"
           "             2 = R1#r.a,\n             R2 = R1#r{},\n      "
           "       true = R1 =:= R2,\n             R3 = R2#r{c = fun(X)"
           " -> X end, \n                       d = <<\"foo\">>, \n    "
           "                   e = [x,y,z], \n                       f "
           "= {R0,R1}},\n             R4 = R3#r{a = R3#r{b = #r{}}},\n "
           "            true = erlang:is_record((R4#r.a)#r.b, r),\n    "
           "         #r{a = R0, b = 3, c = 3.14, d = [], e = [[]], f = "
           "[{}]} = \n                 R4#r{a = R0, b = 3, c = 3.14, d "
           "= [], e = [[]], f = [{}]},\n             ok.\n\n         %%"
           " Just playing around a bit...\n         t1() ->\n          "
           "   ((#r{a = (#r{b = #r{}})#r{a = #r{}}})#r{b = #r{}})#r{c ="
           " #r{}}.\n\n         t2() ->\n             R0 = #r{},\n     "
           "        #r{_ = R0#r{a = ok}}.\n\n         %% Implicit calls"
           " to setelement/3 must go to the BIF,\n         %% not to th"
           "is function.\n         setelement(_, _, _) ->\n            "
           " erlang:error(wrong_setelement_called).\n      ">>],
    run(Config, Ts),
    ok.

otp_5915(doc) ->
    "Strict record tests in guards.";
otp_5915(suite) ->
    [];
otp_5915(Config) when is_list(Config) ->
    Ts =
        [<<"-record(r, {a = 4,b}).\n         -record(r1, {a,b}).\n     "
           "    -record(r2, {a = #r1{},b,c=length([1,2,3])}).\n        "
           " -record(r3, {a = fun(_) -> #r1{} end(1), b}).\n\n         "
           "t() ->\n             foo = fun(A) when A#r1.a > A#r1.b -> f"
           "oo end(#r1{b = 2}),\n             0 = fun(A) when A#r2.a ->"
           " 0 end(#r2{a = true}),\n             1 = fun(A) when (#r1{a"
           " = A})#r1.a > 2 -> 1 end(3),\n             2 = fun(N) when "
           "((#r2{a = #r{a = 4}, b = length([a,b,c])})#r2.a)#r.a > N ->"
           "\n                         2 end(2),\n             3 = fun("
           "A) when (A#r2.a)#r1.a =:= 3 -> 3 end(#r2{a = #r1{a = 3}}),"
           "\n             ok = fun() ->\n                          F ="
           " fun(A) when record(A#r.a, r1) -> 4;\n                     "
           "            (A) when record(A#r1.a, r1) -> 5\n             "
           "                 end,\n                          5 = F(#r1{"
           "a = #r1{}}),\n                          4 = F(#r{a = #r1{}}"
           "),\n                          ok\n                  end(),"
           "\n             3 = fun(A) when record(A#r1.a, r),\n        "
           "                           (A#r1.a)#r.a > 3 -> 3\n         "
           "        end(#r1{a = #r{a = 4}}),\n             7 = fun(A) w"
           "hen record(A#r3.a, r1) -> 7 end(#r3{}),\n             [#r1{"
           "a = 2,b = 1}] = \n                 fun() ->\n              "
           "           [A || A <- [#r1{a = 1, b = 3}, \n               "
           "                      #r2{a = 2,b = 1}, \n                 "
           "                    #r1{a = 2, b = 1}],\n                  "
           "             A#r1.a > \n                                   "
           "A#r1.b]\n                 end(),\n             {[_],b} = \n"
           "                 fun(L) ->\n                         %% A i"
           "s checked only once:\n                         R1 = [{A,B} "
           "|| A <- L, A#r1.a, B <- L, A#r1.b],\n                      "
           "   A = #r2{a = true},\n                         %% A is che"
           "cked again:\n                         B = if A#r1.a -> a; t"
           "rue -> b end,\n                         {R1,B}\n           "
           "      end([#r1{a = true, b = true}]),\n\n             p = f"
           "un(A) when (A#r1.a =:= 2) or (A#r2.a =:= 1) -> o;\n        "
           "            (_) -> p\n                 end(#r1{a = 2}),\n\n"
           "             o = fun(A) when (A#r1.a =:= 2) orelse (A#r2.a "
           "=:= 1) -> o;\n                    (_) -> p\n               "
           "  end(#r1{a = 2}),\n\n             3 = fun(A) when A#r1.a >"
           " 3, \n                             record(A, r1) -> 3\n    "
           "             end(#r1{a = 5}),\n\n             ok = fun() ->"
           "\n                          F = fun(A) when (A#r2.a =:= 1) "
           "orelse (A#r2.a) -> 2;\n                                 (A)"
           " when (A#r1.a =:= 1) orelse (A#r1.a) -> 1;\n               "
           "                  (A) when (A#r2.a =:= 2) andalso (A#r2.b) "
           "-> 3\n                              end,\n                 "
           "         1 = F(#r1{a = 1}),\n                          2 = "
           "F(#r2{a = true}),\n                          3 = F(#r2{a = "
           "2, b = true}),\n                          ok\n             "
           "     end(),\n\n             b = fun(A) when false or not (A"
           "#r.a =:= 1) -> a;\n                    (_) -> b\n          "
           "       end(#r1{a = 1}),\n             b = fun(A) when not ("
           "A#r.a =:= 1) or false -> a;\n                    (_) -> b\n"
           "                 end(#r1{a = 1}),\n\n             ok = fun("
           ") ->\n                          F = fun(A) when not (A#r.a "
           "=:= 1) -> yes;\n                                 (_) -> no"
           "\n                              end,\n                     "
           "     no = F(#r1{a = 2}),\n                          yes = F"
           "(#r{a = 2}),\n                          no = F(#r{a = 1}),"
           "\n                          ok\n                  end(),\n"
           "\n             a = fun(A) when record(A, r),\n             "
           "                A#r.a =:= 1,\n                             "
           "A#r.b =:= 2 ->a\n                 end(#r{a = 1, b = 2}),\n "
           "            a = fun(A) when erlang:is_record(A, r),\n      "
           "                       A#r.a =:= 1,\n                      "
           "       A#r.b =:= 2 -> a\n                 end(#r{a = 1, b ="
           " 2}),\n             a = fun(A) when is_record(A, r),\n     "
           "                        A#r.a =:= 1,\n                     "
           "        A#r.b =:= 2 -> a\n                 end(#r{a = 1, b "
           "= 2}),\n\n             nop = fun(A) when (is_record(A, r1) "
           "and (A#r1.a > 3)) or (A#r2.a < 1) ->\n                     "
           "      japp;\n                      (_) ->\n                "
           "           nop\n                   end(#r2{a = 0}),\n      "
           "       nop = fun(A) when (A#r1.a > 3) or (A#r2.a < 1) -> ja"
           "pp;\n                      (_) ->\n                        "
           "   nop\n                   end(#r2{a = 0}),\n\n            "
           " ok = fun() ->\n                          F = fun(A) when ("
           "A#r1.a =:= 2) or (A#r2.a =:= 1) -> o;\n                    "
           "             (_) -> p\n                              end,\n"
           "                          p = F(#r2{a = 1}),\n             "
           "             p = F(#r1{a = 2}),\n                          "
           "ok\n                  end(),\n\n             ok = fun() ->"
           "\n                          F = fun(A) when fail, A#r1.a; A"
           "#r1.a -> ab;\n                                 (_) -> bu\n "
           "                             end,\n                        "
           "  ab = F(#r1{a = true}),\n                          bu = F("
           "#r2{a = true}),\n                          ok\n            "
           "      end(),\n\n             both = fun(A) when A#r.a, A#r."
           "b -> both \n                    end(#r{a = true, b = true})"
           ",\n\n             ok = fun() ->\n                          "
           "F = fun(A, B) when ((A#r1.a) orelse (B#r2.a)) \n           "
           "                                  or (B#r2.b) or (A#r1.b) -"
           "> true;\n                                 (_, _) -> false\n"
           "                              end,\n                       "
           "   true = F(#r1{a = false, b = false}, #r2{a = false, b = t"
           "rue}),\n                          false = F(#r1{a = true, b"
           " = true}, #r1{a = false, b = true}),\n                     "
           "     ok\n                  end(),\n\n             ok.\n    "
           "  ">>],
    run(Config, Ts, [strict_record_tests]),
    ok.

otp_7931(doc) ->
    "Test optimization of record accesses and is_record/3 tests in guar"
    "ds";
otp_7931(suite) ->
    [];
otp_7931(Config) when is_list(Config) ->
    Ts =
        [<<"-record(r, {a = 4,b}).\n         -record(r1, {a,b}).\n     "
           "    -record(r2, {a = #r1{},b,c=length([1,2,3])}).\n        "
           " -record(r3, {a = fun(_) -> #r1{} end(1), b}).\n\n         "
           "t() ->\n             ok = fun() ->\n                    F ="
           " fun(F, [H,H|T]) when is_record(H, r) ->\n                 "
           "               [H|F(F, T)];\n                             ("
           "F, [H|T]) when is_record(H, r) ->\n                        "
           "        [H|F(F, T)];\n                             (_, []) "
           "-> []\n                          end,\n                    "
           "[#r{a=4,b=7},#r{a=1,b=42}] =\n                       F(F, ["
           "#r{a=4,b=7},#r{a=4,b=7},#r{a=1,b=42}]),\n                  "
           "  {'EXIT',_} = (catch F(F, [#r1{}])),\n                    "
           "ok\n                  end(),\n\n             true = fun() -"
           ">\n                      R = #r{},\n                      i"
           "f is_record(R, r) -> true; true -> false end\n             "
           "        end(),\n\n             ok = fun() ->\n             "
           "         F = fun(true, B) when B#r1.a -> ok;\n             "
           "                (false, _) -> error\n                      "
           "end,\n                      ok = F(true, #r1{a=true}),\n   "
           "                   error = F(false, anything_goes),\n      "
           "                {'EXIT',_} = (catch F(true, #r1{})),\n     "
           "                 {'EXIT',_} = (catch F(true, #r{})),\n     "
           "                 ok\n                  end(),\n\n\t     ok "
           "= fun() ->\n\t\t      F = fun([{a,R}=T]) when R#r.a =:= 42 "
           "->\n                                   {ok,tuple_size(T)};"
           "\n\t\t\t     ([{a,R}=T]) when R#r1.a =:= 7 ->\n            "
           "                       {ok,tuple_size(T)};\n\t\t\t     (_) "
           "-> error\n\t\t          end,\n\t\t      {ok,2} = F([{a,#r{a"
           "=42}}]),\n\t\t      {ok,2} = F([{a,#r1{a=7}}]),\n\t\t      "
           "error = F([{a,#r1{}}]),\n\t\t      error = F({a,b,c}),\n\t"
           "\t      error = F([]),\n\t\t      ok\n\t     end(),\n\n\t  "
           "   ok = fun() ->\n\t\t      F = fun(X, Y, Z) when is_record"
           "(X, r1) andalso\n                                          "
           "  (is_record(Y, r2) orelse\n                               "
           "              is_record(Z, r3)) -> true;\n\t\t\t     (_, _,"
           " _) -> false\n\t\t          end,\n\t\t      true = F(#r1{},"
           " #r2{}, #r3{}),\n \t\t      true = F(#r1{}, #r2{}, blurf),"
           "\n \t\t      true = F(#r1{}, blurf, #r3{}),\n \t\t      fal"
           "se = F(#r1{}, blurf, blurf),\n\t\t      false = F(blurf, #r"
           "2{}, #r3{}),\n \t\t      false = F(blurf, #r2{}, blurf),\n "
           "\t\t      false = F(blurf, blurf, #r3{}),\n \t\t      false"
           " = F(blurf, blurf, blurf),\n\t\t      ok\n\t     end(),\n\n"
           "\t     ok = fun() ->\n\t\t      F = fun(R=#r{a=42}) when R#"
           "r.b =:= 7 ->\n                                   {ok,R};\n"
           "\t\t\t     (_) -> error\n\t\t          end,\n\t\t      {ok,"
           "#r{a=42,b=7}} = F(#r{a=42,b=7}),\n\t\t      error = F(#r{})"
           ",\n\t\t      error = F([a,b,c]),\n\t\t      ok\n\t     end("
           "),\n\n             ok.\n      ">>],
    run(Config, Ts, [strict_record_tests]),
    ok.

otp_5990(doc) ->
    "OTP-5990. {erlang,is_record}.";
otp_5990(suite) ->
    [];
otp_5990(Config) when is_list(Config) ->
    Ts =
        [<<"\n         -record(r, {a,b,c}).\n\n         t() ->\n       "
           "      [1,2,3] = [R#r.a || R <- [#r{a = 1}, #r{a = 2}, #r{a "
           "= 3}],\n                                 begin {erlang,is_r"
           "ecord}(R, r) end],\n             [1,2,3] = [R#r.a || R <- ["
           "#r{a = 1}, #r{a = 2}, #r{a = 3}],\n                        "
           "         begin {erlang,is_record}(R, r) end],\n            "
           " ok.\n      ">>,
         <<"\n         -record('OrdSet', {orddata = {},\n              "
           "              ordtype = {}}).\n\n         to_sets(S) when t"
           "uple(S#'OrdSet'.ordtype) ->\n             ok.\n\n         l"
           "c(S) ->\n             [X || X <- [S], tuple(X#'OrdSet'.ordt"
           "ype)].\n\n         t() ->\n             S = #'OrdSet'{},\n "
           "            ok = to_sets(S),\n             [S] = lc(S),\n  "
           "           ok.\n      ">>],
    run(Config, Ts, [strict_record_tests]),
    ok.

otp_7078(doc) ->
    "OTP-7078. Record update: missing test.";
otp_7078(suite) ->
    [];
otp_7078(Config) when is_list(Config) ->
    Ts =
        [<<"\n         -record(r, {f}).\n         -record(r2, {}).\n\n "
           "        t() ->\n             {'EXIT',_} = (catch (#r2{})#r{"
           "}),\n             {'EXIT',_} = (catch (#r2{})#r{f = 2}),\n "
           "            ok.\n      ">>,
         <<"\n         -record(r, {f}).\n\n         maker(F) -> \n     "
           "        put(a, get(a)+1),\n             #r{f = F}.\n\n     "
           "    t() ->\n             put(a, 0),\n             (maker(2)"
           ")#r{},\n             1 = get(a),\n             ok.\n      ">>],
    run(Config, Ts, [strict_record_tests]),
    ok.

-record(otp_7101,{a,b,c = [],d = [],e = []}).

otp_7101(doc) ->
    "OTP-7101. Record update: more than one call to setelement/3.";
otp_7101(suite) ->
    [];
otp_7101(Config) when is_list(Config) ->
    Rec = #otp_7101{},
    Self = self(),
    Tracer =
        spawn_link(fun() ->
                          otp_7101_tracer(Self, 0)
                   end),
    1 = erlang:trace_pattern({erlang,setelement,3}, true),
    erlang:trace(self(), true, [{tracer,Tracer},call]),
    #otp_7101{a = 2,b = 1,c = [],d = [],e = []} = otp_7101_update1(Rec),
    #otp_7101{a = 1,b = 2,c = [],d = [],e = []} = otp_7101_update2(Rec),
    #otp_7101{a = 2,b = 1,c = [],d = [],e = []} = otp_7101_update3(Rec),
    #otp_7101{a = 1,b = 2,c = [],d = [],e = []} = otp_7101_update4(Rec),
    Ref = erlang:trace_delivered(Self),
    receive
        {trace_delivered,Self,Ref} ->
            Tracer ! done
    end,
    1 = erlang:trace_pattern({erlang,setelement,3}, false),
    receive
        4 ->
            ok;
        Other ->
            test_server:fail({unexpected,Other})
    end.

otp_7101_tracer(Parent, N) ->
    receive
        {trace,Parent,call,{erlang,setelement,[_,_,_]}} ->
            otp_7101_tracer(Parent, N + 1);
        done ->
            Parent ! N
    end.

otp_7101_update1(R) ->
    R#otp_7101{b = 1,a = 2}.

otp_7101_update2(R) ->
    R#otp_7101{a = 1,b = 2}.

otp_7101_update3(R) ->
    R#otp_7101{b = 1,a = 2}.

otp_7101_update4(R) ->
    R#otp_7101{a = 1,b = 2}.

run(Config, Tests) ->
    run(Config, Tests, []).

run(Config, Tests, Opts) ->
    F = fun(P) ->
               {SourceFile,Mod} = compile_file_mod(Config),
               _ = compile_file(Config, P, Opts),
               AbsFile = filename:rootname(SourceFile, ".erl"),
               code:purge(Mod),
               code:load_abs(AbsFile, Mod),
               case catch Mod:t() of
                   {'EXIT',_Reason} = Error ->
                       test_server:format("failed, got ~p~n", [Error]),
                       fail();
                   ok ->
                       ok
               end
        end,
    lists:foreach(F, Tests).

compile_file(Config, Test0, Opts0) ->
    {File,_Mod} = compile_file_mod(Config),
    Filename = 'exprec_test.erl',
    Test =
        list_to_binary(["-module(exprec_test). -compile(export_all). ",
                        Test0]),
    File = filename(Filename, Config),
    Opts =
        [export_all,
         return,
         {outdir,test_server:lookup_config(priv_dir, Config)}|
         Opts0],
    ok = file:write_file(File, Test),
    {ok,_M,Ws} = compile:file(File, Opts),
    warnings(File, Ws).

compile_file_mod(Config) ->
    {filename('exprec_test.erl', Config),exprec_test}.

filename(Name, Config) when is_atom(Name) ->
    filename(atom_to_list(Name), Config);
filename(Name, Config) ->
    filename:join(test_server:lookup_config(priv_dir, Config), Name).

warnings(File, Ws) ->
    case
        lists:append([ 
                      W ||
                          {F,W} <- Ws,
                          F =:= File
                     ])
    of
        [] ->
            [];
        L ->
            {warnings,L}
    end.

fail() ->
    io:format("failed~n"),
    test_server:fail().



