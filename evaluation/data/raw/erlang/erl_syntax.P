-file("test/lib/syntax_tools/src/erl_syntax.erl", 1).

-module(erl_syntax).

-export([type/1,
         is_leaf/1,
         is_form/1,
         is_literal/1,
         abstract/1,
         concrete/1,
         revert/1,
         revert_forms/1,
         subtrees/1,
         make_tree/2,
         update_tree/2,
         meta/1,
         get_pos/1,
         set_pos/2,
         copy_pos/2,
         get_precomments/1,
         set_precomments/2,
         add_precomments/2,
         get_postcomments/1,
         set_postcomments/2,
         add_postcomments/2,
         has_comments/1,
         remove_comments/1,
         copy_comments/2,
         join_comments/2,
         get_ann/1,
         set_ann/2,
         add_ann/2,
         copy_ann/2,
         get_attrs/1,
         set_attrs/2,
         copy_attrs/2,
         flatten_form_list/1,
         cons/2,
         list_head/1,
         list_tail/1,
         is_list_skeleton/1,
         is_proper_list/1,
         list_elements/1,
         list_length/1,
         normalize_list/1,
         compact_list/1,
         application/2,
         application/3,
         application_arguments/1,
         application_operator/1,
         arity_qualifier/2,
         arity_qualifier_argument/1,
         arity_qualifier_body/1,
         atom/1,
         is_atom/2,
         atom_value/1,
         atom_literal/1,
         atom_name/1,
         attribute/1,
         attribute/2,
         attribute_arguments/1,
         attribute_name/1,
         binary/1,
         binary_comp/2,
         binary_comp_template/1,
         binary_comp_body/1,
         binary_field/1,
         binary_field/2,
         binary_field/3,
         binary_field_body/1,
         binary_field_types/1,
         binary_field_size/1,
         binary_fields/1,
         binary_generator/2,
         binary_generator_body/1,
         binary_generator_pattern/1,
         block_expr/1,
         block_expr_body/1,
         case_expr/2,
         case_expr_argument/1,
         case_expr_clauses/1,
         catch_expr/1,
         catch_expr_body/1,
         char/1,
         is_char/2,
         char_value/1,
         char_literal/1,
         char_literal/2,
         clause/2,
         clause/3,
         clause_body/1,
         clause_guard/1,
         clause_patterns/1,
         comment/1,
         comment/2,
         comment_padding/1,
         comment_text/1,
         cond_expr/1,
         cond_expr_clauses/1,
         conjunction/1,
         conjunction_body/1,
         disjunction/1,
         disjunction_body/1,
         eof_marker/0,
         error_marker/1,
         error_marker_info/1,
         float/1,
         float_value/1,
         float_literal/1,
         form_list/1,
         form_list_elements/1,
         fun_expr/1,
         fun_expr_arity/1,
         fun_expr_clauses/1,
         function/2,
         function_arity/1,
         function_clauses/1,
         function_name/1,
         generator/2,
         generator_body/1,
         generator_pattern/1,
         if_expr/1,
         if_expr_clauses/1,
         implicit_fun/1,
         implicit_fun/2,
         implicit_fun/3,
         implicit_fun_name/1,
         infix_expr/3,
         infix_expr_left/1,
         infix_expr_operator/1,
         infix_expr_right/1,
         integer/1,
         is_integer/2,
         integer_value/1,
         integer_literal/1,
         list/1,
         list/2,
         list_comp/2,
         list_comp_body/1,
         list_comp_template/1,
         list_prefix/1,
         list_suffix/1,
         macro/1,
         macro/2,
         macro_arguments/1,
         macro_name/1,
         match_expr/2,
         match_expr_body/1,
         match_expr_pattern/1,
         module_qualifier/2,
         module_qualifier_argument/1,
         module_qualifier_body/1,
         nil/0,
         operator/1,
         operator_literal/1,
         operator_name/1,
         parentheses/1,
         parentheses_body/1,
         prefix_expr/2,
         prefix_expr_argument/1,
         prefix_expr_operator/1,
         receive_expr/1,
         receive_expr/3,
         receive_expr_action/1,
         receive_expr_clauses/1,
         receive_expr_timeout/1,
         record_access/2,
         record_access/3,
         record_access_argument/1,
         record_access_field/1,
         record_access_type/1,
         record_expr/2,
         record_expr/3,
         record_expr_argument/1,
         record_expr_fields/1,
         record_expr_type/1,
         record_field/1,
         record_field/2,
         record_field_name/1,
         record_field_value/1,
         record_index_expr/2,
         record_index_expr_field/1,
         record_index_expr_type/1,
         rule/2,
         rule_arity/1,
         rule_clauses/1,
         rule_name/1,
         size_qualifier/2,
         size_qualifier_argument/1,
         size_qualifier_body/1,
         string/1,
         is_string/2,
         string_value/1,
         string_literal/1,
         string_literal/2,
         text/1,
         text_string/1,
         try_expr/2,
         try_expr/3,
         try_expr/4,
         try_after_expr/2,
         try_expr_body/1,
         try_expr_clauses/1,
         try_expr_handlers/1,
         try_expr_after/1,
         class_qualifier/2,
         class_qualifier_argument/1,
         class_qualifier_body/1,
         tuple/1,
         tuple_elements/1,
         tuple_size/1,
         underscore/0,
         variable/1,
         variable_name/1,
         variable_literal/1,
         warning_marker/1,
         warning_marker_info/1,
         tree/1,
         tree/2,
         data/1,
         is_tree/1]).

-export_type([{forms,0},
              {syntaxTree,0},
              {syntaxTreeAttributes,0},
              {padding,0}]).

-record(com,{pre = [] :: [syntaxTree()],post = [] :: [syntaxTree()]}).

-record(attr,{pos = 0 :: term(),
              ann = [] :: [term()],
              com = none :: none | #com{}}).

-type syntaxTreeAttributes() :: #attr{}.

-record(tree,{type :: undefined | atom(),
              attr = #attr{} :: #attr{},
              data :: undefined | term()}).

-record(wrapper,{type :: undefined | atom(),
                 attr = #attr{} :: #attr{},
                 tree :: undefined | erl_parse()}).

-type syntaxTree() :: #tree{} | #wrapper{} | erl_parse().

-type erl_parse() :: erl_parse:abstract_form()
                   | erl_parse:abstract_expr().

-spec type(syntaxTree()) -> atom().

type(#tree{type = T}) ->
    T;
type(#wrapper{type = T}) ->
    T;
type(Node) ->
    case Node of
        {atom,_,_} ->
            atom;
        {char,_,_} ->
            char;
        {float,_,_} ->
            float;
        {integer,_,_} ->
            integer;
        {nil,_} ->
            nil;
        {string,_,_} ->
            string;
        {var,_,Name} ->
            if
                Name =:= '_' ->
                    underscore;
                true ->
                    variable
            end;
        {error,_} ->
            error_marker;
        {warning,_} ->
            warning_marker;
        {eof,_} ->
            eof_marker;
        {'case',_,_,_} ->
            case_expr;
        {'catch',_,_} ->
            catch_expr;
        {'cond',_,_} ->
            cond_expr;
        {'fun',_,{clauses,_}} ->
            fun_expr;
        {'fun',_,{function,_,_}} ->
            implicit_fun;
        {'fun',_,{function,_,_,_}} ->
            implicit_fun;
        {'if',_,_} ->
            if_expr;
        {'receive',_,_,_,_} ->
            receive_expr;
        {'receive',_,_} ->
            receive_expr;
        {attribute,_,_,_} ->
            attribute;
        {bin,_,_} ->
            binary;
        {bin_element,_,_,_,_} ->
            binary_field;
        {block,_,_} ->
            block_expr;
        {call,_,_,_} ->
            application;
        {clause,_,_,_,_} ->
            clause;
        {cons,_,_,_} ->
            list;
        {function,_,_,_,_} ->
            function;
        {b_generate,_,_,_} ->
            binary_generator;
        {generate,_,_,_} ->
            generator;
        {lc,_,_,_} ->
            list_comp;
        {bc,_,_,_} ->
            binary_comp;
        {match,_,_,_} ->
            match_expr;
        {op,_,_,_,_} ->
            infix_expr;
        {op,_,_,_} ->
            prefix_expr;
        {record,_,_,_,_} ->
            record_expr;
        {record,_,_,_} ->
            record_expr;
        {record_field,_,_,_,_} ->
            record_access;
        {record_field,_,_,_} ->
            record_access;
        {record_index,_,_,_} ->
            record_index_expr;
        {remote,_,_,_} ->
            module_qualifier;
        {rule,_,_,_,_} ->
            rule;
        {'try',_,_,_,_,_} ->
            try_expr;
        {tuple,_,_} ->
            tuple;
        _ ->
            error({badarg,Node})
    end.

-spec is_leaf(syntaxTree()) -> boolean().

is_leaf(Node) ->
    case type(Node) of
        atom ->
            true;
        char ->
            true;
        comment ->
            true;
        eof_marker ->
            true;
        error_marker ->
            true;
        float ->
            true;
        integer ->
            true;
        nil ->
            true;
        operator ->
            true;
        string ->
            true;
        text ->
            true;
        tuple ->
            tuple_elements(Node) =:= [];
        underscore ->
            true;
        variable ->
            true;
        warning_marker ->
            true;
        _ ->
            false
    end.

-spec is_form(syntaxTree()) -> boolean().

is_form(Node) ->
    case type(Node) of
        attribute ->
            true;
        comment ->
            true;
        function ->
            true;
        eof_marker ->
            true;
        error_marker ->
            true;
        form_list ->
            true;
        rule ->
            true;
        warning_marker ->
            true;
        text ->
            true;
        _ ->
            false
    end.

-spec get_pos(syntaxTree()) -> term().

get_pos(#tree{attr = Attr}) ->
    Attr#attr.pos;
get_pos(#wrapper{attr = Attr}) ->
    Attr#attr.pos;
get_pos({error,{Pos,_,_}}) ->
    Pos;
get_pos({warning,{Pos,_,_}}) ->
    Pos;
get_pos(Node) ->
    element(2, Node).

-spec set_pos(syntaxTree(), term()) -> syntaxTree().

set_pos(Node, Pos) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = Attr#attr{pos = Pos}};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = Attr#attr{pos = Pos}};
        _ ->
            set_pos(wrap(Node), Pos)
    end.

-spec copy_pos(syntaxTree(), syntaxTree()) -> syntaxTree().

copy_pos(Source, Target) ->
    set_pos(Target, get_pos(Source)).

get_com(#tree{attr = Attr}) ->
    Attr#attr.com;
get_com(#wrapper{attr = Attr}) ->
    Attr#attr.com;
get_com(_) ->
    none.

set_com(Node, Com) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = Attr#attr{com = Com}};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = Attr#attr{com = Com}};
        _ ->
            set_com(wrap(Node), Com)
    end.

-spec get_precomments(syntaxTree()) -> [syntaxTree()].

get_precomments(#tree{attr = Attr}) ->
    get_precomments_1(Attr);
get_precomments(#wrapper{attr = Attr}) ->
    get_precomments_1(Attr);
get_precomments(_) ->
    [].

get_precomments_1(#attr{com = none}) ->
    [];
get_precomments_1(#attr{com = #com{pre = Cs}}) ->
    Cs.

-spec set_precomments(syntaxTree(), [syntaxTree()]) -> syntaxTree().

set_precomments(Node, Cs) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = set_precomments_1(Attr, Cs)};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = set_precomments_1(Attr, Cs)};
        _ ->
            set_precomments(wrap(Node), Cs)
    end.

set_precomments_1(#attr{com = none} = Attr, Cs) ->
    Attr#attr{com = #com{pre = Cs}};
set_precomments_1(#attr{com = Com} = Attr, Cs) ->
    Attr#attr{com = Com#com{pre = Cs}}.

-spec add_precomments([syntaxTree()], syntaxTree()) -> syntaxTree().

add_precomments(Cs, Node) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = add_precomments_1(Cs, Attr)};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = add_precomments_1(Cs, Attr)};
        _ ->
            add_precomments(Cs, wrap(Node))
    end.

add_precomments_1(Cs, #attr{com = none} = Attr) ->
    Attr#attr{com = #com{pre = Cs}};
add_precomments_1(Cs, #attr{com = Com} = Attr) ->
    Attr#attr{com = Com#com{pre = Com#com.pre ++ Cs}}.

-spec get_postcomments(syntaxTree()) -> [syntaxTree()].

get_postcomments(#tree{attr = Attr}) ->
    get_postcomments_1(Attr);
get_postcomments(#wrapper{attr = Attr}) ->
    get_postcomments_1(Attr);
get_postcomments(_) ->
    [].

get_postcomments_1(#attr{com = none}) ->
    [];
get_postcomments_1(#attr{com = #com{post = Cs}}) ->
    Cs.

-spec set_postcomments(syntaxTree(), [syntaxTree()]) -> syntaxTree().

set_postcomments(Node, Cs) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = set_postcomments_1(Attr, Cs)};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = set_postcomments_1(Attr, Cs)};
        _ ->
            set_postcomments(wrap(Node), Cs)
    end.

set_postcomments_1(#attr{com = none} = Attr, Cs) ->
    Attr#attr{com = #com{post = Cs}};
set_postcomments_1(#attr{com = Com} = Attr, Cs) ->
    Attr#attr{com = Com#com{post = Cs}}.

-spec add_postcomments([syntaxTree()], syntaxTree()) -> syntaxTree().

add_postcomments(Cs, Node) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = add_postcomments_1(Cs, Attr)};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = add_postcomments_1(Cs, Attr)};
        _ ->
            add_postcomments(Cs, wrap(Node))
    end.

add_postcomments_1(Cs, #attr{com = none} = Attr) ->
    Attr#attr{com = #com{post = Cs}};
add_postcomments_1(Cs, #attr{com = Com} = Attr) ->
    Attr#attr{com = Com#com{post = Com#com.post ++ Cs}}.

-spec has_comments(syntaxTree()) -> boolean().

has_comments(#tree{attr = Attr}) ->
    case Attr#attr.com of
        none ->
            false;
        #com{pre = [],post = []} ->
            false;
        _ ->
            true
    end;
has_comments(#wrapper{attr = Attr}) ->
    case Attr#attr.com of
        none ->
            false;
        #com{pre = [],post = []} ->
            false;
        _ ->
            true
    end;
has_comments(_) ->
    false.

-spec remove_comments(syntaxTree()) -> syntaxTree().

remove_comments(Node) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = Attr#attr{com = none}};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = Attr#attr{com = none}};
        _ ->
            Node
    end.

-spec copy_comments(syntaxTree(), syntaxTree()) -> syntaxTree().

copy_comments(Source, Target) ->
    set_com(Target, get_com(Source)).

-spec join_comments(syntaxTree(), syntaxTree()) -> syntaxTree().

join_comments(Source, Target) ->
    add_postcomments(get_postcomments(Source),
                     add_precomments(get_precomments(Source), Target)).

-spec get_ann(syntaxTree()) -> [term()].

get_ann(#tree{attr = Attr}) ->
    Attr#attr.ann;
get_ann(#wrapper{attr = Attr}) ->
    Attr#attr.ann;
get_ann(_) ->
    [].

-spec set_ann(syntaxTree(), [term()]) -> syntaxTree().

set_ann(Node, As) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = Attr#attr{ann = As}};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = Attr#attr{ann = As}};
        _ ->
            set_ann(wrap(Node), As)
    end.

-spec add_ann(term(), syntaxTree()) -> syntaxTree().

add_ann(A, Node) ->
    case Node of
        #tree{attr = Attr} ->
            Node#tree{attr = Attr#attr{ann = [A|Attr#attr.ann]}};
        #wrapper{attr = Attr} ->
            Node#wrapper{attr = Attr#attr{ann = [A|Attr#attr.ann]}};
        _ ->
            add_ann(A, wrap(Node))
    end.

-spec copy_ann(syntaxTree(), syntaxTree()) -> syntaxTree().

copy_ann(Source, Target) ->
    set_ann(Target, get_ann(Source)).

-spec get_attrs(syntaxTree()) -> syntaxTreeAttributes().

get_attrs(#tree{attr = Attr}) ->
    Attr;
get_attrs(#wrapper{attr = Attr}) ->
    Attr;
get_attrs(Node) ->
    #attr{pos = get_pos(Node),ann = get_ann(Node),com = get_com(Node)}.

-spec set_attrs(syntaxTree(), syntaxTreeAttributes()) -> syntaxTree().

set_attrs(Node, Attr) ->
    case Node of
        #tree{} ->
            Node#tree{attr = Attr};
        #wrapper{} ->
            Node#wrapper{attr = Attr};
        _ ->
            set_attrs(wrap(Node), Attr)
    end.

-spec copy_attrs(syntaxTree(), syntaxTree()) -> syntaxTree().

copy_attrs(S, T) ->
    set_attrs(T, get_attrs(S)).

-spec comment([string()]) -> syntaxTree().

comment(Strings) ->
    comment(none, Strings).

-type padding() :: none | integer().

-record(comment,{pad :: undefined | padding(),
                 text :: undefined | [string()]}).

-spec comment(padding(), [string()]) -> syntaxTree().

comment(Pad, Strings) ->
    tree(comment, #comment{pad = Pad,text = Strings}).

-spec comment_text(syntaxTree()) -> [string()].

comment_text(Node) ->
    (data(Node))#comment.text.

-spec comment_padding(syntaxTree()) -> padding().

comment_padding(Node) ->
    (data(Node))#comment.pad.

-spec form_list([syntaxTree()]) -> syntaxTree().

form_list(Forms) ->
    tree(form_list, Forms).

-spec form_list_elements(syntaxTree()) -> [syntaxTree()].

form_list_elements(Node) ->
    data(Node).

-spec flatten_form_list(syntaxTree()) -> syntaxTree().

flatten_form_list(Node) ->
    Fs = form_list_elements(Node),
    Fs1 = lists:reverse(flatten_form_list_1(Fs, [])),
    copy_attrs(Node, form_list(Fs1)).

flatten_form_list_1([F|Fs], As) ->
    case type(F) of
        form_list ->
            As1 = flatten_form_list_1(form_list_elements(F), As),
            flatten_form_list_1(Fs, As1);
        _ ->
            flatten_form_list_1(Fs, [F|As])
    end;
flatten_form_list_1([], As) ->
    As.

-spec text(string()) -> syntaxTree().

text(String) ->
    tree(text, String).

-spec text_string(syntaxTree()) -> string().

text_string(Node) ->
    data(Node).

-spec variable(atom() | string()) -> syntaxTree().

variable(Name) when is_atom(Name) ->
    tree(variable, Name);
variable(Name) ->
    tree(variable, list_to_atom(Name)).

revert_variable(Node) ->
    Pos = get_pos(Node),
    Name = variable_name(Node),
    {var,Pos,Name}.

-spec variable_name(syntaxTree()) -> atom().

variable_name(Node) ->
    case unwrap(Node) of
        {var,_,Name} ->
            Name;
        Node1 ->
            data(Node1)
    end.

-spec variable_literal(syntaxTree()) -> string().

variable_literal(Node) ->
    case unwrap(Node) of
        {var,_,Name} ->
            atom_to_list(Name);
        Node1 ->
            atom_to_list(data(Node1))
    end.

-spec underscore() -> syntaxTree().

underscore() ->
    tree(underscore, []).

revert_underscore(Node) ->
    Pos = get_pos(Node),
    {var,Pos,'_'}.

-spec integer(integer()) -> syntaxTree().

integer(Value) ->
    tree(integer, Value).

revert_integer(Node) ->
    Pos = get_pos(Node),
    {integer,Pos,integer_value(Node)}.

-spec is_integer(syntaxTree(), integer()) -> boolean().

is_integer(Node, Value) ->
    case unwrap(Node) of
        {integer,_,Value} ->
            true;
        #tree{type = integer,data = Value} ->
            true;
        _ ->
            false
    end.

-spec integer_value(syntaxTree()) -> integer().

integer_value(Node) ->
    case unwrap(Node) of
        {integer,_,Value} ->
            Value;
        Node1 ->
            data(Node1)
    end.

-spec integer_literal(syntaxTree()) -> string().

integer_literal(Node) ->
    integer_to_list(integer_value(Node)).

-spec float(float()) -> syntaxTree().

float(Value) ->
    make_float(Value).

make_float(Value) ->
    tree(float, Value).

revert_float(Node) ->
    Pos = get_pos(Node),
    {float,Pos,float_value(Node)}.

-spec float_value(syntaxTree()) -> float().

float_value(Node) ->
    case unwrap(Node) of
        {float,_,Value} ->
            Value;
        Node1 ->
            data(Node1)
    end.

-spec float_literal(syntaxTree()) -> string().

float_literal(Node) ->
    float_to_list(float_value(Node)).

-spec char(char()) -> syntaxTree().

char(Char) ->
    tree(char, Char).

revert_char(Node) ->
    Pos = get_pos(Node),
    {char,Pos,char_value(Node)}.

-spec is_char(syntaxTree(), char()) -> boolean().

is_char(Node, Value) ->
    case unwrap(Node) of
        {char,_,Value} ->
            true;
        #tree{type = char,data = Value} ->
            true;
        _ ->
            false
    end.

-spec char_value(syntaxTree()) -> char().

char_value(Node) ->
    case unwrap(Node) of
        {char,_,Char} ->
            Char;
        Node1 ->
            data(Node1)
    end.

-spec char_literal(syntaxTree()) -> nonempty_string().

char_literal(Node) ->
    char_literal(Node, latin1).

-type encoding() :: utf8 | unicode | latin1.

-spec char_literal(syntaxTree(), encoding()) -> nonempty_string().

char_literal(Node, unicode) ->
    io_lib:write_char(char_value(Node));
char_literal(Node, utf8) ->
    io_lib:write_char(char_value(Node));
char_literal(Node, latin1) ->
    io_lib:write_char_as_latin1(char_value(Node)).

-spec string(string()) -> syntaxTree().

string(String) ->
    tree(string, String).

revert_string(Node) ->
    Pos = get_pos(Node),
    {string,Pos,string_value(Node)}.

-spec is_string(syntaxTree(), string()) -> boolean().

is_string(Node, Value) ->
    case unwrap(Node) of
        {string,_,Value} ->
            true;
        #tree{type = string,data = Value} ->
            true;
        _ ->
            false
    end.

-spec string_value(syntaxTree()) -> string().

string_value(Node) ->
    case unwrap(Node) of
        {string,_,List} ->
            List;
        Node1 ->
            data(Node1)
    end.

-spec string_literal(syntaxTree()) -> nonempty_string().

string_literal(Node) ->
    string_literal(Node, latin1).

-spec string_literal(syntaxTree(), encoding()) -> nonempty_string().

string_literal(Node, utf8) ->
    io_lib:write_string(string_value(Node));
string_literal(Node, unicode) ->
    io_lib:write_string(string_value(Node));
string_literal(Node, latin1) ->
    io_lib:write_string_as_latin1(string_value(Node)).

-spec atom(atom() | string()) -> syntaxTree().

atom(Name) when is_atom(Name) ->
    tree(atom, Name);
atom(Name) ->
    tree(atom, list_to_atom(Name)).

revert_atom(Node) ->
    Pos = get_pos(Node),
    {atom,Pos,atom_value(Node)}.

-spec is_atom(syntaxTree(), atom()) -> boolean().

is_atom(Node, Value) ->
    case unwrap(Node) of
        {atom,_,Value} ->
            true;
        #tree{type = atom,data = Value} ->
            true;
        _ ->
            false
    end.

-spec atom_value(syntaxTree()) -> atom().

atom_value(Node) ->
    case unwrap(Node) of
        {atom,_,Name} ->
            Name;
        Node1 ->
            data(Node1)
    end.

-spec atom_name(syntaxTree()) -> string().

atom_name(Node) ->
    atom_to_list(atom_value(Node)).

-spec atom_literal(syntaxTree()) -> string().

atom_literal(Node) ->
    io_lib:write_atom(atom_value(Node)).

-spec tuple([syntaxTree()]) -> syntaxTree().

tuple(List) ->
    tree(tuple, List).

revert_tuple(Node) ->
    Pos = get_pos(Node),
    {tuple,Pos,tuple_elements(Node)}.

-spec tuple_elements(syntaxTree()) -> [syntaxTree()].

tuple_elements(Node) ->
    case unwrap(Node) of
        {tuple,_,List} ->
            List;
        Node1 ->
            data(Node1)
    end.

-spec tuple_size(syntaxTree()) -> non_neg_integer().

tuple_size(Node) ->
    length(tuple_elements(Node)).

-spec list([syntaxTree()]) -> syntaxTree().

list(List) ->
    list(List, none).

-record(list,{prefix :: undefined | [syntaxTree()],
              suffix :: undefined | none | syntaxTree()}).

-spec list([syntaxTree()], none | syntaxTree()) -> syntaxTree().

list([], none) ->
    nil();
list(Elements, Tail) when Elements =/= [] ->
    tree(list, #list{prefix = Elements,suffix = Tail}).

revert_list(Node) ->
    Pos = get_pos(Node),
    P = list_prefix(Node),
    S = case list_suffix(Node) of
            none ->
                revert_nil(set_pos(nil(), Pos));
            S1 ->
                S1
        end,
    lists:foldr(fun(X, A) ->
                       {cons,Pos,X,A}
                end,
                S,
                P).

-spec nil() -> syntaxTree().

nil() ->
    tree(nil).

revert_nil(Node) ->
    Pos = get_pos(Node),
    {nil,Pos}.

-spec list_prefix(syntaxTree()) -> [syntaxTree()].

list_prefix(Node) ->
    case unwrap(Node) of
        {cons,_,Head,Tail} ->
            [Head|cons_prefix(Tail)];
        Node1 ->
            (data(Node1))#list.prefix
    end.

cons_prefix({cons,_,Head,Tail}) ->
    [Head|cons_prefix(Tail)];
cons_prefix(_) ->
    [].

-spec list_suffix(syntaxTree()) -> none | syntaxTree().

list_suffix(Node) ->
    case unwrap(Node) of
        {cons,_,_,Tail} ->
            case cons_suffix(Tail) of
                {nil,_} ->
                    none;
                Tail1 ->
                    Tail1
            end;
        Node1 ->
            (data(Node1))#list.suffix
    end.

cons_suffix({cons,_,_,Tail}) ->
    cons_suffix(Tail);
cons_suffix(Tail) ->
    Tail.

-spec cons(syntaxTree(), syntaxTree()) -> syntaxTree().

cons(Head, Tail) ->
    case type(Tail) of
        list ->
            copy_comments(Tail,
                          list([Head|list_prefix(Tail)],
                               list_suffix(Tail)));
        nil ->
            copy_comments(Tail, list([Head]));
        _ ->
            list([Head], Tail)
    end.

-spec list_head(syntaxTree()) -> syntaxTree().

list_head(Node) ->
    hd(list_prefix(Node)).

-spec list_tail(syntaxTree()) -> syntaxTree().

list_tail(Node) ->
    Tail = list_suffix(Node),
    case tl(list_prefix(Node)) of
        [] ->
            if
                Tail =:= none ->
                    nil();
                true ->
                    Tail
            end;
        Es ->
            list(Es, Tail)
    end.

-spec is_list_skeleton(syntaxTree()) -> boolean().

is_list_skeleton(Node) ->
    case type(Node) of
        list ->
            true;
        nil ->
            true;
        _ ->
            false
    end.

-spec is_proper_list(syntaxTree()) -> boolean().

is_proper_list(Node) ->
    case type(Node) of
        list ->
            case list_suffix(Node) of
                none ->
                    true;
                Tail ->
                    is_proper_list(Tail)
            end;
        nil ->
            true;
        _ ->
            false
    end.

-spec list_elements(syntaxTree()) -> [syntaxTree()].

list_elements(Node) ->
    lists:reverse(list_elements(Node, [])).

list_elements(Node, As) ->
    case type(Node) of
        list ->
            As1 = lists:reverse(list_prefix(Node)) ++ As,
            case list_suffix(Node) of
                none ->
                    As1;
                Tail ->
                    list_elements(Tail, As1)
            end;
        nil ->
            As
    end.

-spec list_length(syntaxTree()) -> non_neg_integer().

list_length(Node) ->
    list_length(Node, 0).

list_length(Node, A) ->
    case type(Node) of
        list ->
            A1 = length(list_prefix(Node)) + A,
            case list_suffix(Node) of
                none ->
                    A1;
                Tail ->
                    list_length(Tail, A1)
            end;
        nil ->
            A
    end.

-spec normalize_list(syntaxTree()) -> syntaxTree().

normalize_list(Node) ->
    case type(Node) of
        list ->
            P = list_prefix(Node),
            case list_suffix(Node) of
                none ->
                    copy_attrs(Node, normalize_list_1(P, nil()));
                Tail ->
                    Tail1 = normalize_list(Tail),
                    copy_attrs(Node, normalize_list_1(P, Tail1))
            end;
        _ ->
            Node
    end.

normalize_list_1(Es, Tail) ->
    lists:foldr(fun(X, A) ->
                       list([X], A)
                end,
                Tail,
                Es).

-spec compact_list(syntaxTree()) -> syntaxTree().

compact_list(Node) ->
    case type(Node) of
        list ->
            case list_suffix(Node) of
                none ->
                    Node;
                Tail ->
                    case type(Tail) of
                        list ->
                            Tail1 = compact_list(Tail),
                            Node1 =
                                list(list_prefix(Node)
                                     ++
                                     list_prefix(Tail1),
                                     list_suffix(Tail1)),
                            join_comments(Tail1,
                                          copy_attrs(Node, Node1));
                        nil ->
                            Node1 = list(list_prefix(Node)),
                            join_comments(Tail, copy_attrs(Node, Node1));
                        _ ->
                            Node
                    end
            end;
        _ ->
            Node
    end.

-spec binary([syntaxTree()]) -> syntaxTree().

binary(List) ->
    tree(binary, List).

revert_binary(Node) ->
    Pos = get_pos(Node),
    {bin,Pos,binary_fields(Node)}.

-spec binary_fields(syntaxTree()) -> [syntaxTree()].

binary_fields(Node) ->
    case unwrap(Node) of
        {bin,_,List} ->
            List;
        Node1 ->
            data(Node1)
    end.

-spec binary_field(syntaxTree()) -> syntaxTree().

binary_field(Body) ->
    binary_field(Body, []).

-spec binary_field(syntaxTree(), none | syntaxTree(), [syntaxTree()]) ->
                      syntaxTree().

binary_field(Body, none, Types) ->
    binary_field(Body, Types);
binary_field(Body, Size, Types) ->
    binary_field(size_qualifier(Body, Size), Types).

-record(binary_field,{body :: undefined | syntaxTree(),
                      types :: undefined | [syntaxTree()]}).

-spec binary_field(syntaxTree(), [syntaxTree()]) -> syntaxTree().

binary_field(Body, Types) ->
    tree(binary_field, #binary_field{body = Body,types = Types}).

revert_binary_field(Node) ->
    Pos = get_pos(Node),
    Body = binary_field_body(Node),
    {Expr,Size} =
        case type(Body) of
            size_qualifier ->
                {size_qualifier_body(Body),
                 size_qualifier_argument(Body)};
            _ ->
                {Body,default}
        end,
    Types =
        case binary_field_types(Node) of
            [] ->
                default;
            Ts ->
                fold_binary_field_types(Ts)
        end,
    {bin_element,Pos,Expr,Size,Types}.

-spec binary_field_body(syntaxTree()) -> syntaxTree().

binary_field_body(Node) ->
    case unwrap(Node) of
        {bin_element,_,Body,Size,_} ->
            if
                Size =:= default ->
                    Body;
                true ->
                    size_qualifier(Body, Size)
            end;
        Node1 ->
            (data(Node1))#binary_field.body
    end.

-spec binary_field_types(syntaxTree()) -> [syntaxTree()].

binary_field_types(Node) ->
    case unwrap(Node) of
        {bin_element,Pos,_,_,Types} ->
            if
                Types =:= default ->
                    [];
                true ->
                    unfold_binary_field_types(Types, Pos)
            end;
        Node1 ->
            (data(Node1))#binary_field.types
    end.

-spec binary_field_size(syntaxTree()) -> none | syntaxTree().

binary_field_size(Node) ->
    case unwrap(Node) of
        {bin_element,_,_,Size,_} ->
            if
                Size =:= default ->
                    none;
                true ->
                    Size
            end;
        Node1 ->
            Body = (data(Node1))#binary_field.body,
            case type(Body) of
                size_qualifier ->
                    size_qualifier_argument(Body);
                _ ->
                    none
            end
    end.

-record(size_qualifier,{body :: undefined | syntaxTree(),
                        size :: undefined | syntaxTree()}).

-spec size_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().

size_qualifier(Body, Size) ->
    tree(size_qualifier, #size_qualifier{body = Body,size = Size}).

-spec size_qualifier_body(syntaxTree()) -> syntaxTree().

size_qualifier_body(Node) ->
    (data(Node))#size_qualifier.body.

-spec size_qualifier_argument(syntaxTree()) -> syntaxTree().

size_qualifier_argument(Node) ->
    (data(Node))#size_qualifier.size.

-spec error_marker(term()) -> syntaxTree().

error_marker(Error) ->
    tree(error_marker, Error).

revert_error_marker(Node) ->
    {error,error_marker_info(Node)}.

-spec error_marker_info(syntaxTree()) -> term().

error_marker_info(Node) ->
    case unwrap(Node) of
        {error,Error} ->
            Error;
        T ->
            data(T)
    end.

-spec warning_marker(term()) -> syntaxTree().

warning_marker(Warning) ->
    tree(warning_marker, Warning).

revert_warning_marker(Node) ->
    {warning,warning_marker_info(Node)}.

-spec warning_marker_info(syntaxTree()) -> term().

warning_marker_info(Node) ->
    case unwrap(Node) of
        {warning,Error} ->
            Error;
        T ->
            data(T)
    end.

-spec eof_marker() -> syntaxTree().

eof_marker() ->
    tree(eof_marker).

revert_eof_marker(Node) ->
    Pos = get_pos(Node),
    {eof,Pos}.

-spec attribute(syntaxTree()) -> syntaxTree().

attribute(Name) ->
    attribute(Name, none).

-record(attribute,{name :: undefined | syntaxTree(),
                   args :: undefined | none | [syntaxTree()]}).

-spec attribute(syntaxTree(), none | [syntaxTree()]) -> syntaxTree().

attribute(Name, Args) ->
    tree(attribute, #attribute{name = Name,args = Args}).

revert_attribute(Node) ->
    Name = attribute_name(Node),
    Args = attribute_arguments(Node),
    Pos = get_pos(Node),
    case type(Name) of
        atom ->
            revert_attribute_1(atom_value(Name), Args, Pos, Node);
        _ ->
            Node
    end.

revert_attribute_1(module, [M], Pos, Node) ->
    case revert_module_name(M) of
        {ok,A} ->
            {attribute,Pos,module,A};
        error ->
            Node
    end;
revert_attribute_1(module, [M,List], Pos, Node) ->
    Vs =
        case is_list_skeleton(List) of
            true ->
                case is_proper_list(List) of
                    true ->
                        fold_variable_names(list_elements(List));
                    false ->
                        Node
                end;
            false ->
                Node
        end,
    case revert_module_name(M) of
        {ok,A} ->
            {attribute,Pos,module,{A,Vs}};
        error ->
            Node
    end;
revert_attribute_1(export, [List], Pos, Node) ->
    case is_list_skeleton(List) of
        true ->
            case is_proper_list(List) of
                true ->
                    Fs = fold_function_names(list_elements(List)),
                    {attribute,Pos,export,Fs};
                false ->
                    Node
            end;
        false ->
            Node
    end;
revert_attribute_1(import, [M], Pos, Node) ->
    case revert_module_name(M) of
        {ok,A} ->
            {attribute,Pos,import,A};
        error ->
            Node
    end;
revert_attribute_1(import, [M,List], Pos, Node) ->
    case revert_module_name(M) of
        {ok,A} ->
            case is_list_skeleton(List) of
                true ->
                    case is_proper_list(List) of
                        true ->
                            Fs =
                                fold_function_names(list_elements(List)),
                            {attribute,Pos,import,{A,Fs}};
                        false ->
                            Node
                    end;
                false ->
                    Node
            end;
        error ->
            Node
    end;
revert_attribute_1(file, [A,Line], Pos, Node) ->
    case type(A) of
        string ->
            case type(Line) of
                integer ->
                    {attribute,Pos,file,{concrete(A),concrete(Line)}};
                _ ->
                    Node
            end;
        _ ->
            Node
    end;
revert_attribute_1(record, [A,Tuple], Pos, Node) ->
    case type(A) of
        atom ->
            case type(Tuple) of
                tuple ->
                    Fs = fold_record_fields(tuple_elements(Tuple)),
                    {attribute,Pos,record,{concrete(A),Fs}};
                _ ->
                    Node
            end;
        _ ->
            Node
    end;
revert_attribute_1(N, [T], Pos, _) ->
    {attribute,Pos,N,concrete(T)};
revert_attribute_1(_, _, _, Node) ->
    Node.

revert_module_name(A) ->
    case type(A) of
        atom ->
            {ok,concrete(A)};
        _ ->
            error
    end.

-spec attribute_name(syntaxTree()) -> syntaxTree().

attribute_name(Node) ->
    case unwrap(Node) of
        {attribute,Pos,Name,_} ->
            set_pos(atom(Name), Pos);
        Node1 ->
            (data(Node1))#attribute.name
    end.

-spec attribute_arguments(syntaxTree()) -> none | [syntaxTree()].

attribute_arguments(Node) ->
    case unwrap(Node) of
        {attribute,Pos,Name,Data} ->
            case Name of
                module ->
                    {M1,Vs} =
                        case Data of
                            {M0,Vs0} ->
                                {M0,unfold_variable_names(Vs0, Pos)};
                            M0 ->
                                {M0,none}
                        end,
                    M2 = atom(M1),
                    M = set_pos(M2, Pos),
                    if
                        Vs == none ->
                            [M];
                        true ->
                            [M,set_pos(list(Vs), Pos)]
                    end;
                export ->
                    [set_pos(list(unfold_function_names(Data, Pos)),
                             Pos)];
                import ->
                    {Module,Imports} = Data,
                    [set_pos(atom(Module), Pos),
                     set_pos(list(unfold_function_names(Imports, Pos)),
                             Pos)];
                file ->
                    {File,Line} = Data,
                    [set_pos(string(File), Pos),
                     set_pos(integer(Line), Pos)];
                record ->
                    {Type,Entries} = Data,
                    [set_pos(atom(Type), Pos),
                     set_pos(tuple(unfold_record_fields(Entries)), Pos)];
                _ ->
                    [set_pos(abstract(Data), Pos)]
            end;
        Node1 ->
            (data(Node1))#attribute.args
    end.

-record(arity_qualifier,{body :: undefined | syntaxTree(),
                         arity :: undefined | syntaxTree()}).

-spec arity_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().

arity_qualifier(Body, Arity) ->
    tree(arity_qualifier, #arity_qualifier{body = Body,arity = Arity}).

-spec arity_qualifier_body(syntaxTree()) -> syntaxTree().

arity_qualifier_body(Node) ->
    (data(Node))#arity_qualifier.body.

-spec arity_qualifier_argument(syntaxTree()) -> syntaxTree().

arity_qualifier_argument(Node) ->
    (data(Node))#arity_qualifier.arity.

-record(module_qualifier,{module :: undefined | syntaxTree(),
                          body :: undefined | syntaxTree()}).

-spec module_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().

module_qualifier(Module, Body) ->
    tree(module_qualifier,
         #module_qualifier{module = Module,body = Body}).

revert_module_qualifier(Node) ->
    Pos = get_pos(Node),
    Module = module_qualifier_argument(Node),
    Body = module_qualifier_body(Node),
    {remote,Pos,Module,Body}.

-spec module_qualifier_argument(syntaxTree()) -> syntaxTree().

module_qualifier_argument(Node) ->
    case unwrap(Node) of
        {remote,_,Module,_} ->
            Module;
        Node1 ->
            (data(Node1))#module_qualifier.module
    end.

-spec module_qualifier_body(syntaxTree()) -> syntaxTree().

module_qualifier_body(Node) ->
    case unwrap(Node) of
        {remote,_,_,Body} ->
            Body;
        Node1 ->
            (data(Node1))#module_qualifier.body
    end.

-record(func,{name :: undefined | syntaxTree(),
              clauses :: undefined | [syntaxTree()]}).

-spec function(syntaxTree(), [syntaxTree()]) -> syntaxTree().

function(Name, Clauses) ->
    tree(function, #func{name = Name,clauses = Clauses}).

revert_function(Node) ->
    Name = function_name(Node),
    Clauses =
        [ 
         revert_clause(C) ||
             C <- function_clauses(Node)
        ],
    Pos = get_pos(Node),
    case type(Name) of
        atom ->
            A = function_arity(Node),
            {function,Pos,concrete(Name),A,Clauses};
        _ ->
            Node
    end.

-spec function_name(syntaxTree()) -> syntaxTree().

function_name(Node) ->
    case unwrap(Node) of
        {function,Pos,Name,_,_} ->
            set_pos(atom(Name), Pos);
        Node1 ->
            (data(Node1))#func.name
    end.

-spec function_clauses(syntaxTree()) -> [syntaxTree()].

function_clauses(Node) ->
    case unwrap(Node) of
        {function,_,_,_,Clauses} ->
            Clauses;
        Node1 ->
            (data(Node1))#func.clauses
    end.

-spec function_arity(syntaxTree()) -> arity().

function_arity(Node) ->
    length(clause_patterns(hd(function_clauses(Node)))).

-type guard() :: none | syntaxTree() | [syntaxTree()] | [[syntaxTree()]].

-spec clause(guard(), [syntaxTree()]) -> syntaxTree().

clause(Guard, Body) ->
    clause([], Guard, Body).

-record(clause,{patterns :: undefined | [syntaxTree()],
                guard :: undefined | guard(),
                body :: undefined | [syntaxTree()]}).

-spec clause([syntaxTree()], guard(), [syntaxTree()]) -> syntaxTree().

clause(Patterns, Guard, Body) ->
    Guard1 =
        case Guard of
            [] ->
                none;
            [X|_] when is_list(X) ->
                disjunction(conjunction_list(Guard));
            [_|_] ->
                conjunction(Guard);
            _ ->
                Guard
        end,
    tree(clause,
         #clause{patterns = Patterns,guard = Guard1,body = Body}).

conjunction_list([L|Ls]) ->
    [conjunction(L)|conjunction_list(Ls)];
conjunction_list([]) ->
    [].

revert_clause(Node) ->
    Pos = get_pos(Node),
    Guard =
        case clause_guard(Node) of
            none ->
                [];
            E ->
                case type(E) of
                    disjunction ->
                        revert_clause_disjunction(E);
                    conjunction ->
                        [conjunction_body(E)];
                    _ ->
                        [[E]]
                end
        end,
    {clause,Pos,clause_patterns(Node),Guard,clause_body(Node)}.

revert_clause_disjunction(D) ->
    [ 
     case type(E) of
         conjunction ->
             conjunction_body(E);
         _ ->
             [E]
     end ||
         E <- disjunction_body(D)
    ].

revert_try_clause(Node) ->
    fold_try_clause(revert_clause(Node)).

fold_try_clause({clause,Pos,[P],Guard,Body}) ->
    P1 =
        case type(P) of
            class_qualifier ->
                {tuple,
                 Pos,
                 [class_qualifier_argument(P),
                  class_qualifier_body(P),
                  {var,Pos,'_'}]};
            _ ->
                {tuple,Pos,[{atom,Pos,throw},P,{var,Pos,'_'}]}
        end,
    {clause,Pos,[P1],Guard,Body}.

unfold_try_clauses(Cs) ->
    [ 
     unfold_try_clause(C) ||
         C <- Cs
    ].

unfold_try_clause({clause,
                   Pos,
                   [{tuple,_,[{atom,_,throw},V,_]}],
                   Guard,
                   Body}) ->
    {clause,Pos,[V],Guard,Body};
unfold_try_clause({clause,Pos,[{tuple,_,[C,V,_]}],Guard,Body}) ->
    {clause,Pos,[class_qualifier(C, V)],Guard,Body}.

-spec clause_patterns(syntaxTree()) -> [syntaxTree()].

clause_patterns(Node) ->
    case unwrap(Node) of
        {clause,_,Patterns,_,_} ->
            Patterns;
        Node1 ->
            (data(Node1))#clause.patterns
    end.

-spec clause_guard(syntaxTree()) -> none | syntaxTree().

clause_guard(Node) ->
    case unwrap(Node) of
        {clause,_,_,Guard,_} ->
            case Guard of
                [] ->
                    none;
                [L|_] when is_list(L) ->
                    disjunction(conjunction_list(Guard));
                [_|_] ->
                    conjunction(Guard)
            end;
        Node1 ->
            (data(Node1))#clause.guard
    end.

-spec clause_body(syntaxTree()) -> [syntaxTree()].

clause_body(Node) ->
    case unwrap(Node) of
        {clause,_,_,_,Body} ->
            Body;
        Node1 ->
            (data(Node1))#clause.body
    end.

-spec disjunction([syntaxTree()]) -> syntaxTree().

disjunction(Tests) ->
    tree(disjunction, Tests).

-spec disjunction_body(syntaxTree()) -> [syntaxTree()].

disjunction_body(Node) ->
    data(Node).

-spec conjunction([syntaxTree()]) -> syntaxTree().

conjunction(Tests) ->
    tree(conjunction, Tests).

-spec conjunction_body(syntaxTree()) -> [syntaxTree()].

conjunction_body(Node) ->
    data(Node).

-spec catch_expr(syntaxTree()) -> syntaxTree().

catch_expr(Expr) ->
    tree(catch_expr, Expr).

revert_catch_expr(Node) ->
    Pos = get_pos(Node),
    Expr = catch_expr_body(Node),
    {'catch',Pos,Expr}.

-spec catch_expr_body(syntaxTree()) -> syntaxTree().

catch_expr_body(Node) ->
    case unwrap(Node) of
        {'catch',_,Expr} ->
            Expr;
        Node1 ->
            data(Node1)
    end.

-record(match_expr,{pattern :: undefined | syntaxTree(),
                    body :: undefined | syntaxTree()}).

-spec match_expr(syntaxTree(), syntaxTree()) -> syntaxTree().

match_expr(Pattern, Body) ->
    tree(match_expr, #match_expr{pattern = Pattern,body = Body}).

revert_match_expr(Node) ->
    Pos = get_pos(Node),
    Pattern = match_expr_pattern(Node),
    Body = match_expr_body(Node),
    {match,Pos,Pattern,Body}.

-spec match_expr_pattern(syntaxTree()) -> syntaxTree().

match_expr_pattern(Node) ->
    case unwrap(Node) of
        {match,_,Pattern,_} ->
            Pattern;
        Node1 ->
            (data(Node1))#match_expr.pattern
    end.

-spec match_expr_body(syntaxTree()) -> syntaxTree().

match_expr_body(Node) ->
    case unwrap(Node) of
        {match,_,_,Body} ->
            Body;
        Node1 ->
            (data(Node1))#match_expr.body
    end.

-spec operator(atom() | string()) -> syntaxTree().

operator(Name) when is_atom(Name) ->
    tree(operator, Name);
operator(Name) ->
    tree(operator, list_to_atom(Name)).

-spec operator_name(syntaxTree()) -> atom().

operator_name(Node) ->
    data(Node).

-spec operator_literal(syntaxTree()) -> string().

operator_literal(Node) ->
    atom_to_list(operator_name(Node)).

-record(infix_expr,{operator :: undefined | syntaxTree(),
                    left :: undefined | syntaxTree(),
                    right :: undefined | syntaxTree()}).

-spec infix_expr(syntaxTree(), syntaxTree(), syntaxTree()) ->
                    syntaxTree().

infix_expr(Left, Operator, Right) ->
    tree(infix_expr,
         #infix_expr{operator = Operator,left = Left,right = Right}).

revert_infix_expr(Node) ->
    Pos = get_pos(Node),
    Operator = infix_expr_operator(Node),
    Left = infix_expr_left(Node),
    Right = infix_expr_right(Node),
    case type(Operator) of
        operator ->
            {op,Pos,operator_name(Operator),Left,Right};
        _ ->
            Node
    end.

-spec infix_expr_left(syntaxTree()) -> syntaxTree().

infix_expr_left(Node) ->
    case unwrap(Node) of
        {op,_,_,Left,_} ->
            Left;
        Node1 ->
            (data(Node1))#infix_expr.left
    end.

-spec infix_expr_operator(syntaxTree()) -> syntaxTree().

infix_expr_operator(Node) ->
    case unwrap(Node) of
        {op,Pos,Operator,_,_} ->
            set_pos(operator(Operator), Pos);
        Node1 ->
            (data(Node1))#infix_expr.operator
    end.

-spec infix_expr_right(syntaxTree()) -> syntaxTree().

infix_expr_right(Node) ->
    case unwrap(Node) of
        {op,_,_,_,Right} ->
            Right;
        Node1 ->
            (data(Node1))#infix_expr.right
    end.

-record(prefix_expr,{operator :: undefined | syntaxTree(),
                     argument :: undefined | syntaxTree()}).

-spec prefix_expr(syntaxTree(), syntaxTree()) -> syntaxTree().

prefix_expr(Operator, Argument) ->
    tree(prefix_expr,
         #prefix_expr{operator = Operator,argument = Argument}).

revert_prefix_expr(Node) ->
    Pos = get_pos(Node),
    Operator = prefix_expr_operator(Node),
    Argument = prefix_expr_argument(Node),
    case type(Operator) of
        operator ->
            {op,Pos,operator_name(Operator),Argument};
        _ ->
            Node
    end.

-spec prefix_expr_operator(syntaxTree()) -> syntaxTree().

prefix_expr_operator(Node) ->
    case unwrap(Node) of
        {op,Pos,Operator,_} ->
            set_pos(operator(Operator), Pos);
        Node1 ->
            (data(Node1))#prefix_expr.operator
    end.

-spec prefix_expr_argument(syntaxTree()) -> syntaxTree().

prefix_expr_argument(Node) ->
    case unwrap(Node) of
        {op,_,_,Argument} ->
            Argument;
        Node1 ->
            (data(Node1))#prefix_expr.argument
    end.

-spec record_field(syntaxTree()) -> syntaxTree().

record_field(Name) ->
    record_field(Name, none).

-record(record_field,{name :: undefined | syntaxTree(),
                      value :: undefined | none | syntaxTree()}).

-spec record_field(syntaxTree(), none | syntaxTree()) -> syntaxTree().

record_field(Name, Value) ->
    tree(record_field, #record_field{name = Name,value = Value}).

-spec record_field_name(syntaxTree()) -> syntaxTree().

record_field_name(Node) ->
    (data(Node))#record_field.name.

-spec record_field_value(syntaxTree()) -> none | syntaxTree().

record_field_value(Node) ->
    (data(Node))#record_field.value.

-record(record_index_expr,{type :: undefined | syntaxTree(),
                           field :: undefined | syntaxTree()}).

-spec record_index_expr(syntaxTree(), syntaxTree()) -> syntaxTree().

record_index_expr(Type, Field) ->
    tree(record_index_expr,
         #record_index_expr{type = Type,field = Field}).

revert_record_index_expr(Node) ->
    Pos = get_pos(Node),
    Type = record_index_expr_type(Node),
    Field = record_index_expr_field(Node),
    case type(Type) of
        atom ->
            {record_index,Pos,concrete(Type),Field};
        _ ->
            Node
    end.

-spec record_index_expr_type(syntaxTree()) -> syntaxTree().

record_index_expr_type(Node) ->
    case unwrap(Node) of
        {record_index,Pos,Type,_} ->
            set_pos(atom(Type), Pos);
        Node1 ->
            (data(Node1))#record_index_expr.type
    end.

-spec record_index_expr_field(syntaxTree()) -> syntaxTree().

record_index_expr_field(Node) ->
    case unwrap(Node) of
        {record_index,_,_,Field} ->
            Field;
        Node1 ->
            (data(Node1))#record_index_expr.field
    end.

-spec record_access(syntaxTree(), syntaxTree()) -> syntaxTree().

record_access(Argument, Field) ->
    record_access(Argument, none, Field).

-record(record_access,{argument :: undefined | syntaxTree(),
                       type :: undefined | none | syntaxTree(),
                       field :: undefined | syntaxTree()}).

-spec record_access(syntaxTree(), none | syntaxTree(), syntaxTree()) ->
                       syntaxTree().

record_access(Argument, Type, Field) ->
    tree(record_access,
         #record_access{argument = Argument,type = Type,field = Field}).

revert_record_access(Node) ->
    Pos = get_pos(Node),
    Argument = record_access_argument(Node),
    Type = record_access_type(Node),
    Field = record_access_field(Node),
    if
        Type =:= none ->
            {record_field,Pos,Argument,Field};
        true ->
            case type(Type) of
                atom ->
                    {record_field,Pos,Argument,concrete(Type),Field};
                _ ->
                    Node
            end
    end.

-spec record_access_argument(syntaxTree()) -> syntaxTree().

record_access_argument(Node) ->
    case unwrap(Node) of
        {record_field,_,Argument,_} ->
            Argument;
        {record_field,_,Argument,_,_} ->
            Argument;
        Node1 ->
            (data(Node1))#record_access.argument
    end.

-spec record_access_type(syntaxTree()) -> none | syntaxTree().

record_access_type(Node) ->
    case unwrap(Node) of
        {record_field,_,_,_} ->
            none;
        {record_field,Pos,_,Type,_} ->
            set_pos(atom(Type), Pos);
        Node1 ->
            (data(Node1))#record_access.type
    end.

-spec record_access_field(syntaxTree()) -> syntaxTree().

record_access_field(Node) ->
    case unwrap(Node) of
        {record_field,_,_,Field} ->
            Field;
        {record_field,_,_,_,Field} ->
            Field;
        Node1 ->
            (data(Node1))#record_access.field
    end.

-spec record_expr(syntaxTree(), [syntaxTree()]) -> syntaxTree().

record_expr(Type, Fields) ->
    record_expr(none, Type, Fields).

-record(record_expr,{argument :: undefined | none | syntaxTree(),
                     type :: undefined | syntaxTree(),
                     fields :: undefined | [syntaxTree()]}).

-spec record_expr(none | syntaxTree(), syntaxTree(), [syntaxTree()]) ->
                     syntaxTree().

record_expr(Argument, Type, Fields) ->
    tree(record_expr,
         #record_expr{argument = Argument,type = Type,fields = Fields}).

revert_record_expr(Node) ->
    Pos = get_pos(Node),
    Argument = record_expr_argument(Node),
    Type = record_expr_type(Node),
    Fields = record_expr_fields(Node),
    case type(Type) of
        atom ->
            T = concrete(Type),
            Fs = fold_record_fields(Fields),
            case Argument of
                none ->
                    {record,Pos,T,Fs};
                _ ->
                    {record,Pos,Argument,T,Fs}
            end;
        _ ->
            Node
    end.

-spec record_expr_argument(syntaxTree()) -> none | syntaxTree().

record_expr_argument(Node) ->
    case unwrap(Node) of
        {record,_,_,_} ->
            none;
        {record,_,Argument,_,_} ->
            Argument;
        Node1 ->
            (data(Node1))#record_expr.argument
    end.

-spec record_expr_type(syntaxTree()) -> syntaxTree().

record_expr_type(Node) ->
    case unwrap(Node) of
        {record,Pos,Type,_} ->
            set_pos(atom(Type), Pos);
        {record,Pos,_,Type,_} ->
            set_pos(atom(Type), Pos);
        Node1 ->
            (data(Node1))#record_expr.type
    end.

-spec record_expr_fields(syntaxTree()) -> [syntaxTree()].

record_expr_fields(Node) ->
    case unwrap(Node) of
        {record,_,_,Fields} ->
            unfold_record_fields(Fields);
        {record,_,_,_,Fields} ->
            unfold_record_fields(Fields);
        Node1 ->
            (data(Node1))#record_expr.fields
    end.

-spec application(none | syntaxTree(), syntaxTree(), [syntaxTree()]) ->
                     syntaxTree().

application(none, Name, Arguments) ->
    application(Name, Arguments);
application(Module, Name, Arguments) ->
    application(module_qualifier(Module, Name), Arguments).

-record(application,{operator :: undefined | syntaxTree(),
                     arguments :: undefined | [syntaxTree()]}).

-spec application(syntaxTree(), [syntaxTree()]) -> syntaxTree().

application(Operator, Arguments) ->
    tree(application,
         #application{operator = Operator,arguments = Arguments}).

revert_application(Node) ->
    Pos = get_pos(Node),
    Operator = application_operator(Node),
    Arguments = application_arguments(Node),
    {call,Pos,Operator,Arguments}.

-spec application_operator(syntaxTree()) -> syntaxTree().

application_operator(Node) ->
    case unwrap(Node) of
        {call,_,Operator,_} ->
            Operator;
        Node1 ->
            (data(Node1))#application.operator
    end.

-spec application_arguments(syntaxTree()) -> [syntaxTree()].

application_arguments(Node) ->
    case unwrap(Node) of
        {call,_,_,Arguments} ->
            Arguments;
        Node1 ->
            (data(Node1))#application.arguments
    end.

-record(list_comp,{template :: undefined | syntaxTree(),
                   body :: undefined | [syntaxTree()]}).

-spec list_comp(syntaxTree(), [syntaxTree()]) -> syntaxTree().

list_comp(Template, Body) ->
    tree(list_comp, #list_comp{template = Template,body = Body}).

revert_list_comp(Node) ->
    Pos = get_pos(Node),
    Template = list_comp_template(Node),
    Body = list_comp_body(Node),
    {lc,Pos,Template,Body}.

-spec list_comp_template(syntaxTree()) -> syntaxTree().

list_comp_template(Node) ->
    case unwrap(Node) of
        {lc,_,Template,_} ->
            Template;
        Node1 ->
            (data(Node1))#list_comp.template
    end.

-spec list_comp_body(syntaxTree()) -> [syntaxTree()].

list_comp_body(Node) ->
    case unwrap(Node) of
        {lc,_,_,Body} ->
            Body;
        Node1 ->
            (data(Node1))#list_comp.body
    end.

-record(binary_comp,{template :: undefined | syntaxTree(),
                     body :: undefined | [syntaxTree()]}).

-spec binary_comp(syntaxTree(), [syntaxTree()]) -> syntaxTree().

binary_comp(Template, Body) ->
    tree(binary_comp, #binary_comp{template = Template,body = Body}).

revert_binary_comp(Node) ->
    Pos = get_pos(Node),
    Template = binary_comp_template(Node),
    Body = binary_comp_body(Node),
    {bc,Pos,Template,Body}.

-spec binary_comp_template(syntaxTree()) -> syntaxTree().

binary_comp_template(Node) ->
    case unwrap(Node) of
        {bc,_,Template,_} ->
            Template;
        Node1 ->
            (data(Node1))#binary_comp.template
    end.

-spec binary_comp_body(syntaxTree()) -> [syntaxTree()].

binary_comp_body(Node) ->
    case unwrap(Node) of
        {bc,_,_,Body} ->
            Body;
        Node1 ->
            (data(Node1))#binary_comp.body
    end.

-record(rule,{name :: undefined | syntaxTree(),
              clauses :: undefined | [syntaxTree()]}).

-spec rule(syntaxTree(), [syntaxTree()]) -> syntaxTree().

rule(Name, Clauses) ->
    tree(rule, #rule{name = Name,clauses = Clauses}).

revert_rule(Node) ->
    Name = rule_name(Node),
    Clauses =
        [ 
         revert_clause(C) ||
             C <- rule_clauses(Node)
        ],
    Pos = get_pos(Node),
    case type(Name) of
        atom ->
            A = rule_arity(Node),
            {rule,Pos,concrete(Name),A,Clauses};
        _ ->
            Node
    end.

-spec rule_name(syntaxTree()) -> syntaxTree().

rule_name(Node) ->
    case unwrap(Node) of
        {rule,Pos,Name,_,_} ->
            set_pos(atom(Name), Pos);
        Node1 ->
            (data(Node1))#rule.name
    end.

-spec rule_clauses(syntaxTree()) -> [syntaxTree()].

rule_clauses(Node) ->
    case unwrap(Node) of
        {rule,_,_,_,Clauses} ->
            Clauses;
        Node1 ->
            (data(Node1))#rule.clauses
    end.

-spec rule_arity(syntaxTree()) -> arity().

rule_arity(Node) ->
    length(clause_patterns(hd(rule_clauses(Node)))).

-record(generator,{pattern :: undefined | syntaxTree(),
                   body :: undefined | syntaxTree()}).

-spec generator(syntaxTree(), syntaxTree()) -> syntaxTree().

generator(Pattern, Body) ->
    tree(generator, #generator{pattern = Pattern,body = Body}).

revert_generator(Node) ->
    Pos = get_pos(Node),
    Pattern = generator_pattern(Node),
    Body = generator_body(Node),
    {generate,Pos,Pattern,Body}.

-spec generator_pattern(syntaxTree()) -> syntaxTree().

generator_pattern(Node) ->
    case unwrap(Node) of
        {generate,_,Pattern,_} ->
            Pattern;
        Node1 ->
            (data(Node1))#generator.pattern
    end.

-spec generator_body(syntaxTree()) -> syntaxTree().

generator_body(Node) ->
    case unwrap(Node) of
        {generate,_,_,Body} ->
            Body;
        Node1 ->
            (data(Node1))#generator.body
    end.

-record(binary_generator,{pattern :: undefined | syntaxTree(),
                          body :: undefined | syntaxTree()}).

-spec binary_generator(syntaxTree(), syntaxTree()) -> syntaxTree().

binary_generator(Pattern, Body) ->
    tree(binary_generator,
         #binary_generator{pattern = Pattern,body = Body}).

revert_binary_generator(Node) ->
    Pos = get_pos(Node),
    Pattern = binary_generator_pattern(Node),
    Body = binary_generator_body(Node),
    {b_generate,Pos,Pattern,Body}.

-spec binary_generator_pattern(syntaxTree()) -> syntaxTree().

binary_generator_pattern(Node) ->
    case unwrap(Node) of
        {b_generate,_,Pattern,_} ->
            Pattern;
        Node1 ->
            (data(Node1))#binary_generator.pattern
    end.

-spec binary_generator_body(syntaxTree()) -> syntaxTree().

binary_generator_body(Node) ->
    case unwrap(Node) of
        {b_generate,_,_,Body} ->
            Body;
        Node1 ->
            (data(Node1))#binary_generator.body
    end.

-spec block_expr([syntaxTree()]) -> syntaxTree().

block_expr(Body) ->
    tree(block_expr, Body).

revert_block_expr(Node) ->
    Pos = get_pos(Node),
    Body = block_expr_body(Node),
    {block,Pos,Body}.

-spec block_expr_body(syntaxTree()) -> [syntaxTree()].

block_expr_body(Node) ->
    case unwrap(Node) of
        {block,_,Body} ->
            Body;
        Node1 ->
            data(Node1)
    end.

-spec if_expr([syntaxTree()]) -> syntaxTree().

if_expr(Clauses) ->
    tree(if_expr, Clauses).

revert_if_expr(Node) ->
    Pos = get_pos(Node),
    Clauses =
        [ 
         revert_clause(C) ||
             C <- if_expr_clauses(Node)
        ],
    {'if',Pos,Clauses}.

-spec if_expr_clauses(syntaxTree()) -> [syntaxTree()].

if_expr_clauses(Node) ->
    case unwrap(Node) of
        {'if',_,Clauses} ->
            Clauses;
        Node1 ->
            data(Node1)
    end.

-record(case_expr,{argument :: undefined | syntaxTree(),
                   clauses :: undefined | [syntaxTree()]}).

-spec case_expr(syntaxTree(), [syntaxTree()]) -> syntaxTree().

case_expr(Argument, Clauses) ->
    tree(case_expr, #case_expr{argument = Argument,clauses = Clauses}).

revert_case_expr(Node) ->
    Pos = get_pos(Node),
    Argument = case_expr_argument(Node),
    Clauses =
        [ 
         revert_clause(C) ||
             C <- case_expr_clauses(Node)
        ],
    {'case',Pos,Argument,Clauses}.

-spec case_expr_argument(syntaxTree()) -> syntaxTree().

case_expr_argument(Node) ->
    case unwrap(Node) of
        {'case',_,Argument,_} ->
            Argument;
        Node1 ->
            (data(Node1))#case_expr.argument
    end.

-spec case_expr_clauses(syntaxTree()) -> [syntaxTree()].

case_expr_clauses(Node) ->
    case unwrap(Node) of
        {'case',_,_,Clauses} ->
            Clauses;
        Node1 ->
            (data(Node1))#case_expr.clauses
    end.

-spec cond_expr([syntaxTree()]) -> syntaxTree().

cond_expr(Clauses) ->
    tree(cond_expr, Clauses).

revert_cond_expr(Node) ->
    Pos = get_pos(Node),
    Clauses =
        [ 
         revert_clause(C) ||
             C <- cond_expr_clauses(Node)
        ],
    {'cond',Pos,Clauses}.

-spec cond_expr_clauses(syntaxTree()) -> [syntaxTree()].

cond_expr_clauses(Node) ->
    case unwrap(Node) of
        {'cond',_,Clauses} ->
            Clauses;
        Node1 ->
            data(Node1)
    end.

-spec receive_expr([syntaxTree()]) -> syntaxTree().

receive_expr(Clauses) ->
    receive_expr(Clauses, none, []).

-record(receive_expr,{clauses :: undefined | [syntaxTree()],
                      timeout :: undefined | none | syntaxTree(),
                      action :: undefined | [syntaxTree()]}).

-spec receive_expr([syntaxTree()], none | syntaxTree(), [syntaxTree()]) ->
                      syntaxTree().

receive_expr(Clauses, Timeout, Action) ->
    Action1 =
        case Timeout of
            none ->
                [];
            _ ->
                Action
        end,
    tree(receive_expr,
         #receive_expr{clauses = Clauses,
                       timeout = Timeout,
                       action = Action1}).

revert_receive_expr(Node) ->
    Pos = get_pos(Node),
    Clauses =
        [ 
         revert_clause(C) ||
             C <- receive_expr_clauses(Node)
        ],
    Timeout = receive_expr_timeout(Node),
    Action = receive_expr_action(Node),
    case Timeout of
        none ->
            {'receive',Pos,Clauses};
        _ ->
            {'receive',Pos,Clauses,Timeout,Action}
    end.

-spec receive_expr_clauses(syntaxTree()) -> [syntaxTree()].

receive_expr_clauses(Node) ->
    case unwrap(Node) of
        {'receive',_,Clauses} ->
            Clauses;
        {'receive',_,Clauses,_,_} ->
            Clauses;
        Node1 ->
            (data(Node1))#receive_expr.clauses
    end.

-spec receive_expr_timeout(syntaxTree()) -> none | syntaxTree().

receive_expr_timeout(Node) ->
    case unwrap(Node) of
        {'receive',_,_} ->
            none;
        {'receive',_,_,Timeout,_} ->
            Timeout;
        Node1 ->
            (data(Node1))#receive_expr.timeout
    end.

-spec receive_expr_action(syntaxTree()) -> [syntaxTree()].

receive_expr_action(Node) ->
    case unwrap(Node) of
        {'receive',_,_} ->
            [];
        {'receive',_,_,_,Action} ->
            Action;
        Node1 ->
            (data(Node1))#receive_expr.action
    end.

-spec try_expr([syntaxTree()], [syntaxTree()]) -> syntaxTree().

try_expr(Body, Handlers) ->
    try_expr(Body, [], Handlers).

-spec try_expr([syntaxTree()], [syntaxTree()], [syntaxTree()]) ->
                  syntaxTree().

try_expr(Body, Clauses, Handlers) ->
    try_expr(Body, Clauses, Handlers, []).

-spec try_after_expr([syntaxTree()], [syntaxTree()]) -> syntaxTree().

try_after_expr(Body, After) ->
    try_expr(Body, [], [], After).

-record(try_expr,{body :: undefined | [syntaxTree()],
                  clauses :: undefined | [syntaxTree()],
                  handlers :: undefined | [syntaxTree()],
                  'after' :: undefined | [syntaxTree()]}).

-spec try_expr([syntaxTree()],
               [syntaxTree()],
               [syntaxTree()],
               [syntaxTree()]) ->
                  syntaxTree().

try_expr(Body, Clauses, Handlers, After) ->
    tree(try_expr,
         #try_expr{body = Body,
                   clauses = Clauses,
                   handlers = Handlers,
                   'after' = After}).

revert_try_expr(Node) ->
    Pos = get_pos(Node),
    Body = try_expr_body(Node),
    Clauses =
        [ 
         revert_clause(C) ||
             C <- try_expr_clauses(Node)
        ],
    Handlers =
        [ 
         revert_try_clause(C) ||
             C <- try_expr_handlers(Node)
        ],
    After = try_expr_after(Node),
    {'try',Pos,Body,Clauses,Handlers,After}.

-spec try_expr_body(syntaxTree()) -> [syntaxTree()].

try_expr_body(Node) ->
    case unwrap(Node) of
        {'try',_,Body,_,_,_} ->
            Body;
        Node1 ->
            (data(Node1))#try_expr.body
    end.

-spec try_expr_clauses(syntaxTree()) -> [syntaxTree()].

try_expr_clauses(Node) ->
    case unwrap(Node) of
        {'try',_,_,Clauses,_,_} ->
            Clauses;
        Node1 ->
            (data(Node1))#try_expr.clauses
    end.

-spec try_expr_handlers(syntaxTree()) -> [syntaxTree()].

try_expr_handlers(Node) ->
    case unwrap(Node) of
        {'try',_,_,_,Handlers,_} ->
            unfold_try_clauses(Handlers);
        Node1 ->
            (data(Node1))#try_expr.handlers
    end.

-spec try_expr_after(syntaxTree()) -> [syntaxTree()].

try_expr_after(Node) ->
    case unwrap(Node) of
        {'try',_,_,_,_,After} ->
            After;
        Node1 ->
            (data(Node1))#try_expr.'after'
    end.

-record(class_qualifier,{class :: undefined | syntaxTree(),
                         body :: undefined | syntaxTree()}).

-spec class_qualifier(syntaxTree(), syntaxTree()) -> syntaxTree().

class_qualifier(Class, Body) ->
    tree(class_qualifier, #class_qualifier{class = Class,body = Body}).

-spec class_qualifier_argument(syntaxTree()) -> syntaxTree().

class_qualifier_argument(Node) ->
    (data(Node))#class_qualifier.class.

-spec class_qualifier_body(syntaxTree()) -> syntaxTree().

class_qualifier_body(Node) ->
    (data(Node))#class_qualifier.body.

-spec implicit_fun(syntaxTree(), none | syntaxTree()) -> syntaxTree().

implicit_fun(Name, none) ->
    implicit_fun(Name);
implicit_fun(Name, Arity) ->
    implicit_fun(arity_qualifier(Name, Arity)).

-spec implicit_fun(none | syntaxTree(), syntaxTree(), syntaxTree()) ->
                      syntaxTree().

implicit_fun(none, Name, Arity) ->
    implicit_fun(Name, Arity);
implicit_fun(Module, Name, Arity) ->
    implicit_fun(module_qualifier(Module, arity_qualifier(Name, Arity))).

-spec implicit_fun(syntaxTree()) -> syntaxTree().

implicit_fun(Name) ->
    tree(implicit_fun, Name).

revert_implicit_fun(Node) ->
    Pos = get_pos(Node),
    Name = implicit_fun_name(Node),
    case type(Name) of
        arity_qualifier ->
            F = arity_qualifier_body(Name),
            A = arity_qualifier_argument(Name),
            case {type(F),type(A)} of
                {atom,integer} ->
                    {'fun',Pos,{function,concrete(F),concrete(A)}};
                _ ->
                    Node
            end;
        module_qualifier ->
            M = module_qualifier_argument(Name),
            Name1 = module_qualifier_body(Name),
            F = arity_qualifier_body(Name1),
            A = arity_qualifier_argument(Name1),
            case {type(M),type(F),type(A)} of
                {atom,atom,integer} ->
                    {'fun',
                     Pos,
                     {function,concrete(M),concrete(F),concrete(A)}};
                _ ->
                    Node
            end;
        _ ->
            Node
    end.

-spec implicit_fun_name(syntaxTree()) -> syntaxTree().

implicit_fun_name(Node) ->
    case unwrap(Node) of
        {'fun',Pos,{function,Atom,Arity}} ->
            arity_qualifier(set_pos(atom(Atom), Pos),
                            set_pos(integer(Arity), Pos));
        {'fun',Pos,{function,Module,Atom,Arity}}
            when is_atom(Module), is_atom(Atom), is_integer(Arity) ->
            module_qualifier(set_pos(atom(Module), Pos),
                             arity_qualifier(set_pos(atom(Atom), Pos),
                                             set_pos(integer(Arity),
                                                     Pos)));
        {'fun',_Pos,{function,Module,Atom,Arity}} ->
            module_qualifier(Module, arity_qualifier(Atom, Arity));
        Node1 ->
            data(Node1)
    end.

-spec fun_expr([syntaxTree()]) -> syntaxTree().

fun_expr(Clauses) ->
    tree(fun_expr, Clauses).

revert_fun_expr(Node) ->
    Clauses =
        [ 
         revert_clause(C) ||
             C <- fun_expr_clauses(Node)
        ],
    Pos = get_pos(Node),
    {'fun',Pos,{clauses,Clauses}}.

-spec fun_expr_clauses(syntaxTree()) -> [syntaxTree()].

fun_expr_clauses(Node) ->
    case unwrap(Node) of
        {'fun',_,{clauses,Clauses}} ->
            Clauses;
        Node1 ->
            data(Node1)
    end.

-spec fun_expr_arity(syntaxTree()) -> arity().

fun_expr_arity(Node) ->
    length(clause_patterns(hd(fun_expr_clauses(Node)))).

-spec parentheses(syntaxTree()) -> syntaxTree().

parentheses(Expr) ->
    tree(parentheses, Expr).

revert_parentheses(Node) ->
    parentheses_body(Node).

-spec parentheses_body(syntaxTree()) -> syntaxTree().

parentheses_body(Node) ->
    data(Node).

-spec macro(syntaxTree()) -> syntaxTree().

macro(Name) ->
    macro(Name, none).

-record(macro,{name :: undefined | syntaxTree(),
               arguments :: undefined | none | [syntaxTree()]}).

-spec macro(syntaxTree(), none | [syntaxTree()]) -> syntaxTree().

macro(Name, Arguments) ->
    tree(macro, #macro{name = Name,arguments = Arguments}).

-spec macro_name(syntaxTree()) -> syntaxTree().

macro_name(Node) ->
    (data(Node))#macro.name.

-spec macro_arguments(syntaxTree()) -> none | [syntaxTree()].

macro_arguments(Node) ->
    (data(Node))#macro.arguments.

-spec abstract(term()) -> syntaxTree().

abstract([H|T] = L) when is_integer(H) ->
    case is_printable(L) of
        true ->
            string(L);
        false ->
            abstract_tail(H, T)
    end;
abstract([H|T]) ->
    abstract_tail(H, T);
abstract(T) when is_atom(T) ->
    atom(T);
abstract(T) when is_integer(T) ->
    integer(T);
abstract(T) when is_float(T) ->
    make_float(T);
abstract([]) ->
    nil();
abstract(T) when is_tuple(T) ->
    tuple(abstract_list(tuple_to_list(T)));
abstract(T) when is_binary(T) ->
    binary([ 
            binary_field(integer(B)) ||
                B <- binary_to_list(T)
           ]);
abstract(T) ->
    error({badarg,T}).

abstract_list([T|Ts]) ->
    [abstract(T)|abstract_list(Ts)];
abstract_list([]) ->
    [].

abstract_tail(H1, [H2|T]) ->
    cons(abstract(H1), abstract_tail(H2, T));
abstract_tail(H, T) ->
    cons(abstract(H), abstract(T)).

-spec concrete(syntaxTree()) -> term().

concrete(Node) ->
    case type(Node) of
        atom ->
            atom_value(Node);
        integer ->
            integer_value(Node);
        float ->
            float_value(Node);
        char ->
            char_value(Node);
        string ->
            string_value(Node);
        nil ->
            [];
        list ->
            [concrete(list_head(Node))|concrete(list_tail(Node))];
        tuple ->
            list_to_tuple(concrete_list(tuple_elements(Node)));
        binary ->
            Fs =
                [ 
                 revert_binary_field(binary_field(binary_field_body(F),
                                                  case
                                                      binary_field_size(F)
                                                  of
                                                      none ->
                                                          none;
                                                      S ->
                                                          revert(S)
                                                  end,
                                                  binary_field_types(F))) ||
                     F <- binary_fields(Node)
                ],
            {value,B,_} =
                eval_bits:expr_grp(Fs,
                                   [],
                                   fun(F, _) ->
                                          {value,concrete(F),[]}
                                   end,
                                   [],
                                   true),
            B;
        _ ->
            error({badarg,Node})
    end.

concrete_list([E|Es]) ->
    [concrete(E)|concrete_list(Es)];
concrete_list([]) ->
    [].

-spec is_literal(syntaxTree()) -> boolean().

is_literal(T) ->
    case type(T) of
        atom ->
            true;
        integer ->
            true;
        float ->
            true;
        char ->
            true;
        string ->
            true;
        nil ->
            true;
        list ->
            is_literal(list_head(T))
            andalso
            is_literal(list_tail(T));
        tuple ->
            lists:all(fun is_literal/1, tuple_elements(T));
        _ ->
            false
    end.

-spec revert(syntaxTree()) -> syntaxTree().

revert(Node) ->
    case is_tree(Node) of
        false ->
            unwrap(Node);
        true ->
            case is_leaf(Node) of
                true ->
                    revert_root(Node);
                false ->
                    Gs =
                        [ 
                         [ 
                          revert(X) ||
                              X <- L
                         ] ||
                             L <- subtrees(Node)
                        ],
                    Node1 = update_tree(Node, Gs),
                    revert_root(Node1)
            end
    end.

revert_root(Node) ->
    case type(Node) of
        application ->
            revert_application(Node);
        atom ->
            revert_atom(Node);
        attribute ->
            revert_attribute(Node);
        binary ->
            revert_binary(Node);
        binary_comp ->
            revert_binary_comp(Node);
        binary_field ->
            revert_binary_field(Node);
        binary_generator ->
            revert_binary_generator(Node);
        block_expr ->
            revert_block_expr(Node);
        case_expr ->
            revert_case_expr(Node);
        catch_expr ->
            revert_catch_expr(Node);
        char ->
            revert_char(Node);
        clause ->
            revert_clause(Node);
        cond_expr ->
            revert_cond_expr(Node);
        eof_marker ->
            revert_eof_marker(Node);
        error_marker ->
            revert_error_marker(Node);
        float ->
            revert_float(Node);
        fun_expr ->
            revert_fun_expr(Node);
        function ->
            revert_function(Node);
        generator ->
            revert_generator(Node);
        if_expr ->
            revert_if_expr(Node);
        implicit_fun ->
            revert_implicit_fun(Node);
        infix_expr ->
            revert_infix_expr(Node);
        integer ->
            revert_integer(Node);
        list ->
            revert_list(Node);
        list_comp ->
            revert_list_comp(Node);
        match_expr ->
            revert_match_expr(Node);
        module_qualifier ->
            revert_module_qualifier(Node);
        nil ->
            revert_nil(Node);
        parentheses ->
            revert_parentheses(Node);
        prefix_expr ->
            revert_prefix_expr(Node);
        receive_expr ->
            revert_receive_expr(Node);
        record_access ->
            revert_record_access(Node);
        record_expr ->
            revert_record_expr(Node);
        record_index_expr ->
            revert_record_index_expr(Node);
        rule ->
            revert_rule(Node);
        string ->
            revert_string(Node);
        try_expr ->
            revert_try_expr(Node);
        tuple ->
            revert_tuple(Node);
        underscore ->
            revert_underscore(Node);
        variable ->
            revert_variable(Node);
        warning_marker ->
            revert_warning_marker(Node);
        _ ->
            Node
    end.

-type forms() :: syntaxTree() | [syntaxTree()].

-spec revert_forms(forms()) -> [erl_parse()].

revert_forms(Forms) when is_list(Forms) ->
    revert_forms(form_list(Forms));
revert_forms(T) ->
    case type(T) of
        form_list ->
            T1 = flatten_form_list(T),
            case catch {ok,revert_forms_1(form_list_elements(T1))} of
                {ok,Fs} ->
                    Fs;
                {error,_} = Error ->
                    error(Error);
                {'EXIT',R} ->
                    exit(R);
                R ->
                    throw(R)
            end;
        _ ->
            error({badarg,T})
    end.

revert_forms_1([T|Ts]) ->
    case type(T) of
        comment ->
            revert_forms_1(Ts);
        _ ->
            T1 = revert(T),
            case is_tree(T1) of
                true ->
                    throw({error,T1});
                false ->
                    [T1|revert_forms_1(Ts)]
            end
    end;
revert_forms_1([]) ->
    [].

-spec subtrees(syntaxTree()) -> [[syntaxTree()]].

subtrees(T) ->
    case is_leaf(T) of
        true ->
            [];
        false ->
            case type(T) of
                application ->
                    [[application_operator(T)],application_arguments(T)];
                arity_qualifier ->
                    [[arity_qualifier_body(T)],
                     [arity_qualifier_argument(T)]];
                attribute ->
                    case attribute_arguments(T) of
                        none ->
                            [[attribute_name(T)]];
                        As ->
                            [[attribute_name(T)],As]
                    end;
                binary ->
                    [binary_fields(T)];
                binary_comp ->
                    [[binary_comp_template(T)],binary_comp_body(T)];
                binary_field ->
                    case binary_field_types(T) of
                        [] ->
                            [[binary_field_body(T)]];
                        Ts ->
                            [[binary_field_body(T)],Ts]
                    end;
                binary_generator ->
                    [[binary_generator_pattern(T)],
                     [binary_generator_body(T)]];
                block_expr ->
                    [block_expr_body(T)];
                case_expr ->
                    [[case_expr_argument(T)],case_expr_clauses(T)];
                catch_expr ->
                    [[catch_expr_body(T)]];
                class_qualifier ->
                    [[class_qualifier_argument(T)],
                     [class_qualifier_body(T)]];
                clause ->
                    case clause_guard(T) of
                        none ->
                            [clause_patterns(T),clause_body(T)];
                        G ->
                            [clause_patterns(T),[G],clause_body(T)]
                    end;
                cond_expr ->
                    [cond_expr_clauses(T)];
                conjunction ->
                    [conjunction_body(T)];
                disjunction ->
                    [disjunction_body(T)];
                form_list ->
                    [form_list_elements(T)];
                fun_expr ->
                    [fun_expr_clauses(T)];
                function ->
                    [[function_name(T)],function_clauses(T)];
                generator ->
                    [[generator_pattern(T)],[generator_body(T)]];
                if_expr ->
                    [if_expr_clauses(T)];
                implicit_fun ->
                    [[implicit_fun_name(T)]];
                infix_expr ->
                    [[infix_expr_left(T)],
                     [infix_expr_operator(T)],
                     [infix_expr_right(T)]];
                list ->
                    case list_suffix(T) of
                        none ->
                            [list_prefix(T)];
                        S ->
                            [list_prefix(T),[S]]
                    end;
                list_comp ->
                    [[list_comp_template(T)],list_comp_body(T)];
                macro ->
                    case macro_arguments(T) of
                        none ->
                            [[macro_name(T)]];
                        As ->
                            [[macro_name(T)],As]
                    end;
                match_expr ->
                    [[match_expr_pattern(T)],[match_expr_body(T)]];
                module_qualifier ->
                    [[module_qualifier_argument(T)],
                     [module_qualifier_body(T)]];
                parentheses ->
                    [[parentheses_body(T)]];
                prefix_expr ->
                    [[prefix_expr_operator(T)],
                     [prefix_expr_argument(T)]];
                receive_expr ->
                    case receive_expr_timeout(T) of
                        none ->
                            [receive_expr_clauses(T)];
                        E ->
                            [receive_expr_clauses(T),
                             [E],
                             receive_expr_action(T)]
                    end;
                record_access ->
                    case record_access_type(T) of
                        none ->
                            [[record_access_argument(T)],
                             [record_access_field(T)]];
                        R ->
                            [[record_access_argument(T)],
                             [R],
                             [record_access_field(T)]]
                    end;
                record_expr ->
                    case record_expr_argument(T) of
                        none ->
                            [[record_expr_type(T)],
                             record_expr_fields(T)];
                        V ->
                            [[V],
                             [record_expr_type(T)],
                             record_expr_fields(T)]
                    end;
                record_field ->
                    case record_field_value(T) of
                        none ->
                            [[record_field_name(T)]];
                        V ->
                            [[record_field_name(T)],[V]]
                    end;
                record_index_expr ->
                    [[record_index_expr_type(T)],
                     [record_index_expr_field(T)]];
                rule ->
                    [[rule_name(T)],rule_clauses(T)];
                size_qualifier ->
                    [[size_qualifier_body(T)],
                     [size_qualifier_argument(T)]];
                try_expr ->
                    [try_expr_body(T),
                     try_expr_clauses(T),
                     try_expr_handlers(T),
                     try_expr_after(T)];
                tuple ->
                    [tuple_elements(T)]
            end
    end.

-spec update_tree(syntaxTree(), [[syntaxTree()]]) -> syntaxTree().

update_tree(Node, Groups) ->
    copy_attrs(Node, make_tree(type(Node), Groups)).

-spec make_tree(atom(), [[syntaxTree()]]) -> syntaxTree().

make_tree(application, [[F],A]) ->
    application(F, A);
make_tree(arity_qualifier, [[N],[A]]) ->
    arity_qualifier(N, A);
make_tree(attribute, [[N]]) ->
    attribute(N);
make_tree(attribute, [[N],A]) ->
    attribute(N, A);
make_tree(binary, [Fs]) ->
    binary(Fs);
make_tree(binary_comp, [[T],B]) ->
    binary_comp(T, B);
make_tree(binary_field, [[B]]) ->
    binary_field(B);
make_tree(binary_field, [[B],Ts]) ->
    binary_field(B, Ts);
make_tree(binary_generator, [[P],[E]]) ->
    binary_generator(P, E);
make_tree(block_expr, [B]) ->
    block_expr(B);
make_tree(case_expr, [[A],C]) ->
    case_expr(A, C);
make_tree(catch_expr, [[B]]) ->
    catch_expr(B);
make_tree(class_qualifier, [[A],[B]]) ->
    class_qualifier(A, B);
make_tree(clause, [P,B]) ->
    clause(P, none, B);
make_tree(clause, [P,[G],B]) ->
    clause(P, G, B);
make_tree(cond_expr, [C]) ->
    cond_expr(C);
make_tree(conjunction, [E]) ->
    conjunction(E);
make_tree(disjunction, [E]) ->
    disjunction(E);
make_tree(form_list, [E]) ->
    form_list(E);
make_tree(fun_expr, [C]) ->
    fun_expr(C);
make_tree(function, [[N],C]) ->
    function(N, C);
make_tree(generator, [[P],[E]]) ->
    generator(P, E);
make_tree(if_expr, [C]) ->
    if_expr(C);
make_tree(implicit_fun, [[N]]) ->
    implicit_fun(N);
make_tree(infix_expr, [[L],[F],[R]]) ->
    infix_expr(L, F, R);
make_tree(list, [P]) ->
    list(P);
make_tree(list, [P,[S]]) ->
    list(P, S);
make_tree(list_comp, [[T],B]) ->
    list_comp(T, B);
make_tree(macro, [[N]]) ->
    macro(N);
make_tree(macro, [[N],A]) ->
    macro(N, A);
make_tree(match_expr, [[P],[E]]) ->
    match_expr(P, E);
make_tree(module_qualifier, [[M],[N]]) ->
    module_qualifier(M, N);
make_tree(parentheses, [[E]]) ->
    parentheses(E);
make_tree(prefix_expr, [[F],[A]]) ->
    prefix_expr(F, A);
make_tree(receive_expr, [C]) ->
    receive_expr(C);
make_tree(receive_expr, [C,[E],A]) ->
    receive_expr(C, E, A);
make_tree(record_access, [[E],[F]]) ->
    record_access(E, F);
make_tree(record_access, [[E],[T],[F]]) ->
    record_access(E, T, F);
make_tree(record_expr, [[T],F]) ->
    record_expr(T, F);
make_tree(record_expr, [[E],[T],F]) ->
    record_expr(E, T, F);
make_tree(record_field, [[N]]) ->
    record_field(N);
make_tree(record_field, [[N],[E]]) ->
    record_field(N, E);
make_tree(record_index_expr, [[T],[F]]) ->
    record_index_expr(T, F);
make_tree(rule, [[N],C]) ->
    rule(N, C);
make_tree(size_qualifier, [[N],[A]]) ->
    size_qualifier(N, A);
make_tree(try_expr, [B,C,H,A]) ->
    try_expr(B, C, H, A);
make_tree(tuple, [E]) ->
    tuple(E).

-spec meta(syntaxTree()) -> syntaxTree().

meta(T) ->
    case type(T) of
        variable ->
            case lists:member(meta_var, get_ann(T)) of
                false ->
                    meta_precomment(T);
                true ->
                    set_ann(T, lists:delete(meta_var, get_ann(T)))
            end;
        _ ->
            case has_comments(T) of
                true ->
                    meta_precomment(T);
                false ->
                    meta_1(T)
            end
    end.

meta_precomment(T) ->
    case get_precomments(T) of
        [] ->
            meta_postcomment(T);
        Cs ->
            meta_call(set_precomments,
                      [meta_postcomment(T),list(meta_list(Cs))])
    end.

meta_postcomment(T) ->
    case get_postcomments(T) of
        [] ->
            meta_0(T);
        Cs ->
            meta_call(set_postcomments, [meta_0(T),list(meta_list(Cs))])
    end.

meta_0(T) ->
    meta_1(remove_comments(T)).

meta_1(T) ->
    case type(T) of
        atom ->
            meta_call(atom, [T]);
        char ->
            meta_call(char, [T]);
        comment ->
            meta_call(comment,
                      [list([ 
                             string(S) ||
                                 S <- comment_text(T)
                            ])]);
        eof_marker ->
            meta_call(eof_marker, []);
        error_marker ->
            meta_call(error_marker, [abstract(error_marker_info(T))]);
        float ->
            meta_call(float, [T]);
        integer ->
            meta_call(integer, [T]);
        nil ->
            meta_call(nil, []);
        operator ->
            meta_call(operator, [atom(operator_name(T))]);
        string ->
            meta_call(string, [T]);
        text ->
            meta_call(text, [string(text_string(T))]);
        underscore ->
            meta_call(underscore, []);
        variable ->
            meta_call(variable,
                      [string(atom_to_list(variable_name(T)))]);
        warning_marker ->
            meta_call(warning_marker,
                      [abstract(warning_marker_info(T))]);
        list ->
            case list_suffix(T) of
                none ->
                    meta_call(list, [list(meta_list(list_prefix(T)))]);
                S ->
                    meta_call(list,
                              [list(meta_list(list_prefix(T))),meta(S)])
            end;
        tuple ->
            meta_call(tuple, [list(meta_list(tuple_elements(T)))]);
        Type ->
            meta_call(make_tree,
                      [abstract(Type),meta_subtrees(subtrees(T))])
    end.

meta_list([T|Ts]) ->
    [meta(T)|meta_list(Ts)];
meta_list([]) ->
    [].

meta_subtrees(Gs) ->
    list([ 
          list([ 
                meta(T) ||
                    T <- G
               ]) ||
              G <- Gs
         ]).

meta_call(F, As) ->
    application(atom(erl_syntax), atom(F), As).

-spec tree(atom()) -> #tree{}.

tree(Type) ->
    tree(Type, []).

-spec tree(atom(), term()) -> #tree{}.

tree(Type, Data) ->
    #tree{type = Type,data = Data}.

-spec is_tree(syntaxTree()) -> boolean().

is_tree(#tree{}) ->
    true;
is_tree(_) ->
    false.

-spec data(syntaxTree()) -> term().

data(#tree{data = D}) ->
    D;
data(T) ->
    error({badarg,T}).

-spec wrap(erl_parse()) -> #wrapper{}.

wrap(Node) ->
    #wrapper{type = type(Node),
             attr = #attr{pos = get_pos(Node)},
             tree = Node}.

-spec unwrap(syntaxTree()) -> #tree{} | erl_parse().

unwrap(#wrapper{tree = Node}) ->
    Node;
unwrap(Node) ->
    Node.

is_printable(S) ->
    io_lib:printable_list(S).

unfold_function_names(Ns, Pos) ->
    F = fun({Atom,Arity}) ->
               N = arity_qualifier(atom(Atom), integer(Arity)),
               set_pos(N, Pos)
        end,
    [ 
     F(N) ||
         N <- Ns
    ].

fold_function_names(Ns) ->
    [ 
     fold_function_name(N) ||
         N <- Ns
    ].

fold_function_name(N) ->
    Name = arity_qualifier_body(N),
    Arity = arity_qualifier_argument(N),
    true = (type(Name) =:= atom) and (type(Arity) =:= integer),
    {concrete(Name),concrete(Arity)}.

fold_variable_names(Vs) ->
    [ 
     variable_name(V) ||
         V <- Vs
    ].

unfold_variable_names(Vs, Pos) ->
    [ 
     set_pos(variable(V), Pos) ||
         V <- Vs
    ].

fold_record_fields(Fs) ->
    [ 
     fold_record_field(F) ||
         F <- Fs
    ].

fold_record_field(F) ->
    Pos = get_pos(F),
    Name = record_field_name(F),
    case record_field_value(F) of
        none ->
            {record_field,Pos,Name};
        Value ->
            {record_field,Pos,Name,Value}
    end.

unfold_record_fields(Fs) ->
    [ 
     unfold_record_field(F) ||
         F <- Fs
    ].

unfold_record_field({typed_record_field,Field,_Type}) ->
    unfold_record_field_1(Field);
unfold_record_field(Field) ->
    unfold_record_field_1(Field).

unfold_record_field_1({record_field,Pos,Name}) ->
    set_pos(record_field(Name), Pos);
unfold_record_field_1({record_field,Pos,Name,Value}) ->
    set_pos(record_field(Name, Value), Pos).

fold_binary_field_types(Ts) ->
    [ 
     fold_binary_field_type(T) ||
         T <- Ts
    ].

fold_binary_field_type(Node) ->
    case type(Node) of
        size_qualifier ->
            {concrete(size_qualifier_body(Node)),
             concrete(size_qualifier_argument(Node))};
        _ ->
            concrete(Node)
    end.

unfold_binary_field_types(Ts, Pos) ->
    [ 
     unfold_binary_field_type(T, Pos) ||
         T <- Ts
    ].

unfold_binary_field_type({Type,Size}, Pos) ->
    set_pos(size_qualifier(atom(Type), integer(Size)), Pos);
unfold_binary_field_type(Type, Pos) ->
    set_pos(atom(Type), Pos).



