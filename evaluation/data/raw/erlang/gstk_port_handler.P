-file("test/lib/gs/src/gstk_port_handler.erl", 1).

-module(gstk_port_handler).

-compile([{nowarn_deprecated_function,{gs,error,2}}]).

-file("test/lib/gs/src/gstk.hrl", 1).

-record(gstkid,{id = undefined,widget,widget_data,owner,parent,objtype}).

-record(so,{main,object,hscroll,vscroll,misc}).

-file("test/lib/gs/src/gstk_port_handler.erl", 40).

-export([exec/1,call/2,start_link/1,init/2,ping/1,stop/1]).

-export([wait_for_connection/2]).

get_env(App, KeyAtom) ->
    KeyStr = atom_to_list(KeyAtom),
    true,
    case init:get_argument(App) of
        {ok,[[KeyStr,ValStr]]} ->
            {ok,list_to_atom(ValStr)};
        _ ->
            undefined
    end.

start_link(Gstk) ->
    true,
    Mode =
        case {os:type(),get_env(gs, backend_comm)} of
            {{win32,_Flavor},undefined} ->
                use_socket;
            {_OS,undefined} ->
                use_port;
            {_OS,{ok,socket}} ->
                use_socket;
            {_OS,{ok,port}} ->
                use_port
        end,
    true,
    Pid = spawn_link(gstk_port_handler, init, [Gstk,Mode]),
    receive
        {Pid,ok} ->
            {ok,Pid};
        {Pid,error,Reason} ->
            {error,Reason}
    after
        1000 * 30 -> {error,timeout}
    end.

call(PortHandler, Cmd) ->
    PortHandler ! {call,["erlcall {",Cmd,$}]},
    receive
        {result,Result} ->
            true,
            {result,Result};
        {bad_result,Bad_Result} ->
            true,
            {bad_result,Bad_Result}
    end.

ping(PortHandler) ->
    true,
    PortHandler ! {ping,self()},
    receive
        {pong,_From,PortOrSock} ->
            {ok,PortOrSock}
    end.

stop(PortHandler) ->
    true,
    PortHandler ! {stop,self()},
    receive
        {stopped,PortHandler} ->
            ok
    end.

exec(Cmd) ->
    get(port_handler) ! {exec,["erlexec {",Cmd,$}]},
    ok.

-record(state,{out,gstk}).

init(Gstk, Mode) ->
    process_flag(trap_exit, true),
    PrivDir = code:priv_dir(gs),
    TclDir = filename:join(PrivDir, "tcl"),
    TclBinDir = filename:join(TclDir, "bin"),
    TclLibDir = filename:join(TclDir, "lib"),
    InitScript = filename:nativename(filename:join(PrivDir, "gstk.tcl")),
    true,
    true,
    true,
    {Wish,Options} =
        case filelib:wildcard(filename:join(TclBinDir, "wish*")) of
            [PrivWish|_] ->
                [TclLibrary] =
                    filelib:wildcard(filename:join(PrivDir,
                                                   "tcl/lib/tcl[1-9]*")),
                [TkLibrary] =
                    filelib:wildcard(filename:join(PrivDir,
                                                   "tcl/lib/tk[1-9]*")),
                Opts =
                    [{env,
                      [{"TCL_LIBRARY",TclLibrary},
                       {"TK_LIBRARY",TkLibrary},
                       {"LD_LIBRARY_PATH",TclLibDir}]},
                     {packet,4}],
                {PrivWish,Opts};
            _ ->
                {search_wish(["wish85",
                              "wish8.5",
                              "wish84",
                              "wish8.4",
                              "wish83",
                              "wish8.3",
                              "wish82",
                              "wish8.2",
                              "wish"],
                             Gstk),
                 [{packet,4}]}
        end,
    true,
    Cmd =
        case Mode of
            use_socket ->
                SocketOpts =
                    [{nodelay,true},{packet,4},{reuseaddr,true}],
                {ok,ListenSocket} = gen_tcp:listen(0, SocketOpts),
                {ok,ListenPort} = inet:port(ListenSocket),
                spawn_link(gstk_port_handler,
                           wait_for_connection,
                           [self(),ListenSocket]),
                lists:concat([Wish,
                              " ",
                              InitScript,
                              " -- ",
                              PrivDir,
                              " ",
                              ListenPort]);
            use_port ->
                lists:concat([Wish," ",InitScript," -- ",PrivDir])
        end,
    true,
    Port =
        case timer:tc(erlang, open_port, [{spawn,Cmd},Options]) of
            {_T,Port1} when is_port(Port1) ->
                true,
                link(Port1),
                Port1;
            {_T,{error,_Reason1}} ->
                true,
                Gstk ! {self(),error,backend_died},
                exit(normal)
        end,
    State =
        case Mode of
            use_socket ->
                Sock =
                    receive
                        {connected,Socket} ->
                            Socket;
                        {'EXIT',_Pid,_Reason2} ->
                            Gstk ! {self(),error,backend_died},
                            exit(normal)
                    end,
                true,
                #state{out = {socket,Sock},gstk = Gstk};
            use_port ->
                #state{out = {port,Port},gstk = Gstk}
        end,
    Gstk ! {self(),ok},
    idle(State).

search_wish([], Gstk) ->
    Gstk ! {self(),error,backend_died},
    exit(normal);
search_wish([WishName|WishNames], Gstk) ->
    case os:find_executable(WishName) of
        false ->
            search_wish(WishNames, Gstk);
        Wish ->
            Wish
    end.

wait_for_connection(CallerPid, ListenSocket) ->
    {ok,Sock} = gen_tcp:accept(ListenSocket, 1000 * 20),
    true,
    ok = gen_tcp:controlling_process(Sock, CallerPid),
    CallerPid ! {connected,Sock}.

idle(State) ->
    true,
    receive
        {call,Cmd} ->
            output(State, Cmd),
            idle(State);
        {exec,Cmd} ->
            collect_exec_calls(Cmd, [], 0, State),
            idle(State);
        {_Port,{data,Input}} ->
            true,
            handle_input(State, Input),
            idle(State);
        {tcp,_Sock,Input} ->
            true,
            handle_input(State, Input),
            idle(State);
        {ping,From} ->
            From ! {pong,self(),State#state.out},
            idle(State);
        {stop,From} ->
            From ! {stopped,self()};
        {'EXIT',_Pid,normal} ->
            true,
            idle(State);
        {'EXIT',Pid,Reason} ->
            true,
            exit({port_handler,Pid,Reason});
        Other ->
            true,
            gs:error("gstk_port_handler: got other: ~w~n", [Other]),
            idle(State)
    end.

collect_exec_calls(Cmd, Queue, QueueLen, State) when QueueLen < 4 ->
    receive
        {exec,NewCmd} ->
            collect_exec_calls(NewCmd, [Cmd|Queue], QueueLen + 1, State)
    after
        0 ->
            if
                QueueLen == 0 ->
                    output(State, Cmd);
                true ->
                    output(State, join_cmd_reverse(Cmd, Queue, []))
            end
    end;
collect_exec_calls(Cmd, Queue, _QueueLen, State) ->
    String = join_cmd_reverse(Cmd, Queue, []),
    output(State, String).

join_cmd_reverse(Cmd, [], DeepStr) ->
    [DeepStr|Cmd];
join_cmd_reverse(Cmd, [Cmd1|Cmds], DeepStr) ->
    join_cmd_reverse(Cmd, Cmds, [Cmd1,$;|DeepStr]).

handle_input(State, [Type|Data]) ->
    GstkPid = State#state.gstk,
    case Type of
        1 ->
            handle_event(GstkPid, Data);
        2 ->
            GstkPid ! {result,Data};
        3 ->
            GstkPid ! {bad_result,Data};
        4 ->
            gs:error("gstk_port_handler: error in input : ~s~n", [Data])
    end.

output(#state{out = {socket,Sock}}, Cmd) ->
    true,
    ok = gen_tcp:send(Sock, Cmd);
output(#state{out = {port,Port}}, Cmd) ->
    true,
    Port ! {self(),{command,Cmd}}.

handle_event(GstkPid, Bytes) when is_list(Bytes) ->
    Event = tcl2erl:parse_event(Bytes),
    true,
    gstk:event(GstkPid, Event).



