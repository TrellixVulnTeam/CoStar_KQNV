-file("test/lib/kernel/src/file_server.erl", 1).

-module(file_server).

-behaviour(gen_server).

-export([format_error/1]).

-export([start/0,start_link/0,stop/0]).

-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]).

format_error({_Line,file_server,Reason}) ->
    io_lib:format("~w", [Reason]);
format_error({_Line,Mod,Reason}) ->
    Mod:format_error(Reason);
format_error(ErrorId) ->
    erl_posix_msg:message(ErrorId).

start() ->
    do_start(start).

start_link() ->
    do_start(start_link).

stop() ->
    gen_server:call(file_server_2, stop, infinity).

-type state() :: port().

-spec init([]) -> {ok, state()} | {stop, term()}.

init([]) ->
    process_flag(trap_exit, true),
    case prim_file:start() of
        {ok,Handle} ->
            ets:new(file_io_servers, [named_table]),
            {ok,Handle};
        {error,Reason} ->
            {stop,Reason}
    end.

-spec handle_call(term(), term(), state()) ->
                     {noreply, state()} |
                     {reply,
                      eof | ok | {error, term()} | {ok, term()},
                      state()} |
                     {stop, normal, stopped, state()}.

handle_call({open,Name,ModeList}, {Pid,_Tag} = _From, Handle)
    when is_list(ModeList) ->
    Child = file_io_server:start_link(Pid, Name, ModeList),
    case Child of
        {ok,P} when is_pid(P) ->
            ets:insert(file_io_servers, {P,Name});
        _ ->
            ok
    end,
    {reply,Child,Handle};
handle_call({open,_Name,_Mode}, _From, Handle) ->
    {reply,{error,einval},Handle};
handle_call({read_file,Name}, _From, Handle) ->
    {reply,prim_file:read_file(Name),Handle};
handle_call({write_file,Name,Bin}, _From, Handle) ->
    {reply,prim_file:write_file(Name, Bin),Handle};
handle_call({set_cwd,Name}, _From, Handle) ->
    {reply,prim_file:set_cwd(Handle, Name),Handle};
handle_call({delete,Name}, _From, Handle) ->
    {reply,prim_file:delete(Handle, Name),Handle};
handle_call({rename,Fr,To}, _From, Handle) ->
    {reply,prim_file:rename(Handle, Fr, To),Handle};
handle_call({make_dir,Name}, _From, Handle) ->
    {reply,prim_file:make_dir(Handle, Name),Handle};
handle_call({del_dir,Name}, _From, Handle) ->
    {reply,prim_file:del_dir(Handle, Name),Handle};
handle_call({list_dir,Name}, _From, Handle) ->
    {reply,prim_file:list_dir(Handle, Name),Handle};
handle_call({list_dir_all,Name}, _From, Handle) ->
    {reply,prim_file:list_dir_all(Handle, Name),Handle};
handle_call(get_cwd, _From, Handle) ->
    {reply,prim_file:get_cwd(Handle),Handle};
handle_call({get_cwd}, _From, Handle) ->
    {reply,prim_file:get_cwd(Handle),Handle};
handle_call({get_cwd,Name}, _From, Handle) ->
    {reply,prim_file:get_cwd(Handle, Name),Handle};
handle_call({read_file_info,Name}, _From, Handle) ->
    {reply,prim_file:read_file_info(Handle, Name),Handle};
handle_call({read_file_info,Name,Opts}, _From, Handle) ->
    {reply,prim_file:read_file_info(Handle, Name, Opts),Handle};
handle_call({altname,Name}, _From, Handle) ->
    {reply,prim_file:altname(Handle, Name),Handle};
handle_call({write_file_info,Name,Info}, _From, Handle) ->
    {reply,prim_file:write_file_info(Handle, Name, Info),Handle};
handle_call({write_file_info,Name,Info,Opts}, _From, Handle) ->
    {reply,prim_file:write_file_info(Handle, Name, Info, Opts),Handle};
handle_call({read_link_info,Name}, _From, Handle) ->
    {reply,prim_file:read_link_info(Handle, Name),Handle};
handle_call({read_link_info,Name,Opts}, _From, Handle) ->
    {reply,prim_file:read_link_info(Handle, Name, Opts),Handle};
handle_call({read_link,Name}, _From, Handle) ->
    {reply,prim_file:read_link(Handle, Name),Handle};
handle_call({read_link_all,Name}, _From, Handle) ->
    {reply,prim_file:read_link_all(Handle, Name),Handle};
handle_call({make_link,Old,New}, _From, Handle) ->
    {reply,prim_file:make_link(Handle, Old, New),Handle};
handle_call({make_symlink,Old,New}, _From, Handle) ->
    {reply,prim_file:make_symlink(Handle, Old, New),Handle};
handle_call({copy,SourceName,SourceOpts,DestName,DestOpts,Length},
            _From,
            Handle) ->
    Reply =
        case prim_file:open(SourceName, [read,binary|SourceOpts]) of
            {ok,Source} ->
                SourceReply =
                    case
                        prim_file:open(DestName,
                                       [write,binary|DestOpts])
                    of
                        {ok,Dest} ->
                            DestReply =
                                prim_file:copy(Source, Dest, Length),
                            prim_file:close(Dest),
                            DestReply;
                        {error,_} = Error ->
                            Error
                    end,
                prim_file:close(Source),
                SourceReply;
            {error,_} = Error ->
                Error
        end,
    {reply,Reply,Handle};
handle_call(stop, _From, Handle) ->
    {stop,normal,stopped,Handle};
handle_call(Request, From, Handle) ->
    error_logger:error_msg("handle_call(~p, ~p, _)", [Request,From]),
    {noreply,Handle}.

-spec handle_cast(term(), state()) -> {noreply, state()}.

handle_cast(Msg, State) ->
    error_logger:error_msg("handle_cast(~p, _)", [Msg]),
    {noreply,State}.

-spec handle_info(term(), state()) ->
                     {noreply, state()} | {stop, normal, state()}.

handle_info({'EXIT',Pid,_Reason}, Handle) when is_pid(Pid) ->
    ets:delete(file_io_servers, Pid),
    {noreply,Handle};
handle_info({'EXIT',Handle,_Reason}, Handle) ->
    error_logger:error_msg("Port controlling ~w terminated in ~w",
                           [file_server_2,file_server]),
    {stop,normal,Handle};
handle_info(Info, State) ->
    error_logger:error_msg("handle_Info(~p, _)", [Info]),
    {noreply,State}.

-spec terminate(term(), state()) -> ok.

terminate(_Reason, Handle) ->
    prim_file:stop(Handle).

-spec code_change(term(), state(), term()) -> {ok, state()}.

code_change(_OldVsn, State, _Extra) ->
    {ok,State}.

do_start(Start) ->
    case init:get_argument(master) of
        error ->
            gen_server:Start({local,file_server_2}, file_server, [], []);
        {ok,[[Node]]} ->
            do_start(Start, list_to_atom(Node), file_server_2);
        X ->
            {error,{get_argument,master,X}}
    end.

do_start(Start, Node, Name) ->
    case rpc:call(Node, erlang, whereis, [Name]) of
        Filer when is_pid(Filer); Filer =:= undefined ->
            case catch do_start_slave(Start, Filer, Name) of
                {'EXIT',Reason} ->
                    {error,Reason};
                Result ->
                    Result
            end;
        Other ->
            {error,{no_master,Other}}
    end.

do_start_slave(start_link, Filer, Name) ->
    Self = self(),
    Token = make_ref(),
    Slave =
        spawn_link(fun() ->
                          relay_start(Self, Token, Filer, Name)
                   end),
    receive
        {started,Token} ->
            {ok,Slave}
    end;
do_start_slave(start, Filer, Name) ->
    Self = self(),
    Token = make_ref(),
    Slave =
        spawn(fun() ->
                     relay_start(Self, Token, Filer, Name)
              end),
    SlaveMonitor = monitor(process, Slave),
    receive
        {started,Token} ->
            demonitor(SlaveMonitor, [flush]),
            {ok,Slave};
        {'DOWN',SlaveMonitor,_,_,Reason} ->
            exit(Reason)
    end.

relay_start(Parent, Token, Filer, Name) when is_pid(Filer) ->
    case catch register(Name, self()) of
        true ->
            ok;
        _ ->
            exit({already_started,whereis(Name)})
    end,
    FilerMonitor = monitor(process, Filer),
    process_flag(trap_exit, true),
    Parent ! {started,Token},
    relay_loop(Parent, Filer, FilerMonitor);
relay_start(Parent, Token, undefined, _Name) ->
    process_flag(trap_exit, true),
    Parent ! {started,Token},
    receive
        {'EXIT',Parent,Reason} ->
            exit(Reason)
    end.

relay_loop(Parent, Filer, FilerMonitor) ->
    receive
        {'DOWN',FilerMonitor,_,_,Reason} ->
            exit(Reason);
        {'EXIT',Parent,Reason} ->
            exit(Reason);
        Msg ->
            Filer ! Msg
    end,
    relay_loop(Parent, Filer, FilerMonitor).



