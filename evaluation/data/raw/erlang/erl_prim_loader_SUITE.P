-file("test/lib/kernel/test/erl_prim_loader_SUITE.erl", 1).

-module(erl_prim_loader_SUITE).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/kernel-2.15.3/include/file.hrl",
      1).

-record(file_info,{size :: undefined | non_neg_integer(),
                   type :: undefined
                         | device
                         | directory
                         | other
                         | regular
                         | symlink,
                   access :: undefined
                           | read
                           | write
                           | read_write
                           | none,
                   atime :: undefined | file:date_time() | integer(),
                   mtime :: undefined | file:date_time() | integer(),
                   ctime :: undefined | file:date_time() | integer(),
                   mode :: undefined | integer(),
                   links :: undefined | non_neg_integer(),
                   major_device :: undefined | integer(),
                   minor_device :: undefined | integer(),
                   inode :: undefined | integer(),
                   uid :: undefined | integer(),
                   gid :: undefined | integer()}).

-record(file_descriptor,{module :: undefined | module(),
                         data :: undefined | term()}).

-file("test/lib/kernel/test/erl_prim_loader_SUITE.erl", 22).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/kernel/test/erl_prim_loader_SUITE.erl", 23).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2]).

-export([get_path/1,
         set_path/1,
         get_file/1,
         inet_existing/1,
         inet_coming_up/1,
         inet_disconnects/1,
         multiple_slaves/1,
         file_requests/1,
         local_archive/1,
         remote_archive/1,
         primary_archive/1,
         virtual_dir_in_archive/1]).

-export([init_per_testcase/2,end_per_testcase/2]).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [get_path,
     set_path,
     get_file,
     inet_existing,
     inet_coming_up,
     inet_disconnects,
     multiple_slaves,
     file_requests,
     local_archive,
     remote_archive,
     primary_archive,
     virtual_dir_in_archive].

groups() ->
    [].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

init_per_testcase(Func, Config) when is_atom(Func), is_list(Config) ->
    Dog = test_server:timetrap(test_server:minutes(3)),
    [{watchdog,Dog}|Config].

end_per_testcase(_Func, Config) ->
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog).

get_path(doc) ->
    [];
get_path(Config) when is_list(Config) ->
    case erl_prim_loader:get_path() of
        {ok,Path} when is_list(Path) ->
            ok;
        _ ->
            test_server:fail(get_path)
    end,
    ok.

set_path(doc) ->
    [];
set_path(Config) when is_list(Config) ->
    {ok,Path} = erl_prim_loader:get_path(),
    ok = erl_prim_loader:set_path(Path),
    {ok,Path} = erl_prim_loader:get_path(),
    NewPath = Path ++ ["dummy_dir","/dummy_dir/dummy_dir"],
    ok = erl_prim_loader:set_path(NewPath),
    {ok,NewPath} = erl_prim_loader:get_path(),
    ok = erl_prim_loader:set_path(Path),
    {ok,Path} = erl_prim_loader:get_path(),
    {'EXIT',_} = (catch erl_prim_loader:set_path(not_a_list)),
    {ok,Path} = erl_prim_loader:get_path(),
    ok.

get_file(doc) ->
    [];
get_file(Config) when is_list(Config) ->
    case
        erl_prim_loader:get_file("lists" ++ code:objfile_extension())
    of
        {ok,Bin,File} when is_binary(Bin), is_list(File) ->
            ok;
        _ ->
            test_server:fail(get_valid_file)
    end,
    error = erl_prim_loader:get_file("duuuuuuummmy_file"),
    error = erl_prim_loader:get_file(duuuuuuummmy_file),
    error = erl_prim_loader:get_file({dummy}),
    ok.

inet_existing(doc) ->
    ["Start a node using the 'inet' loading method, ",
     "from an already started boot server."];
inet_existing(Config) when is_list(Config) ->
    Name = erl_prim_test_inet_existing,
    Host = host(),
    Cookie = atom_to_list(erlang:get_cookie()),
    IpStr = ip_str(Host),
    LFlag = get_loader_flag(os:type()),
    Args = LFlag ++ " -hosts " ++ IpStr ++ " -setcookie " ++ Cookie,
    {ok,BootPid} = erl_boot_server:start_link([Host]),
    {ok,Node} = start_node(Name, Args),
    {ok,[["inet"]]} = rpc:call(Node, init, get_argument, [loader]),
    stop_node(Node),
    unlink(BootPid),
    exit(BootPid, kill),
    ok.

inet_coming_up(doc) ->
    ["Start a node using the 'inet' loading method, ",
     "but start the boot server afterwards."];
inet_coming_up(Config) when is_list(Config) ->
    Name = erl_prim_test_inet_coming_up,
    Cookie = atom_to_list(erlang:get_cookie()),
    Host = host(),
    IpStr = ip_str(Host),
    LFlag = get_loader_flag(os:type()),
    Args = LFlag ++ " -hosts " ++ IpStr ++ " -setcookie " ++ Cookie,
    {ok,Node} = start_node(Name, Args, [{wait,false}]),
    test_server:sleep(test_server:seconds(6)),
    io:format("erl_boot_server:start_link([~p]).", [Host]),
    {ok,BootPid} = erl_boot_server:start_link([Host]),
    wait_really_started(Node, 25),
    {ok,[["inet"]]} = rpc:call(Node, init, get_argument, [loader]),
    stop_node(Node),
    unlink(BootPid),
    exit(BootPid, kill),
    ok.

wait_really_started(Node, 0) ->
    test_server:fail({not_booted,Node});
wait_really_started(Node, N) ->
    case rpc:call(Node, init, get_status, []) of
        {started,_} ->
            ok;
        _ ->
            test_server:sleep(1000),
            wait_really_started(Node, N - 1)
    end.

inet_disconnects(doc) ->
    ["Start a node using the 'inet' loading method, ",
     "then lose the connection."];
inet_disconnects(Config) when is_list(Config) ->
    case test_server:is_native(erl_boot_server) of
        true ->
            {skip,"erl_boot_server is native"};
        false ->
            Name = erl_prim_test_inet_disconnects,
            Host = host(),
            Cookie = atom_to_list(erlang:get_cookie()),
            IpStr = ip_str(Host),
            LFlag = get_loader_flag(os:type()),
            Args =
                LFlag ++ " -hosts " ++ IpStr ++ " -setcookie " ++ Cookie,
            {ok,BootPid} = erl_boot_server:start([Host]),
            Self = self(),
            Stopper =
                spawn_link(fun() ->
                                  stop_boot(BootPid, Self)
                           end),
            receive
                {Stopper,ready} ->
                    ok
            end,
            {ok,Node} = start_node(Name, Args, [{wait,false}]),
            receive
                {Stopper,ok} ->
                    ok;
                {Stopper,{error,Reason}} ->
                    test_server:fail(Reason)
            after
                60000 -> test_server:fail(stopper_died)
            end,
            {ok,BootPid2} = erl_boot_server:start_link([Host]),
            wait_really_started(Node, 25),
            {ok,[["inet"]]} =
                rpc:call(Node, init, get_argument, [loader]),
            stop_node(Node),
            unlink(BootPid2),
            exit(BootPid2, kill),
            ok
    end.

stop_boot(BootPid, Super) ->
    erlang:trace(all, true, [call]),
    1 = erlang:trace_pattern({erl_boot_server,send_file_result,3},
                             true,
                             [local]),
    BootRef = monitor(process, BootPid),
    Super ! {self(),ready},
    Result = get_calls(100, BootPid),
    exit(BootPid, kill),
    erlang:trace_pattern({erl_boot_server,send_file_result,3},
                         false,
                         [local]),
    erlang:trace(all, false, [call]),
    receive
        {'DOWN',BootRef,_,_,killed} ->
            ok
    end,
    Super ! {self(),Result}.

get_calls(0, _) ->
    ok;
get_calls(Count, Pid) ->
    receive
        {trace,_,call,_MFA} ->
            get_calls(Count - 1, Pid)
    after
        10000 -> {error,{trace_msg_timeout,Count}}
    end.

multiple_slaves(doc) ->
    ["Start nodes in parallell, all using the 'inet' loading method, ",
     "verify that the boot server manages"];
multiple_slaves(Config) when is_list(Config) ->
    case os:type() of
        {ose,_} ->
            {comment,"OSE: multiple nodes not supported"};
        _ ->
            Name = erl_prim_test_multiple_slaves,
            Host = host(),
            Cookie = atom_to_list(erlang:get_cookie()),
            IpStr = ip_str(Host),
            LFlag = get_loader_flag(os:type()),
            Args =
                LFlag ++ " -hosts " ++ IpStr ++ " -setcookie " ++ Cookie,
            NoOfNodes = 10,
            NamesAndNodes =
                lists:map(fun(N) ->
                                 NameN =
                                     atom_to_list(Name)
                                     ++
                                     integer_to_list(N),
                                 NodeN = NameN ++ "@" ++ Host,
                                 {list_to_atom(NameN),
                                  list_to_atom(NodeN)}
                          end,
                          lists:seq(1, NoOfNodes)),
            Nodes = start_multiple_nodes(NamesAndNodes, Args, []),
            test_server:sleep(test_server:seconds(5)),
            {ok,BootPid} = erl_boot_server:start_link([Host]),
            test_server:sleep(test_server:seconds(10)),
            wait_and_shutdown(lists:reverse(Nodes), 30),
            unlink(BootPid),
            exit(BootPid, kill),
            ok
    end.

start_multiple_nodes([{Name,Node}|NNs], Args, Started) ->
    {ok,Node} = start_node(Name, Args, [{wait,false}]),
    start_multiple_nodes(NNs, Args, [Node|Started]);
start_multiple_nodes([], _, Nodes) ->
    Nodes.

wait_and_shutdown([Node|Nodes], Tries) ->
    wait_really_started(Node, Tries),
    {ok,[["inet"]]} = rpc:call(Node, init, get_argument, [loader]),
    stop_node(Node),
    wait_and_shutdown(Nodes, Tries);
wait_and_shutdown([], _) ->
    ok.

file_requests(doc) ->
    ["Start a node using the 'inet' loading method, ",
     "verify that the boot server responds to file requests."];
file_requests(Config) when is_list(Config) ->
    {ok,Node,BootPid} = complete_start_node(erl_prim_test_file_req),
    {ok,Files} = file:list_dir("."),
    io:format("Files: ~p~n", [Files]),
    {ok,Files} = rpc:call(Node, erl_prim_loader, list_dir, ["."]),
    {ok,Info} = file:read_file_info(code:which(test_server)),
    {ok,Info} =
        rpc:call(Node,
                 erl_prim_loader,
                 read_file_info,
                 [code:which(test_server)]),
    {ok,Cwd} = file:get_cwd(),
    {ok,Cwd} = rpc:call(Node, erl_prim_loader, get_cwd, []),
    case file:get_cwd("C:") of
        {error,enotsup} ->
            ok;
        {ok,DCwd} ->
            {ok,DCwd} = rpc:call(Node, erl_prim_loader, get_cwd, ["C:"])
    end,
    stop_node(Node),
    unlink(BootPid),
    exit(BootPid, kill),
    ok.

complete_start_node(Name) ->
    Host = host(),
    Cookie = atom_to_list(erlang:get_cookie()),
    IpStr = ip_str(Host),
    LFlag = get_loader_flag(os:type()),
    Args = LFlag ++ " -hosts " ++ IpStr ++ " -setcookie " ++ Cookie,
    {ok,BootPid} = erl_boot_server:start_link([Host]),
    {ok,Node} = start_node(Name, Args),
    wait_really_started(Node, 25),
    {ok,Node,BootPid}.

local_archive(suite) ->
    [];
local_archive(doc) ->
    ["Read files from local archive."];
local_archive(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    KernelDir = filename:basename(code:lib_dir(kernel)),
    Archive =
        filename:join([PrivDir,KernelDir ++ init:archive_extension()]),
    file:delete(Archive),
    {ok,Archive} = create_archive(Archive, [KernelDir]),
    Node = node(),
    BeamName = "inet.beam",
    ok = test_archive(Node, Archive, KernelDir, BeamName),
    ok = rpc:call(Node, erl_prim_loader, release_archives, []),
    ok = file:delete(Archive),
    ok.

remote_archive(suite) ->
    {req,[{local_slave_nodes,1},{time,10}]};
remote_archive(doc) ->
    ["Read files from remote archive."];
remote_archive(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    KernelDir = filename:basename(code:lib_dir(kernel)),
    Archive =
        filename:join([PrivDir,KernelDir ++ init:archive_extension()]),
    file:delete(Archive),
    {ok,Archive} = create_archive(Archive, [KernelDir]),
    {ok,Node,BootPid} = complete_start_node(remote_archive),
    BeamName = "inet.beam",
    ok = test_archive(Node, Archive, KernelDir, BeamName),
    stop_node(Node),
    unlink(BootPid),
    exit(BootPid, kill),
    ok.

primary_archive(suite) ->
    {req,[{local_slave_nodes,1},{time,10}]};
primary_archive(doc) ->
    ["Read files from primary archive."];
primary_archive(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Archive = filename:join([PrivDir,"primary_archive.zip"]),
    file:delete(Archive),
    DataDir = test_server:lookup_config(data_dir, Config),
    {ok,_} =
        zip:create(Archive,
                   ["primary_archive"],
                   [{compress,[]},{cwd,DataDir}]),
    {ok,_} = zip:extract(Archive, [{cwd,PrivDir}]),
    TopDir = filename:join([PrivDir,"primary_archive"]),
    DictDir = "primary_archive_dict-1.0",
    DummyDir = "primary_archive_dummy",
    ok = compile_app(TopDir, DictDir),
    ok = compile_app(TopDir, DummyDir),
    {ok,TopFiles} = file:list_dir(TopDir),
    {ok,{_,ArchiveBin}} =
        zip:create(Archive,
                   TopFiles,
                   [memory,{compress,[]},{cwd,TopDir}]),
    Cookie = atom_to_list(erlang:get_cookie()),
    Args = " -setcookie " ++ Cookie,
    {ok,Node} = start_node(primary_archive, Args),
    wait_really_started(Node, 25),
    {_,_,_} = rpc:call(Node, erlang, date, []),
    ExpectedEbins = [Archive,DictDir ++ "/ebin",DummyDir ++ "/ebin"],
    io:format("ExpectedEbins: ~p\n", [ExpectedEbins]),
    {ok,FileInfo} = prim_file:read_file_info(Archive),
    {ok,Ebins} =
        rpc:call(Node,
                 erl_prim_loader,
                 set_primary_archive,
                 [Archive,ArchiveBin,FileInfo,fun escript:parse_file/1]),
    ExpectedEbins = lists:sort(Ebins),
    {ok,TopFiles2} =
        rpc:call(Node, erl_prim_loader, list_dir, [Archive]),
    [DictDir,DummyDir] = lists:sort(TopFiles2),
    BeamName = "primary_archive_dict_app.beam",
    ok = test_archive(Node, Archive, DictDir, BeamName),
    {ok,[]} =
        rpc:call(Node,
                 erl_prim_loader,
                 set_primary_archive,
                 [undefined,
                  undefined,
                  undefined,
                  fun escript:parse_file/1]),
    stop_node(Node),
    ok = file:delete(Archive),
    ok.

test_archive(Node, TopDir, AppDir, BeamName) ->
    io:format("test_archive: ~p\n",
              [rpc:call(Node, erl_prim_loader, list_dir, [TopDir])]),
    {ok,TopFiles} = rpc:call(Node, erl_prim_loader, list_dir, [TopDir]),
    true = lists:member(AppDir, TopFiles),
    AbsAppDir = TopDir ++ "/" ++ AppDir,
    {ok,AppFiles} =
        rpc:call(Node, erl_prim_loader, list_dir, [AbsAppDir]),
    true = lists:member("ebin", AppFiles),
    Ebin = AbsAppDir ++ "/ebin",
    {ok,EbinFiles} = rpc:call(Node, erl_prim_loader, list_dir, [Ebin]),
    Beam = Ebin ++ "/" ++ BeamName,
    true = lists:member(BeamName, EbinFiles),
    error =
        rpc:call(Node,
                 erl_prim_loader,
                 list_dir,
                 [TopDir ++ "/no_such_file"]),
    error =
        rpc:call(Node,
                 erl_prim_loader,
                 list_dir,
                 [TopDir ++ "/ebin/no_such_file"]),
    {ok,#file_info{type = directory}} =
        rpc:call(Node, erl_prim_loader, read_file_info, [TopDir]),
    {ok,#file_info{type = directory}} =
        rpc:call(Node, erl_prim_loader, read_file_info, [Ebin]),
    {ok,#file_info{type = regular} = FI} =
        rpc:call(Node, erl_prim_loader, read_file_info, [Beam]),
    error =
        rpc:call(Node,
                 erl_prim_loader,
                 read_file_info,
                 [TopDir ++ "/no_such_file"]),
    error =
        rpc:call(Node,
                 erl_prim_loader,
                 read_file_info,
                 [TopDir ++ "/ebin/no_such_file"]),
    {ok,Bin,Beam} = rpc:call(Node, erl_prim_loader, get_file, [Beam]),
    if
        FI#file_info.size =:= byte_size(Bin) ->
            ok;
        true ->
            exit({FI#file_info.size,byte_size(Bin)})
    end,
    error = rpc:call(Node, erl_prim_loader, get_file, ["/no_such_file"]),
    error =
        rpc:call(Node,
                 erl_prim_loader,
                 get_file,
                 ["/ebin/no_such_file"]),
    ok.

create_archive(Archive, AppDirs) ->
    LibDir = code:lib_dir(),
    Opts = [{compress,[]},{cwd,LibDir}],
    io:format("zip:create(~p,\n\t~p,\n\t~p).\n", [Archive,AppDirs,Opts]),
    zip:create(Archive, AppDirs, Opts).

virtual_dir_in_archive(suite) ->
    [];
virtual_dir_in_archive(doc) ->
    ["Read virtual directories from archive."];
virtual_dir_in_archive(Config) when is_list(Config) ->
    PrivDir = test_server:lookup_config(priv_dir, Config),
    Data = <<"A little piece of data.">>,
    ArchiveBase = "archive_with_virtual_dirs",
    Archive =
        filename:join([PrivDir,ArchiveBase ++ init:archive_extension()]),
    FileBase = "a_data_file.beam",
    EbinBase = "ebin",
    FileInArchive = filename:join([ArchiveBase,EbinBase,FileBase]),
    BinFiles = [{FileInArchive,Data}],
    Opts = [{compress,[]}],
    file:delete(Archive),
    io:format("zip:create(~p,\n\t~p,\n\t~p).\n",
              [Archive,BinFiles,Opts]),
    {ok,Archive} = zip:create(Archive, BinFiles, Opts),
    {ok,BinFiles} = zip:unzip(Archive, [memory]),
    FullPath = filename:join([Archive,FileInArchive]),
    {ok,_} = erl_prim_loader:read_file_info(FullPath),
    EbinDir = filename:dirname(FullPath),
    {ok,_} = erl_prim_loader:read_file_info(EbinDir),
    {ok,[FileBase]} = erl_prim_loader:list_dir(EbinDir),
    AppDir = filename:dirname(EbinDir),
    {ok,_} = erl_prim_loader:read_file_info(AppDir),
    {ok,[EbinBase]} = erl_prim_loader:list_dir(AppDir),
    ok = erl_prim_loader:release_archives(),
    ok = file:delete(Archive),
    ok.

ip_str({A,B,C,D}) ->
    lists:concat([A,".",B,".",C,".",D]);
ip_str(Host) ->
    {ok,Ip} = inet:getaddr(Host, inet),
    ip_str(Ip).

start_node(Name, Args) ->
    start_node(Name, Args, []).

start_node(Name, Args, Opts) ->
    Opts2 = [{args,Args}|Opts],
    io:format("test_server:start_node(~p, peer, ~p).\n", [Name,Opts2]),
    Res = test_server:start_node(Name, peer, Opts2),
    io:format("start_node -> ~p\n", [Res]),
    Res.

host() ->
    {ok,Host} = inet:gethostname(),
    Host.

stop_node(Node) ->
    test_server:stop_node(Node).

get_loader_flag(_) ->
    " -loader inet ".

compile_app(TopDir, AppName) ->
    AppDir = filename:join([TopDir,AppName]),
    SrcDir = filename:join([AppDir,"src"]),
    OutDir = filename:join([AppDir,"ebin"]),
    {ok,Files} = file:list_dir(SrcDir),
    compile_files(Files, SrcDir, OutDir).

compile_files([File|Files], SrcDir, OutDir) ->
    case filename:extension(File) of
        ".erl" ->
            AbsFile = filename:join([SrcDir,File]),
            case compile:file(AbsFile, [{outdir,OutDir}]) of
                {ok,_Mod} ->
                    compile_files(Files, SrcDir, OutDir);
                Error ->
                    {compilation_error,AbsFile,OutDir,Error}
            end;
        _ ->
            compile_files(Files, SrcDir, OutDir)
    end;
compile_files([], _, _) ->
    ok.



