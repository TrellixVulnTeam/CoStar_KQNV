-file("test/lib/test_server/src/erl2html2.erl", 1).

-module(erl2html2).

-export([convert/2,convert/3]).

convert([], _Dest) ->
    ok;
convert(File, Dest) ->
    Encoding = encoding(File),
    Header =
        ["<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n<!"
         "-- autogenerated by '",
         atom_to_list(erl2html2),
         "'. -->\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" con"
         "tent=\"text/html;charset=",
         html_encoding(Encoding),
         "\"/>\n<title>",
         to_raw_list(File, Encoding),
         "</title>\n</head>\n\n<body bgcolor=\"white\" text=\"black\" l"
         "ink=\"blue\" vlink=\"purple\" alink=\"red\">\n"],
    convert(File, Dest, Header).

convert(File, Dest, Header) ->
    case parse_file(File) of
        {ok,Functions} ->
            case file:open(File, [raw,{read_ahead,10000}]) of
                {ok,SFd} ->
                    case file:open(Dest, [write,raw]) of
                        {ok,DFd} ->
                            file:write(DFd, [Header,"<pre>\n"]),
                            _Lines =
                                build_html(SFd,
                                           DFd,
                                           encoding(File),
                                           Functions),
                            file:write(DFd,
                                       ["</pre>\n",
                                        footer(),
                                        "</body>\n</html>\n"]),
                            file:close(SFd),
                            file:close(DFd),
                            ok;
                        Error ->
                            Error
                    end;
                Error ->
                    Error
            end;
        Error ->
            Error
    end.

parse_file(File) ->
    case epp:open(File, [], []) of
        {ok,Epp} ->
            Forms = parse_file(Epp, File, false),
            epp:close(Epp),
            {ok,Forms};
        {error,E} ->
            {error,E}
    end.

parse_file(Epp, File, InCorrectFile) ->
    case epp:parse_erl_form(Epp) of
        {ok,Form} ->
            case Form of
                {attribute,_,file,{File,_}} ->
                    parse_file(Epp, File, true);
                {attribute,_,file,{_OtherFile,_}} ->
                    parse_file(Epp, File, false);
                {function,L,F,A,[_|C]} when InCorrectFile ->
                    Clauses =
                        [ 
                         {clause,CL} ||
                             {clause,CL,_,_,_} <- C
                        ],
                    [{atom_to_list(F),A,L}|Clauses]
                    ++
                    parse_file(Epp, File, true);
                _ ->
                    parse_file(Epp, File, InCorrectFile)
            end;
        {error,_E} ->
            parse_file(Epp, File, InCorrectFile);
        {eof,_Location} ->
            []
    end.

build_html(SFd, DFd, Encoding, Functions) ->
    build_html(SFd,
               DFd,
               Encoding,
               file:read_line(SFd),
               1,
               Functions,
               false).

build_html(SFd,
           DFd,
           Encoding,
           {ok,Str},
           L,
           [{F,A,L}|Functions],
           _IsFuncDef) ->
    FALink =
        test_server_ctrl:uri_encode(F ++ "-" ++ integer_to_list(A),
                                    utf8),
    file:write(DFd, ["<a name=\"",to_raw_list(FALink, Encoding),"\"/>"]),
    build_html(SFd, DFd, Encoding, {ok,Str}, L, Functions, true);
build_html(SFd,
           DFd,
           Encoding,
           {ok,Str},
           L,
           [{clause,L}|Functions],
           _IsFuncDef) ->
    build_html(SFd, DFd, Encoding, {ok,Str}, L, Functions, true);
build_html(SFd, DFd, Encoding, {ok,Str}, L, Functions, IsFuncDef) ->
    LStr = line_number(L),
    Str1 = line(Str, IsFuncDef),
    file:write(DFd, [LStr,Str1]),
    build_html(SFd,
               DFd,
               Encoding,
               file:read_line(SFd),
               L + 1,
               Functions,
               false);
build_html(_SFd, _DFd, _Encoding, eof, L, _Functions, _IsFuncDef) ->
    L.

line_number(L) ->
    LStr = integer_to_list(L),
    Pred =
        case length(LStr) of
            Length when Length < 5 ->
                lists:duplicate(5 - Length, $\s);
            _ ->
                []
        end,
    ["<a name=\"",LStr,"\"/>",Pred,LStr,": "].

line(Str, IsFuncDef) ->
    Str1 = htmlize(Str),
    possibly_enhance(Str1, IsFuncDef).

htmlize([$<|Str]) ->
    [$&,$l,$t,$;|htmlize(Str)];
htmlize([$>|Str]) ->
    [$&,$g,$t,$;|htmlize(Str)];
htmlize([$&|Str]) ->
    [$&,$a,$m,$p,$;|htmlize(Str)];
htmlize([$"|Str]) ->
    [$&,$q,$u,$o,$t,$;|htmlize(Str)];
htmlize([Ch|Str]) ->
    [Ch|htmlize(Str)];
htmlize([]) ->
    [].

possibly_enhance(Str, true) ->
    case
        lists:splitwith(fun($() ->
                               false;
                           (_) ->
                               true
                        end,
                        Str)
    of
        {_,[]} ->
            Str;
        {F,A} ->
            ["<b>",F,"</b>",A]
    end;
possibly_enhance([$%|_] = Str, _) ->
    ["<i>",Str -- "\n","</i>","\n"];
possibly_enhance([$-|_] = Str, _) ->
    possibly_enhance(Str, true);
possibly_enhance(Str, false) ->
    Str.

footer() ->
    "".

encoding(File) ->
    case epp:read_encoding(File) of
        none ->
            epp:default_encoding();
        E ->
            E
    end.

html_encoding(latin1) ->
    "iso-8859-1";
html_encoding(utf8) ->
    "utf-8".

to_raw_list(X, latin1) when is_list(X) ->
    X;
to_raw_list(X, utf8) when is_list(X) ->
    binary_to_list(unicode:characters_to_binary(X)).



