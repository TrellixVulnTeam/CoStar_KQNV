-file("test/lib/kernel/src/gen_tcp.erl", 1).

-module(gen_tcp).

-export([connect/3,
         connect/4,
         listen/2,
         accept/1,
         accept/2,
         shutdown/2,
         close/1]).

-export([send/2,recv/2,recv/3,unrecv/2]).

-export([controlling_process/2]).

-export([fdopen/2]).

-file("test/lib/kernel/src/inet_int.hrl", 1).

-record(connect_opts,{ifaddr = any,port = 0,fd = - 1,opts = []}).

-record(listen_opts,{ifaddr = any,
                     port = 0,
                     backlog = 5,
                     fd = - 1,
                     opts = []}).

-record(udp_opts,{ifaddr = any,port = 0,fd = - 1,opts = [{active,true}]}).

-record(sctp_opts,{ifaddr,
                   port = 0,
                   fd = - 1,
                   type = seqpacket,
                   opts =
                       [{mode,binary},
                        {buffer,65536},
                        {sndbuf,65536},
                        {recbuf,1024},
                        {sctp_events,undefined}]}).

-file("test/lib/kernel/src/gen_tcp.erl", 30).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/kernel/src/../include/file.hrl",
      1).

-record(file_info,{size :: undefined | non_neg_integer(),
                   type :: undefined
                         | device
                         | directory
                         | other
                         | regular
                         | symlink,
                   access :: undefined
                           | read
                           | write
                           | read_write
                           | none,
                   atime :: undefined
                          | file:date_time()
                          | non_neg_integer(),
                   mtime :: undefined
                          | file:date_time()
                          | non_neg_integer(),
                   ctime :: undefined
                          | file:date_time()
                          | non_neg_integer(),
                   mode :: undefined | non_neg_integer(),
                   links :: undefined | non_neg_integer(),
                   major_device :: undefined | non_neg_integer(),
                   minor_device :: undefined | non_neg_integer(),
                   inode :: undefined | non_neg_integer(),
                   uid :: undefined | non_neg_integer(),
                   gid :: undefined | non_neg_integer()}).

-record(file_descriptor,{module :: undefined | module(),
                         data :: undefined | term()}).

-file("test/lib/kernel/src/gen_tcp.erl", 31).

-type option() :: {active, true | false | once}
                | {buffer, non_neg_integer()}
                | {delay_send, boolean()}
                | {deliver, port | term}
                | {dontroute, boolean()}
                | {exit_on_close, boolean()}
                | {header, non_neg_integer()}
                | {high_msgq_watermark, pos_integer()}
                | {high_watermark, non_neg_integer()}
                | {keepalive, boolean()}
                | {linger, {boolean(), non_neg_integer()}}
                | {low_msgq_watermark, pos_integer()}
                | {low_watermark, non_neg_integer()}
                | {mode, list | binary}
                | list
                | binary
                | {nodelay, boolean()}
                | {packet,
                   0 |
                   1 |
                   2 |
                   4 |
                   raw |
                   sunrm |
                   asn1 |
                   cdr |
                   fcgi |
                   line |
                   tpkt |
                   http |
                   httph |
                   http_bin |
                   httph_bin}
                | {packet_size, non_neg_integer()}
                | {priority, non_neg_integer()}
                | {raw,
                   Protocol :: non_neg_integer(),
                   OptionNum :: non_neg_integer(),
                   ValueBin :: binary()}
                | {recbuf, non_neg_integer()}
                | {reuseaddr, boolean()}
                | {send_timeout, non_neg_integer() | infinity}
                | {send_timeout_close, boolean()}
                | {sndbuf, non_neg_integer()}
                | {tos, non_neg_integer()}
                | {ipv6_v6only, boolean()}.

-type option_name() :: active
                     | buffer
                     | delay_send
                     | deliver
                     | dontroute
                     | exit_on_close
                     | header
                     | high_msgq_watermark
                     | high_watermark
                     | keepalive
                     | linger
                     | low_msgq_watermark
                     | low_watermark
                     | mode
                     | nodelay
                     | packet
                     | packet_size
                     | priority
                     | {raw,
                        Protocol :: non_neg_integer(),
                        OptionNum :: non_neg_integer(),
                        ValueSpec :: (ValueSize :: non_neg_integer())
                                   | (ValueBin :: binary())}
                     | recbuf
                     | reuseaddr
                     | send_timeout
                     | send_timeout_close
                     | sndbuf
                     | tos
                     | ipv6_v6only.

-type connect_option() :: {ip, inet:ip_address()}
                        | {fd, Fd :: non_neg_integer()}
                        | {ifaddr, inet:ip_address()}
                        | inet:address_family()
                        | {port, inet:port_number()}
                        | {tcp_module, module()}
                        | option().

-type listen_option() :: {ip, inet:ip_address()}
                       | {fd, Fd :: non_neg_integer()}
                       | {ifaddr, inet:ip_address()}
                       | inet:address_family()
                       | {port, inet:port_number()}
                       | {backlog, B :: non_neg_integer()}
                       | {tcp_module, module()}
                       | option().

-type socket() :: port().

-export_type([{option,0},
              {option_name,0},
              {connect_option,0},
              {listen_option,0}]).

-spec connect(Address, Port, Options) -> {ok, Socket} | {error, Reason}
                 when
                     is_subtype(Address,
                                inet:ip_address() | inet:hostname()),
                     is_subtype(Port, inet:port_number()),
                     is_subtype(Options, [connect_option()]),
                     is_subtype(Socket, socket()),
                     is_subtype(Reason, inet:posix()).

connect(Address, Port, Opts) ->
    connect(Address, Port, Opts, infinity).

-spec connect(Address, Port, Options, Timeout) ->
                 {ok, Socket} | {error, Reason}
                 when
                     is_subtype(Address,
                                inet:ip_address() | inet:hostname()),
                     is_subtype(Port, inet:port_number()),
                     is_subtype(Options, [connect_option()]),
                     is_subtype(Timeout, timeout()),
                     is_subtype(Socket, socket()),
                     is_subtype(Reason, inet:posix()).

connect(Address, Port, Opts, Time) ->
    Timer = inet:start_timer(Time),
    Res = (catch connect1(Address, Port, Opts, Timer)),
    inet:stop_timer(Timer),
    case Res of
        {ok,S} ->
            {ok,S};
        {error,einval} ->
            exit(badarg);
        {'EXIT',Reason} ->
            exit(Reason);
        Error ->
            Error
    end.

connect1(Address, Port, Opts, Timer) ->
    Mod = mod(Opts, Address),
    case Mod:getaddrs(Address, Timer) of
        {ok,IPs} ->
            case Mod:getserv(Port) of
                {ok,TP} ->
                    try_connect(IPs,
                                TP,
                                Opts,
                                Timer,
                                Mod,
                                {error,einval});
                Error ->
                    Error
            end;
        Error ->
            Error
    end.

try_connect([IP|IPs], Port, Opts, Timer, Mod, _) ->
    Time = inet:timeout(Timer),
    case Mod:connect(IP, Port, Opts, Time) of
        {ok,S} ->
            {ok,S};
        {error,einval} ->
            {error,einval};
        {error,timeout} ->
            {error,timeout};
        Err1 ->
            try_connect(IPs, Port, Opts, Timer, Mod, Err1)
    end;
try_connect([], _Port, _Opts, _Timer, _Mod, Err) ->
    Err.

-spec listen(Port, Options) -> {ok, ListenSocket} | {error, Reason}
                when
                    is_subtype(Port, inet:port_number()),
                    is_subtype(Options, [listen_option()]),
                    is_subtype(ListenSocket, socket()),
                    is_subtype(Reason, system_limit | inet:posix()).

listen(Port, Opts) ->
    Mod = mod(Opts, undefined),
    case Mod:getserv(Port) of
        {ok,TP} ->
            Mod:listen(TP, Opts);
        {error,einval} ->
            exit(badarg);
        Other ->
            Other
    end.

-spec accept(ListenSocket) -> {ok, Socket} | {error, Reason}
                when
                    is_subtype(ListenSocket, socket()),
                    is_subtype(Socket, socket()),
                    is_subtype(Reason,
                               closed |
                               timeout |
                               system_limit |
                               inet:posix()).

accept(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:accept(S);
        Error ->
            Error
    end.

-spec accept(ListenSocket, Timeout) -> {ok, Socket} | {error, Reason}
                when
                    is_subtype(ListenSocket, socket()),
                    is_subtype(Timeout, timeout()),
                    is_subtype(Socket, socket()),
                    is_subtype(Reason,
                               closed |
                               timeout |
                               system_limit |
                               inet:posix()).

accept(S, Time) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:accept(S, Time);
        Error ->
            Error
    end.

-spec shutdown(Socket, How) -> ok | {error, Reason}
                  when
                      is_subtype(Socket, socket()),
                      is_subtype(How, read | write | read_write),
                      is_subtype(Reason, inet:posix()).

shutdown(S, How) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:shutdown(S, How);
        Error ->
            Error
    end.

-spec close(Socket) -> ok when is_subtype(Socket, socket()).

close(S) ->
    inet:tcp_close(S).

-spec send(Socket, Packet) -> ok | {error, Reason}
              when
                  is_subtype(Socket, socket()),
                  is_subtype(Packet, iodata()),
                  is_subtype(Reason, closed | inet:posix()).

send(S, Packet) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:send(S, Packet);
        Error ->
            Error
    end.

-spec recv(Socket, Length) -> {ok, Packet} | {error, Reason}
              when
                  is_subtype(Socket, socket()),
                  is_subtype(Length, non_neg_integer()),
                  is_subtype(Packet, string() | binary() | HttpPacket),
                  is_subtype(Reason, closed | inet:posix()),
                  is_subtype(HttpPacket, term()).

recv(S, Length) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:recv(S, Length);
        Error ->
            Error
    end.

-spec recv(Socket, Length, Timeout) -> {ok, Packet} | {error, Reason}
              when
                  is_subtype(Socket, socket()),
                  is_subtype(Length, non_neg_integer()),
                  is_subtype(Timeout, timeout()),
                  is_subtype(Packet, string() | binary() | HttpPacket),
                  is_subtype(Reason, closed | inet:posix()),
                  is_subtype(HttpPacket, term()).

recv(S, Length, Time) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:recv(S, Length, Time);
        Error ->
            Error
    end.

unrecv(S, Data) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:unrecv(S, Data);
        Error ->
            Error
    end.

-spec controlling_process(Socket, Pid) -> ok | {error, Reason}
                             when
                                 is_subtype(Socket, socket()),
                                 is_subtype(Pid, pid()),
                                 is_subtype(Reason,
                                            closed |
                                            not_owner |
                                            inet:posix()).

controlling_process(S, NewOwner) ->
    case inet_db:lookup_socket(S) of
        {ok,_Mod} ->
            inet:tcp_controlling_process(S, NewOwner);
        Error ->
            Error
    end.

fdopen(Fd, Opts) ->
    Mod = mod(Opts, undefined),
    Mod:fdopen(Fd, Opts).

mod(Address) ->
    case inet_db:tcp_module() of
        inet_tcp when tuple_size(Address) =:= 8 ->
            inet6_tcp;
        Mod ->
            Mod
    end.

mod([{tcp_module,Mod}|_], _Address) ->
    Mod;
mod([inet|_], _Address) ->
    inet_tcp;
mod([inet6|_], _Address) ->
    inet6_tcp;
mod([{ip,Address}|Opts], _) ->
    mod(Opts, Address);
mod([{ifaddr,Address}|Opts], _) ->
    mod(Opts, Address);
mod([_|Opts], Address) ->
    mod(Opts, Address);
mod([], Address) ->
    mod(Address).



