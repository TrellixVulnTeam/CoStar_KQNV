-file("test/lib/inets/src/ftp/ftp.erl", 1).

-module(ftp).

-behaviour(gen_server).

-behaviour(inets_service).

-export([cd/2,
         close/1,
         delete/2,
         formaterror/1,
         lcd/2,
         lpwd/1,
         ls/1,
         ls/2,
         mkdir/2,
         nlist/1,
         nlist/2,
         open/1,
         open/2,
         pwd/1,
         quote/2,
         recv/2,
         recv/3,
         recv_bin/2,
         recv_chunk_start/2,
         recv_chunk/1,
         rename/3,
         rmdir/2,
         send/2,
         send/3,
         send_bin/3,
         send_chunk_start/2,
         send_chunk/2,
         send_chunk_end/1,
         type/2,
         user/3,
         user/4,
         account/2,
         append/3,
         append/2,
         append_bin/3,
         append_chunk/2,
         append_chunk_end/1,
         append_chunk_start/2,
         info/1]).

-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]).

-export([start_link/1,start_link/2]).

-export([start_standalone/1,
         start_service/1,
         stop_service/1,
         services/0,
         service_info/1]).

-file("test/lib/inets/src/ftp/ftp_internal.hrl", 1).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/inets-5.9.2/src/inets_app/inets_internal.hrl",
      1).

-file("test/lib/inets/src/ftp/ftp_internal.hrl", 25).

-file([], 25).

-file("test/lib/inets/src/ftp/ftp.erl", 56).

-record(state,{csock = undefined,
               dsock = undefined,
               verbose = false,
               ldir = undefined,
               type = ftp_server_default,
               chunk = false,
               mode = passive,
               timeout = 60 * 1000,
               data = <<>>,
               ctrl_data = {<<>>,[],start},
               owner = undefined,
               client = undefined,
               caller = undefined,
               ipfamily,
               progress = ignore,
               dtimeout = infinity}).

-type shortage_reason() :: etnospc | epnospc.

-type restriction_reason() :: epath | efnamena | elogin | enotbinary.

-type common_reason() :: econn | eclosed | term().

-type file_write_error_reason() :: term().

-spec open(Host :: string() | inet:ip_address()) ->
              {ok, Pid :: pid()} | {error, Reason :: ehost | term()}.

open({option_list,Options}) when is_list(Options) ->
    try
        {ok,StartOptions} = start_options(Options),
        {ok,OpenOptions} = open_options(Options),
        case
            ftp_sup:start_child([[[{client,self()}|StartOptions],[]]])
        of
            {ok,Pid} ->
                call(Pid, {open,ip_comm,OpenOptions}, plain);
            Error1 ->
                Error1
        end
    catch
        Error2 ->
            Error2
    end;
open(Host) ->
    open(Host, []).

-spec open(Host :: string() | inet:ip_address(), Opts :: list()) ->
              {ok, Pid :: pid()} | {error, Reason :: ehost | term()}.

open(Host, Port) when is_integer(Port) ->
    open(Host, [{port,Port}]);
open(Host, Opts) when is_list(Opts) ->
    inets_trace:report_event(80,
                             "open",
                             ftpc,
                             [{module,ftp},
                              {line,149},
                              {host,Host},
                              {opts,Opts}]),
    try
        {ok,StartOptions} = start_options(Opts),
        inets_trace:report_event(80,
                                 "open",
                                 ftpc,
                                 [{module,ftp},
                                  {line,152},
                                  {start_options,StartOptions}]),
        {ok,OpenOptions} = open_options([{host,Host}|Opts]),
        inets_trace:report_event(80,
                                 "open",
                                 ftpc,
                                 [{module,ftp},
                                  {line,154},
                                  {open_options,OpenOptions}]),
        case start_link(StartOptions, []) of
            {ok,Pid} ->
                inets_trace:report_event(80,
                                         "open - ok",
                                         ftpc,
                                         [{module,ftp},
                                          {line,157},
                                          {pid,Pid}]),
                call(Pid, {open,ip_comm,OpenOptions}, plain);
            Error1 ->
                inets_trace:report_event(80,
                                         "open - error",
                                         ftpc,
                                         [{module,ftp},
                                          {line,160},
                                          {error1,Error1}]),
                Error1
        end
    catch
        Error2 ->
            inets_trace:report_event(80,
                                     "open - error",
                                     ftpc,
                                     [{module,ftp},
                                      {line,165},
                                      {error2,Error2}]),
            Error2
    end.

-spec user(Pid :: pid(), User :: string(), Pass :: string()) ->
              ok | {error, Reason :: euser | common_reason()}.

user(Pid, User, Pass) ->
    call(Pid, {user,User,Pass}, atom).

-spec user(Pid :: pid(),
           User :: string(),
           Pass :: string(),
           Acc :: string()) ->
              ok | {error, Reason :: euser | common_reason()}.

user(Pid, User, Pass, Acc) ->
    call(Pid, {user,User,Pass,Acc}, atom).

-spec account(Pid :: pid(), Acc :: string()) ->
                 ok | {error, Reason :: eacct | common_reason()}.

account(Pid, Acc) ->
    call(Pid, {account,Acc}, atom).

-spec pwd(Pid :: pid()) ->
             {ok, Dir :: string()} |
             {error, Reason :: restriction_reason() | common_reason()}.

pwd(Pid) ->
    call(Pid, pwd, ctrl).

-spec lpwd(Pid :: pid()) -> {ok, Dir :: string()}.

lpwd(Pid) ->
    call(Pid, lpwd, string).

-spec cd(Pid :: pid(), Dir :: string()) ->
            ok |
            {error, Reason :: restriction_reason() | common_reason()}.

cd(Pid, Dir) ->
    call(Pid, {cd,Dir}, atom).

-spec lcd(Pid :: pid(), Dir :: string()) ->
             ok | {error, Reason :: restriction_reason()}.

lcd(Pid, Dir) ->
    call(Pid, {lcd,Dir}, string).

-spec ls(Pid :: pid()) ->
            {ok, Listing :: string()} |
            {error, Reason :: restriction_reason() | common_reason()}.

ls(Pid) ->
    ls(Pid, "").

-spec ls(Pid :: pid(), Dir :: string()) ->
            {ok, Listing :: string()} |
            {error, Reason :: restriction_reason() | common_reason()}.

ls(Pid, Dir) ->
    call(Pid, {dir,long,Dir}, string).

-spec nlist(Pid :: pid()) ->
               {ok, Listing :: string()} |
               {error, Reason :: restriction_reason() | common_reason()}.

nlist(Pid) ->
    nlist(Pid, "").

-spec nlist(Pid :: pid(), Pathname :: string()) ->
               {ok, Listing :: string()} |
               {error, Reason :: restriction_reason() | common_reason()}.

nlist(Pid, Dir) ->
    call(Pid, {dir,short,Dir}, string).

-spec rename(Pid :: pid(), Old :: string(), New :: string()) ->
                ok |
                {error,
                 Reason :: restriction_reason() | common_reason()}.

rename(Pid, Old, New) ->
    call(Pid, {rename,Old,New}, string).

-spec delete(Pid :: pid(), File :: string()) ->
                ok |
                {error,
                 Reason :: restriction_reason() | common_reason()}.

delete(Pid, File) ->
    call(Pid, {delete,File}, string).

-spec mkdir(Pid :: pid(), Dir :: string()) ->
               ok |
               {error, Reason :: restriction_reason() | common_reason()}.

mkdir(Pid, Dir) ->
    call(Pid, {mkdir,Dir}, atom).

-spec rmdir(Pid :: pid(), Dir :: string()) ->
               ok |
               {error, Reason :: restriction_reason() | common_reason()}.

rmdir(Pid, Dir) ->
    call(Pid, {rmdir,Dir}, atom).

-spec type(Pid :: pid(), Type :: ascii | binary) ->
              ok |
              {error,
               Reason :: etype | restriction_reason() | common_reason()}.

type(Pid, Type) ->
    call(Pid, {type,Type}, atom).

-spec recv(Pid :: pid(), RemoteFileName :: string()) ->
              ok |
              {error,
               Reason :: restriction_reason()
                       | common_reason()
                       | file_write_error_reason()}.

recv(Pid, RemotFileName) ->
    recv(Pid, RemotFileName, RemotFileName).

-spec recv(Pid :: pid(),
           RemoteFileName :: string(),
           LocalFileName :: string()) ->
              ok | {error, Reason :: term()}.

recv(Pid, RemotFileName, LocalFileName) ->
    call(Pid, {recv,RemotFileName,LocalFileName}, atom).

-spec recv_bin(Pid :: pid(), RemoteFile :: string()) ->
                  {ok, Bin :: binary()} |
                  {error,
                   Reason :: restriction_reason() | common_reason()}.

recv_bin(Pid, RemoteFile) ->
    call(Pid, {recv_bin,RemoteFile}, bin).

-spec recv_chunk_start(Pid :: pid(), RemoteFile :: string()) ->
                          ok |
                          {error,
                           Reason :: restriction_reason()
                                   | common_reason()}.

recv_chunk_start(Pid, RemoteFile) ->
    call(Pid, {recv_chunk_start,RemoteFile}, atom).

-spec recv_chunk(Pid :: pid()) ->
                    ok |
                    {ok, Bin :: binary()} |
                    {error,
                     Reason :: restriction_reason() | common_reason()}.

recv_chunk(Pid) ->
    call(Pid, recv_chunk, atom).

-spec send(Pid :: pid(), LocalFileName :: string()) ->
              ok |
              {error,
               Reason :: restriction_reason()
                       | common_reason()
                       | shortage_reason()}.

send(Pid, LocalFileName) ->
    send(Pid, LocalFileName, LocalFileName).

-spec send(Pid :: pid(),
           LocalFileName :: string(),
           RemoteFileName :: string()) ->
              ok |
              {error,
               Reason :: restriction_reason()
                       | common_reason()
                       | shortage_reason()}.

send(Pid, LocalFileName, RemotFileName) ->
    call(Pid, {send,LocalFileName,RemotFileName}, atom).

-spec send_bin(Pid :: pid(), Bin :: binary(), RemoteFile :: string()) ->
                  ok |
                  {error,
                   Reason :: restriction_reason()
                           | common_reason()
                           | shortage_reason()}.

send_bin(Pid, Bin, RemoteFile) when is_binary(Bin) ->
    call(Pid, {send_bin,Bin,RemoteFile}, atom);
send_bin(_Pid, _Bin, _RemoteFile) ->
    {error,enotbinary}.

-spec send_chunk_start(Pid :: pid(), RemoteFile :: string()) ->
                          ok |
                          {error,
                           Reason :: restriction_reason()
                                   | common_reason()}.

send_chunk_start(Pid, RemoteFile) ->
    call(Pid, {send_chunk_start,RemoteFile}, atom).

-spec append_chunk_start(Pid :: pid(), RemoteFile :: string()) ->
                            ok | {error, Reason :: term()}.

append_chunk_start(Pid, RemoteFile) ->
    call(Pid, {append_chunk_start,RemoteFile}, atom).

-spec send_chunk(Pid :: pid(), Bin :: binary()) ->
                    ok |
                    {error,
                     Reason :: echunk
                             | restriction_reason()
                             | common_reason()}.

send_chunk(Pid, Bin) when is_binary(Bin) ->
    call(Pid, {transfer_chunk,Bin}, atom);
send_chunk(_Pid, _Bin) ->
    {error,enotbinary}.

-spec append_chunk(Pid :: pid(), Bin :: binary()) ->
                      ok |
                      {error,
                       Reason :: echunk
                               | restriction_reason()
                               | common_reason()}.

append_chunk(Pid, Bin) when is_binary(Bin) ->
    call(Pid, {transfer_chunk,Bin}, atom);
append_chunk(_Pid, _Bin) ->
    {error,enotbinary}.

-spec send_chunk_end(Pid :: pid()) ->
                        ok |
                        {error,
                         Reason :: restriction_reason()
                                 | common_reason()
                                 | shortage_reason()}.

send_chunk_end(Pid) ->
    call(Pid, chunk_end, atom).

-spec append_chunk_end(Pid :: pid()) ->
                          ok |
                          {error,
                           Reason :: restriction_reason()
                                   | common_reason()
                                   | shortage_reason()}.

append_chunk_end(Pid) ->
    call(Pid, chunk_end, atom).

-spec append(Pid :: pid(), LocalFileName :: string()) ->
                ok |
                {error,
                 Reason :: epath
                         | elogin
                         | etnospc
                         | epnospc
                         | efnamena
                         | common_reason()}.

append(Pid, LocalFileName) ->
    append(Pid, LocalFileName, LocalFileName).

-spec append(Pid :: pid(),
             LocalFileName :: string(),
             RemoteFileName :: string()) ->
                ok | {error, Reason :: term()}.

append(Pid, LocalFileName, RemotFileName) ->
    call(Pid, {append,LocalFileName,RemotFileName}, atom).

-spec append_bin(Pid :: pid(), Bin :: binary(), RemoteFile :: string()) ->
                    ok |
                    {error,
                     Reason :: restriction_reason()
                             | common_reason()
                             | shortage_reason()}.

append_bin(Pid, Bin, RemoteFile) when is_binary(Bin) ->
    call(Pid, {append_bin,Bin,RemoteFile}, atom);
append_bin(_Pid, _Bin, _RemoteFile) ->
    {error,enotbinary}.

-spec quote(Pid :: pid(), Cmd :: string()) -> list().

quote(Pid, Cmd) when is_list(Cmd) ->
    call(Pid, {quote,Cmd}, atom).

-spec close(Pid :: pid()) -> ok.

close(Pid) ->
    cast(Pid, close),
    ok.

-spec formaterror(Tag :: term()) -> string().

formaterror(Tag) ->
    ftp_response:error_string(Tag).

info(Pid) ->
    call(Pid, info, list).

start_standalone(Options) ->
    try
        {ok,StartOptions} = start_options(Options),
        {ok,OpenOptions} = open_options(Options),
        case start_link(StartOptions, []) of
            {ok,Pid} ->
                call(Pid, {open,ip_comm,OpenOptions}, plain);
            Error1 ->
                Error1
        end
    catch
        Error2 ->
            Error2
    end.

start_service(Options) ->
    try
        {ok,StartOptions} = start_options(Options),
        {ok,OpenOptions} = open_options(Options),
        case
            ftp_sup:start_child([[[{client,self()}|StartOptions],[]]])
        of
            {ok,Pid} ->
                call(Pid, {open,ip_comm,OpenOptions}, plain);
            Error1 ->
                Error1
        end
    catch
        Error2 ->
            Error2
    end.

stop_service(Pid) ->
    close(Pid).

services() ->
    [ 
     {ftpc,Pid} ||
         {_,Pid,_,_} <- supervisor:which_children(ftp_sup)
    ].

service_info(Pid) ->
    {ok,Info} = call(Pid, info, list),
    {ok,
     [proplists:lookup(mode, Info),
      proplists:lookup(local_port, Info),
      proplists:lookup(peer, Info),
      proplists:lookup(peer_port, Info)]}.

start_options(Options) ->
    inets_trace:report_event(80,
                             "start_options",
                             ftpc,
                             [{module,ftp},{line,802},{options,Options}]),
    case lists:keysearch(flags, 1, Options) of
        {value,{flags,Flags}} ->
            Verbose = lists:member(verbose, Flags),
            IsTrace = lists:member(trace, Flags),
            IsDebug = lists:member(debug, Flags),
            DebugLevel =
                if
                    IsTrace =:= true ->
                        trace;
                    IsDebug =:= true ->
                        debug;
                    true ->
                        disable
                end,
            {ok,[{verbose,Verbose},{debug,DebugLevel},{priority,low}]};
        false ->
            ValidateVerbose =
                fun(true) ->
                       true;
                   (false) ->
                       true;
                   (_) ->
                       false
                end,
            ValidateDebug =
                fun(trace) ->
                       true;
                   (debug) ->
                       true;
                   (disable) ->
                       true;
                   (_) ->
                       false
                end,
            ValidatePriority =
                fun(low) ->
                       true;
                   (normal) ->
                       true;
                   (high) ->
                       true;
                   (_) ->
                       false
                end,
            ValidOptions =
                [{verbose,ValidateVerbose,false,false},
                 {debug,ValidateDebug,false,disable},
                 {priority,ValidatePriority,false,low}],
            validate_options(Options, ValidOptions, [])
    end.

open_options(Options) ->
    inets_trace:report_event(80,
                             "open_options",
                             ftpc,
                             [{module,ftp},{line,855},{options,Options}]),
    ValidateMode =
        fun(active) ->
               true;
           (passive) ->
               true;
           (_) ->
               false
        end,
    ValidateHost =
        fun(Host) when is_list(Host) ->
               true;
           (Host)
               when
                   is_tuple(Host)
                   andalso
                   (size(Host) =:= 4
                    orelse
                    size(Host) =:= 8) ->
               true;
           (_) ->
               false
        end,
    ValidatePort =
        fun(Port)
               when
                   is_integer(Port)
                   andalso
                   Port > 0 ->
               true;
           (_) ->
               false
        end,
    ValidateIpFamily =
        fun(inet) ->
               true;
           (inet6) ->
               true;
           (inet6fb4) ->
               true;
           (_) ->
               false
        end,
    ValidateTimeout =
        fun(Timeout)
               when
                   is_integer(Timeout)
                   andalso
                   Timeout >= 0 ->
               true;
           (_) ->
               false
        end,
    ValidateDTimeout =
        fun(DTimeout)
               when
                   is_integer(DTimeout)
                   andalso
                   DTimeout >= 0 ->
               true;
           (infinity) ->
               true;
           (_) ->
               false
        end,
    ValidateProgress =
        fun(ignore) ->
               true;
           ({Mod,Func,_InitProgress})
               when
                   is_atom(Mod)
                   andalso
                   is_atom(Func) ->
               true;
           (_) ->
               false
        end,
    ValidOptions =
        [{mode,ValidateMode,false,passive},
         {host,ValidateHost,true,ehost},
         {port,ValidatePort,false,21},
         {ipfamily,ValidateIpFamily,false,inet},
         {timeout,ValidateTimeout,false,60 * 1000},
         {dtimeout,ValidateDTimeout,false,infinity},
         {progress,ValidateProgress,false,ignore}],
    validate_options(Options, ValidOptions, []).

validate_options([], [], Acc) ->
    inets_trace:report_event(80,
                             "validate_options -> done",
                             ftpc,
                             [{module,ftp},{line,909},{acc,Acc}]),
    {ok,lists:reverse(Acc)};
validate_options([], ValidOptions, Acc) ->
    inets_trace:report_event(80,
                             "validate_options -> done",
                             ftpc,
                             [{module,ftp},
                              {line,912},
                              {valid_options,ValidOptions},
                              {acc,Acc}]),
    case
        [ 
         {Key,Reason} ||
             {Key,_,true,Reason} <- ValidOptions
        ]
    of
        [] ->
            Defaults =
                [ 
                 {Key,Default} ||
                     {Key,_,_,Default} <- ValidOptions
                ],
            {ok,lists:reverse(Defaults ++ Acc)};
        [{_,Reason}|_Missing] ->
            throw({error,Reason})
    end;
validate_options([{Key,Value}|Options], ValidOptions, Acc) ->
    inets_trace:report_event(80,
                             "validate_options -> check",
                             ftpc,
                             [{module,ftp},
                              {line,924},
                              {key,Key},
                              {value,Value},
                              {acc,Acc}]),
    case lists:keysearch(Key, 1, ValidOptions) of
        {value,{Key,Validate,_,Default}} ->
            case catch Validate(Value) of
                true ->
                    inets_trace:report_event(80,
                                             "validate_options -> check"
                                             " - accept",
                                             ftpc,
                                             [{module,ftp},{line,930}]),
                    NewValidOptions =
                        lists:keydelete(Key, 1, ValidOptions),
                    validate_options(Options,
                                     NewValidOptions,
                                     [{Key,Value}|Acc]);
                _ ->
                    inets_trace:report_event(80,
                                             "validate_options -> check"
                                             " - reject",
                                             ftpc,
                                             [{module,ftp},
                                              {line,935},
                                              {default,Default}]),
                    NewValidOptions =
                        lists:keydelete(Key, 1, ValidOptions),
                    validate_options(Options,
                                     NewValidOptions,
                                     [{Key,Default}|Acc])
            end;
        false ->
            validate_options(Options, ValidOptions, Acc)
    end;
validate_options([_|Options], ValidOptions, Acc) ->
    validate_options(Options, ValidOptions, Acc).

init(Options) ->
    process_flag(trap_exit, true),
    {value,{client,Client}} = lists:keysearch(client, 1, Options),
    monitor(process, Client),
    inet_db:start(),
    {ok,Dir} = file:get_cwd(),
    case key_search(debug, Options, disable) of
        trace ->
            dbg:tracer(),
            dbg:p(all, [call]),
            dbg:tpl(ftp, [{'_',[],[{return_trace}]}]),
            dbg:tpl(ftp_response, [{'_',[],[{return_trace}]}]),
            dbg:tpl(ftp_progress, [{'_',[],[{return_trace}]}]);
        debug ->
            dbg:tracer(),
            dbg:p(all, [call]),
            dbg:tp(ftp, [{'_',[],[{return_trace}]}]),
            dbg:tp(ftp_response, [{'_',[],[{return_trace}]}]),
            dbg:tp(ftp_progress, [{'_',[],[{return_trace}]}]);
        _ ->
            ok
    end,
    Verbose = key_search(verbose, Options, false),
    IpFamily = key_search(ipfamily, Options, inet),
    State =
        #state{owner = Client,
               verbose = Verbose,
               ipfamily = IpFamily,
               ldir = Dir},
    Priority = key_search(priority, Options, low),
    process_flag(priority, Priority),
    {ok,State}.

handle_call({_,info},
            _,
            #state{verbose = Verbose,
                   mode = Mode,
                   timeout = Timeout,
                   ipfamily = IpFamily,
                   csock = Socket,
                   progress = Progress} =
                State) ->
    {ok,{_,LocalPort}} = inet:sockname(Socket),
    {ok,{Address,Port}} = inet:peername(Socket),
    Options =
        [{verbose,Verbose},
         {ipfamily,IpFamily},
         {mode,Mode},
         {peer,Address},
         {peer_port,Port},
         {local_port,LocalPort},
         {timeout,Timeout},
         {progress,Progress}],
    {reply,{ok,Options},State};
handle_call({Pid,_}, _, #state{owner = Owner} = State)
    when Owner =/= Pid ->
    {reply,{error,not_connection_owner},State};
handle_call({_,{open,ip_comm,Opts}}, From, State) ->
    inets_trace:report_event(60,
                             "handle_call(open)",
                             ftpc,
                             [{module,ftp},{line,1041},{opts,Opts}]),
    case key_search(host, Opts, undefined) of
        undefined ->
            {stop,normal,{error,ehost},State};
        Host ->
            Mode = key_search(mode, Opts, passive),
            Port = key_search(port, Opts, 21),
            Timeout = key_search(timeout, Opts, 60 * 1000),
            DTimeout = key_search(dtimeout, Opts, infinity),
            Progress = key_search(progress, Opts, ignore),
            IpFamily = key_search(ipfamily, Opts, inet),
            State2 =
                State#state{client = From,
                            mode = Mode,
                            progress = progress(Progress),
                            ipfamily = IpFamily,
                            dtimeout = DTimeout},
            inets_trace:report_event(60,
                                     "handle_call(open) -> setup ctrl c"
                                     "onnection with",
                                     ftpc,
                                     [{module,ftp},
                                      {line,1059},
                                      {host,Host},
                                      {port,Port},
                                      {timeout,Timeout}]),
            case setup_ctrl_connection(Host, Port, Timeout, State2) of
                {ok,State3,WaitTimeout} ->
                    inets_trace:report_event(60,
                                             "handle_call(open) -> ctrl"
                                             " connection setup done",
                                             ftpc,
                                             [{module,ftp},
                                              {line,1063},
                                              {waittimeout,WaitTimeout}]),
                    {noreply,State3,WaitTimeout};
                {error,Reason} ->
                    inets_trace:report_event(60,
                                             "handle_call(open) -> ctrl"
                                             " connection setup failed",
                                             ftpc,
                                             [{module,ftp},
                                              {line,1067},
                                              {reason,Reason}]),
                    gen_server:reply(From, {error,ehost}),
                    {stop,normal,State2#state{client = undefined}}
            end
    end;
handle_call({_,{open,ip_comm,Host,Opts}}, From, State) ->
    Mode = key_search(mode, Opts, passive),
    Port = key_search(port, Opts, 21),
    Timeout = key_search(timeout, Opts, 60 * 1000),
    DTimeout = key_search(dtimeout, Opts, infinity),
    Progress = key_search(progress, Opts, ignore),
    State2 =
        State#state{client = From,
                    mode = Mode,
                    progress = progress(Progress),
                    dtimeout = DTimeout},
    case setup_ctrl_connection(Host, Port, Timeout, State2) of
        {ok,State3,WaitTimeout} ->
            {noreply,State3,WaitTimeout};
        {error,_Reason} ->
            gen_server:reply(From, {error,ehost}),
            {stop,normal,State2#state{client = undefined}}
    end;
handle_call({_,{user,User,Password}},
            From,
            #state{csock = CSock} = State)
    when CSock =/= undefined ->
    handle_user(User, Password, "", State#state{client = From});
handle_call({_,{user,User,Password,Acc}},
            From,
            #state{csock = CSock} = State)
    when CSock =/= undefined ->
    handle_user(User, Password, Acc, State#state{client = From});
handle_call({_,{account,Acc}}, From, State) ->
    handle_user_account(Acc, State#state{client = From});
handle_call({_,pwd}, From, #state{chunk = false} = State) ->
    send_ctrl_message(State, mk_cmd("PWD", [])),
    activate_ctrl_connection(State),
    {noreply,State#state{client = From,caller = pwd}};
handle_call({_,lpwd}, From, #state{ldir = LDir} = State) ->
    {reply,{ok,LDir},State#state{client = From}};
handle_call({_,{cd,Dir}}, From, #state{chunk = false} = State) ->
    send_ctrl_message(State, mk_cmd("CWD ~s", [Dir])),
    activate_ctrl_connection(State),
    {noreply,State#state{client = From,caller = cd}};
handle_call({_,{lcd,Dir}}, _From, #state{ldir = LDir0} = State) ->
    LDir = filename:absname(Dir, LDir0),
    case file:read_file_info(LDir) of
        {ok,_} ->
            {reply,ok,State#state{ldir = LDir}};
        _ ->
            {reply,{error,epath},State}
    end;
handle_call({_,{dir,Len,Dir}},
            {_Pid,_} = From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller = {dir,Dir,Len},
                                      client = From});
handle_call({_,{rename,CurrFile,NewFile}},
            From,
            #state{chunk = false} = State) ->
    send_ctrl_message(State, mk_cmd("RNFR ~s", [CurrFile])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {rename,NewFile},client = From}};
handle_call({_,{delete,File}},
            {_Pid,_} = From,
            #state{chunk = false} = State) ->
    send_ctrl_message(State, mk_cmd("DELE ~s", [File])),
    activate_ctrl_connection(State),
    {noreply,State#state{client = From}};
handle_call({_,{mkdir,Dir}}, From, #state{chunk = false} = State) ->
    send_ctrl_message(State, mk_cmd("MKD ~s", [Dir])),
    activate_ctrl_connection(State),
    {noreply,State#state{client = From}};
handle_call({_,{rmdir,Dir}}, From, #state{chunk = false} = State) ->
    send_ctrl_message(State, mk_cmd("RMD ~s", [Dir])),
    activate_ctrl_connection(State),
    {noreply,State#state{client = From}};
handle_call({_,{type,Type}}, From, #state{chunk = false} = State) ->
    case Type of
        ascii ->
            send_ctrl_message(State, mk_cmd("TYPE A", [])),
            activate_ctrl_connection(State),
            {noreply,
             State#state{caller = type,type = ascii,client = From}};
        binary ->
            send_ctrl_message(State, mk_cmd("TYPE I", [])),
            activate_ctrl_connection(State),
            {noreply,
             State#state{caller = type,type = binary,client = From}};
        _ ->
            {reply,{error,etype},State}
    end;
handle_call({_,{recv,RemoteFile,LocalFile}},
            From,
            #state{chunk = false,ldir = LocalDir} = State) ->
    progress_report({remote_file,RemoteFile}, State),
    NewLocalFile = filename:absname(LocalFile, LocalDir),
    case file_open(NewLocalFile, write) of
        {ok,Fd} ->
            setup_data_connection(State#state{client = From,
                                              caller =
                                                  {recv_file,
                                                   RemoteFile,
                                                   Fd}});
        {error,_What} ->
            {reply,{error,epath},State}
    end;
handle_call({_,{recv_bin,RemoteFile}},
            From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller = {recv_bin,RemoteFile},
                                      client = From});
handle_call({_,{recv_chunk_start,RemoteFile}},
            From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller =
                                          {start_chunk_transfer,
                                           "RETR",
                                           RemoteFile},
                                      client = From});
handle_call({_,recv_chunk}, _, #state{chunk = false} = State) ->
    {reply,{error,"ftp:recv_chunk_start/2 not called"},State};
handle_call({_,recv_chunk}, From, #state{chunk = true} = State) ->
    activate_data_connection(State),
    {noreply,State#state{client = From,caller = recv_chunk}};
handle_call({_,{send,LocalFile,RemoteFile}},
            From,
            #state{chunk = false,ldir = LocalDir} = State) ->
    progress_report({local_file,filename:absname(LocalFile, LocalDir)},
                    State),
    setup_data_connection(State#state{caller =
                                          {transfer_file,
                                           {"STOR",LocalFile,RemoteFile}},
                                      client = From});
handle_call({_,{append,LocalFile,RemoteFile}},
            From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller =
                                          {transfer_file,
                                           {"APPE",LocalFile,RemoteFile}},
                                      client = From});
handle_call({_,{send_bin,Bin,RemoteFile}},
            From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller =
                                          {transfer_data,
                                           {"STOR",Bin,RemoteFile}},
                                      client = From});
handle_call({_,{append_bin,Bin,RemoteFile}},
            From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller =
                                          {transfer_data,
                                           {"APPE",Bin,RemoteFile}},
                                      client = From});
handle_call({_,{send_chunk_start,RemoteFile}},
            From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller =
                                          {start_chunk_transfer,
                                           "STOR",
                                           RemoteFile},
                                      client = From});
handle_call({_,{append_chunk_start,RemoteFile}},
            From,
            #state{chunk = false} = State) ->
    setup_data_connection(State#state{caller =
                                          {start_chunk_transfer,
                                           "APPE",
                                           RemoteFile},
                                      client = From});
handle_call({_,{transfer_chunk,Bin}}, _, #state{chunk = true} = State) ->
    send_data_message(State, Bin),
    {reply,ok,State};
handle_call({_,chunk_end}, From, #state{chunk = true} = State) ->
    close_data_connection(State),
    activate_ctrl_connection(State),
    {noreply,
     State#state{client = From,
                 dsock = undefined,
                 caller = end_chunk_transfer,
                 chunk = false}};
handle_call({_,{quote,Cmd}}, From, #state{chunk = false} = State) ->
    send_ctrl_message(State, mk_cmd(Cmd, [])),
    activate_ctrl_connection(State),
    {noreply,State#state{client = From,caller = quote}};
handle_call({_,_Req}, _From, #state{csock = CSock} = State)
    when CSock =:= undefined ->
    {reply,{error,not_connected},State};
handle_call(_, _, #state{chunk = true} = State) ->
    {reply,{error,echunk},State};
handle_call(Request, _Timeout, State) ->
    {stop,
     {'API_violation_connection_closed',Request},
     {error,{connection_terminated,'API_violation'}},
     State}.

handle_cast({Pid,close}, #state{owner = Pid} = State) ->
    send_ctrl_message(State, mk_cmd("QUIT", [])),
    close_ctrl_connection(State),
    close_data_connection(State),
    {stop,normal,State#state{csock = undefined,dsock = undefined}};
handle_cast({Pid,close}, State) ->
    Report =
        io_lib:format("A none owner process ~p tried to close an ftp co"
                      "nnection: ~n",
                      [Pid]),
    error_logger:info_report(Report),
    {noreply,State};
handle_cast(Msg, State) ->
    {stop,{'API_violation_connection_closed',Msg},State}.

handle_info(timeout, #state{caller = open} = State) ->
    {stop,timeout,State};
handle_info(timeout, State) ->
    {noreply,State};
handle_info({tcp,Socket,Data},
            #state{dsock = Socket,caller = {recv_file,Fd}} = State) ->
    file_write(binary_to_list(Data), Fd),
    progress_report({binary,Data}, State),
    activate_data_connection(State),
    {noreply,State};
handle_info({tcp,Socket,Data},
            #state{dsock = Socket,client = From,caller = recv_chunk} =
                State) ->
    gen_server:reply(From, {ok,Data}),
    {noreply,State#state{client = undefined,data = <<>>}};
handle_info({tcp,Socket,Data}, #state{dsock = Socket} = State) ->
    activate_data_connection(State),
    {noreply,
     State#state{data = <<(State#state.data)/binary,Data/binary>>}};
handle_info({tcp_closed,Socket},
            #state{dsock = Socket,caller = {recv_file,Fd}} = State) ->
    file_close(Fd),
    progress_report({transfer_size,0}, State),
    activate_ctrl_connection(State),
    {noreply,State#state{dsock = undefined,data = <<>>}};
handle_info({tcp_closed,Socket},
            #state{dsock = Socket,client = From,caller = recv_chunk} =
                State) ->
    gen_server:reply(From, ok),
    {noreply,
     State#state{dsock = undefined,
                 client = undefined,
                 data = <<>>,
                 caller = undefined,
                 chunk = false}};
handle_info({tcp_closed,Socket},
            #state{dsock = Socket,caller = recv_bin,data = Data} = State) ->
    activate_ctrl_connection(State),
    {noreply,
     State#state{dsock = undefined,data = <<>>,caller = {recv_bin,Data}}};
handle_info({tcp_closed,Socket},
            #state{dsock = Socket,
                   data = Data,
                   caller = {handle_dir_result,Dir}} =
                State) ->
    activate_ctrl_connection(State),
    {noreply,
     State#state{dsock = undefined,
                 caller = {handle_dir_result,Dir,Data},
                 data = <<>>}};
handle_info({tcp_error,Socket,Reason},
            #state{dsock = Socket,client = From} = State) ->
    gen_server:reply(From, {error,Reason}),
    close_data_connection(State),
    {noreply,
     State#state{dsock = undefined,
                 client = undefined,
                 data = <<>>,
                 caller = undefined,
                 chunk = false}};
handle_info({tcp,Socket,Data},
            #state{csock = Socket,
                   verbose = Verbose,
                   caller = Caller,
                   client = From,
                   ctrl_data = {CtrlData,AccLines,LineStatus}} =
                State) ->
    case
        ftp_response:parse_lines(<<CtrlData/binary,Data/binary>>,
                                 AccLines,
                                 LineStatus)
    of
        {ok,Lines,NextMsgData} ->
            verbose(Lines, Verbose, 'receive'),
            CtrlResult = ftp_response:interpret(Lines),
            case Caller of
                quote ->
                    gen_server:reply(From,
                                     string:tokens(Lines, [$\r,$\n])),
                    {noreply,
                     State#state{client = undefined,
                                 caller = undefined,
                                 ctrl_data = {NextMsgData,[],start}}};
                _ ->
                    handle_ctrl_result(CtrlResult,
                                       State#state{ctrl_data =
                                                       {NextMsgData,
                                                        [],
                                                        start}})
            end;
        {continue,NewCtrlData} ->
            activate_ctrl_connection(State),
            {noreply,State#state{ctrl_data = NewCtrlData}}
    end;
handle_info({tcp_closed,Socket}, #state{csock = Socket}) ->
    exit(normal);
handle_info({tcp_error,Socket,Reason}, _) ->
    Report =
        io_lib:format("tcp_error on socket: ~p  for reason: ~p~n",
                      [Socket,Reason]),
    error_logger:error_report(Report),
    exit(normal);
handle_info({'DOWN',_Ref,_Type,_Process,normal}, State) ->
    {stop,normal,State#state{client = undefined}};
handle_info({'DOWN',_Ref,_Type,_Process,shutdown}, State) ->
    {stop,normal,State#state{client = undefined}};
handle_info({'DOWN',_Ref,_Type,_Process,timeout}, State) ->
    {stop,normal,State#state{client = undefined}};
handle_info({'DOWN',_Ref,_Type,Process,Reason}, State) ->
    {stop,
     {stopped,{'EXIT',Process,Reason}},
     State#state{client = undefined}};
handle_info({'EXIT',Pid,Reason}, #state{progress = Pid} = State) ->
    Report =
        io_lib:format("Progress reporting stopped for reason ~p~n",
                      [Reason]),
    error_logger:info_report(Report),
    {noreply,State#state{progress = ignore}};
handle_info(Info, State) ->
    Report =
        io_lib:format("ftp : ~p : Unexpected message: ~p\n",
                      [self(),Info]),
    error_logger:info_report(Report),
    {noreply,State}.

terminate(normal, State) ->
    progress_report(stop, State),
    do_termiante({error,econn}, State);
terminate(Reason, State) ->
    Report =
        io_lib:format("Ftp connection closed due to: ~p~n", [Reason]),
    error_logger:error_report(Report),
    do_termiante({error,eclosed}, State).

do_termiante(ErrorMsg, State) ->
    close_data_connection(State),
    close_ctrl_connection(State),
    case State#state.client of
        undefined ->
            ok;
        From ->
            gen_server:reply(From, ErrorMsg)
    end,
    ok.

code_change(_Vsn, State1, upgrade_from_pre_5_12) ->
    {state,
     CSock,
     DSock,
     Verbose,
     LDir,
     Type,
     Chunk,
     Mode,
     Timeout,
     Data,
     CtrlData,
     Owner,
     Client,
     Caller,
     IPv6Disable,
     Progress} =
        State1,
    IpFamily =
        if
            IPv6Disable =:= true ->
                inet;
            true ->
                inet6fb4
        end,
    State2 =
        #state{csock = CSock,
               dsock = DSock,
               verbose = Verbose,
               ldir = LDir,
               type = Type,
               chunk = Chunk,
               mode = Mode,
               timeout = Timeout,
               data = Data,
               ctrl_data = CtrlData,
               owner = Owner,
               client = Client,
               caller = Caller,
               ipfamily = IpFamily,
               progress = Progress},
    {ok,State2};
code_change(_Vsn, State1, downgrade_to_pre_5_12) ->
    #state{csock = CSock,
           dsock = DSock,
           verbose = Verbose,
           ldir = LDir,
           type = Type,
           chunk = Chunk,
           mode = Mode,
           timeout = Timeout,
           data = Data,
           ctrl_data = CtrlData,
           owner = Owner,
           client = Client,
           caller = Caller,
           ipfamily = IpFamily,
           progress = Progress} =
        State1,
    IPv6Disable =
        if
            IpFamily =:= inet ->
                true;
            true ->
                false
        end,
    State2 =
        {state,
         CSock,
         DSock,
         Verbose,
         LDir,
         Type,
         Chunk,
         Mode,
         Timeout,
         Data,
         CtrlData,
         Owner,
         Client,
         Caller,
         IPv6Disable,
         Progress},
    {ok,State2};
code_change(_Vsn, State, _Extra) ->
    {ok,State}.

start_link([Opts,GenServerOptions]) ->
    start_link(Opts, GenServerOptions).

start_link(Opts, GenServerOptions) ->
    case lists:keysearch(client, 1, Opts) of
        {value,_} ->
            gen_server:start_link(ftp, Opts, GenServerOptions);
        false ->
            Opts2 = [{client,self()}|Opts],
            gen_server:start_link(ftp, Opts2, GenServerOptions)
    end.

handle_user(User, Password, Acc, State) ->
    send_ctrl_message(State, mk_cmd("USER ~s", [User])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {handle_user,Password,Acc}}}.

handle_user_passwd(Password, Acc, State) ->
    send_ctrl_message(State, mk_cmd("PASS ~s", [Password])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {handle_user_passwd,Acc}}}.

handle_user_account(Acc, State) ->
    send_ctrl_message(State, mk_cmd("ACCT ~s", [Acc])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = handle_user_account}}.

handle_ctrl_result({pos_compl,_},
                   #state{caller = open,client = From} = State) ->
    gen_server:reply(From, {ok,self()}),
    {noreply,State#state{client = undefined,caller = undefined}};
handle_ctrl_result({_,Lines}, #state{caller = open} = State) ->
    ctrl_result_response(econn, State, {error,Lines});
handle_ctrl_result({pos_compl,_Lines},
                   #state{mode = active,
                          caller =
                              {setup_data_connection,{LSock,Caller}}} =
                       State) ->
    handle_caller(State#state{caller = Caller,dsock = {lsock,LSock}});
handle_ctrl_result({Status,Lines},
                   #state{mode = active,
                          caller = {setup_data_connection,{LSock,_}}} =
                       State) ->
    close_connection(LSock),
    ctrl_result_response(Status, State, {error,Lines});
handle_ctrl_result({pos_compl,Lines},
                   #state{mode = passive,
                          ipfamily = inet6,
                          client = From,
                          caller = {setup_data_connection,Caller},
                          csock = CSock,
                          timeout = Timeout} =
                       State) ->
    [_,PortStr|_] = lists:reverse(string:tokens(Lines, "|")),
    {ok,{IP,_}} = inet:peername(CSock),
    case connect(IP, list_to_integer(PortStr), Timeout, State) of
        {ok,_,Socket} ->
            handle_caller(State#state{caller = Caller,dsock = Socket});
        {error,_Reason} = Error ->
            gen_server:reply(From, Error),
            {noreply,State#state{client = undefined,caller = undefined}}
    end;
handle_ctrl_result({pos_compl,Lines},
                   #state{mode = passive,
                          ipfamily = inet,
                          client = From,
                          caller = {setup_data_connection,Caller},
                          timeout = Timeout} =
                       State) ->
    {_,[$(|Rest]} =
        lists:splitwith(fun($() ->
                               false;
                           (_) ->
                               true
                        end,
                        Lines),
    {NewPortAddr,_} =
        lists:splitwith(fun($)) ->
                               false;
                           (_) ->
                               true
                        end,
                        Rest),
    [A1,A2,A3,A4,P1,P2] =
        lists:map(fun(X) ->
                         list_to_integer(X)
                  end,
                  string:tokens(NewPortAddr, [$,])),
    IP = {A1,A2,A3,A4},
    Port = P1 * 256 + P2,
    case connect(IP, Port, Timeout, State) of
        {ok,_,Socket} ->
            handle_caller(State#state{caller = Caller,dsock = Socket});
        {error,_Reason} = Error ->
            gen_server:reply(From, Error),
            {noreply,State#state{client = undefined,caller = undefined}}
    end;
handle_ctrl_result(_,
                   #state{mode = passive,
                          caller = {setup_data_connection,Caller}} =
                       State) ->
    setup_data_connection(State#state{mode = active,caller = Caller});
handle_ctrl_result({pos_interm,_},
                   #state{caller = {handle_user,PassWord,Acc}} = State) ->
    handle_user_passwd(PassWord, Acc, State);
handle_ctrl_result({Status,_},
                   #state{caller = {handle_user,_,_}} = State) ->
    ctrl_result_response(Status, State, {error,euser});
handle_ctrl_result({pos_interm_acct,_},
                   #state{caller = {handle_user_passwd,Acc}} = State)
    when Acc =/= "" ->
    handle_user_account(Acc, State);
handle_ctrl_result({Status,_},
                   #state{caller = {handle_user_passwd,_}} = State) ->
    ctrl_result_response(Status, State, {error,euser});
handle_ctrl_result({pos_compl,Lines},
                   #state{caller = pwd,client = From} = State) ->
    Dir = pwd_result(Lines),
    gen_server:reply(From, {ok,Dir}),
    {noreply,State#state{client = undefined,caller = undefined}};
handle_ctrl_result({pos_prel,_}, #state{caller = {dir,Dir}} = State) ->
    case accept_data_connection(State) of
        {ok,NewState} ->
            activate_data_connection(NewState),
            {noreply,NewState#state{caller = {handle_dir_result,Dir}}};
        {error,_Reason} = ERROR ->
            case State#state.client of
                undefined ->
                    {stop,ERROR,State};
                From ->
                    gen_server:reply(From, ERROR),
                    {stop,normal,State#state{client = undefined}}
            end
    end;
handle_ctrl_result({pos_compl,_},
                   #state{caller = {handle_dir_result,Dir,Data},
                          client = From} =
                       State) ->
    case Dir of
        "" ->
            gen_server:reply(From, {ok,Data}),
            {noreply,State#state{client = undefined,caller = undefined}};
        _ ->
            gen_server:reply(From, {ok,Data}),
            {noreply,State#state{client = undefined,caller = undefined}}
    end;
handle_ctrl_result({pos_compl,Lines},
                   #state{caller = {handle_dir_data,Dir,DirData}} =
                       State) ->
    OldDir = pwd_result(Lines),
    send_ctrl_message(State, mk_cmd("CWD ~s", [Dir])),
    activate_ctrl_connection(State),
    {noreply,
     State#state{caller = {handle_dir_data_second_phase,OldDir,DirData}}};
handle_ctrl_result({Status,_},
                   #state{caller = {handle_dir_data,_,_}} = State) ->
    ctrl_result_response(Status, State, {error,epath});
handle_ctrl_result(S = {_Status,_},
                   #state{caller = {handle_dir_result,_,_}} = State) ->
    ctrl_result_response(S, State, {error,epath});
handle_ctrl_result({pos_compl,_},
                   #state{caller =
                              {handle_dir_data_second_phase,
                               OldDir,
                               DirData}} =
                       State) ->
    send_ctrl_message(State, mk_cmd("CWD ~s", [OldDir])),
    activate_ctrl_connection(State),
    {noreply,
     State#state{caller = {handle_dir_data_third_phase,DirData}}};
handle_ctrl_result({Status,_},
                   #state{caller = {handle_dir_data_second_phase,_,_}} =
                       State) ->
    ctrl_result_response(Status, State, {error,epath});
handle_ctrl_result(_,
                   #state{caller = {handle_dir_data_third_phase,DirData},
                          client = From} =
                       State) ->
    gen_server:reply(From, {ok,DirData}),
    {noreply,State#state{client = undefined,caller = undefined}};
handle_ctrl_result({Status,_}, #state{caller = cd} = State) ->
    ctrl_result_response(Status, State, {error,epath});
handle_ctrl_result(Status = {epath,_}, #state{caller = {dir,_}} = State) ->
    ctrl_result_response(Status, State, {error,epath});
handle_ctrl_result({pos_interm,_},
                   #state{caller = {rename,NewFile}} = State) ->
    send_ctrl_message(State, mk_cmd("RNTO ~s", [NewFile])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = rename_second_phase}};
handle_ctrl_result({Status,_}, #state{caller = {rename,_}} = State) ->
    ctrl_result_response(Status, State, {error,epath});
handle_ctrl_result({Status,_},
                   #state{caller = rename_second_phase} = State) ->
    ctrl_result_response(Status, State, {error,epath});
handle_ctrl_result({pos_prel,_}, #state{caller = recv_bin} = State) ->
    case accept_data_connection(State) of
        {ok,NewState} ->
            activate_data_connection(NewState),
            {noreply,NewState};
        {error,_Reason} = ERROR ->
            case State#state.client of
                undefined ->
                    {stop,ERROR,State};
                From ->
                    gen_server:reply(From, ERROR),
                    {stop,normal,State#state{client = undefined}}
            end
    end;
handle_ctrl_result({pos_compl,_},
                   #state{caller = {recv_bin,Data},client = From} =
                       State) ->
    gen_server:reply(From, {ok,Data}),
    close_data_connection(State),
    {noreply,State#state{client = undefined,caller = undefined}};
handle_ctrl_result({Status,_}, #state{caller = recv_bin} = State) ->
    close_data_connection(State),
    ctrl_result_response(Status,
                         State#state{dsock = undefined},
                         {error,epath});
handle_ctrl_result({Status,_}, #state{caller = {recv_bin,_}} = State) ->
    close_data_connection(State),
    ctrl_result_response(Status,
                         State#state{dsock = undefined},
                         {error,epath});
handle_ctrl_result({pos_prel,_},
                   #state{client = From,caller = start_chunk_transfer} =
                       State) ->
    case accept_data_connection(State) of
        {ok,NewState} ->
            gen_server:reply(From, ok),
            {noreply,
             NewState#state{chunk = true,
                            client = undefined,
                            caller = undefined}};
        {error,_Reason} = ERROR ->
            case State#state.client of
                undefined ->
                    {stop,ERROR,State};
                From ->
                    gen_server:reply(From, ERROR),
                    {stop,normal,State#state{client = undefined}}
            end
    end;
handle_ctrl_result({pos_prel,_}, #state{caller = {recv_file,_}} = State) ->
    case accept_data_connection(State) of
        {ok,NewState} ->
            activate_data_connection(NewState),
            {noreply,NewState};
        {error,_Reason} = ERROR ->
            case State#state.client of
                undefined ->
                    {stop,ERROR,State};
                From ->
                    gen_server:reply(From, ERROR),
                    {stop,normal,State#state{client = undefined}}
            end
    end;
handle_ctrl_result({Status,_}, #state{caller = {recv_file,Fd}} = State) ->
    file_close(Fd),
    close_data_connection(State),
    ctrl_result_response(Status,
                         State#state{dsock = undefined},
                         {error,epath});
handle_ctrl_result({pos_prel,_},
                   #state{caller = {transfer_file,Fd}} = State) ->
    case accept_data_connection(State) of
        {ok,NewState} ->
            send_file(Fd, NewState);
        {error,_Reason} = ERROR ->
            case State#state.client of
                undefined ->
                    {stop,ERROR,State};
                From ->
                    gen_server:reply(From, ERROR),
                    {stop,normal,State#state{client = undefined}}
            end
    end;
handle_ctrl_result({pos_prel,_},
                   #state{caller = {transfer_data,Bin}} = State) ->
    case accept_data_connection(State) of
        {ok,NewState} ->
            send_data_message(NewState, Bin),
            close_data_connection(NewState),
            activate_ctrl_connection(NewState),
            {noreply,
             NewState#state{caller = transfer_data_second_phase,
                            dsock = undefined}};
        {error,_Reason} = ERROR ->
            case State#state.client of
                undefined ->
                    {stop,ERROR,State};
                From ->
                    gen_server:reply(From, ERROR),
                    {stop,normal,State#state{client = undefined}}
            end
    end;
handle_ctrl_result({Status,Lines}, #state{client = From} = State)
    when From =/= undefined ->
    ctrl_result_response(Status, State, {error,Lines}).

ctrl_result_response(pos_compl, #state{client = From} = State, _) ->
    gen_server:reply(From, ok),
    {noreply,State#state{client = undefined,caller = undefined}};
ctrl_result_response(enofile, #state{client = From} = State, _) ->
    gen_server:reply(From, {error,enofile}),
    {noreply,State#state{client = undefined,caller = undefined}};
ctrl_result_response(Status, #state{client = From} = State, _)
    when
        Status =:= etnospc
        orelse
        Status =:= epnospc
        orelse
        Status =:= efnamena
        orelse
        Status =:= econn ->
    gen_server:reply(From, {error,Status}),
    {stop,normal,State#state{client = undefined}};
ctrl_result_response(_, #state{client = From} = State, ErrorMsg) ->
    gen_server:reply(From, ErrorMsg),
    {noreply,State#state{client = undefined,caller = undefined}}.

handle_caller(#state{caller = {dir,Dir,Len}} = State) ->
    Cmd =
        case Len of
            short ->
                "NLST";
            long ->
                "LIST"
        end,
    case Dir of
        "" ->
            send_ctrl_message(State, mk_cmd(Cmd, ""));
        _ ->
            send_ctrl_message(State, mk_cmd(Cmd ++ " ~s", [Dir]))
    end,
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {dir,Dir}}};
handle_caller(#state{caller = {recv_bin,RemoteFile}} = State) ->
    send_ctrl_message(State, mk_cmd("RETR ~s", [RemoteFile])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = recv_bin}};
handle_caller(#state{caller = {start_chunk_transfer,Cmd,RemoteFile}} =
                  State) ->
    send_ctrl_message(State, mk_cmd("~s ~s", [Cmd,RemoteFile])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = start_chunk_transfer}};
handle_caller(#state{caller = {recv_file,RemoteFile,Fd}} = State) ->
    send_ctrl_message(State, mk_cmd("RETR ~s", [RemoteFile])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {recv_file,Fd}}};
handle_caller(#state{caller = {transfer_file,{Cmd,LocalFile,RemoteFile}},
                     ldir = LocalDir,
                     client = From} =
                  State) ->
    case file_open(filename:absname(LocalFile, LocalDir), read) of
        {ok,Fd} ->
            send_ctrl_message(State, mk_cmd("~s ~s", [Cmd,RemoteFile])),
            activate_ctrl_connection(State),
            {noreply,State#state{caller = {transfer_file,Fd}}};
        {error,_} ->
            gen_server:reply(From, {error,epath}),
            {noreply,
             State#state{client = undefined,
                         caller = undefined,
                         dsock = undefined}}
    end;
handle_caller(#state{caller = {transfer_data,{Cmd,Bin,RemoteFile}}} =
                  State) ->
    send_ctrl_message(State, mk_cmd("~s ~s", [Cmd,RemoteFile])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {transfer_data,Bin}}}.

setup_ctrl_connection(Host, Port, Timeout, State) ->
    MsTime = millisec_time(),
    case connect(Host, Port, Timeout, State) of
        {ok,IpFam,CSock} ->
            NewState = State#state{csock = CSock,ipfamily = IpFam},
            activate_ctrl_connection(NewState),
            case Timeout - (millisec_time() - MsTime) of
                Timeout2 when Timeout2 >= 0 ->
                    {ok,NewState#state{caller = open},Timeout2};
                _ ->
                    {ok,NewState#state{caller = open},0}
            end;
        Error ->
            Error
    end.

setup_data_connection(#state{mode = active,
                             caller = Caller,
                             csock = CSock} =
                          State) ->
    case catch inet:sockname(CSock) of
        {ok,{{_,_,_,_,_,_,_,_} = IP,_}} ->
            {ok,LSock} =
                gen_tcp:listen(0,
                               [{ip,IP},
                                {active,false},
                                inet6,
                                binary,
                                {packet,0}]),
            {ok,Port} = inet:port(LSock),
            IpAddress = inet_parse:ntoa(IP),
            Cmd = mk_cmd("EPRT |2|~s|~p|", [IpAddress,Port]),
            send_ctrl_message(State, Cmd),
            activate_ctrl_connection(State),
            {noreply,
             State#state{caller = {setup_data_connection,{LSock,Caller}}}};
        {ok,{{_,_,_,_} = IP,_}} ->
            {ok,LSock} =
                gen_tcp:listen(0,
                               [{ip,IP},
                                {active,false},
                                binary,
                                {packet,0}]),
            {ok,Port} = inet:port(LSock),
            {IP1,IP2,IP3,IP4} = IP,
            {Port1,Port2} = {Port div 256,Port rem 256},
            send_ctrl_message(State,
                              mk_cmd("PORT ~w,~w,~w,~w,~w,~w",
                                     [IP1,IP2,IP3,IP4,Port1,Port2])),
            activate_ctrl_connection(State),
            {noreply,
             State#state{caller = {setup_data_connection,{LSock,Caller}}}}
    end;
setup_data_connection(#state{mode = passive,
                             ipfamily = inet6,
                             caller = Caller} =
                          State) ->
    send_ctrl_message(State, mk_cmd("EPSV", [])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {setup_data_connection,Caller}}};
setup_data_connection(#state{mode = passive,
                             ipfamily = inet,
                             caller = Caller} =
                          State) ->
    send_ctrl_message(State, mk_cmd("PASV", [])),
    activate_ctrl_connection(State),
    {noreply,State#state{caller = {setup_data_connection,Caller}}}.

connect(Host, Port, Timeout, #state{ipfamily = inet = IpFam}) ->
    connect2(Host, Port, IpFam, Timeout);
connect(Host, Port, Timeout, #state{ipfamily = inet6 = IpFam}) ->
    connect2(Host, Port, IpFam, Timeout);
connect(Host, Port, Timeout, #state{ipfamily = inet6fb4}) ->
    case inet:getaddr(Host, inet6) of
        {ok,{0,0,0,0,0,65535,_,_} = IPv6} ->
            case inet:getaddr(Host, inet) of
                {ok,IPv4} ->
                    IpFam = inet,
                    connect2(IPv4, Port, IpFam, Timeout);
                _ ->
                    IpFam = inet6,
                    connect2(IPv6, Port, IpFam, Timeout)
            end;
        {ok,IPv6} ->
            IpFam = inet6,
            connect2(IPv6, Port, IpFam, Timeout);
        _ ->
            case inet:getaddr(Host, inet) of
                {ok,IPv4} ->
                    IpFam = inet,
                    connect2(IPv4, Port, IpFam, Timeout);
                Error ->
                    Error
            end
    end.

connect2(Host, Port, IpFam, Timeout) ->
    Opts = [IpFam,binary,{packet,0},{active,false}],
    case gen_tcp:connect(Host, Port, Opts, Timeout) of
        {ok,Sock} ->
            {ok,IpFam,Sock};
        Error ->
            Error
    end.

accept_data_connection(#state{mode = active,
                              dtimeout = DTimeout,
                              dsock = {lsock,LSock}} =
                           State) ->
    case gen_tcp:accept(LSock, DTimeout) of
        {ok,Socket} ->
            gen_tcp:close(LSock),
            {ok,State#state{dsock = Socket}};
        {error,Reason} ->
            {error,{data_connect_failed,Reason}}
    end;
accept_data_connection(#state{mode = passive} = State) ->
    {ok,State}.

send_ctrl_message(#state{csock = Socket,verbose = Verbose}, Message) ->
    verbose(lists:flatten(Message), Verbose, send),
    send_message(Socket, Message).

send_data_message(#state{dsock = Socket}, Message) ->
    send_message(Socket, Message).

send_message(Socket, Message) ->
    case gen_tcp:send(Socket, Message) of
        ok ->
            ok;
        {error,Reason} ->
            Report =
                io_lib:format("gen_tcp:send/2 failed for reason ~p~n",
                              [Reason]),
            error_logger:error_report(Report),
            exit(normal)
    end.

activate_ctrl_connection(#state{csock = Socket,ctrl_data = {<<>>,_,_}}) ->
    activate_connection(Socket);
activate_ctrl_connection(#state{csock = Socket}) ->
    self() ! {tcp,Socket,<<>>}.

activate_data_connection(#state{dsock = Socket}) ->
    activate_connection(Socket).

activate_connection(Socket) ->
    inet:setopts(Socket, [{active,once}]).

close_ctrl_connection(#state{csock = undefined}) ->
    ok;
close_ctrl_connection(#state{csock = Socket}) ->
    close_connection(Socket).

close_data_connection(#state{dsock = undefined}) ->
    ok;
close_data_connection(#state{dsock = {lsock,Socket}}) ->
    close_connection(Socket);
close_data_connection(#state{dsock = Socket}) ->
    close_connection(Socket).

close_connection(Socket) ->
    gen_tcp:close(Socket).

send_file(Fd, State) ->
    case file_read(Fd) of
        {ok,N,Bin} when N > 0 ->
            send_data_message(State, Bin),
            progress_report({binary,Bin}, State),
            send_file(Fd, State);
        {ok,_,_} ->
            file_close(Fd),
            close_data_connection(State),
            progress_report({transfer_size,0}, State),
            activate_ctrl_connection(State),
            {noreply,
             State#state{caller = transfer_file_second_phase,
                         dsock = undefined}};
        {error,Reason} ->
            gen_server:reply(State#state.client, {error,Reason}),
            {stop,normal,State#state{client = undefined}}
    end.

file_open(File, Option) ->
    file:open(File, [raw,binary,Option]).

file_close(Fd) ->
    file:close(Fd).

file_read(Fd) ->
    case file:read(Fd, 4096) of
        {ok,Bytes} ->
            {ok,size(Bytes),Bytes};
        eof ->
            {ok,0,[]};
        Other ->
            Other
    end.

file_write(Bytes, Fd) ->
    file:write(Fd, Bytes).

call(GenServer, Msg, Format) ->
    call(GenServer, Msg, Format, infinity).

call(GenServer, Msg, Format, Timeout) ->
    Req = {self(),Msg},
    case catch gen_server:call(GenServer, Req, Timeout) of
        {ok,Bin}
            when
                is_binary(Bin)
                andalso
                Format =:= string ->
            {ok,binary_to_list(Bin)};
        {'EXIT',_} ->
            {error,eclosed};
        Result ->
            Result
    end.

cast(GenServer, Msg) ->
    gen_server:cast(GenServer, {self(),Msg}).

mk_cmd(Fmt, Args) ->
    [io_lib:format(Fmt, Args),$\r,$\n].

pwd_result(Lines) ->
    {_,[$"|Rest]} =
        lists:splitwith(fun($") ->
                               false;
                           (_) ->
                               true
                        end,
                        Lines),
    {Dir,_} =
        lists:splitwith(fun($") ->
                               false;
                           (_) ->
                               true
                        end,
                        Rest),
    Dir.

key_search(Key, List, Default) ->
    case lists:keysearch(Key, 1, List) of
        {value,{_,Val}} ->
            Val;
        false ->
            Default
    end.

verbose(Lines, true, Direction) ->
    DirStr =
        case Direction of
            send ->
                "Sending: ";
            _ ->
                "Receiving: "
        end,
    Str = string:strip(string:strip(Lines, right, $\n), right, $\r),
    erlang:display(DirStr ++ Str);
verbose(_, false, _) ->
    ok.

progress(Options) ->
    ftp_progress:start_link(Options).

progress_report(_, #state{progress = ignore}) ->
    ok;
progress_report(stop, #state{progress = ProgressPid}) ->
    ftp_progress:stop(ProgressPid);
progress_report({binary,Data}, #state{progress = ProgressPid}) ->
    ftp_progress:report(ProgressPid, {transfer_size,size(Data)});
progress_report(Report, #state{progress = ProgressPid}) ->
    ftp_progress:report(ProgressPid, Report).

millisec_time() ->
    {A,B,C} = now(),
    A * 1000000000 + B * 1000 + C div 1000.



