-file("test/lib/percept/src/egd_font.erl", 1).

-module(egd_font).

-export([load/1,size/1,glyph/2]).

-file("test/lib/percept/src/egd.hrl", 1).

-type rgba_float() :: {float(), float(), float(), float()}.

-type rgba_byte() :: {byte(), byte(), byte(), byte()}.

-type rgb() :: {byte(), byte(), byte()}.

-record(image_object,{type,points = [],span,internals,intervals,color}).

-record(image,{width,
               height,
               objects = [],
               background = {1.0,1.0,1.0,1.0},
               image}).

-file("test/lib/percept/src/egd_font.erl", 27).

size(Font) ->
    [{_Key,_Description,Size}] =
        ets:lookup(egd_font_table, {Font,information}),
    Size.

glyph(Font, Code) ->
    [{_Key,Translation,LSs}] = ets:lookup(egd_font_table, {Font,Code}),
    {Translation,LSs}.

load(Filename) ->
    {ok,Bin} = file:read_file(Filename),
    Font = binary_to_term(Bin),
    load_font_header(Font).

initialize_table() ->
    ets:new(egd_font_table, [named_table,ordered_set,public]).

glyph_insert(Font, Code, Translation, LSs) ->
    Element = {{Font,Code},Translation,LSs},
    ets:insert(egd_font_table, Element).

font_insert(Font, Description, Dimensions) ->
    Element = {{Font,information},Description,Dimensions},
    ets:insert(egd_font_table, Element).

is_font_loaded(Font) ->
    try
        case ets:lookup(egd_font_table, {Font,information}) of
            [] ->
                false;
            _ ->
                true
        end
    catch
        error:_ ->
            initialize_table(),
            false
    end.

load_font_header({_Type,_Version,Font}) ->
    load_font_body(Font).

load_font_body({Key,Desc,W,H,Glyphs,Bitmaps}) ->
    case is_font_loaded(Key) of
        true ->
            Key;
        false ->
            font_insert(Key, Desc, {W,H}),
            parse_glyphs(Glyphs, Bitmaps, Key),
            Key
    end.

parse_glyphs([], _, _Key) ->
    ok;
parse_glyphs([Glyph|Glyphs], Bs, Key) ->
    {Code,Translation,LSs} = parse_glyph(Glyph, Bs),
    glyph_insert(Key, Code, Translation, LSs),
    parse_glyphs(Glyphs, Bs, Key).

parse_glyph({Code,W,H,X0,Y0,Xm,Offset}, Bitmasks) ->
    BytesPerLine = (W + 7) div 8,
    NumBytes = BytesPerLine * H,
    <<_:Offset/binary,Bitmask:NumBytes/binary,_/binary>> = Bitmasks,
    LSs = render_glyph(W, H, X0, Y0, Xm, Bitmask),
    {Code,{W,H,X0,Y0,Xm},LSs}.

render_glyph(W, H, X0, Y0, Xm, Bitmask) ->
    render_glyph(W, {0,H}, X0, Y0, Xm, Bitmask, []).

render_glyph(_W, {H,H}, _X0, _Y0, _Xm, _Bitmask, Out) ->
    Out;
render_glyph(W, {Hi,H}, X0, Y0, Xm, Bitmask, LSs) ->
    N = (W + 7) div 8,
    O = N * Hi,
    <<_:O/binary,Submask/binary>> = Bitmask,
    LS = render_glyph_horizontal(Submask, {down,W - 1}, W - 1, []),
    render_glyph(W, {Hi + 1,H}, X0, Y0, Xm, Bitmask, [LS|LSs]).

render_glyph_horizontal(Value, {Pr,Px}, 0, Spans) ->
    Cr = bit_spin(Value, 0),
    case {Pr,Cr} of
        {up,up} ->
            [{0,Px}|Spans];
        {up,down} ->
            [{1,Px}|Spans];
        {down,up} ->
            [{0,0}|Spans];
        {down,down} ->
            Spans
    end;
render_glyph_horizontal(Value, {Pr,Px}, Cx, Spans) ->
    Cr = bit_spin(Value, Cx),
    case {Pr,Cr} of
        {up,up} ->
            render_glyph_horizontal(Value, {Cr,Px}, Cx - 1, Spans);
        {up,down} ->
            render_glyph_horizontal(Value,
                                    {Cr,Cx},
                                    Cx - 1,
                                    [{Cx + 1,Px}|Spans]);
        {down,up} ->
            render_glyph_horizontal(Value, {Cr,Cx}, Cx - 1, Spans);
        {down,down} ->
            render_glyph_horizontal(Value, {Cr,Px}, Cx - 1, Spans)
    end.

bit_spin(Value, Cx) ->
    <<_:Cx,Bit:1,_/bits>> = Value,
    case Bit of
        1 ->
            up;
        0 ->
            down
    end.



