-file("test/lib/kernel/src/file.erl", 1).

-module(file).

-export([format_error/1]).

-export([get_cwd/0,
         get_cwd/1,
         set_cwd/1,
         delete/1,
         rename/2,
         make_dir/1,
         del_dir/1,
         list_dir/1,
         list_dir_all/1,
         read_file_info/1,
         read_file_info/2,
         write_file_info/2,
         write_file_info/3,
         altname/1,
         read_link_info/1,
         read_link_info/2,
         read_link/1,
         read_link_all/1,
         make_link/2,
         make_symlink/2,
         read_file/1,
         write_file/2,
         write_file/3]).

-export([ipread_s32bu_p32bu/3]).

-export([open/2,
         close/1,
         advise/4,
         allocate/3,
         read/2,
         write/2,
         pread/2,
         pread/3,
         pwrite/2,
         pwrite/3,
         read_line/1,
         position/2,
         truncate/1,
         datasync/1,
         sync/1,
         copy/2,
         copy/3]).

-export([consult/1,path_consult/2]).

-export([eval/1,eval/2,path_eval/2,path_eval/3,path_open/3]).

-export([script/1,script/2,path_script/2,path_script/3]).

-export([change_owner/2,
         change_owner/3,
         change_group/2,
         change_mode/2,
         change_time/2,
         change_time/3]).

-export([pid2name/1]).

-export([sendfile/2,sendfile/5]).

-export([raw_read_file_info/1,raw_write_file_info/2]).

-export([copy_opened/3]).

-export([ipread_s32bu_p32bu_int/3]).

-export_type([{date_time,0},
              {fd,0},
              {file_info,0},
              {filename,0},
              {filename_all,0},
              {io_device,0},
              {name,0},
              {name_all,0},
              {posix,0}]).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/kernel/src/../include/file.hrl",
      1).

-record(file_info,{size :: undefined | non_neg_integer(),
                   type :: undefined
                         | device
                         | directory
                         | other
                         | regular
                         | symlink,
                   access :: undefined
                           | read
                           | write
                           | read_write
                           | none,
                   atime :: undefined
                          | file:date_time()
                          | non_neg_integer(),
                   mtime :: undefined
                          | file:date_time()
                          | non_neg_integer(),
                   ctime :: undefined
                          | file:date_time()
                          | non_neg_integer(),
                   mode :: undefined | non_neg_integer(),
                   links :: undefined | non_neg_integer(),
                   major_device :: undefined | non_neg_integer(),
                   minor_device :: undefined | non_neg_integer(),
                   inode :: undefined | non_neg_integer(),
                   uid :: undefined | non_neg_integer(),
                   gid :: undefined | non_neg_integer()}).

-record(file_descriptor,{module :: undefined | module(),
                         data :: undefined | term()}).

-file("test/lib/kernel/src/file.erl", 75).

-type filename() :: string().

-type filename_all() :: string() | binary().

-type file_info() :: #file_info{}.

-type fd() :: #file_descriptor{}.

-type io_device() :: pid() | fd().

-type location() :: integer()
                  | {bof, Offset :: integer()}
                  | {cur, Offset :: integer()}
                  | {eof, Offset :: integer()}
                  | bof
                  | cur
                  | eof.

-type mode() :: read
              | write
              | append
              | exclusive
              | raw
              | binary
              | {delayed_write,
                 Size :: non_neg_integer(),
                 Delay :: non_neg_integer()}
              | delayed_write
              | {read_ahead, Size :: pos_integer()}
              | read_ahead
              | compressed
              | {encoding, unicode:encoding()}.

-type deep_list() :: [char() | atom() | deep_list()].

-type name() :: string() | atom() | deep_list().

-type name_all() :: string()
                  | atom()
                  | deep_list()
                  | (RawFilename :: binary()).

-type posix() :: eacces
               | eagain
               | ebadf
               | ebusy
               | edquot
               | eexist
               | efault
               | efbig
               | eintr
               | einval
               | eio
               | eisdir
               | eloop
               | emfile
               | emlink
               | enametoolong
               | enfile
               | enodev
               | enoent
               | enomem
               | enospc
               | enotblk
               | enotdir
               | enotsup
               | enxio
               | eperm
               | epipe
               | erofs
               | espipe
               | esrch
               | estale
               | exdev.

-type date_time() :: calendar:datetime().

-type posix_file_advise() :: normal
                           | sequential
                           | random
                           | no_reuse
                           | will_need
                           | dont_need.

-type sendfile_option() :: {chunk_size, non_neg_integer()}.

-type file_info_option() :: {time, local}
                          | {time, universal}
                          | {time, posix}.

-export([file_info/1,native_name_encoding/0]).

-spec file_info(Filename) -> {ok, FileInfo} | {error, Reason}
                   when
                       is_subtype(Filename, name_all()),
                       is_subtype(FileInfo, file_info()),
                       is_subtype(Reason, posix() | badarg).

file_info(_) ->
    erlang:nif_error(undef).

-spec native_name_encoding() -> latin1 | utf8.

native_name_encoding() ->
    erlang:nif_error(undef).

-spec format_error(Reason) -> Chars
                      when
                          is_subtype(Reason,
                                     posix() |
                                     badarg |
                                     terminated |
                                     system_limit |
                                     {Line :: integer(),
                                      Mod :: module(),
                                      Term :: term()}),
                          is_subtype(Chars, string()).

format_error({_Line,file,undefined_script}) ->
    "no value returned from script";
format_error({Line,file,{Class,Reason,Stacktrace}}) ->
    io_lib:format("~w: evaluation failed with reason ~w:~w and stacktra"
                  "ce ~w",
                  [Line,Class,Reason,Stacktrace]);
format_error({Line,file,{Reason,Stacktrace}}) ->
    io_lib:format("~w: evaluation failed with reason ~w and stacktrace "
                  "~w",
                  [Line,Reason,Stacktrace]);
format_error({Line,Mod,Reason}) ->
    io_lib:format("~w: ~ts", [Line,Mod:format_error(Reason)]);
format_error(badarg) ->
    "bad argument";
format_error(system_limit) ->
    "a system limit was hit, probably not enough ports";
format_error(terminated) ->
    "the file server process is terminated";
format_error(ErrorId) ->
    erl_posix_msg:message(ErrorId).

-spec pid2name(Pid) -> {ok, Filename} | undefined
                  when
                      is_subtype(Filename, filename_all()),
                      is_subtype(Pid, pid()).

pid2name(Pid) when is_pid(Pid) ->
    case whereis(file_server_2) of
        undefined ->
            undefined;
        _ ->
            case ets:lookup(file_io_servers, Pid) of
                [{_,Name}|_] ->
                    {ok,Name};
                _ ->
                    undefined
            end
    end.

-spec get_cwd() -> {ok, Dir} | {error, Reason}
                 when
                     is_subtype(Dir, filename()),
                     is_subtype(Reason, posix()).

get_cwd() ->
    call(get_cwd, []).

-spec get_cwd(Drive) -> {ok, Dir} | {error, Reason}
                 when
                     is_subtype(Drive, string()),
                     is_subtype(Dir, filename()),
                     is_subtype(Reason, posix() | badarg).

get_cwd(Drive) ->
    check_and_call(get_cwd, [file_name(Drive)]).

-spec set_cwd(Dir) -> ok | {error, Reason}
                 when
                     is_subtype(Dir, name()),
                     is_subtype(Reason,
                                posix() | badarg | no_translation).

set_cwd(Dirname) ->
    check_and_call(set_cwd, [file_name(Dirname)]).

-spec delete(Filename) -> ok | {error, Reason}
                when
                    is_subtype(Filename, name_all()),
                    is_subtype(Reason, posix() | badarg).

delete(Name) ->
    check_and_call(delete, [file_name(Name)]).

-spec rename(Source, Destination) -> ok | {error, Reason}
                when
                    is_subtype(Source, name_all()),
                    is_subtype(Destination, name_all()),
                    is_subtype(Reason, posix() | badarg).

rename(From, To) ->
    check_and_call(rename, [file_name(From),file_name(To)]).

-spec make_dir(Dir) -> ok | {error, Reason}
                  when
                      is_subtype(Dir, name_all()),
                      is_subtype(Reason, posix() | badarg).

make_dir(Name) ->
    check_and_call(make_dir, [file_name(Name)]).

-spec del_dir(Dir) -> ok | {error, Reason}
                 when
                     is_subtype(Dir, name_all()),
                     is_subtype(Reason, posix() | badarg).

del_dir(Name) ->
    check_and_call(del_dir, [file_name(Name)]).

-spec read_file_info(Filename) -> {ok, FileInfo} | {error, Reason}
                        when
                            is_subtype(Filename, name_all()),
                            is_subtype(FileInfo, file_info()),
                            is_subtype(Reason, posix() | badarg).

read_file_info(Name) ->
    check_and_call(read_file_info, [file_name(Name)]).

-spec read_file_info(Filename, Opts) -> {ok, FileInfo} | {error, Reason}
                        when
                            is_subtype(Filename, name_all()),
                            is_subtype(Opts, [file_info_option()]),
                            is_subtype(FileInfo, file_info()),
                            is_subtype(Reason, posix() | badarg).

read_file_info(Name, Opts) when is_list(Opts) ->
    check_and_call(read_file_info, [file_name(Name),Opts]).

-spec altname(Name :: name_all()) -> any().

altname(Name) ->
    check_and_call(altname, [file_name(Name)]).

-spec read_link_info(Name) -> {ok, FileInfo} | {error, Reason}
                        when
                            is_subtype(Name, name_all()),
                            is_subtype(FileInfo, file_info()),
                            is_subtype(Reason, posix() | badarg).

read_link_info(Name) ->
    check_and_call(read_link_info, [file_name(Name)]).

-spec read_link_info(Name, Opts) -> {ok, FileInfo} | {error, Reason}
                        when
                            is_subtype(Name, name_all()),
                            is_subtype(Opts, [file_info_option()]),
                            is_subtype(FileInfo, file_info()),
                            is_subtype(Reason, posix() | badarg).

read_link_info(Name, Opts) when is_list(Opts) ->
    check_and_call(read_link_info, [file_name(Name),Opts]).

-spec read_link(Name) -> {ok, Filename} | {error, Reason}
                   when
                       is_subtype(Name, name_all()),
                       is_subtype(Filename, filename()),
                       is_subtype(Reason, posix() | badarg).

read_link(Name) ->
    check_and_call(read_link, [file_name(Name)]).

-spec read_link_all(Name) -> {ok, Filename} | {error, Reason}
                       when
                           is_subtype(Name, name_all()),
                           is_subtype(Filename, filename_all()),
                           is_subtype(Reason, posix() | badarg).

read_link_all(Name) ->
    check_and_call(read_link_all, [file_name(Name)]).

-spec write_file_info(Filename, FileInfo) -> ok | {error, Reason}
                         when
                             is_subtype(Filename, name_all()),
                             is_subtype(FileInfo, file_info()),
                             is_subtype(Reason, posix() | badarg).

write_file_info(Name, Info = #file_info{}) ->
    check_and_call(write_file_info, [file_name(Name),Info]).

-spec write_file_info(Filename, FileInfo, Opts) -> ok | {error, Reason}
                         when
                             is_subtype(Filename, name_all()),
                             is_subtype(Opts, [file_info_option()]),
                             is_subtype(FileInfo, file_info()),
                             is_subtype(Reason, posix() | badarg).

write_file_info(Name, Info = #file_info{}, Opts) when is_list(Opts) ->
    check_and_call(write_file_info, [file_name(Name),Info,Opts]).

-spec list_dir(Dir) -> {ok, Filenames} | {error, Reason}
                  when
                      is_subtype(Dir, name_all()),
                      is_subtype(Filenames, [filename()]),
                      is_subtype(Reason,
                                 posix() |
                                 badarg |
                                 {no_translation,
                                  Filename :: unicode:latin1_binary()}).

list_dir(Name) ->
    check_and_call(list_dir, [file_name(Name)]).

-spec list_dir_all(Dir) -> {ok, Filenames} | {error, Reason}
                      when
                          is_subtype(Dir, name_all()),
                          is_subtype(Filenames, [filename_all()]),
                          is_subtype(Reason, posix() | badarg).

list_dir_all(Name) ->
    check_and_call(list_dir_all, [file_name(Name)]).

-spec read_file(Filename) -> {ok, Binary} | {error, Reason}
                   when
                       is_subtype(Filename, name_all()),
                       is_subtype(Binary, binary()),
                       is_subtype(Reason,
                                  posix() |
                                  badarg |
                                  terminated |
                                  system_limit).

read_file(Name) ->
    check_and_call(read_file, [file_name(Name)]).

-spec make_link(Existing, New) -> ok | {error, Reason}
                   when
                       is_subtype(Existing, name_all()),
                       is_subtype(New, name_all()),
                       is_subtype(Reason, posix() | badarg).

make_link(Old, New) ->
    check_and_call(make_link, [file_name(Old),file_name(New)]).

-spec make_symlink(Existing, New) -> ok | {error, Reason}
                      when
                          is_subtype(Existing, name_all()),
                          is_subtype(New, name_all()),
                          is_subtype(Reason, posix() | badarg).

make_symlink(Old, New) ->
    check_and_call(make_symlink, [file_name(Old),file_name(New)]).

-spec write_file(Filename, Bytes) -> ok | {error, Reason}
                    when
                        is_subtype(Filename, name_all()),
                        is_subtype(Bytes, iodata()),
                        is_subtype(Reason,
                                   posix() |
                                   badarg |
                                   terminated |
                                   system_limit).

write_file(Name, Bin) ->
    check_and_call(write_file, [file_name(Name),make_binary(Bin)]).

-spec write_file(Filename, Bytes, Modes) -> ok | {error, Reason}
                    when
                        is_subtype(Filename, name_all()),
                        is_subtype(Bytes, iodata()),
                        is_subtype(Modes, [mode()]),
                        is_subtype(Reason,
                                   posix() |
                                   badarg |
                                   terminated |
                                   system_limit).

write_file(Name, Bin, ModeList) when is_list(ModeList) ->
    case make_binary(Bin) of
        B when is_binary(B) ->
            case
                open(Name,
                     [binary,
                      write|
                      lists:delete(binary,
                                   lists:delete(write, ModeList))])
            of
                {ok,Handle} ->
                    case write(Handle, B) of
                        ok ->
                            close(Handle);
                        E1 ->
                            close(Handle),
                            E1
                    end;
                E2 ->
                    E2
            end;
        E3 ->
            E3
    end.

raw_read_file_info(Name) ->
    Args = [file_name(Name)],
    case check_args(Args) of
        ok ->
            [FileName] = Args,
            prim_file:read_file_info(FileName);
        Error ->
            Error
    end.

raw_write_file_info(Name, #file_info{} = Info) ->
    Args = [file_name(Name)],
    case check_args(Args) of
        ok ->
            [FileName] = Args,
            prim_file:write_file_info(FileName, Info);
        Error ->
            Error
    end.

-spec open(File, Modes) -> {ok, IoDevice} | {error, Reason}
              when
                  is_subtype(File, Filename | iodata()),
                  is_subtype(Filename, name_all()),
                  is_subtype(Modes, [mode() | ram]),
                  is_subtype(IoDevice, io_device()),
                  is_subtype(Reason, posix() | badarg | system_limit).

open(Item, ModeList) when is_list(ModeList) ->
    case lists:member(raw, ModeList) of
        true ->
            case catch application:get_env(kernel, raw_files) of
                {ok,false} ->
                    open(Item, lists:delete(raw, ModeList));
                _ ->
                    Args = [file_name(Item)|ModeList],
                    case check_args(Args) of
                        ok ->
                            [FileName|_] = Args,
                            prim_file:open(FileName, ModeList);
                        Error ->
                            Error
                    end
            end;
        false ->
            case lists:member(ram, ModeList) of
                true ->
                    case check_args(ModeList) of
                        ok ->
                            ram_file:open(Item, ModeList);
                        Error ->
                            Error
                    end;
                false ->
                    Args = [file_name(Item)|ModeList],
                    case check_args(Args) of
                        ok ->
                            [FileName|_] = Args,
                            call(open, [FileName,ModeList]);
                        Error ->
                            Error
                    end
            end
    end;
open(Item, Mode) ->
    open(Item, mode_list(Mode)).

-spec close(IoDevice) -> ok | {error, Reason}
               when
                   is_subtype(IoDevice, io_device()),
                   is_subtype(Reason, posix() | badarg | terminated).

close(File) when is_pid(File) ->
    case file_request(File, close) of
        {error,terminated} ->
            ok;
        Other ->
            Other
    end;
close(#file_descriptor{module = Module} = Handle) ->
    Module:close(Handle);
close(_) ->
    {error,badarg}.

-spec advise(IoDevice, Offset, Length, Advise) -> ok | {error, Reason}
                when
                    is_subtype(IoDevice, io_device()),
                    is_subtype(Offset, integer()),
                    is_subtype(Length, integer()),
                    is_subtype(Advise, posix_file_advise()),
                    is_subtype(Reason, posix() | badarg).

advise(File, Offset, Length, Advise) when is_pid(File) ->
    file_request(File, {advise,Offset,Length,Advise});
advise(#file_descriptor{module = Module} = Handle,
       Offset,
       Length,
       Advise) ->
    Module:advise(Handle, Offset, Length, Advise);
advise(_, _, _, _) ->
    {error,badarg}.

-spec allocate(File, Offset, Length) -> ok | {error, posix()}
                  when
                      is_subtype(File, io_device()),
                      is_subtype(Offset, non_neg_integer()),
                      is_subtype(Length, non_neg_integer()).

allocate(File, Offset, Length) when is_pid(File) ->
    file_request(File, {allocate,Offset,Length});
allocate(#file_descriptor{module = Module} = Handle, Offset, Length) ->
    Module:allocate(Handle, Offset, Length).

-spec read(IoDevice, Number) -> {ok, Data} | eof | {error, Reason}
              when
                  is_subtype(IoDevice, io_device() | atom()),
                  is_subtype(Number, non_neg_integer()),
                  is_subtype(Data, string() | binary()),
                  is_subtype(Reason,
                             posix() |
                             badarg |
                             terminated |
                             {no_translation, unicode, latin1}).

read(File, Sz)
    when
        is_pid(File)
        orelse
        is_atom(File),
        is_integer(Sz),
        Sz >= 0 ->
    case io:request(File, {get_chars,'',Sz}) of
        Data when is_list(Data); is_binary(Data) ->
            {ok,Data};
        Other ->
            Other
    end;
read(#file_descriptor{module = Module} = Handle, Sz)
    when is_integer(Sz), Sz >= 0 ->
    Module:read(Handle, Sz);
read(_, _) ->
    {error,badarg}.

-spec read_line(IoDevice) -> {ok, Data} | eof | {error, Reason}
                   when
                       is_subtype(IoDevice, io_device() | atom()),
                       is_subtype(Data, string() | binary()),
                       is_subtype(Reason,
                                  posix() |
                                  badarg |
                                  terminated |
                                  {no_translation, unicode, latin1}).

read_line(File)
    when
        is_pid(File)
        orelse
        is_atom(File) ->
    case io:request(File, {get_line,''}) of
        Data when is_list(Data); is_binary(Data) ->
            {ok,Data};
        Other ->
            Other
    end;
read_line(#file_descriptor{module = Module} = Handle) ->
    Module:read_line(Handle);
read_line(_) ->
    {error,badarg}.

-spec pread(IoDevice, LocNums) -> {ok, DataL} | eof | {error, Reason}
               when
                   is_subtype(IoDevice, io_device()),
                   is_subtype(LocNums,
                              [{Location :: location(),
                                Number :: non_neg_integer()}]),
                   is_subtype(DataL, [Data]),
                   is_subtype(Data, string() | binary() | eof),
                   is_subtype(Reason, posix() | badarg | terminated).

pread(File, L) when is_pid(File), is_list(L) ->
    pread_int(File, L, []);
pread(#file_descriptor{module = Module} = Handle, L) when is_list(L) ->
    Module:pread(Handle, L);
pread(_, _) ->
    {error,badarg}.

pread_int(_File, [], R) ->
    {ok,lists:reverse(R)};
pread_int(File, [{At,Sz}|T], R) when is_integer(Sz), Sz >= 0 ->
    case pread(File, At, Sz) of
        {ok,Data} ->
            pread_int(File, T, [Data|R]);
        eof ->
            pread_int(File, T, [eof|R]);
        {error,_} = Error ->
            Error
    end;
pread_int(_, _, _) ->
    {error,badarg}.

-spec pread(IoDevice, Location, Number) ->
               {ok, Data} | eof | {error, Reason}
               when
                   is_subtype(IoDevice, io_device()),
                   is_subtype(Location, location()),
                   is_subtype(Number, non_neg_integer()),
                   is_subtype(Data, string() | binary()),
                   is_subtype(Reason, posix() | badarg | terminated).

pread(File, At, Sz) when is_pid(File), is_integer(Sz), Sz >= 0 ->
    file_request(File, {pread,At,Sz});
pread(#file_descriptor{module = Module} = Handle, Offs, Sz)
    when is_integer(Sz), Sz >= 0 ->
    Module:pread(Handle, Offs, Sz);
pread(_, _, _) ->
    {error,badarg}.

-spec write(IoDevice, Bytes) -> ok | {error, Reason}
               when
                   is_subtype(IoDevice, io_device() | atom()),
                   is_subtype(Bytes, iodata()),
                   is_subtype(Reason, posix() | badarg | terminated).

write(File, Bytes)
    when
        is_pid(File)
        orelse
        is_atom(File) ->
    case make_binary(Bytes) of
        Bin when is_binary(Bin) ->
            io:request(File, {put_chars,latin1,Bin});
        Error ->
            Error
    end;
write(#file_descriptor{module = Module} = Handle, Bytes) ->
    Module:write(Handle, Bytes);
write(_, _) ->
    {error,badarg}.

-spec pwrite(IoDevice, LocBytes) -> ok | {error, {N, Reason}}
                when
                    is_subtype(IoDevice, io_device()),
                    is_subtype(LocBytes,
                               [{Location :: location(),
                                 Bytes :: iodata()}]),
                    is_subtype(N, non_neg_integer()),
                    is_subtype(Reason, posix() | badarg | terminated).

pwrite(File, L) when is_pid(File), is_list(L) ->
    pwrite_int(File, L, 0);
pwrite(#file_descriptor{module = Module} = Handle, L) when is_list(L) ->
    Module:pwrite(Handle, L);
pwrite(_, _) ->
    {error,badarg}.

pwrite_int(_File, [], _R) ->
    ok;
pwrite_int(File, [{At,Bytes}|T], R) ->
    case pwrite(File, At, Bytes) of
        ok ->
            pwrite_int(File, T, R + 1);
        {error,Reason} ->
            {error,{R,Reason}}
    end;
pwrite_int(_, _, _) ->
    {error,badarg}.

-spec pwrite(IoDevice, Location, Bytes) -> ok | {error, Reason}
                when
                    is_subtype(IoDevice, io_device()),
                    is_subtype(Location, location()),
                    is_subtype(Bytes, iodata()),
                    is_subtype(Reason, posix() | badarg | terminated).

pwrite(File, At, Bytes) when is_pid(File) ->
    file_request(File, {pwrite,At,Bytes});
pwrite(#file_descriptor{module = Module} = Handle, Offs, Bytes) ->
    Module:pwrite(Handle, Offs, Bytes);
pwrite(_, _, _) ->
    {error,badarg}.

-spec datasync(IoDevice) -> ok | {error, Reason}
                  when
                      is_subtype(IoDevice, io_device()),
                      is_subtype(Reason, posix() | badarg | terminated).

datasync(File) when is_pid(File) ->
    file_request(File, datasync);
datasync(#file_descriptor{module = Module} = Handle) ->
    Module:datasync(Handle);
datasync(_) ->
    {error,badarg}.

-spec sync(IoDevice) -> ok | {error, Reason}
              when
                  is_subtype(IoDevice, io_device()),
                  is_subtype(Reason, posix() | badarg | terminated).

sync(File) when is_pid(File) ->
    file_request(File, sync);
sync(#file_descriptor{module = Module} = Handle) ->
    Module:sync(Handle);
sync(_) ->
    {error,badarg}.

-spec position(IoDevice, Location) ->
                  {ok, NewPosition} | {error, Reason}
                  when
                      is_subtype(IoDevice, io_device()),
                      is_subtype(Location, location()),
                      is_subtype(NewPosition, integer()),
                      is_subtype(Reason, posix() | badarg | terminated).

position(File, At) when is_pid(File) ->
    file_request(File, {position,At});
position(#file_descriptor{module = Module} = Handle, At) ->
    Module:position(Handle, At);
position(_, _) ->
    {error,badarg}.

-spec truncate(IoDevice) -> ok | {error, Reason}
                  when
                      is_subtype(IoDevice, io_device()),
                      is_subtype(Reason, posix() | badarg | terminated).

truncate(File) when is_pid(File) ->
    file_request(File, truncate);
truncate(#file_descriptor{module = Module} = Handle) ->
    Module:truncate(Handle);
truncate(_) ->
    {error,badarg}.

-spec copy(Source, Destination) -> {ok, BytesCopied} | {error, Reason}
              when
                  is_subtype(Source,
                             io_device() | Filename | {Filename, Modes}),
                  is_subtype(Destination,
                             io_device() | Filename | {Filename, Modes}),
                  is_subtype(Filename, name_all()),
                  is_subtype(Modes, [mode()]),
                  is_subtype(BytesCopied, non_neg_integer()),
                  is_subtype(Reason, posix() | badarg | terminated).

copy(Source, Dest) ->
    copy_int(Source, Dest, infinity).

-spec copy(Source, Destination, ByteCount) ->
              {ok, BytesCopied} | {error, Reason}
              when
                  is_subtype(Source,
                             io_device() | Filename | {Filename, Modes}),
                  is_subtype(Destination,
                             io_device() | Filename | {Filename, Modes}),
                  is_subtype(Filename, name_all()),
                  is_subtype(Modes, [mode()]),
                  is_subtype(ByteCount, non_neg_integer() | infinity),
                  is_subtype(BytesCopied, non_neg_integer()),
                  is_subtype(Reason, posix() | badarg | terminated).

copy(Source, Dest, Length)
    when is_integer(Length), Length >= 0; is_atom(Length) ->
    copy_int(Source, Dest, Length);
copy(_, _, _) ->
    {error,badarg}.

copy_int(Source, Dest, Length)
    when
        is_pid(Source), is_pid(Dest);
        is_pid(Source), is_record(Dest, file_descriptor);
        is_record(Source, file_descriptor), is_pid(Dest) ->
    copy_opened_int(Source, Dest, Length, 0);
copy_int(#file_descriptor{module = Module} = Source,
         #file_descriptor{module = Module} = Dest,
         Length) ->
    Module:copy(Source, Dest, Length);
copy_int(#file_descriptor{} = Source, #file_descriptor{} = Dest, Length) ->
    copy_opened_int(Source, Dest, Length, 0);
copy_int({SourceName,SourceOpts}, {DestName,DestOpts}, Length)
    when is_list(SourceOpts), is_list(DestOpts) ->
    check_and_call(copy,
                   [file_name(SourceName),
                    SourceOpts,
                    file_name(DestName),
                    DestOpts,
                    Length]);
copy_int({SourceName,SourceOpts}, Dest, Length)
    when
        is_list(SourceOpts), is_pid(Dest);
        is_list(SourceOpts), is_record(Dest, file_descriptor) ->
    case file_name(SourceName) of
        {error,_} = Error ->
            Error;
        Source ->
            case open(Source, [read|SourceOpts]) of
                {ok,Handle} ->
                    Result = copy_opened_int(Handle, Dest, Length, 0),
                    close(Handle),
                    Result;
                {error,_} = Error ->
                    Error
            end
    end;
copy_int(Source, {DestName,DestOpts}, Length)
    when
        is_pid(Source), is_list(DestOpts);
        is_record(Source, file_descriptor), is_list(DestOpts) ->
    case file_name(DestName) of
        {error,_} = Error ->
            Error;
        Dest ->
            case open(Dest, [write|DestOpts]) of
                {ok,Handle} ->
                    Result = copy_opened_int(Source, Handle, Length, 0),
                    close(Handle),
                    Result;
                {error,_} = Error ->
                    Error
            end
    end;
copy_int(Source, Dest, Length)
    when is_pid(Source); is_record(Source, file_descriptor) ->
    copy_int(Source, {Dest,[]}, Length);
copy_int({_SourceName,SourceOpts} = Source, Dest, Length)
    when is_list(SourceOpts) ->
    copy_int(Source, {Dest,[]}, Length);
copy_int(Source, Dest, Length)
    when is_pid(Dest); is_record(Dest, file_descriptor) ->
    copy_int({Source,[]}, Dest, Length);
copy_int(Source, {_DestName,DestOpts} = Dest, Length)
    when is_list(DestOpts) ->
    copy_int({Source,[]}, Dest, Length);
copy_int(Source, Dest, Length) ->
    copy_int({Source,[]}, {Dest,[]}, Length).

copy_opened(Source, Dest, Length)
    when is_integer(Length), Length >= 0; is_atom(Length) ->
    copy_opened_int(Source, Dest, Length);
copy_opened(_, _, _) ->
    {error,badarg}.

copy_opened_int(Source, Dest, Length) when is_pid(Source), is_pid(Dest) ->
    copy_opened_int(Source, Dest, Length, 0);
copy_opened_int(Source, Dest, Length)
    when is_pid(Source), is_record(Dest, file_descriptor) ->
    copy_opened_int(Source, Dest, Length, 0);
copy_opened_int(Source, Dest, Length)
    when is_record(Source, file_descriptor), is_pid(Dest) ->
    copy_opened_int(Source, Dest, Length, 0);
copy_opened_int(Source, Dest, Length)
    when
        is_record(Source, file_descriptor),
        is_record(Dest, file_descriptor) ->
    copy_opened_int(Source, Dest, Length, 0);
copy_opened_int(_, _, _) ->
    {error,badarg}.

copy_opened_int(_, _, Length, Copied) when Length =< 0 ->
    {ok,Copied};
copy_opened_int(Source, Dest, Length, Copied) ->
    N = if
            Length > 65536 ->
                65536;
            true ->
                Length
        end,
    case read(Source, N) of
        {ok,Data} ->
            M = if
                    is_binary(Data) ->
                        byte_size(Data);
                    is_list(Data) ->
                        length(Data)
                end,
            case write(Dest, Data) of
                ok ->
                    if
                        M < N ->
                            {ok,Copied + M};
                        true ->
                            NewLength =
                                if
                                    is_atom(Length) ->
                                        Length;
                                    true ->
                                        Length - M
                                end,
                            copy_opened_int(Source,
                                            Dest,
                                            NewLength,
                                            Copied + M)
                    end;
                {error,_} = Error ->
                    Error
            end;
        eof ->
            {ok,Copied};
        {error,_} = Error ->
            Error
    end.

ipread_s32bu_p32bu(File, Pos, MaxSize) when is_pid(File) ->
    ipread_s32bu_p32bu_int(File, Pos, MaxSize);
ipread_s32bu_p32bu(#file_descriptor{module = Module} = Handle,
                   Pos,
                   MaxSize) ->
    Module:ipread_s32bu_p32bu(Handle, Pos, MaxSize);
ipread_s32bu_p32bu(_, _, _) ->
    {error,badarg}.

ipread_s32bu_p32bu_int(File, Pos, Infinity) when is_atom(Infinity) ->
    ipread_s32bu_p32bu_int(File, Pos, 1 bsl 31 - 1);
ipread_s32bu_p32bu_int(File, Pos, MaxSize)
    when is_integer(MaxSize), MaxSize >= 0 ->
    if
        MaxSize < 1 bsl 31 ->
            case pread(File, Pos, 8) of
                {ok,Header} ->
                    ipread_s32bu_p32bu_2(File, Header, MaxSize);
                Error ->
                    Error
            end;
        true ->
            {error,einval}
    end;
ipread_s32bu_p32bu_int(_File, _Pos, _MaxSize) ->
    {error,badarg}.

ipread_s32bu_p32bu_2(_File,
                     <<0:32/big-unsigned,Pos:32/big-unsigned>>,
                     _MaxSize) ->
    {ok,{0,Pos,eof}};
ipread_s32bu_p32bu_2(File,
                     <<Size:32/big-unsigned,Pos:32/big-unsigned>>,
                     MaxSize)
    when Size =< MaxSize ->
    case pread(File, Pos, Size) of
        {ok,Data} ->
            {ok,{Size,Pos,Data}};
        eof ->
            {ok,{Size,Pos,eof}};
        Error ->
            Error
    end;
ipread_s32bu_p32bu_2(_File, <<_:8/binary>>, _MaxSize) ->
    eof;
ipread_s32bu_p32bu_2(_File, <<_/binary>>, _MaxSize) ->
    eof;
ipread_s32bu_p32bu_2(File, Header, MaxSize) when is_list(Header) ->
    ipread_s32bu_p32bu_2(File, list_to_binary(Header), MaxSize).

-spec consult(Filename) -> {ok, Terms} | {error, Reason}
                 when
                     is_subtype(Filename, name_all()),
                     is_subtype(Terms, [term()]),
                     is_subtype(Reason,
                                posix() |
                                badarg |
                                terminated |
                                system_limit |
                                {Line :: integer(),
                                 Mod :: module(),
                                 Term :: term()}).

consult(File) ->
    case open(File, [read]) of
        {ok,Fd} ->
            R = consult_stream(Fd),
            close(Fd),
            R;
        Error ->
            Error
    end.

-spec path_consult(Path, Filename) ->
                      {ok, Terms, FullName} | {error, Reason}
                      when
                          is_subtype(Path, [Dir]),
                          is_subtype(Dir, name_all()),
                          is_subtype(Filename, name_all()),
                          is_subtype(Terms, [term()]),
                          is_subtype(FullName, filename_all()),
                          is_subtype(Reason,
                                     posix() |
                                     badarg |
                                     terminated |
                                     system_limit |
                                     {Line :: integer(),
                                      Mod :: module(),
                                      Term :: term()}).

path_consult(Path, File) ->
    case path_open(Path, File, [read]) of
        {ok,Fd,Full} ->
            case consult_stream(Fd) of
                {ok,List} ->
                    close(Fd),
                    {ok,List,Full};
                E1 ->
                    close(Fd),
                    E1
            end;
        E2 ->
            E2
    end.

-spec eval(Filename) -> ok | {error, Reason}
              when
                  is_subtype(Filename, name_all()),
                  is_subtype(Reason,
                             posix() |
                             badarg |
                             terminated |
                             system_limit |
                             {Line :: integer(),
                              Mod :: module(),
                              Term :: term()}).

eval(File) ->
    eval(File, erl_eval:new_bindings()).

-spec eval(Filename, Bindings) -> ok | {error, Reason}
              when
                  is_subtype(Filename, name_all()),
                  is_subtype(Bindings, erl_eval:binding_struct()),
                  is_subtype(Reason,
                             posix() |
                             badarg |
                             terminated |
                             system_limit |
                             {Line :: integer(),
                              Mod :: module(),
                              Term :: term()}).

eval(File, Bs) ->
    case open(File, [read]) of
        {ok,Fd} ->
            R = eval_stream(Fd, ignore, Bs),
            close(Fd),
            R;
        Error ->
            Error
    end.

-spec path_eval(Path, Filename) -> {ok, FullName} | {error, Reason}
                   when
                       is_subtype(Path, [Dir :: name_all()]),
                       is_subtype(Filename, name_all()),
                       is_subtype(FullName, filename_all()),
                       is_subtype(Reason,
                                  posix() |
                                  badarg |
                                  terminated |
                                  system_limit |
                                  {Line :: integer(),
                                   Mod :: module(),
                                   Term :: term()}).

path_eval(Path, File) ->
    path_eval(Path, File, erl_eval:new_bindings()).

-spec path_eval(Path, Filename, Bindings) ->
                   {ok, FullName} | {error, Reason}
                   when
                       is_subtype(Path, [Dir :: name_all()]),
                       is_subtype(Filename, name_all()),
                       is_subtype(Bindings, erl_eval:binding_struct()),
                       is_subtype(FullName, filename_all()),
                       is_subtype(Reason,
                                  posix() |
                                  badarg |
                                  terminated |
                                  system_limit |
                                  {Line :: integer(),
                                   Mod :: module(),
                                   Term :: term()}).

path_eval(Path, File, Bs) ->
    case path_open(Path, File, [read]) of
        {ok,Fd,Full} ->
            case eval_stream(Fd, ignore, Bs) of
                ok ->
                    close(Fd),
                    {ok,Full};
                E1 ->
                    close(Fd),
                    E1
            end;
        E2 ->
            E2
    end.

-spec script(Filename) -> {ok, Value} | {error, Reason}
                when
                    is_subtype(Filename, name_all()),
                    is_subtype(Value, term()),
                    is_subtype(Reason,
                               posix() |
                               badarg |
                               terminated |
                               system_limit |
                               {Line :: integer(),
                                Mod :: module(),
                                Term :: term()}).

script(File) ->
    script(File, erl_eval:new_bindings()).

-spec script(Filename, Bindings) -> {ok, Value} | {error, Reason}
                when
                    is_subtype(Filename, name_all()),
                    is_subtype(Bindings, erl_eval:binding_struct()),
                    is_subtype(Value, term()),
                    is_subtype(Reason,
                               posix() |
                               badarg |
                               terminated |
                               system_limit |
                               {Line :: integer(),
                                Mod :: module(),
                                Term :: term()}).

script(File, Bs) ->
    case open(File, [read]) of
        {ok,Fd} ->
            R = eval_stream(Fd, return, Bs),
            close(Fd),
            R;
        Error ->
            Error
    end.

-spec path_script(Path, Filename) ->
                     {ok, Value, FullName} | {error, Reason}
                     when
                         is_subtype(Path, [Dir :: name_all()]),
                         is_subtype(Filename, name_all()),
                         is_subtype(Value, term()),
                         is_subtype(FullName, filename_all()),
                         is_subtype(Reason,
                                    posix() |
                                    badarg |
                                    terminated |
                                    system_limit |
                                    {Line :: integer(),
                                     Mod :: module(),
                                     Term :: term()}).

path_script(Path, File) ->
    path_script(Path, File, erl_eval:new_bindings()).

-spec path_script(Path, Filename, Bindings) ->
                     {ok, Value, FullName} | {error, Reason}
                     when
                         is_subtype(Path, [Dir :: name_all()]),
                         is_subtype(Filename, name_all()),
                         is_subtype(Bindings, erl_eval:binding_struct()),
                         is_subtype(Value, term()),
                         is_subtype(FullName, filename_all()),
                         is_subtype(Reason,
                                    posix() |
                                    badarg |
                                    terminated |
                                    system_limit |
                                    {Line :: integer(),
                                     Mod :: module(),
                                     Term :: term()}).

path_script(Path, File, Bs) ->
    case path_open(Path, File, [read]) of
        {ok,Fd,Full} ->
            case eval_stream(Fd, return, Bs) of
                {ok,R} ->
                    close(Fd),
                    {ok,R,Full};
                E1 ->
                    close(Fd),
                    E1
            end;
        E2 ->
            E2
    end.

-spec path_open(Path, Filename, Modes) ->
                   {ok, IoDevice, FullName} | {error, Reason}
                   when
                       is_subtype(Path, [Dir :: name_all()]),
                       is_subtype(Filename, name_all()),
                       is_subtype(Modes, [mode()]),
                       is_subtype(IoDevice, io_device()),
                       is_subtype(FullName, filename_all()),
                       is_subtype(Reason,
                                  posix() | badarg | system_limit).

path_open(PathList, Name, Mode) ->
    case file_name(Name) of
        {error,_} = Error ->
            Error;
        FileName ->
            case filename:pathtype(FileName) of
                relative ->
                    path_open_first(PathList, FileName, Mode, enoent);
                _ ->
                    case open(Name, Mode) of
                        {ok,Fd} ->
                            {ok,Fd,Name};
                        Error ->
                            Error
                    end
            end
    end.

-spec change_mode(Filename, Mode) -> ok | {error, Reason}
                     when
                         is_subtype(Filename, name_all()),
                         is_subtype(Mode, integer()),
                         is_subtype(Reason, posix() | badarg).

change_mode(Name, Mode) when is_integer(Mode) ->
    write_file_info(Name, #file_info{mode = Mode}).

-spec change_owner(Filename, Uid) -> ok | {error, Reason}
                      when
                          is_subtype(Filename, name_all()),
                          is_subtype(Uid, integer()),
                          is_subtype(Reason, posix() | badarg).

change_owner(Name, OwnerId) when is_integer(OwnerId) ->
    write_file_info(Name, #file_info{uid = OwnerId}).

-spec change_owner(Filename, Uid, Gid) -> ok | {error, Reason}
                      when
                          is_subtype(Filename, name_all()),
                          is_subtype(Uid, integer()),
                          is_subtype(Gid, integer()),
                          is_subtype(Reason, posix() | badarg).

change_owner(Name, OwnerId, GroupId)
    when is_integer(OwnerId), is_integer(GroupId) ->
    write_file_info(Name, #file_info{uid = OwnerId,gid = GroupId}).

-spec change_group(Filename, Gid) -> ok | {error, Reason}
                      when
                          is_subtype(Filename, name_all()),
                          is_subtype(Gid, integer()),
                          is_subtype(Reason, posix() | badarg).

change_group(Name, GroupId) when is_integer(GroupId) ->
    write_file_info(Name, #file_info{gid = GroupId}).

-spec change_time(Filename, Mtime) -> ok | {error, Reason}
                     when
                         is_subtype(Filename, name_all()),
                         is_subtype(Mtime, date_time()),
                         is_subtype(Reason, posix() | badarg).

change_time(Name, {{Y,M,D},{H,Min,Sec}} = Time)
    when
        is_integer(Y),
        is_integer(M),
        is_integer(D),
        is_integer(H),
        is_integer(Min),
        is_integer(Sec) ->
    write_file_info(Name, #file_info{mtime = Time}).

-spec change_time(Filename, Atime, Mtime) -> ok | {error, Reason}
                     when
                         is_subtype(Filename, name_all()),
                         is_subtype(Atime, date_time()),
                         is_subtype(Mtime, date_time()),
                         is_subtype(Reason, posix() | badarg).

change_time(Name,
            {{AY,AM,AD},{AH,AMin,ASec}} = Atime,
            {{MY,MM,MD},{MH,MMin,MSec}} = Mtime)
    when
        is_integer(AY),
        is_integer(AM),
        is_integer(AD),
        is_integer(AH),
        is_integer(AMin),
        is_integer(ASec),
        is_integer(MY),
        is_integer(MM),
        is_integer(MD),
        is_integer(MH),
        is_integer(MMin),
        is_integer(MSec) ->
    write_file_info(Name, #file_info{atime = Atime,mtime = Mtime}).

-spec sendfile(RawFile, Socket, Offset, Bytes, Opts) ->
                  {ok, non_neg_integer()} |
                  {error, inet:posix() | closed | badarg | not_owner}
                  when
                      is_subtype(RawFile, fd()),
                      is_subtype(Socket, inet:socket()),
                      is_subtype(Offset, non_neg_integer()),
                      is_subtype(Bytes, non_neg_integer()),
                      is_subtype(Opts, [sendfile_option()]).

sendfile(File, _Sock, _Offet, _Bytes, _Opts) when is_pid(File) ->
    {error,badarg};
sendfile(File, Sock, Offset, Bytes, []) ->
    sendfile(File,
             Sock,
             Offset,
             Bytes,
             (1 bsl 20) * 20,
             [],
             [],
             false,
             false,
             false);
sendfile(File, Sock, Offset, Bytes, Opts) ->
    ChunkSize0 = proplists:get_value(chunk_size, Opts, (1 bsl 20) * 20),
    ChunkSize =
        if
            ChunkSize0 > (1 bsl 20) * 20 ->
                (1 bsl 20) * 20;
            true ->
                ChunkSize0
        end,
    sendfile(File,
             Sock,
             Offset,
             Bytes,
             ChunkSize,
             [],
             [],
             false,
             false,
             false).

-spec sendfile(Filename, Socket) ->
                  {ok, non_neg_integer()} |
                  {error, inet:posix() | closed | badarg | not_owner}
                  when
                      is_subtype(Filename, name_all()),
                      is_subtype(Socket, inet:socket()).

sendfile(Filename, Sock) ->
    case file:open(Filename, [read,raw,binary]) of
        {error,Reason} ->
            {error,Reason};
        {ok,Fd} ->
            Res = sendfile(Fd, Sock, 0, 0, []),
            file:close(Fd),
            Res
    end.

sendfile(#file_descriptor{module = Mod} = Fd,
         Sock,
         Offset,
         Bytes,
         ChunkSize,
         Headers,
         Trailers,
         Nodiskio,
         MNowait,
         Sync)
    when is_port(Sock) ->
    case
        Mod:sendfile(Fd,
                     Sock,
                     Offset,
                     Bytes,
                     ChunkSize,
                     Headers,
                     Trailers,
                     Nodiskio,
                     MNowait,
                     Sync)
    of
        {error,enotsup} ->
            sendfile_fallback(Fd,
                              Sock,
                              Offset,
                              Bytes,
                              ChunkSize,
                              Headers,
                              Trailers);
        Else ->
            Else
    end;
sendfile(_, _, _, _, _, _, _, _, _, _) ->
    {error,badarg}.

sendfile_fallback(File,
                  Sock,
                  Offset,
                  Bytes,
                  ChunkSize,
                  Headers,
                  Trailers)
    when Headers == []; is_integer(Headers) ->
    case sendfile_fallback(File, Sock, Offset, Bytes, ChunkSize) of
        {ok,BytesSent}
            when is_list(Trailers), Trailers =/= [], is_integer(Headers) ->
            sendfile_send(Sock, Trailers, BytesSent + Headers);
        {ok,BytesSent} when is_list(Trailers), Trailers =/= [] ->
            sendfile_send(Sock, Trailers, BytesSent);
        {ok,BytesSent} when is_integer(Headers) ->
            {ok,BytesSent + Headers};
        Else ->
            Else
    end;
sendfile_fallback(File,
                  Sock,
                  Offset,
                  Bytes,
                  ChunkSize,
                  Headers,
                  Trailers) ->
    case sendfile_send(Sock, Headers, 0) of
        {ok,BytesSent} ->
            sendfile_fallback(File,
                              Sock,
                              Offset,
                              Bytes,
                              ChunkSize,
                              BytesSent,
                              Trailers);
        Else ->
            Else
    end.

sendfile_fallback(File, Sock, Offset, Bytes, ChunkSize) ->
    {ok,CurrPos} = file:position(File, {cur,0}),
    {ok,_NewPos} = file:position(File, {bof,Offset}),
    Res = sendfile_fallback_int(File, Sock, Bytes, ChunkSize, 0),
    file:position(File, {bof,CurrPos}),
    Res.

sendfile_fallback_int(File, Sock, Bytes, ChunkSize, BytesSent)
    when Bytes > BytesSent; Bytes == 0 ->
    Size =
        if
            Bytes == 0 ->
                ChunkSize;
            Bytes - BytesSent < ChunkSize ->
                Bytes - BytesSent;
            true ->
                ChunkSize
        end,
    case file:read(File, Size) of
        {ok,Data} ->
            case sendfile_send(Sock, Data, BytesSent) of
                {ok,NewBytesSent} ->
                    sendfile_fallback_int(File,
                                          Sock,
                                          Bytes,
                                          ChunkSize,
                                          NewBytesSent);
                Error ->
                    Error
            end;
        eof ->
            {ok,BytesSent};
        Error ->
            Error
    end;
sendfile_fallback_int(_File, _Sock, BytesSent, _ChunkSize, BytesSent) ->
    {ok,BytesSent}.

sendfile_send(Sock, Data, Old) ->
    Len = iolist_size(Data),
    case gen_tcp:send(Sock, Data) of
        ok ->
            {ok,Len + Old};
        Else ->
            Else
    end.

consult_stream(Fd) ->
    _ = epp:set_encoding(Fd),
    consult_stream(Fd, 1, []).

consult_stream(Fd, Line, Acc) ->
    case io:read(Fd, '', Line) of
        {ok,Term,EndLine} ->
            consult_stream(Fd, EndLine, [Term|Acc]);
        {error,Error,_Line} ->
            {error,Error};
        {eof,_Line} ->
            {ok,lists:reverse(Acc)}
    end.

eval_stream(Fd, Handling, Bs) ->
    _ = epp:set_encoding(Fd),
    eval_stream(Fd, Handling, 1, undefined, [], Bs).

eval_stream(Fd, H, Line, Last, E, Bs) ->
    eval_stream2(io:parse_erl_exprs(Fd, '', Line), Fd, H, Last, E, Bs).

eval_stream2({ok,Form,EndLine}, Fd, H, Last, E, Bs0) ->
    try erl_eval:exprs(Form, Bs0) of
        {value,V,Bs} ->
            eval_stream(Fd, H, EndLine, {V}, E, Bs)
    catch
        Class:Reason ->
            Error =
                {EndLine,file,{Class,Reason,erlang:get_stacktrace()}},
            eval_stream(Fd, H, EndLine, Last, [Error|E], Bs0)
    end;
eval_stream2({error,What,EndLine}, Fd, H, Last, E, Bs) ->
    eval_stream(Fd, H, EndLine, Last, [What|E], Bs);
eval_stream2({eof,EndLine}, _Fd, H, Last, E, _Bs) ->
    case {H,Last,E} of
        {return,{Val},[]} ->
            {ok,Val};
        {return,undefined,E} ->
            {error,
             hd(lists:reverse(E, [{EndLine,file,undefined_script}]))};
        {ignore,_,[]} ->
            ok;
        {_,_,[_|_] = E} ->
            {error,hd(lists:reverse(E))}
    end.

path_open_first([Path|Rest], Name, Mode, LastError) ->
    case file_name(Path) of
        {error,_} = Error ->
            Error;
        FilePath ->
            FileName = fname_join(FilePath, Name),
            case open(FileName, Mode) of
                {ok,Fd} ->
                    {ok,Fd,FileName};
                {error,enoent} ->
                    path_open_first(Rest, Name, Mode, LastError);
                Error ->
                    Error
            end
    end;
path_open_first([], _Name, _Mode, LastError) ->
    {error,LastError}.

fname_join(".", Name) ->
    Name;
fname_join(Dir, Name) ->
    filename:join(Dir, Name).

file_name(N) when is_binary(N) ->
    N;
file_name(N) ->
    try
        file_name_1(N, file:native_name_encoding())
    catch
        Reason ->
            {error,Reason}
    end.

file_name_1([C|T], latin1) when is_integer(C), C < 256 ->
    [C|file_name_1(T, latin1)];
file_name_1([C|T], utf8) when is_integer(C) ->
    [C|file_name_1(T, utf8)];
file_name_1([H|T], E) ->
    file_name_1(H, E) ++ file_name_1(T, E);
file_name_1([], _) ->
    [];
file_name_1(N, _) when is_atom(N) ->
    atom_to_list(N);
file_name_1(_, _) ->
    throw(badarg).

make_binary(Bin) when is_binary(Bin) ->
    Bin;
make_binary(List) ->
    try
        iolist_to_binary(List)
    catch
        error:Reason ->
            {error,Reason}
    end.

mode_list(read) ->
    [read];
mode_list(write) ->
    [write];
mode_list(read_write) ->
    [read,write];
mode_list({binary,Mode}) when is_atom(Mode) ->
    [binary|mode_list(Mode)];
mode_list({character,Mode}) when is_atom(Mode) ->
    mode_list(Mode);
mode_list(_) ->
    [{error,badarg}].

call(Command, Args) when is_list(Args) ->
    X = erlang:dt_spread_tag(true),
    Y = gen_server:call(file_server_2,
                        list_to_tuple([Command|Args]),
                        infinity),
    erlang:dt_restore_tag(X),
    Y.

check_and_call(Command, Args) when is_list(Args) ->
    case check_args(Args) of
        ok ->
            call(Command, Args);
        Error ->
            Error
    end.

check_args([{error,_} = Error|_Rest]) ->
    Error;
check_args([_Name|Rest]) ->
    check_args(Rest);
check_args([]) ->
    ok.

file_request(Io, Request) ->
    Ref = monitor(process, Io),
    Io ! {file_request,self(),Ref,Request},
    receive
        {file_reply,Ref,Reply} ->
            demonitor(Ref, [flush]),
            Reply;
        {'DOWN',Ref,_,_,_} ->
            {error,terminated}
    end.



