-file("test/lib/gs/src/gstk_entry.erl", 1).

-module(gstk_entry).

-compile([{nowarn_deprecated_function,{gs,error,2}}]).

-export([create/3,
         config/3,
         read/3,
         delete/2,
         event/5,
         option/5,
         read_option/5]).

-file("test/lib/gs/src/gstk.hrl", 1).

-record(gstkid,{id = undefined,widget,widget_data,owner,parent,objtype}).

-record(so,{main,object,hscroll,vscroll,misc}).

-file("test/lib/gs/src/gstk_entry.erl", 94).

create(DB, GstkId, Opts) ->
    TkW = gstk_generic:mk_tkw_child(DB, GstkId),
    PlacePreCmd = [";place ",TkW],
    Ngstkid = GstkId#gstkid{widget = TkW},
    case
        gstk_generic:make_command(Opts,
                                  Ngstkid,
                                  TkW,
                                  "",
                                  PlacePreCmd,
                                  DB)
    of
        {error,Reason} ->
            {error,Reason};
        Cmd when is_list(Cmd) ->
            case gstk:call(["entry ",TkW,Cmd]) of
                {result,_} ->
                    gstk:exec([TkW,
                               " conf -bo 2 -relief sunken -highlightth"
                               " 2;"]),
                    Ngstkid;
                Bad_Result ->
                    {error,Bad_Result}
            end
    end.

config(DB, Gstkid, Opts) ->
    TkW = Gstkid#gstkid.widget,
    SimplePreCmd = [TkW," conf"],
    PlacePreCmd = [";place ",TkW],
    gstk_generic:mk_cmd_and_exec(Opts,
                                 Gstkid,
                                 TkW,
                                 SimplePreCmd,
                                 PlacePreCmd,
                                 DB).

read(DB, Gstkid, Opt) ->
    gstk_generic:read_option(DB, Gstkid, Opt).

delete(DB, Gstkid) ->
    gstk_db:delete_widget(DB, Gstkid),
    Gstkid#gstkid.widget.

event(DB, Gstkid, Etype, Edata, Args) ->
    gstk_generic:event(DB, Gstkid, Etype, Edata, Args).

option(Option, Gstkid, TkW, DB, _) ->
    case Option of
        {font,Font} ->
            gstk_db:insert_opt(DB, Gstkid, Option),
            {s,[" -font ",gstk_font:choose_ascii(DB, Font)]};
        {insertbg,Color} ->
            {s,[" -insertba ",gstk:to_color(Color)]};
        {insertbw,Width} ->
            {s,[" -insertbo ",gstk:to_ascii(Width)]};
        {justify,How} ->
            {s,[" -ju ",gstk:to_ascii(How)]};
        {text,Str} ->
            {c,[TkW," del 0 end; ",TkW," ins 0 ",gstk:to_ascii(Str)]};
        {xselection,Bool} ->
            {s,[" -exportse ",gstk:to_ascii(Bool)]};
        {delete,{From,To}} ->
            {c,[TkW," del ",p_index(From),$\s,p_index(To)]};
        {delete,Index} ->
            {c,[TkW," de ",p_index(Index)]};
        {insert,{Idx,Str}} ->
            {c,[TkW," ins ",gstk:to_ascii(Idx),$\s,gstk:to_ascii(Str)]};
        {select,clear} ->
            {c,[TkW," sel clear"]};
        {select,{From,To}} ->
            {c,[TkW," sel range ",p_index(From),$\s,p_index(To)]};
        _ ->
            invalid_option
    end.

read_option(Option, Gstkid, TkW, DB, _) ->
    case Option of
        insertbg ->
            tcl2erl:ret_color([TkW," cg -insertba"]);
        insertbw ->
            tcl2erl:ret_int([TkW," cg -insertbo"]);
        font ->
            gstk_db:opt(DB, Gstkid, font, undefined);
        justify ->
            tcl2erl:ret_atom([TkW," cg -jus"]);
        text ->
            tcl2erl:ret_str([TkW," get"]);
        xselection ->
            tcl2erl:ret_bool([TkW," cg -exports"]);
        {index,Idx} ->
            tcl2erl:ret_int([TkW,"cg ind ",p_index(Idx)]);
        _ ->
            {bad_result,{Gstkid#gstkid.objtype,invalid_option,Option}}
    end.

p_index(Index) when is_integer(Index) ->
    gstk:to_ascii(Index);
p_index(insert) ->
    "insert";
p_index(last) ->
    "end";
p_index(Idx) ->
    gs:error("Bad index in entry: ~w~n", [Idx]),
    0.



