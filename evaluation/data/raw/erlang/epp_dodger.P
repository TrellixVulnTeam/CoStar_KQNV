-file("test/lib/syntax_tools/src/epp_dodger.erl", 1).

-module(epp_dodger).

-export([parse_file/1,
         quick_parse_file/1,
         parse_file/2,
         quick_parse_file/2,
         parse/1,
         quick_parse/1,
         parse/2,
         quick_parse/2,
         parse/3,
         quick_parse/3,
         parse_form/2,
         parse_form/3,
         quick_parse_form/2,
         quick_parse_form/3,
         format_error/1,
         tokens_to_string/1]).

-type errorinfo() :: term().

-type option() :: atom() | {atom(), term()}.

-spec parse_file(file:filename()) ->
                    {ok, erl_syntax:forms()} | {error, errorinfo()}.

parse_file(File) ->
    parse_file(File, []).

-spec parse_file(file:filename(), [option()]) ->
                    {ok, erl_syntax:forms()} | {error, errorinfo()}.

parse_file(File, Options) ->
    parse_file(File, fun parse/3, Options).

-spec quick_parse_file(file:filename()) ->
                          {ok, erl_syntax:forms()} |
                          {error, errorinfo()}.

quick_parse_file(File) ->
    quick_parse_file(File, []).

-spec quick_parse_file(file:filename(), [option()]) ->
                          {ok, erl_syntax:forms()} |
                          {error, errorinfo()}.

quick_parse_file(File, Options) ->
    parse_file(File, fun quick_parse/3, Options ++ [no_fail]).

parse_file(File, Parser, Options) ->
    case file:open(File, [read]) of
        {ok,Dev} ->
            _ = epp:set_encoding(Dev),
            try Parser(Dev, 1, Options) after ok = file:close(Dev) end;
        {error,_} = Error ->
            Error
    end.

-spec parse(file:io_device()) -> {ok, erl_syntax:forms()}.

parse(Dev) ->
    parse(Dev, 1).

-spec parse(file:io_device(), integer()) -> {ok, erl_syntax:forms()}.

parse(Dev, L) ->
    parse(Dev, L, []).

-spec parse(file:io_device(), integer(), [option()]) ->
               {ok, erl_syntax:forms()}.

parse(Dev, L0, Options) ->
    parse(Dev, L0, fun parse_form/3, Options).

-spec quick_parse(file:io_device()) -> {ok, erl_syntax:forms()}.

quick_parse(Dev) ->
    quick_parse(Dev, 1).

-spec quick_parse(file:io_device(), integer()) ->
                     {ok, erl_syntax:forms()}.

quick_parse(Dev, L) ->
    quick_parse(Dev, L, []).

-spec quick_parse(file:io_device(), integer(), [option()]) ->
                     {ok, erl_syntax:forms()}.

quick_parse(Dev, L0, Options) ->
    parse(Dev, L0, fun quick_parse_form/3, Options).

parse(Dev, L0, Parser, Options) ->
    parse(Dev, L0, [], Parser, Options).

parse(Dev, L0, Fs, Parser, Options) ->
    case Parser(Dev, L0, Options) of
        {ok,none,L1} ->
            parse(Dev, L1, Fs, Parser, Options);
        {ok,F,L1} ->
            parse(Dev, L1, [F|Fs], Parser, Options);
        {error,IoErr,L1} ->
            parse(Dev, L1, [{error,IoErr}|Fs], Parser, Options);
        {eof,_L1} ->
            {ok,lists:reverse(Fs)}
    end.

-spec parse_form(file:io_device(), integer()) ->
                    {ok, erl_syntax:forms(), integer()} |
                    {eof, integer()} |
                    {error, errorinfo(), integer()}.

parse_form(Dev, L0) ->
    parse_form(Dev, L0, []).

-spec parse_form(file:io_device(), integer(), [option()]) ->
                    {ok, erl_syntax:forms(), integer()} |
                    {eof, integer()} |
                    {error, errorinfo(), integer()}.

parse_form(Dev, L0, Options) ->
    parse_form(Dev, L0, fun normal_parser/2, Options).

-spec quick_parse_form(file:io_device(), integer()) ->
                          {ok, erl_syntax:forms(), integer()} |
                          {eof, integer()} |
                          {error, errorinfo(), integer()}.

quick_parse_form(Dev, L0) ->
    quick_parse_form(Dev, L0, []).

-spec quick_parse_form(file:io_device(), integer(), [option()]) ->
                          {ok, erl_syntax:forms(), integer()} |
                          {eof, integer()} |
                          {error, errorinfo(), integer()}.

quick_parse_form(Dev, L0, Options) ->
    parse_form(Dev, L0, fun quick_parser/2, Options).

-record(opt,{clever = false :: boolean()}).

parse_form(Dev, L0, Parser, Options) ->
    NoFail = proplists:get_bool(no_fail, Options),
    Opt = #opt{clever = proplists:get_bool(clever, Options)},
    case io:scan_erl_form(Dev, "", L0) of
        {ok,Ts,L1} ->
            case catch {ok,Parser(Ts, Opt)} of
                {'EXIT',Term} ->
                    {error,io_error(L1, {unknown,Term}),L1};
                {error,Term} ->
                    IoErr = io_error(L1, Term),
                    {error,IoErr,L1};
                {parse_error,_IoErr} when NoFail ->
                    {ok,
                     erl_syntax:set_pos(erl_syntax:text(tokens_to_string(Ts)),
                                        start_pos(Ts, L1)),
                     L1};
                {parse_error,IoErr} ->
                    {error,IoErr,L1};
                {ok,F} ->
                    {ok,F,L1}
            end;
        {error,_IoErr,_L1} = Err ->
            Err;
        {error,_Reason} ->
            {eof,L0};
        {eof,_L1} = Eof ->
            Eof
    end.

io_error(L, Desc) ->
    {L,epp_dodger,Desc}.

start_pos([T|_Ts], _L) ->
    element(2, T);
start_pos([], L) ->
    L.

parse_tokens(Ts) ->
    parse_tokens(Ts, fun fix_form/1).

parse_tokens(Ts, Fix) ->
    case erl_parse:parse_form(Ts) of
        {ok,Form} ->
            Form;
        {error,IoErr} ->
            case Fix(Ts) of
                {form,Form} ->
                    Form;
                {retry,Ts1,Fix1} ->
                    parse_tokens(Ts1, Fix1);
                error ->
                    throw({parse_error,IoErr})
            end
    end.

quick_parser(Ts, _Opt) ->
    filter_form(parse_tokens(quickscan_form(Ts))).

quickscan_form([{'-',_L},{atom,La,define}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',_L},{atom,La,undef}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',_L},{atom,La,include}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',_L},{atom,La,include_lib}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',_L},{atom,La,ifdef}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',_L},{atom,La,ifndef}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',_L},{atom,La,else}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',_L},{atom,La,endif}|_Ts]) ->
    kill_form(La);
quickscan_form([{'-',L},{'?',_},{Type,_,_} = N|[{'(',_}|_] = Ts])
    when Type =:= atom; Type =:= var ->
    quickscan_macros_1(N, Ts, [{'-',L}]);
quickscan_form([{'?',_L},{Type,_,_} = N|[{'(',_}|_] = Ts])
    when Type =:= atom; Type =:= var ->
    quickscan_macros_1(N, Ts, []);
quickscan_form(Ts) ->
    quickscan_macros(Ts).

kill_form(L) ->
    [{atom,L,'?preprocessor declaration?'},
     {'(',L},
     {')',L},
     {'->',L},
     {atom,L,kill},
     {dot,L}].

quickscan_macros(Ts) ->
    quickscan_macros(Ts, []).

quickscan_macros([{'?',_},{Type,_,A}|Ts], [{string,L,S}|As])
    when Type =:= atom; Type =:= var ->
    {_,Ts1} = skip_macro_args(Ts),
    S1 = S ++ quick_macro_string(A),
    quickscan_macros(Ts1, [{string,L,S1}|As]);
quickscan_macros([{'?',_},{Type,_,_} = N|[{'(',_}|_] = Ts],
                 [{':',_}|_] = As)
    when Type =:= atom; Type =:= var ->
    Ts1 =
        case skip_macro_args(Ts) of
            {_,[{'->',_}|_] = Ts2} ->
                Ts2;
            {_,[{'when',_}|_] = Ts2} ->
                Ts2;
            _ ->
                Ts
        end,
    quickscan_macros_1(N, Ts1, As);
quickscan_macros([{'?',_},{Type,_,_} = N|Ts], As)
    when Type =:= atom; Type =:= var ->
    {_,Ts1} = skip_macro_args(Ts),
    quickscan_macros_1(N, Ts1, As);
quickscan_macros([T|Ts], As) ->
    quickscan_macros(Ts, [T|As]);
quickscan_macros([], As) ->
    lists:reverse(As).

quickscan_macros_1({_Type,_,A}, [{string,L,S}|Ts], As) ->
    S1 = quick_macro_string(A) ++ S,
    quickscan_macros(Ts, [{string,L,S1}|As]);
quickscan_macros_1({_Type,L,A}, Ts, As) ->
    quickscan_macros(Ts, [{atom,L,quick_macro_atom(A)}|As]).

quick_macro_atom(A) ->
    list_to_atom("?" ++ atom_to_list(A)).

quick_macro_string(A) ->
    "(?" ++ atom_to_list(A) ++ ")".

skip_macro_args([{'(',_} = T|Ts]) ->
    skip_macro_args(Ts, [')'], [T]);
skip_macro_args(Ts) ->
    {[],Ts}.

skip_macro_args([{'(',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, [')'|Es], [T|As]);
skip_macro_args([{'{',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['}'|Es], [T|As]);
skip_macro_args([{'[',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, [']'|Es], [T|As]);
skip_macro_args([{'<<',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['>>'|Es], [T|As]);
skip_macro_args([{'begin',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['end'|Es], [T|As]);
skip_macro_args([{'if',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['end'|Es], [T|As]);
skip_macro_args([{'case',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['end'|Es], [T|As]);
skip_macro_args([{'receive',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['end'|Es], [T|As]);
skip_macro_args([{'try',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['end'|Es], [T|As]);
skip_macro_args([{'cond',_} = T|Ts], Es, As) ->
    skip_macro_args(Ts, ['end'|Es], [T|As]);
skip_macro_args([{E,_} = T|Ts], [E], As) ->
    {lists:reverse([T|As]),Ts};
skip_macro_args([{E,_} = T|Ts], [E|Es], As) ->
    skip_macro_args(Ts, Es, [T|As]);
skip_macro_args([T|Ts], Es, As) ->
    skip_macro_args(Ts, Es, [T|As]);
skip_macro_args([], _Es, _As) ->
    throw({error,macro_args}).

filter_form({function,
             _,
             '?preprocessor declaration?',
             _,
             [{clause,_,[],[],[{atom,_,kill}]}]}) ->
    none;
filter_form(T) ->
    T.

normal_parser(Ts, Opt) ->
    rewrite_form(parse_tokens(scan_form(Ts, Opt))).

scan_form([{'-',_L},{atom,La,define}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,define}|
     scan_macros(Ts, Opt)];
scan_form([{'-',_L},{atom,La,undef}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,undef}|
     scan_macros(Ts, Opt)];
scan_form([{'-',_L},{atom,La,include}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,include}|
     scan_macros(Ts, Opt)];
scan_form([{'-',_L},{atom,La,include_lib}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,include_lib}|
     scan_macros(Ts, Opt)];
scan_form([{'-',_L},{atom,La,ifdef}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,ifdef}|
     scan_macros(Ts, Opt)];
scan_form([{'-',_L},{atom,La,ifndef}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,ifndef}|
     scan_macros(Ts, Opt)];
scan_form([{'-',_L},{atom,La,else}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,else}|
     scan_macros(Ts, Opt)];
scan_form([{'-',_L},{atom,La,endif}|Ts], Opt) ->
    [{atom,La,'?preprocessor declaration?'},
     {'(',La},
     {')',La},
     {'->',La},
     {atom,La,endif}|
     scan_macros(Ts, Opt)];
scan_form([{'-',L},{'?',L1},{Type,_,_} = N|[{'(',_}|_] = Ts], Opt)
    when Type =:= atom; Type =:= var ->
    macro(L1, N, Ts, [{'-',L}], Opt);
scan_form([{'?',L},{Type,_,_} = N|[{'(',_}|_] = Ts], Opt)
    when Type =:= atom; Type =:= var ->
    macro(L, N, Ts, [], Opt);
scan_form(Ts, Opt) ->
    scan_macros(Ts, Opt).

scan_macros(Ts, Opt) ->
    scan_macros(Ts, [], Opt).

scan_macros([{'?',_} = M,{Type,_,_} = N|Ts],
            [{string,L,_} = S|As],
            #opt{clever = true} = Opt)
    when Type =:= atom; Type =:= var ->
    scan_macros([M,N|Ts], [{'++',L},S|As], Opt);
scan_macros([{'?',L},{Type,_,_} = N|[{'(',_}|_] = Ts],
            [{':',_}|_] = As,
            Opt)
    when Type =:= atom; Type =:= var ->
    {Args,Rest} = skip_macro_args(Ts),
    case Rest of
        [{'->',_}|_] ->
            macro_call(Args, L, N, Rest, As, Opt);
        [{'when',_}|_] ->
            macro_call(Args, L, N, Rest, As, Opt);
        _ ->
            macro(L, N, Ts, As, Opt)
    end;
scan_macros([{'?',L},{Type,_,_} = N|[{'(',_}|_] = Ts], As, Opt)
    when Type =:= atom; Type =:= var ->
    {Args,Rest} = skip_macro_args(Ts),
    macro_call(Args, L, N, Rest, As, Opt);
scan_macros([{'?',L},{Type,_,_} = N|Ts], As, Opt)
    when Type =:= atom; Type =:= var ->
    macro(L, N, Ts, As, Opt);
scan_macros([T|Ts], As, Opt) ->
    scan_macros(Ts, [T|As], Opt);
scan_macros([], As, _Opt) ->
    lists:reverse(As).

macro(L, {Type,_,A}, Rest, As, Opt) ->
    scan_macros_1([], Rest, [{atom,L,macro_atom(Type, A)}|As], Opt).

macro_call([{'(',_},{')',_}], L, {_,Ln,_} = N, Rest, As, Opt) ->
    {Open,Close} = parentheses(As),
    scan_macros_1([],
                  Rest,
                  lists:reverse(Open
                                ++
                                [{atom,L,'? <macro> ('},
                                 {'(',L},
                                 N,
                                 {')',Ln}]
                                ++
                                Close,
                                As),
                  Opt);
macro_call([{'(',_}|Args], L, {_,Ln,_} = N, Rest, As, Opt) ->
    {Open,Close} = parentheses(As),
    scan_macros_1(Args ++ Close,
                  Rest,
                  lists:reverse(Open
                                ++
                                [{atom,L,'? <macro> ('},
                                 {'(',L},
                                 N,
                                 {',',Ln}],
                                As),
                  Opt).

macro_atom(atom, A) ->
    list_to_atom("? " ++ atom_to_list(A));
macro_atom(var, A) ->
    list_to_atom("?," ++ atom_to_list(A)).

parentheses([{string,_,_}|_]) ->
    {[],[]};
parentheses(_) ->
    {[{'(',0}],[{')',0}]}.

scan_macros_1(Args,
              [{string,L,_}|_] = Rest,
              As,
              #opt{clever = true} = Opt) ->
    scan_macros(Args ++ [{'++',L}|Rest], As, Opt);
scan_macros_1(Args, Rest, As, Opt) ->
    scan_macros(Args ++ Rest, As, Opt).

rewrite_form({function,
              L,
              '?preprocessor declaration?',
              _,
              [{clause,_,[],[],[{call,_,A,As}]}]}) ->
    erl_syntax:set_pos(erl_syntax:attribute(A, rewrite_list(As)), L);
rewrite_form({function,
              L,
              '?preprocessor declaration?',
              _,
              [{clause,_,[],[],[A]}]}) ->
    erl_syntax:set_pos(erl_syntax:attribute(A), L);
rewrite_form(T) ->
    rewrite(T).

rewrite_list([T|Ts]) ->
    [rewrite(T)|rewrite_list(Ts)];
rewrite_list([]) ->
    [].

rewrite(Node) ->
    case erl_syntax:type(Node) of
        atom ->
            case atom_to_list(erl_syntax:atom_value(Node)) of
                "? " ++ As ->
                    A1 = list_to_atom(As),
                    N = erl_syntax:copy_pos(Node, erl_syntax:atom(A1)),
                    erl_syntax:copy_pos(Node, erl_syntax:macro(N));
                "?," ++ As ->
                    A1 = list_to_atom(As),
                    N = erl_syntax:copy_pos(Node,
                                            erl_syntax:variable(A1)),
                    erl_syntax:copy_pos(Node, erl_syntax:macro(N));
                _ ->
                    Node
            end;
        application ->
            F = erl_syntax:application_operator(Node),
            case erl_syntax:type(F) of
                atom ->
                    case erl_syntax:atom_value(F) of
                        '? <macro> (' ->
                            [A|As] =
                                erl_syntax:application_arguments(Node),
                            M = erl_syntax:macro(A, rewrite_list(As)),
                            erl_syntax:copy_pos(Node, M);
                        _ ->
                            rewrite_1(Node)
                    end;
                _ ->
                    rewrite_1(Node)
            end;
        _ ->
            rewrite_1(Node)
    end.

rewrite_1(Node) ->
    case erl_syntax:subtrees(Node) of
        [] ->
            Node;
        Gs ->
            Node1 =
                erl_syntax:make_tree(erl_syntax:type(Node),
                                     [ 
                                      [ 
                                       rewrite(T) ||
                                           T <- Ts
                                      ] ||
                                          Ts <- Gs
                                     ]),
            erl_syntax:copy_pos(Node, Node1)
    end.

fix_form([{atom,_,'?preprocessor declaration?'},
          {'(',_},
          {')',_},
          {'->',_},
          {atom,_,define},
          {'(',_}|
          _] =
             Ts) ->
    case lists:reverse(Ts) of
        [{dot,_},{')',_}|_] ->
            {retry,Ts,fun fix_define/1};
        [{dot,L}|Ts1] ->
            Ts2 = lists:reverse([{dot,L},{')',L}|Ts1]),
            {retry,Ts2,fun fix_define/1};
        _ ->
            error
    end;
fix_form(_Ts) ->
    error.

fix_define([{atom,L,'?preprocessor declaration?'},
            {'(',_},
            {')',_},
            {'->',_},
            {atom,La,define},
            {'(',_},
            N,
            {',',_}|
            Ts]) ->
    [{dot,_},{')',_}|Ts1] = lists:reverse(Ts),
    S = tokens_to_string(lists:reverse(Ts1)),
    A = erl_syntax:set_pos(erl_syntax:atom(define), La),
    Txt = erl_syntax:set_pos(erl_syntax:text(S), La),
    {form,erl_syntax:set_pos(erl_syntax:attribute(A, [N,Txt]), L)};
fix_define(_Ts) ->
    error.

-spec tokens_to_string([term()]) -> string().

tokens_to_string([{atom,_,A}|Ts]) ->
    io_lib:write_atom(A) ++ " " ++ tokens_to_string(Ts);
tokens_to_string([{string,_,S}|Ts]) ->
    io_lib:write_string(S) ++ " " ++ tokens_to_string(Ts);
tokens_to_string([{char,_,C}|Ts]) ->
    io_lib:write_char(C) ++ " " ++ tokens_to_string(Ts);
tokens_to_string([{float,_,F}|Ts]) ->
    float_to_list(F) ++ " " ++ tokens_to_string(Ts);
tokens_to_string([{integer,_,N}|Ts]) ->
    integer_to_list(N) ++ " " ++ tokens_to_string(Ts);
tokens_to_string([{var,_,A}|Ts]) ->
    atom_to_list(A) ++ " " ++ tokens_to_string(Ts);
tokens_to_string([{dot,_}|Ts]) ->
    ".\n" ++ tokens_to_string(Ts);
tokens_to_string([{A,_}|Ts]) ->
    atom_to_list(A) ++ " " ++ tokens_to_string(Ts);
tokens_to_string([]) ->
    "".

-spec format_error(term()) -> string().

format_error(macro_args) ->
    errormsg("macro call missing end parenthesis");
format_error({unknown,Reason}) ->
    errormsg(io_lib:format("unknown error: ~P", [Reason,15])).

errormsg(String) ->
    io_lib:format("~s: ~s", [epp_dodger,String]).



