-file("test/lib/edoc/src/edoc_wiki.erl", 1).

-module(edoc_wiki).

-export([parse_xml/2,expand_text/2]).

-file("test/lib/edoc/src/edoc.hrl", 1).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/edoc/src/../include/edoc_doclet.hrl",
      1).

-record(context,{dir = "",env,opts = []}).

-record(doclet_gen,{sources = [],
                    app = [],
                    packages = [],
                    modules = [],
                    filemap}).

-record(doclet_toc,{paths,indir}).

-file("test/lib/edoc/src/edoc.hrl", 43).

-file([], 43).

-record(module,{name = [],
                parameters = none,
                functions = [],
                exports = [],
                attributes = [],
                records = [],
                encoding = latin1}).

-record(env,{module = [],
             package = [],
             root = "",
             file_suffix,
             package_summary,
             apps,
             modules,
             packages,
             app_default,
             macros = [],
             includes = []}).

-record(comment,{line = 0,text}).

-record(entry,{name,args = [],line = 0,export,data}).

-record(tag,{name,line = 0,origin = comment,data}).

-file("test/lib/edoc/src/edoc_wiki.erl", 71).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/xmerl-1.3.2/include/xmerl.hrl",
      1).

-record(xmlDecl,{vsn,encoding,standalone,attributes}).

-record(xmlAttribute,{name,
                      expanded_name = [],
                      nsinfo = [],
                      namespace = [],
                      parents = [],
                      pos,
                      language = [],
                      value,
                      normalized}).

-record(xmlNamespace,{default = [],nodes = []}).

-record(xmlNsNode,{parents = [],pos,prefix,uri = []}).

-record(xmlElement,{name,
                    expanded_name = [],
                    nsinfo = [],
                    namespace = #xmlNamespace{},
                    parents = [],
                    pos,
                    attributes = [],
                    content = [],
                    language = "",
                    xmlbase = "",
                    elementdef = undeclared}).

-record(xmlText,{parents = [],pos,language = [],value,type = text}).

-record(xmlComment,{parents = [],pos,language = [],value}).

-record(xmlPI,{name,parents = [],pos,value}).

-record(xmlDocument,{content}).

-record(xmlContext,{axis_type = forward,
                    context_node,
                    context_position = 1,
                    nodeset = [],
                    bindings = [],
                    functions = [],
                    namespace = [],
                    whole_document}).

-record(xmlNode,{type = element,node,parents = [],pos = 1}).

-record(xmlObj,{type,value}).

-record(xmerl_fun_states,{event,hook,rules,fetch,cont}).

-record(xmerl_scanner,{encoding = undefined,
                       standalone = no,
                       environment = prolog,
                       declarations = [],
                       doctype_name,
                       doctype_DTD = internal,
                       comments = true,
                       document = false,
                       default_attrs = false,
                       rules,
                       keep_rules = false,
                       namespace_conformant = false,
                       xmlbase,
                       xmlbase_cache,
                       fetch_path = [],
                       filename = file_name_unknown,
                       validation = off,
                       schemaLocation = [],
                       space = preserve,
                       event_fun,
                       hook_fun,
                       acc_fun,
                       fetch_fun,
                       close_fun,
                       continuation_fun,
                       rules_read_fun,
                       rules_write_fun,
                       rules_delete_fun,
                       user_state,
                       fun_states = #xmerl_fun_states{},
                       entity_references = [],
                       text_decl = false,
                       quiet = false,
                       col = 1,
                       line = 1,
                       common_data = []}).

-record(xmerl_event,{event,line,col,pos,data}).

-file("test/lib/edoc/src/edoc_wiki.erl", 72).

parse_xml(Data, Line) ->
    par(parse_xml_1(expand_text(Data, Line), Line)).

parse_xml_1(Text, Line) ->
    Text1 = "<doc>" ++ Text ++ "</doc>",
    Opts = [{line,Line},{encoding,'iso-8859-1'}],
    case catch {ok,xmerl_scan:string(Text1, Opts)} of
        {ok,{E,_}} ->
            E#xmlElement.content;
        {'EXIT',{fatal,{Reason,L,_C}}} ->
            throw_error(L, {"XML parse error: ~p.",[Reason]});
        {'EXIT',Reason} ->
            throw_error(Line, {"error in XML parser: ~P.",[Reason,10]});
        Other ->
            throw_error(Line, {"nocatch in XML parser: ~P.",[Other,10]})
    end.

expand_text(Cs, L) ->
    lists:reverse(expand_new_line(Cs, L, [])).

expand_new_line([$\s = C|Cs], L, As) ->
    expand_new_line(Cs, L, [C|As]);
expand_new_line([$\t = C|Cs], L, As) ->
    expand_new_line(Cs, L, [C|As]);
expand_new_line([$\n = C|Cs], L, As) ->
    expand_new_line(Cs, L + 1, [C|As]);
expand_new_line([$=,$=,$=,$=|Cs], L, As) ->
    expand_heading(Cs, 2, L, As);
expand_new_line([$=,$=,$=|Cs], L, As) ->
    expand_heading(Cs, 1, L, As);
expand_new_line([$=,$=|Cs], L, As) ->
    expand_heading(Cs, 0, L, As);
expand_new_line(Cs, L, As) ->
    expand(Cs, L, As).

expand([$`,$'|Cs], L, As) ->
    expand(Cs, L, [$`|As]);
expand([$`,$`,$`|Cs], L, As) ->
    {Cs1,Skipped} = strip_empty_lines(Cs),
    N = if
            Skipped > 0 ->
                0;
            true ->
                {As1,_} = edoc_lib:split_at(As, $\n),
                case edoc_lib:is_space(As1) of
                    true ->
                        3 + length(As1);
                    false ->
                        2
                end
        end,
    Ss = lists:duplicate(N, $\s),
    expand_triple(Cs1, L + Skipped, Ss ++ "[ATADC[!<>erp<" ++ As);
expand([$`,$`|Cs], L, As) ->
    expand_double(edoc_lib:strip_space(Cs), L, ">edoc<" ++ As);
expand([$`|Cs], L, As) ->
    expand_single(edoc_lib:strip_space(Cs), L, ">edoc<" ++ As);
expand([$[|Cs], L, As) ->
    expand_uri(Cs, L, As);
expand([$\n = C|Cs], L, As) ->
    expand_new_line(Cs, L + 1, [C|As]);
expand([C|Cs], L, As) ->
    expand(Cs, L, [C|As]);
expand([], _, As) ->
    As.

expand_heading([$=|_] = Cs, N, L, As) ->
    expand_heading_1(Cs, N, L, As);
expand_heading(Cs, N, L, As) ->
    {Cs1,Cs2} = edoc_lib:split_at(Cs, $\n),
    case edoc_lib:strip_space(lists:reverse(Cs1)) of
        [$=,$=|Cs3] ->
            {Es,Ts} =
                lists:splitwith(fun(X) ->
                                       X =:= $=
                                end,
                                Cs3),
            if
                length(Es) =:= N ->
                    Ts1 =
                        edoc_lib:strip_space(lists:reverse(edoc_lib:strip_space(Ts))),
                    expand_heading_2(Ts1, Cs2, N, L, As);
                true ->
                    H1 = lists:duplicate(N + 2, $=),
                    H2 = "==" ++ Es,
                    throw_error(L,
                                {"heading end marker mismatch: ~s...~s",
                                 [H1,H2]})
            end;
        _ ->
            expand_heading_1(Cs, N, L, As)
    end.

expand_heading_1(Cs, N, L, As) ->
    expand(Cs, L, lists:duplicate(N + 2, $=) ++ As).

expand_heading_2(Ts, Cs, N, L, As) ->
    H = 3 + N,
    Ts1 =
        io_lib:format("<h~w><a name=\"~ts\">~ts</a></h~w>\n",
                      [H,make_label(Ts),Ts,H]),
    expand_new_line(Cs, L + 1, lists:reverse(lists:flatten(Ts1), As)).

make_label([$\s|Cs]) ->
    [$_|make_label(edoc_lib:strip_space(Cs))];
make_label([$\t|Cs]) ->
    [$_|make_label(edoc_lib:strip_space(Cs))];
make_label([$\n|Cs]) ->
    [$_|make_label(edoc_lib:strip_space(Cs))];
make_label([C|Cs]) ->
    [C|make_label(Cs)];
make_label([]) ->
    [].

expand_single(Cs, L, As) ->
    expand_single(Cs, L, As, L).

expand_single([$'|Cs], L, As, _L0) ->
    expand(Cs, L, ">edoc/<" ++ edoc_lib:strip_space(As));
expand_single([$<|Cs], L, As, L0) ->
    expand_single(Cs, L, ";tl&" ++ As, L0);
expand_single([$>|Cs], L, As, L0) ->
    expand_single(Cs, L, ";tg&" ++ As, L0);
expand_single([$&|Cs], L, As, L0) ->
    expand_single(Cs, L, ";pma&" ++ As, L0);
expand_single([$\n = C|Cs], L, As, L0) ->
    expand_single(Cs, L + 1, [C|As], L0);
expand_single([C|Cs], L, As, L0) ->
    expand_single(Cs, L, [C|As], L0);
expand_single([], L, _, L0) ->
    throw_error(L0, {"`-quote ended unexpectedly at line ~w",[L]}).

expand_double(Cs, L, As) ->
    expand_double(Cs, L, As, L).

expand_double([$',$'|Cs], L, As, _L0) ->
    expand(Cs, L, ">edoc/<" ++ edoc_lib:strip_space(As));
expand_double([$<|Cs], L, As, L0) ->
    expand_double(Cs, L, ";tl&" ++ As, L0);
expand_double([$>|Cs], L, As, L0) ->
    expand_double(Cs, L, ";tg&" ++ As, L0);
expand_double([$&|Cs], L, As, L0) ->
    expand_double(Cs, L, ";pma&" ++ As, L0);
expand_double([$\n = C|Cs], L, As, L0) ->
    expand_double(Cs, L + 1, [C|As], L0);
expand_double([C|Cs], L, As, L0) ->
    expand_double(Cs, L, [C|As], L0);
expand_double([], L, _, L0) ->
    throw_error(L0, {"``-quote ended unexpectedly at line ~w",[L]}).

expand_triple(Cs, L, As) ->
    expand_triple(Cs, L, As, L).

expand_triple([$',$',$'|Cs], L, As, _L0) ->
    expand(Cs, L, ">erp/<>]]" ++ edoc_lib:strip_space(As));
expand_triple([$],$],$>|Cs], L, As, L0) ->
    expand_triple(Cs, L, ";tg&]]" ++ As, L0);
expand_triple([$\n = C|Cs], L, As, L0) ->
    expand_triple(Cs, L + 1, [C|As], L0);
expand_triple([C|Cs], L, As, L0) ->
    expand_triple(Cs, L, [C|As], L0);
expand_triple([], L, _, L0) ->
    throw_error(L0, {"```-quote ended unexpectedly at line ~w",[L]}).

expand_uri("http:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:ptth", As);
expand_uri("https:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:sptth", As);
expand_uri("ftp:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:ptf", As);
expand_uri("file:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:elif", As);
expand_uri("mailto:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:otliam", As);
expand_uri("nfs:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:sfn", As);
expand_uri("shttp:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:ptths", As);
expand_uri("xmpp:/" ++ Cs, L, As) ->
    expand_uri(Cs, L, "/:ppmx", As);
expand_uri(Cs, L, As) ->
    expand(Cs, L, [$[|As]).

expand_uri([$]|Cs], L, Us, As) ->
    expand(Cs, L, push_uri(Us, ">tt/<" ++ Us ++ ">tt<", As));
expand_uri([$\s = C|Cs], L, Us, As) ->
    expand_uri(Cs, 0, L, [C], Us, As);
expand_uri([$\t = C|Cs], L, Us, As) ->
    expand_uri(Cs, 0, L, [C], Us, As);
expand_uri([$\n = C|Cs], L, Us, As) ->
    expand_uri(Cs, 1, L, [C], Us, As);
expand_uri([C|Cs], L, Us, As) ->
    expand_uri(Cs, L, [C|Us], As);
expand_uri([], L, Us, _As) ->
    expand_uri_error(Us, L).

expand_uri([$]|Cs], N, L, Ss, Us, As) ->
    Ss1 =
        lists:reverse(edoc_lib:strip_space(lists:reverse(edoc_lib:strip_space(Ss)))),
    expand(Cs, L + N, push_uri(Us, Ss1, As));
expand_uri([$\n = C|Cs], N, L, Ss, Us, As) ->
    expand_uri(Cs, N + 1, L, [C|Ss], Us, As);
expand_uri([C|Cs], N, L, Ss, Us, As) ->
    expand_uri(Cs, N, L, [C|Ss], Us, As);
expand_uri([], _, L, _Ss, Us, _As) ->
    expand_uri_error(Us, L).

-spec expand_uri_error(list(), pos_integer()) -> no_return().

expand_uri_error(Us, L) ->
    {Ps,_} = edoc_lib:split_at(lists:reverse(Us), $:),
    throw_error(L, {"reference '[~ts:...' ended unexpectedly",[Ps]}).

push_uri(Us, Ss, As) ->
    ">a/<" ++ Ss ++ ">\"pot_\"=tegrat \"" ++ Us ++ "\"=ferh a<" ++ As.

strip_empty_lines(Cs) ->
    strip_empty_lines(Cs, 0).

strip_empty_lines([], N) ->
    {[],N};
strip_empty_lines(Cs, N) ->
    {Cs1,Cs2} = edoc_lib:split_at(Cs, $\n),
    case edoc_lib:is_space(Cs1) of
        true ->
            strip_empty_lines(Cs2, N + 1);
        false ->
            {Cs,N}
    end.

par(Es) ->
    par(Es, [], []).

par([E = #xmlText{value = Value}|Es], As, Bs) ->
    par_text(Value, As, Bs, E, Es);
par([E = #xmlElement{name = Name}|Es], As, Bs) ->
    case Name of
        p ->
            par_flush(Es, [E|As], Bs);
        hr ->
            par_flush(Es, [E|As], Bs);
        h1 ->
            par_flush(Es, [E|As], Bs);
        h2 ->
            par_flush(Es, [E|As], Bs);
        h3 ->
            par_flush(Es, [E|As], Bs);
        h4 ->
            par_flush(Es, [E|As], Bs);
        h5 ->
            par_flush(Es, [E|As], Bs);
        h6 ->
            par_flush(Es, [E|As], Bs);
        pre ->
            par_flush(Es, [E|As], Bs);
        address ->
            par_flush(Es, [E|As], Bs);
        'div' ->
            par_flush(Es, [par_elem(E)|As], Bs);
        blockquote ->
            par_flush(Es, [par_elem(E)|As], Bs);
        form ->
            par_flush(Es, [par_elem(E)|As], Bs);
        fieldset ->
            par_flush(Es, [par_elem(E)|As], Bs);
        noscript ->
            par_flush(Es, [par_elem(E)|As], Bs);
        ul ->
            par_flush(Es, [par_subelem(E)|As], Bs);
        ol ->
            par_flush(Es, [par_subelem(E)|As], Bs);
        dl ->
            par_flush(Es, [par_subelem(E)|As], Bs);
        table ->
            par_flush(Es, [par_subelem(E)|As], Bs);
        _ ->
            par(Es, [E|As], Bs)
    end;
par([E|Es], As, Bs) ->
    par(Es, [E|As], Bs);
par([], As, Bs) ->
    lists:reverse(As ++ Bs).

par_text(Cs, As, Bs, E, Es) ->
    case ptxt(Cs) of
        none ->
            par(Es, [E|As], Bs);
        {Cs1,Ss,Cs2} ->
            Es1 =
                case Cs1 of
                    [] ->
                        lists:reverse(As);
                    _ ->
                        lists:reverse(As, [E#xmlText{value = Cs1}])
                end,
            Bs0 =
                case Es1 of
                    [] ->
                        Bs;
                    _ ->
                        [#xmlElement{name = p,content = Es1}|Bs]
                end,
            Bs1 = [#xmlText{value = Ss}|Bs0],
            case Cs2 of
                [] ->
                    par(Es, [], Bs1);
                _ ->
                    par_text(Cs2, [], Bs1, #xmlText{value = Cs2}, Es)
            end
    end.

par_flush(Es, As, Bs) ->
    par(Es, [], As ++ Bs).

par_elem(E) ->
    E#xmlElement{content = par(E#xmlElement.content)}.

par_subelem(E) ->
    E#xmlElement{content = par_subelem_1(E#xmlElement.content)}.

par_subelem_1([E = #xmlElement{name = Name}|Es]) ->
    E1 =
        case par_skip(Name) of
            true ->
                E;
            false ->
                case par_sub(Name) of
                    true ->
                        par_subelem(E);
                    false ->
                        par_elem(E)
                end
        end,
    [E1|par_subelem_1(Es)];
par_subelem_1([E|Es]) ->
    [E|par_subelem_1(Es)];
par_subelem_1([]) ->
    [].

par_skip(caption) ->
    true;
par_skip(col) ->
    true;
par_skip(colgroup) ->
    true;
par_skip(_) ->
    false.

par_sub(tr) ->
    true;
par_sub(thead) ->
    true;
par_sub(tfoot) ->
    true;
par_sub(tbody) ->
    true;
par_sub(_) ->
    false.

ptxt(Cs) ->
    ptxt(Cs, []).

ptxt([$\n|Cs], As) ->
    ptxt_1(Cs, As, [$\n]);
ptxt([C|Cs], As) ->
    ptxt(Cs, [C|As]);
ptxt([], _As) ->
    none.

ptxt_1([C = $\s|Cs], As, Ss) ->
    ptxt_1(Cs, As, [C|Ss]);
ptxt_1([C = $\t|Cs], As, Ss) ->
    ptxt_1(Cs, As, [C|Ss]);
ptxt_1([C = $\n|Cs], As, Ss) ->
    ptxt_2(Cs, As, [C|Ss]);
ptxt_1(Cs, As, Ss) ->
    ptxt(Cs, lists:reverse(Ss, As)).

ptxt_2([C = $\s|Cs], As, Ss) ->
    ptxt_2(Cs, As, [C|Ss]);
ptxt_2([C = $\t|Cs], As, Ss) ->
    ptxt_2(Cs, As, [C|Ss]);
ptxt_2([C = $\n|Cs], As, Ss) ->
    ptxt_2(Cs, As, [C|Ss]);
ptxt_2(Cs, As, Ss) ->
    case edoc_lib:is_space(As) of
        true ->
            {[],lists:reverse(Ss ++ As),Cs};
        false ->
            {lists:reverse(As),lists:reverse(Ss),Cs}
    end.

-spec throw_error(non_neg_integer(), {string(), [_]}) -> no_return().

throw_error(L, D) ->
    throw({error,L,D}).



