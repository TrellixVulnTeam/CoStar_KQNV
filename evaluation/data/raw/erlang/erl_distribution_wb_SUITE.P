-file("test/lib/kernel/test/erl_distribution_wb_SUITE.erl", 1).

-module(erl_distribution_wb_SUITE).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/kernel/test/erl_distribution_wb_SUITE.erl", 22).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/kernel-2.15.3/include/inet.hrl",
      1).

-record(hostent,{h_name :: undefined | inet:hostname(),
                 h_aliases = [] :: [inet:hostname()],
                 h_addrtype :: undefined | inet | inet6,
                 h_length :: undefined | non_neg_integer(),
                 h_addr_list = [] :: [inet:ip_address()]}).

-file("test/lib/kernel/test/erl_distribution_wb_SUITE.erl", 23).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2]).

-export([init_per_testcase/2,
         end_per_testcase/2,
         whitebox/1,
         switch_options/1,
         missing_compulsory_dflags/1]).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [whitebox,switch_options,missing_compulsory_dflags].

groups() ->
    [].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

init_per_testcase(Func, Config) when is_atom(Func), is_list(Config) ->
    Dog = test_server:timetrap(test_server:minutes(1)),
    [{watchdog,Dog}|Config].

end_per_testcase(_Func, Config) ->
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog).

switch_options(doc) ->
    ["Tests switching of options for the tcp port, as this is done when"
     " the distribution port is to be shortcut into the emulator. Maybe"
     " this should be in the inet test suite, but only the distribution"
     " does such horrible things..."];
switch_options(Config) when is_list(Config) ->
    ok = test_switch_active(),
    ok = test_switch_active_partial(),
    ok = test_switch_active_and_packet(),
    ok.

whitebox(doc) ->
    ["Whitebox testing of distribution handshakes. Tests both BC with R"
     "5 and the md5 version. Note that after R6B, this should be revise"
     "d to remove BC code."];
whitebox(Config) when is_list(Config) ->
    {ok,Node} = start_node(erl_distribution_wb_SUITE, ""),
    Cookie = erlang:get_cookie(),
    {_,Host} = split(node()),
    ok = pending_up_md5(Node, join(ccc, Host), Cookie),
    ok = simultaneous_md5(Node, join('A', Host), Cookie),
    ok = simultaneous_md5(Node, join(zzzzzzzzzzzzzz, Host), Cookie),
    stop_node(Node),
    ok.

test_switch_active() ->
    {Client,Server} = socket_pair(0, 4),
    ok = write_packets_32(Client, 1, 5),
    receive after 2000 -> ok end,
    ok = read_packets(Server, 1, 1),
    receive after 2000 -> ok end,
    ok = read_packets(Server, 2, 2),
    inet:setopts(Server, [{active,true}]),
    ok = receive_packets(Server, 3, 5),
    close_pair({Client,Server}),
    ok.

test_switch_active_partial() ->
    {Client,Server} = socket_pair(0, 4),
    ok = write_packets_32(Client, 1, 2),
    ok =
        gen_tcp:send(Client,
                     [[(4 bsr 24) band 255,
                       (4 bsr 16) band 255,
                       (4 bsr 8) band 255,
                       4 band 255],
                      [0,0,0]]),
    receive after 2000 -> ok end,
    ok = read_packets(Server, 1, 1),
    receive after 2000 -> ok end,
    ok = read_packets(Server, 2, 2),
    inet:setopts(Server, [{active,true}]),
    ok = gen_tcp:send(Client, [3]),
    ok = write_packets_32(Client, 4, 5),
    ok = receive_packets(Server, 3, 5),
    close_pair({Client,Server}),
    ok.

do_test_switch_active_and_packet(SendBefore, SendAfter) ->
    {Client,Server} = socket_pair(0, 2),
    ok = write_packets_16(Client, 1, 2),
    ok = gen_tcp:send(Client, SendBefore),
    receive after 2000 -> ok end,
    ok = read_packets(Server, 1, 1),
    receive after 2000 -> ok end,
    ok = read_packets(Server, 2, 2),
    inet:setopts(Server, [{packet,4},{active,true}]),
    ok = gen_tcp:send(Client, SendAfter),
    ok = write_packets_32(Client, 4, 5),
    ok = receive_packets(Server, 3, 5),
    close_pair({Client,Server}),
    ok.

test_switch_active_and_packet() ->
    ok = do_test_switch_active_and_packet([0], [0,0,4,0,0,0,3]),
    ok = do_test_switch_active_and_packet([0,0], [0,4,0,0,0,3]),
    ok = do_test_switch_active_and_packet([0,0,0], [4,0,0,0,3]),
    ok = do_test_switch_active_and_packet([0,0,0,4], [0,0,0,3]),
    ok = do_test_switch_active_and_packet([0,0,0,4,0], [0,0,3]),
    ok = do_test_switch_active_and_packet([0,0,0,4,0,0], [0,3]),
    ok = do_test_switch_active_and_packet([0,0,0,4,0,0,0], [3]),
    ok = do_test_switch_active_and_packet([0,0,0,4,0,0,0,3], []),
    ok.

pending_up_md5(Node, OurName, Cookie) ->
    {NA,NB} = split(Node),
    {port,PortNo,_} = erl_epmd:port_please(NA, NB),
    {ok,SocketA} =
        gen_tcp:connect(atom_to_list(NB),
                        PortNo,
                        [{active,false},{packet,2}]),
    send_name(SocketA, OurName, 5),
    ok = recv_status(SocketA),
    {hidden,Node,5,HisChallengeA} = recv_challenge(SocketA),
    OurChallengeA = gen_challenge(),
    OurDigestA = gen_digest(HisChallengeA, Cookie),
    send_challenge_reply(SocketA, OurChallengeA, OurDigestA),
    ok = recv_challenge_ack(SocketA, OurChallengeA, Cookie),
    receive after 1000 -> ok end,
    {ok,SocketB} =
        gen_tcp:connect(atom_to_list(NB),
                        PortNo,
                        [{active,false},{packet,2}]),
    send_name(SocketB, OurName, 5),
    alive = recv_status(SocketB),
    send_status(SocketB, true),
    gen_tcp:close(SocketA),
    {hidden,Node,5,HisChallengeB} = recv_challenge(SocketB),
    OurChallengeB = gen_challenge(),
    OurDigestB = gen_digest(HisChallengeB, Cookie),
    send_challenge_reply(SocketB, OurChallengeB, OurDigestB),
    ok = recv_challenge_ack(SocketB, OurChallengeB, Cookie),
    inet:setopts(SocketB, [{active,false},{packet,4}]),
    gen_tcp:send(SocketB, build_rex_message('', OurName)),
    {Header,Message} = recv_message(SocketB),
    io:format("Received header ~p, data ~p.~n", [Header,Message]),
    gen_tcp:close(SocketB),
    ok.

simultaneous_md5(Node, OurName, Cookie) when OurName < Node ->
    pong = net_adm:ping(Node),
    LSocket =
        case gen_tcp:listen(0, [{active,false},{packet,2}]) of
            {ok,Socket} ->
                Socket;
            Else ->
                exit(Else)
        end,
    EpmdSocket = register(OurName, LSocket, 1, 5),
    {NA,NB} = split(Node),
    rpc:cast(Node, net_adm, ping, [OurName]),
    receive after 1000 -> ok end,
    {port,PortNo,_} = erl_epmd:port_please(NA, NB),
    {ok,SocketA} =
        gen_tcp:connect(atom_to_list(NB),
                        PortNo,
                        [{active,false},{packet,2}]),
    send_name(SocketA, OurName, 5),
    SocketB =
        case gen_tcp:accept(LSocket) of
            {ok,Socket1} ->
                Socket1;
            Else2 ->
                exit(Else2)
        end,
    nok = recv_status(SocketA),
    gen_tcp:close(SocketA),
    {normal,Node,5} = recv_name(SocketB),
    send_status(SocketB, ok_simultaneous),
    MyChallengeB = gen_challenge(),
    send_challenge(SocketB, OurName, MyChallengeB, 5),
    HisChallengeB = recv_challenge_reply(SocketB, MyChallengeB, Cookie),
    DigestB = gen_digest(HisChallengeB, Cookie),
    send_challenge_ack(SocketB, DigestB),
    inet:setopts(SocketB, [{active,false},{packet,4}]),
    {Header,Message} = recv_message(SocketB),
    io:format("Received header ~p, data ~p.~n", [Header,Message]),
    gen_tcp:close(SocketB),
    gen_tcp:close(LSocket),
    gen_tcp:close(EpmdSocket),
    ok;
simultaneous_md5(Node, OurName, Cookie) when OurName > Node ->
    pong = net_adm:ping(Node),
    LSocket =
        case gen_tcp:listen(0, [{active,false},{packet,2}]) of
            {ok,Socket} ->
                Socket;
            Else ->
                exit(Else)
        end,
    EpmdSocket = register(OurName, LSocket, 1, 5),
    {NA,NB} = split(Node),
    rpc:cast(Node, net_adm, ping, [OurName]),
    receive after 1000 -> ok end,
    {port,PortNo,_} = erl_epmd:port_please(NA, NB),
    {ok,SocketA} =
        gen_tcp:connect(atom_to_list(NB),
                        PortNo,
                        [{active,false},{packet,2}]),
    SocketB =
        case gen_tcp:accept(LSocket) of
            {ok,Socket1} ->
                Socket1;
            Else2 ->
                exit(Else2)
        end,
    send_name(SocketA, OurName, 5),
    ok_simultaneous = recv_status(SocketA),
    case
        catch
            begin
                {normal,Node,5} = recv_name(SocketB),
                send_status(SocketB, ok_simultaneous),
                MyChallengeB = gen_challenge(),
                send_challenge(SocketB, OurName, MyChallengeB, 5),
                HisChallengeB =
                    recv_challenge_reply(SocketB, MyChallengeB, Cookie),
                DigestB = gen_digest(HisChallengeB, Cookie),
                send_challenge_ack(SocketB, DigestB),
                inet:setopts(SocketB, [{active,false},{packet,4}]),
                {HeaderB,MessageB} = recv_message(SocketB),
                io:format("Received header ~p, data ~p.~n",
                          [HeaderB,MessageB])
            end
    of
        {'EXIT',Exitcode} ->
            io:format("Expected exitsignal caught: ~p.~n", [Exitcode]);
        Success ->
            io:format("Unexpected success: ~p~n", [Success]),
            exit(unexpected_success)
    end,
    gen_tcp:close(SocketB),
    {hidden,Node,5,HisChallengeA} = recv_challenge(SocketA),
    OurChallengeA = gen_challenge(),
    OurDigestA = gen_digest(HisChallengeA, Cookie),
    send_challenge_reply(SocketA, OurChallengeA, OurDigestA),
    ok = recv_challenge_ack(SocketA, OurChallengeA, Cookie),
    inet:setopts(SocketA, [{active,false},{packet,4}]),
    gen_tcp:send(SocketA, build_rex_message('', OurName)),
    {Header,Message} = recv_message(SocketA),
    io:format("Received header ~p, data ~p.~n", [Header,Message]),
    gen_tcp:close(SocketA),
    gen_tcp:close(LSocket),
    gen_tcp:close(EpmdSocket),
    ok.

missing_compulsory_dflags(doc) ->
    [];
missing_compulsory_dflags(Config) when is_list(Config) ->
    [Name1,Name2] = get_nodenames(2, missing_compulsory_dflags),
    {ok,Node} = start_node(Name1, ""),
    {NA,NB} = split(Node),
    {port,PortNo,_} = erl_epmd:port_please(NA, NB),
    {ok,SocketA} =
        gen_tcp:connect(atom_to_list(NB),
                        PortNo,
                        [{active,false},{packet,2}]),
    BadNode =
        list_to_atom(atom_to_list(Name2) ++ "@" ++ atom_to_list(NB)),
    send_name(SocketA, BadNode, 5, 0),
    not_allowed = recv_status(SocketA),
    gen_tcp:close(SocketA),
    stop_node(Node),
    ok.

write_packets_32(_, M, N) when M > N ->
    ok;
write_packets_32(Sock, M, N) ->
    ok =
        gen_tcp:send(Sock,
                     [[(4 bsr 24) band 255,
                       (4 bsr 16) band 255,
                       (4 bsr 8) band 255,
                       4 band 255],
                      [(M bsr 24) band 255,
                       (M bsr 16) band 255,
                       (M bsr 8) band 255,
                       M band 255]]),
    write_packets_32(Sock, M + 1, N).

write_packets_16(_, M, N) when M > N ->
    ok;
write_packets_16(Sock, M, N) ->
    ok =
        gen_tcp:send(Sock,
                     [[(4 bsr 8) band 255,4 band 255],
                      [(M bsr 24) band 255,
                       (M bsr 16) band 255,
                       (M bsr 8) band 255,
                       M band 255]]),
    write_packets_16(Sock, M + 1, N).

read_packets(_, M, N) when M > N ->
    ok;
read_packets(Sock, M, N) ->
    Expected =
        [(M bsr 24) band 255,
         (M bsr 16) band 255,
         (M bsr 8) band 255,
         M band 255],
    case gen_tcp:recv(Sock, 0) of
        {ok,Expected} ->
            read_packets(Sock, M + 1, N);
        {ok,Unexpected} ->
            exit({unexpected_data_read,Unexpected});
        Error ->
            exit({error_read,Error})
    end.

receive_packets(Sock, M, N) when M > N ->
    receive
        {tcp,Sock,Data} ->
            exit({extra_data,Data})
    after
        0 -> ok
    end;
receive_packets(Sock, M, N) ->
    Expect =
        [(M bsr 24) band 255,
         (M bsr 16) band 255,
         (M bsr 8) band 255,
         M band 255],
    receive
        {tcp,Sock,Expect} ->
            receive_packets(Sock, M + 1, N);
        {tcp,Sock,Unexpected} ->
            exit({unexpected_data_received,Unexpected})
    after
        500 -> exit({no_data_received_for,M})
    end.

socket_pair(ClientPack, ServerPack) ->
    {ok,Listen} =
        gen_tcp:listen(0, [{active,false},{packet,ServerPack}]),
    {ok,Host} = inet:gethostname(),
    {ok,Port} = inet:port(Listen),
    {ok,Client} =
        gen_tcp:connect(Host,
                        Port,
                        [{active,false},{packet,ClientPack}]),
    {ok,Server} = gen_tcp:accept(Listen),
    gen_tcp:close(Listen),
    {Client,Server}.

close_pair({Client,Server}) ->
    gen_tcp:close(Client),
    gen_tcp:close(Server),
    ok.

gen_challenge() ->
    {_,_,N} = now(),
    N.

gen_digest(Challenge, Cookie)
    when is_integer(Challenge), is_atom(Cookie) ->
    C0 = erlang:md5_init(),
    C1 = erlang:md5_update(C0, atom_to_list(Cookie)),
    C2 = erlang:md5_update(C1, integer_to_list(Challenge)),
    binary_to_list(erlang:md5_final(C2)).

send_status(Socket, Stat) ->
    case gen_tcp:send(Socket, [$s|atom_to_list(Stat)]) of
        {error,_} ->
            exit(could_not_send_status);
        _ ->
            true
    end.

recv_status(Socket) ->
    case gen_tcp:recv(Socket, 0) of
        {ok,[$s|StrStat]} ->
            list_to_atom(StrStat);
        Bad ->
            exit(Bad)
    end.

send_challenge(Socket, Node, Challenge, Version) ->
    send_challenge(Socket, Node, Challenge, Version, 4 bor 256).

send_challenge(Socket, Node, Challenge, Version, Flags) ->
    {ok,{{_Ip1,_Ip2,_Ip3,_Ip4},_}} = inet:sockname(Socket),
    case
        inet_tcp:send(Socket,
                      [$n,
                       [(Version bsr 8) band 255,Version band 255],
                       [(Flags bsr 24) band 255,
                        (Flags bsr 16) band 255,
                        (Flags bsr 8) band 255,
                        Flags band 255],
                       [(Challenge bsr 24) band 255,
                        (Challenge bsr 16) band 255,
                        (Challenge bsr 8) band 255,
                        Challenge band 255],
                       atom_to_list(Node)])
    of
        {error,closed} ->
            self() ! {tcp_closed,Socket},
            {error,closed};
        R ->
            R
    end.

recv_challenge(Socket) ->
    case gen_tcp:recv(Socket, 0) of
        {ok,[$n,V1,V0,Fl1,Fl2,Fl3,Fl4,CA3,CA2,CA1,CA0|Ns]} ->
            Flags = Fl1 bsl 24 bor (Fl2 bsl 16) bor (Fl3 bsl 8) bor Fl4,
            Type =
                case Flags band 1 of
                    0 ->
                        hidden;
                    _ ->
                        normal
                end,
            Node = list_to_atom(Ns),
            Version = V1 bsl 8 bor V0,
            Challenge =
                CA3 bsl 24 bor (CA2 bsl 16) bor (CA1 bsl 8) bor CA0,
            {Type,Node,Version,Challenge};
        _ ->
            exit(no_node)
    end.

send_challenge_reply(Socket, Challenge, Digest) ->
    case
        inet_tcp:send(Socket,
                      [$r,
                       [(Challenge bsr 24) band 255,
                        (Challenge bsr 16) band 255,
                        (Challenge bsr 8) band 255,
                        Challenge band 255],
                       Digest])
    of
        {error,closed} ->
            self() ! {tcp_closed,Socket},
            {error,closed};
        R ->
            R
    end.

recv_challenge_reply(Socket, ChallengeA, Cookie) ->
    case gen_tcp:recv(Socket, 0) of
        {ok,[$r,CB3,CB2,CB1,CB0|SumB]} when length(SumB) == 16 ->
            SumA = gen_digest(ChallengeA, Cookie),
            ChallengeB =
                CB3 bsl 24 bor (CB2 bsl 16) bor (CB1 bsl 8) bor CB0,
            if
                SumB == SumA ->
                    ChallengeB;
                true ->
                    exit(bad_challenge_reply)
            end;
        _ ->
            exit(no_node)
    end.

send_challenge_ack(Socket, Digest) ->
    case inet_tcp:send(Socket, [$a,Digest]) of
        {error,closed} ->
            self() ! {tcp_closed,Socket},
            {error,closed};
        R ->
            R
    end.

recv_challenge_ack(Socket, ChallengeB, CookieA) ->
    case gen_tcp:recv(Socket, 0) of
        {ok,[$a|SumB]} when length(SumB) == 16 ->
            SumA = gen_digest(ChallengeB, CookieA),
            if
                SumB == SumA ->
                    ok;
                true ->
                    exit(bad_challenge_ack)
            end;
        _ ->
            exit(bad_challenge_ack)
    end.

send_name(Socket, MyNode0, Version) ->
    send_name(Socket, MyNode0, Version, 4 bor 256).

send_name(Socket, MyNode0, Version, Flags) ->
    MyNode = atom_to_list(MyNode0),
    ok =
        case
            inet_tcp:send(Socket, [<<$n,Version:16,Flags:32>>|MyNode])
        of
            {error,closed} ->
                self() ! {tcp_closed,Socket},
                {error,closed};
            R ->
                R
        end.

recv_name(Socket) ->
    case gen_tcp:recv(Socket, 0) of
        {ok,Data} ->
            get_name(Data);
        Res ->
            exit({no_node,Res})
    end.

get_name([$m,VersionA,VersionB,_Ip1,_Ip2,_Ip3,_Ip4|OtherNode]) ->
    {normal,list_to_atom(OtherNode),VersionA bsl 8 bor VersionB};
get_name([$h,VersionA,VersionB,_Ip1,_Ip2,_Ip3,_Ip4|OtherNode]) ->
    {hidden,list_to_atom(OtherNode),VersionA bsl 8 bor VersionB};
get_name([$n,VersionA,VersionB,Flag1,Flag2,Flag3,Flag4|OtherNode]) ->
    Type =
        case
            (Flag1 bsl 24 bor (Flag2 bsl 16) bor (Flag3 bsl 8) bor Flag4)
            band
            1
        of
            0 ->
                hidden;
            _ ->
                normal
        end,
    {Type,list_to_atom(OtherNode),VersionA bsl 8 bor VersionB};
get_name(Data) ->
    exit(Data).

get_epmd_port() ->
    case init:get_argument(epmd_port) of
        {ok,[[PortStr|_]|_]} when is_list(PortStr) ->
            list_to_integer(PortStr);
        error ->
            4369
    end.

do_register_node(NodeName, TcpPort, VLow, VHigh) ->
    case gen_tcp:connect({127,0,0,1}, get_epmd_port(), []) of
        {ok,Socket} ->
            {N0,_} = split(NodeName),
            Name = atom_to_list(N0),
            Extra = "",
            Elen = length(Extra),
            Len = 1 + 2 + 1 + 1 + 2 + 2 + 2 + length(Name) + 2 + Elen,
            gen_tcp:send(Socket,
                         [[(Len bsr 8) band 255,Len band 255],
                          $x,
                          [(TcpPort bsr 8) band 255,TcpPort band 255],
                          $M,
                          0,
                          [(VHigh bsr 8) band 255,VHigh band 255],
                          [(VLow bsr 8) band 255,VLow band 255],
                          [(length(Name) bsr 8) band 255,
                           length(Name) band 255],
                          Name,
                          [(Elen bsr 8) band 255,Elen band 255],
                          Extra]),
            case wait_for_reg_reply(Socket, []) of
                {error,epmd_close} ->
                    exit(epmd_broken);
                Other ->
                    Other
            end;
        Error ->
            Error
    end.

wait_for_reg_reply(Socket, SoFar) ->
    receive
        {tcp,Socket,Data0} ->
            case SoFar ++ Data0 of
                [$y,Result,A,B] ->
                    case Result of
                        0 ->
                            {alive,Socket,A bsl 8 bor B};
                        _ ->
                            {error,duplicate_name}
                    end;
                Data when length(Data) < 4 ->
                    wait_for_reg_reply(Socket, Data);
                Garbage ->
                    {error,{garbage_from_epmd,Garbage}}
            end;
        {tcp_closed,Socket} ->
            {error,epmd_close}
    after
        10000 ->
            gen_tcp:close(Socket),
            {error,no_reg_reply_from_epmd}
    end.

register(NodeName, ListenSocket, VLow, VHigh) ->
    {ok,{_,TcpPort}} = inet:sockname(ListenSocket),
    case do_register_node(NodeName, TcpPort, VLow, VHigh) of
        {alive,Socket,_Creation} ->
            Socket;
        Other ->
            exit(Other)
    end.

split([$@|T], A) ->
    {lists:reverse(A),T};
split([H|T], A) ->
    split(T, [H|A]).

split(Atom) ->
    {A,B} = split(atom_to_list(Atom), []),
    {list_to_atom(A),list_to_atom(B)}.

build_rex_message(Cookie, OurName) ->
    [$?,
     term_to_binary({6,self(),Cookie,rex}),
     term_to_binary({'$gen_cast',
                     {cast,rpc,cast,[OurName,hello,world,[]],self()}})].

recv_message(Socket) ->
    case gen_tcp:recv(Socket, 0) of
        {ok,Data} ->
            B0 = list_to_binary(Data),
            {_,B1} = split_binary(B0, 1),
            Header = binary_to_term(B1),
            Siz = byte_size(term_to_binary(Header)),
            {_,B2} = split_binary(B1, Siz),
            Message =
                case catch binary_to_term(B2) of
                    {'EXIT',_} ->
                        could_not_digest_message;
                    Other ->
                        Other
                end,
            {Header,Message};
        Res ->
            exit({no_message,Res})
    end.

join(Name, Host) ->
    list_to_atom(atom_to_list(Name) ++ "@" ++ atom_to_list(Host)).

start_node(Name, Param) ->
    test_server:start_node(Name, slave, [{args,Param}]).

stop_node(Node) ->
    test_server:stop_node(Node).

get_nodenames(N, T) ->
    get_nodenames(N, T, []).

get_nodenames(0, _, Acc) ->
    Acc;
get_nodenames(N, T, Acc) ->
    {A,B,C} = now(),
    get_nodenames(N - 1,
                  T,
                  [list_to_atom(atom_to_list(erl_distribution_wb_SUITE)
                                ++
                                "-"
                                ++
                                atom_to_list(T)
                                ++
                                "-"
                                ++
                                integer_to_list(A)
                                ++
                                "-"
                                ++
                                integer_to_list(B)
                                ++
                                "-" ++ integer_to_list(C))|
                   Acc]).



