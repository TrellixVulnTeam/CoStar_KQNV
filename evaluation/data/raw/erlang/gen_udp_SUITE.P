-file("test/lib/kernel/test/gen_udp_SUITE.erl", 1).

-module(gen_udp_SUITE).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/kernel/test/gen_udp_SUITE.erl", 26).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2]).

-export([init_per_testcase/2,end_per_testcase/2]).

-export([send_to_closed/1,
         buffer_size/1,
         binary_passive_recv/1,
         bad_address/1,
         read_packets/1,
         open_fd/1,
         connect/1,
         implicit_inet6/1]).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [send_to_closed,
     buffer_size,
     binary_passive_recv,
     bad_address,
     read_packets,
     open_fd,
     connect,
     implicit_inet6].

groups() ->
    [].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

init_per_testcase(_Case, Config) ->
    Dog = test_server:timetrap(test_server:minutes(1)),
    [{watchdog,Dog}|Config].

end_per_testcase(_Case, Config) ->
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog),
    ok.

send_to_closed(doc) ->
    ["Tests core functionality."];
send_to_closed(suite) ->
    [];
send_to_closed(Config) when is_list(Config) ->
    {ok,Sock} = gen_udp:open(0),
    ok = gen_udp:send(Sock, {127,0,0,1}, 6666, "foo"),
    timer:sleep(2),
    ok = gen_udp:send(Sock, {127,0,0,1}, 6666, "foo"),
    ok = gen_udp:close(Sock),
    ok.

buffer_size(suite) ->
    [];
buffer_size(doc) ->
    ["Test UDP buffer size setting."];
buffer_size(Config) when is_list(Config) ->
    Len = 256,
    Bin = list_to_binary(lists:seq(0, Len - 1)),
    M = 8192 div Len,
    Spec0 =
        [{opt,M},
         {safe,M - 3},
         {long,M + 1},
         {opt,2 * M},
         {safe,2 * M - 3},
         {long,2 * M + 1},
         {opt,4 * M},
         {safe,4 * M - 3},
         {long,4 * M + 1}],
    Spec =
        [ 
         case Tag of
             opt ->
                 [{recbuf,Val * Len},{sndbuf,(Val + 2) * Len}];
             safe ->
                 {list_to_binary(lists:duplicate(Val, Bin)),[correct]};
             long ->
                 {list_to_binary(lists:duplicate(Val, Bin)),
                  [truncated,emsgsize,timeout]}
         end ||
             {Tag,Val} <- Spec0
        ],
    {ok,ClientSocket} = gen_udp:open(0, [binary]),
    {ok,ClientPort} = inet:port(ClientSocket),
    Client = self(),
    ClientIP = {127,0,0,1},
    ServerIP = {127,0,0,1},
    Server =
        spawn_link(fun() ->
                          {ok,ServerSocket} = gen_udp:open(0, [binary]),
                          {ok,ServerPort} = inet:port(ServerSocket),
                          Client ! {self(),port,ServerPort},
                          buffer_size_server(Client,
                                             ClientIP,
                                             ClientPort,
                                             ServerSocket,
                                             1,
                                             Spec),
                          ok = gen_udp:close(ServerSocket)
                   end),
    Mref = monitor(process, Server),
    receive
        {Server,port,ServerPort} ->
            buffer_size_client(Server,
                               ServerIP,
                               ServerPort,
                               ClientSocket,
                               1,
                               Spec)
    end,
    ok = gen_udp:close(ClientSocket),
    receive
        {'DOWN',Mref,_,_,normal} ->
            ok
    end.

buffer_size_client(_, _, _, _, _, []) ->
    ok;
buffer_size_client(Server, IP, Port, Socket, Cnt, [Opts|T])
    when is_list(Opts) ->
    io:format("buffer_size_client Cnt=~w setopts ~p.~n", [Cnt,Opts]),
    ok = inet:setopts(Socket, Opts),
    Server ! {self(),setopts,Cnt},
    receive
        {Server,setopts,Cnt} ->
            ok
    end,
    buffer_size_client(Server, IP, Port, Socket, Cnt + 1, T);
buffer_size_client(Server,
                   IP,
                   Port,
                   Socket,
                   Cnt,
                   [{B,Replies}|T] = Opts)
    when is_binary(B) ->
    io:format("buffer_size_client Cnt=~w send size ~w expecting ~p.~n",
              [Cnt,size(B),Replies]),
    ok = gen_udp:send(Socket, IP, Port, <<Cnt,B/binary>>),
    receive
        {Server,Cnt,Reply} ->
            Tag =
                if
                    is_tuple(Reply) ->
                        element(1, Reply);
                    is_atom(Reply) ->
                        Reply
                end,
            case lists:member(Tag, Replies) of
                true ->
                    ok;
                false ->
                    test_server:fail({reply_mismatch,
                                      Cnt,
                                      Reply,
                                      Replies,
                                      byte_size(B),
                                      inet:getopts(Socket,
                                                   [sndbuf,recbuf])})
            end,
            buffer_size_client(Server, IP, Port, Socket, Cnt + 1, T)
    after
        1313 -> buffer_size_client(Server, IP, Port, Socket, Cnt, Opts)
    end.

buffer_size_server(_, _, _, _, _, []) ->
    ok;
buffer_size_server(Client, IP, Port, Socket, Cnt, [Opts|T])
    when is_list(Opts) ->
    receive
        {Client,setopts,Cnt} ->
            ok
    end,
    io:format("buffer_size_server Cnt=~w setopts ~p.~n", [Cnt,Opts]),
    ok = inet:setopts(Socket, Opts),
    Client ! {self(),setopts,Cnt},
    buffer_size_server(Client, IP, Port, Socket, Cnt + 1, T);
buffer_size_server(Client, IP, Port, Socket, Cnt, [{B,_}|T])
    when is_binary(B) ->
    io:format("buffer_size_server Cnt=~w expecting size ~w.~n",
              [Cnt,size(B)]),
    Client
    !
    {self(),
     Cnt,
     case buffer_size_server_recv(Socket, IP, Port, Cnt) of
         D when is_binary(D) ->
             SizeD = byte_size(D),
             io:format("buffer_size_server Cnt=~w received size ~w.~n",
                       [Cnt,SizeD]),
             case B of
                 D ->
                     correct;
                 <<D:SizeD/binary,_/binary>> ->
                     truncated;
                 _ ->
                     {unexpected,D}
             end;
         Error ->
             io:format("buffer_size_server Cnt=~w received error ~w.~n",
                       [Cnt,Error]),
             Error
     end},
    buffer_size_server(Client, IP, Port, Socket, Cnt + 1, T).

buffer_size_server_recv(Socket, IP, Port, Cnt) ->
    receive
        {udp,Socket,IP,Port,<<Cnt,B/binary>>} ->
            B;
        {udp,Socket,IP,Port,<<_/binary>>} ->
            buffer_size_server_recv(Socket, IP, Port, Cnt);
        {udp_error,Socket,Error} ->
            Error
    after
        5000 -> {timeout,flush()}
    end.

binary_passive_recv(suite) ->
    [];
binary_passive_recv(doc) ->
    ["OTP-3823 gen_udp:recv does not return address in binary mode"];
binary_passive_recv(Config) when is_list(Config) ->
    D1 = "The quick brown fox jumps over a lazy dog",
    D2 = list_to_binary(D1),
    D3 =
        ["The quick",
         <<" brown ">>,
         "fox jumps ",
         <<"over ">>,
         <<>>,
         $a,
         [[]," lazy ",<<"dog">>]],
    D2 = iolist_to_binary(D3),
    B = D2,
    {ok,R} = gen_udp:open(0, [binary,{active,false}]),
    {ok,RP} = inet:port(R),
    {ok,S} = gen_udp:open(0),
    {ok,SP} = inet:port(S),
    ok = gen_udp:send(S, localhost, RP, D1),
    {ok,{{127,0,0,1},SP,B}} = gen_udp:recv(R, byte_size(B) + 1),
    ok = gen_udp:send(S, localhost, RP, D2),
    {ok,{{127,0,0,1},SP,B}} = gen_udp:recv(R, byte_size(B) + 1),
    ok = gen_udp:send(S, localhost, RP, D3),
    {ok,{{127,0,0,1},SP,B}} = gen_udp:recv(R, byte_size(B) + 1),
    ok = gen_udp:close(S),
    ok = gen_udp:close(R),
    ok.

bad_address(suite) ->
    [];
bad_address(doc) ->
    ["OTP-3836 inet_udp crashes when IP-address is larger than 255."];
bad_address(Config) when is_list(Config) ->
    {ok,R} = gen_udp:open(0),
    {ok,RP} = inet:port(R),
    {ok,S} = gen_udp:open(0),
    {ok,_SP} = inet:port(S),
    {'EXIT',badarg} = (catch gen_udp:send(S, {127,0,0,1,0}, RP, "void")),
    {'EXIT',badarg} = (catch gen_udp:send(S, {127,0,0,256}, RP, "void")),
    ok = gen_udp:close(S),
    ok = gen_udp:close(R),
    ok.

read_packets(doc) ->
    ["OTP-6249 UDP option for number of packet reads."];
read_packets(Config) when is_list(Config) ->
    case erlang:system_info(smp_support) of
        false ->
            read_packets_1();
        true ->
            {skip,"SMP emulator"}
    end.

read_packets_1() ->
    N1 = 5,
    N2 = 7,
    {ok,R} = gen_udp:open(0, [{read_packets,N1}]),
    {ok,RP} = inet:port(R),
    {ok,Node} = start_node(gen_udp_SUITE_read_packets),
    Die = make_ref(),
    Loop =
        spawn_link(fun() ->
                          infinite_loop(Die)
                   end),
    Msgs1 =
        [ 
         integer_to_list(M) ||
             M <- lists:seq(1, N1 * 3)
        ],
    [V1|_] = read_packets_test(R, RP, Msgs1, Node),
    {ok,[{read_packets,N1}]} = inet:getopts(R, [read_packets]),
    ok = inet:setopts(R, [{read_packets,N2}]),
    Msgs2 =
        [ 
         integer_to_list(M) ||
             M <- lists:seq(1, N2 * 3)
        ],
    [V2|_] = read_packets_test(R, RP, Msgs2, Node),
    {ok,[{read_packets,N2}]} = inet:getopts(R, [read_packets]),
    stop_node(Node),
    Mref = monitor(process, Loop),
    Loop ! Die,
    receive
        {'DOWN',Mref,_,_,normal} ->
            case {V1,V2} of
                {N1,N2} ->
                    ok;
                _ when V1 =/= N1, V2 =/= N2 ->
                    ok
            end
    end.

infinite_loop(Die) ->
    receive
        Die ->
            ok
    after
        0 -> infinite_loop(Die)
    end.

read_packets_test(R, RP, Msgs, Node) ->
    Len = length(Msgs),
    Receiver = self(),
    Tracer =
        spawn_link(fun() ->
                          receive
                              {Receiver,get_trace} ->
                                  Receiver ! {self(),{trace,flush()}}
                          end
                   end),
    Sender =
        spawn_opt(Node,
                  fun() ->
                         {ok,S} = gen_udp:open(0),
                         {ok,SP} = inet:port(S),
                         Receiver ! {self(),{port,SP}},
                         receive
                             {Receiver,go} ->
                                 read_packets_send(S, RP, Msgs)
                         end
                  end,
                  [link,{priority,high}]),
    receive
        {Sender,{port,SP}} ->
            erlang:trace(self(),
                         true,
                         [running,'receive',{tracer,Tracer}]),
            erlang:yield(),
            Sender ! {Receiver,go},
            read_packets_recv(Len),
            erlang:trace(self(), false, [all]),
            Tracer ! {Receiver,get_trace},
            receive
                {Tracer,{trace,Trace}} ->
                    read_packets_verify(R, SP, Msgs, Trace)
            end
    end.

read_packets_send(S, RP, [Msg|Msgs]) ->
    ok = gen_udp:send(S, localhost, RP, Msg),
    read_packets_send(S, RP, Msgs);
read_packets_send(_S, _RP, []) ->
    ok.

read_packets_recv(0) ->
    ok;
read_packets_recv(N) ->
    receive
        _ ->
            read_packets_recv(N - 1)
    after
        5000 -> timeout
    end.

read_packets_verify(R, SP, Msg, Trace) ->
    lists:reverse(lists:sort(read_packets_verify(R, SP, Msg, Trace, 0))).

read_packets_verify(R, SP, Msgs, [{trace,Self,OutIn,_}|Trace], M)
    when Self =:= self(), OutIn =:= out; Self =:= self(), OutIn =:= in ->
    push(M, read_packets_verify(R, SP, Msgs, Trace, 0));
read_packets_verify(R,
                    SP,
                    [Msg|Msgs],
                    [{trace,Self,'receive',{udp,R,{127,0,0,1},SP,Msg}}|
                     Trace],
                    M)
    when Self =:= self() ->
    read_packets_verify(R, SP, Msgs, Trace, M + 1);
read_packets_verify(_R, _SP, [], [], M) ->
    push(M, []);
read_packets_verify(_R, _SP, Msgs, Trace, M) ->
    test_server:fail({read_packets_verify,mismatch,Msgs,Trace,M}).

push(0, Vs) ->
    Vs;
push(V, Vs) ->
    [V|Vs].

flush() ->
    receive
        X ->
            [X|flush()]
    after
        200 -> []
    end.

open_fd(suite) ->
    [];
open_fd(doc) ->
    ["Test that the 'fd' option works"];
open_fd(Config) when is_list(Config) ->
    Msg =
        "Det gör ont när knoppar brista. Varför skulle annars våren"
        " tveka?",
    Addr = {127,0,0,1},
    {ok,S1} = gen_udp:open(0),
    {ok,P2} = inet:port(S1),
    {ok,FD} = prim_inet:getfd(S1),
    {error,einval} = gen_udp:open(P2, [inet6,{fd,FD}]),
    {ok,S2} = gen_udp:open(P2, [{fd,FD}]),
    {ok,S3} = gen_udp:open(0),
    {ok,P3} = inet:port(S3),
    ok = gen_udp:send(S3, Addr, P2, Msg),
    receive
        {udp,S2,Addr,P3,Msg} ->
            ok = gen_udp:send(S2, Addr, P3, Msg),
            receive
                {udp,S3,Addr,P2,Msg} ->
                    ok
            after
                1000 -> test_server:fail(io_lib:format("~w", [flush()]))
            end
    after
        1000 -> test_server:fail(io_lib:format("~w", [flush()]))
    end.

start_node(Name) ->
    Pa = filename:dirname(code:which(gen_udp_SUITE)),
    test_server:start_node(Name, slave, [{args,"-pa " ++ Pa}]).

stop_node(Node) ->
    test_server:stop_node(Node).

connect(suite) ->
    [];
connect(doc) ->
    ["Test that connect/3 has effect"];
connect(Config) when is_list(Config) ->
    Addr = {127,0,0,1},
    {ok,S1} = gen_udp:open(0),
    {ok,P1} = inet:port(S1),
    {ok,S2} = gen_udp:open(0),
    ok = inet:setopts(S2, [{active,false}]),
    ok = gen_udp:close(S1),
    ok = gen_udp:connect(S2, Addr, P1),
    ok = gen_udp:send(S2, <<3735928559:32>>),
    ok =
        case gen_udp:recv(S2, 0, 5) of
            {error,econnrefused} ->
                ok;
            {error,econnreset} ->
                ok;
            Other ->
                Other
        end,
    ok.

implicit_inet6(Config) when is_list(Config) ->
    Host = ok(inet:gethostname()),
    case inet:getaddr(Host, inet6) of
        {ok,Addr} ->
            implicit_inet6(Host, Addr);
        {error,Reason} ->
            {skip,
             "Can not look up IPv6 address: " ++ atom_to_list(Reason)}
    end.

implicit_inet6(Host, Addr) ->
    Active = {active,false},
    case gen_udp:open(0, [inet6,Active]) of
        {ok,S1} ->
            Loopback = {0,0,0,0,0,0,0,1},
            io:format("~s ~p~n", ["::1",Loopback]),
            implicit_inet6(S1, Active, Loopback),
            ok = gen_udp:close(S1),
            Localhost = "localhost",
            Localaddr = ok(inet:getaddr(Localhost, inet6)),
            io:format("~s ~p~n", [Localhost,Localaddr]),
            S2 = ok(gen_udp:open(0, [{ip,Localaddr},Active])),
            implicit_inet6(S2, Active, Localaddr),
            ok = gen_udp:close(S2),
            io:format("~s ~p~n", [Host,Addr]),
            S3 = ok(gen_udp:open(0, [{ifaddr,Addr},Active])),
            implicit_inet6(S3, Active, Addr),
            ok = gen_udp:close(S3);
        _ ->
            {skip,"IPv6 not supported"}
    end.

implicit_inet6(S1, Active, Addr) ->
    P1 = ok(inet:port(S1)),
    S2 = ok(gen_udp:open(0, [inet6,Active])),
    P2 = ok(inet:port(S2)),
    ok = gen_udp:connect(S2, Addr, P1),
    ok = gen_udp:connect(S1, Addr, P2),
    {Addr,P2} = ok(inet:peername(S1)),
    {Addr,P1} = ok(inet:peername(S2)),
    {Addr,P1} = ok(inet:sockname(S1)),
    {Addr,P2} = ok(inet:sockname(S2)),
    ok = gen_udp:send(S1, Addr, P2, "ping"),
    {Addr,P1,"ping"} = ok(gen_udp:recv(S2, 1024, 1000)),
    ok = gen_udp:send(S2, Addr, P1, "pong"),
    {Addr,P2,"pong"} = ok(gen_udp:recv(S1, 1024)),
    ok = gen_udp:close(S2).

ok({ok,V}) ->
    V.



