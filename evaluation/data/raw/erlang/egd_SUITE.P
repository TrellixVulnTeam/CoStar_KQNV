-file("test/lib/percept/test/egd_SUITE.erl", 1).

-module(egd_SUITE).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/percept/test/egd_SUITE.erl", 22).

-export([all/0,suite/0,groups/0,init_per_group/2,end_per_group/2]).

-export([init_per_suite/1,end_per_suite/1]).

-export([init_per_testcase/2,end_per_testcase/2]).

-export([image_create_and_destroy/1,
         image_shape/1,
         image_primitives/1,
         image_colors/1,
         image_font/1,
         image_png_compliant/1]).

init_per_suite(Config) when is_list(Config) ->
    random:seed(now()),
    Config.

end_per_suite(Config) when is_list(Config) ->
    Config.

init_per_testcase(_Case, Config) ->
    Dog = test_server:timetrap(test_server:minutes(1)),
    [{max_size,800},{watchdog,Dog}|Config].

end_per_testcase(_Case, Config) ->
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog),
    ok.

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [image_create_and_destroy,
     image_shape,
     image_primitives,
     image_colors,
     image_font,
     image_png_compliant].

groups() ->
    [].

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

image_create_and_destroy(suite) ->
    [];
image_create_and_destroy(doc) ->
    ["Image creation and destroy test."];
image_create_and_destroy(Config) when is_list(Config) ->
    {W,H} = get_size(test_server:lookup_config(max_size, Config)),
    Image = egd:create(W, H),
    ok = egd:destroy(Image),
    ok.

image_colors(suite) ->
    [];
image_colors(doc) ->
    ["Image color test."];
image_colors(Config) when is_list(Config) ->
    {W,H} = get_size(test_server:lookup_config(max_size, Config)),
    Image = egd:create(W, H),
    put(image_size, {W,H}),
    RGB = get_rgb(),
    Black = egd:color({0,0,0}),
    Red = egd:color({255,0,0}),
    Green = egd:color({0,255,0}),
    Blue = egd:color({0,0,255}),
    Random = egd:color(Image, RGB),
    ok = egd:line(Image, get_point(), get_point(), Random),
    ok = egd:line(Image, get_point(), get_point(), Red),
    ok = egd:line(Image, get_point(), get_point(), Green),
    ok = egd:line(Image, get_point(), get_point(), Black),
    ok = egd:line(Image, get_point(), get_point(), Blue),
    HtmlDefaultNames =
        [black,
         silver,
         gray,
         white,
         maroon,
         red,
         purple,
         fuchia,
         green,
         lime,
         olive,
         yellow,
         navy,
         blue,
         teal,
         aqua],
    lists:foreach(fun(ColorName) ->
                         Color = egd:color(ColorName),
                         ok =
                             egd:line(Image,
                                      get_point(),
                                      get_point(),
                                      Color)
                  end,
                  HtmlDefaultNames),
    <<_/binary>> = egd:render(Image),
    ok = egd:destroy(Image),
    erase(image_size),
    ok.

image_shape(suite) ->
    [];
image_shape(doc) ->
    ["Image shape api test."];
image_shape(Config) when is_list(Config) ->
    {W,H} = get_size(test_server:lookup_config(max_size, Config)),
    put(image_size, {W,H}),
    Im = egd:create(W, H),
    Fgc = egd:color({255,0,0}),
    ok = egd:line(Im, get_point(), get_point(), Fgc),
    ok = egd:rectangle(Im, get_point(), get_point(), Fgc),
    ok = egd:filledEllipse(Im, get_point(), get_point(), Fgc),
    ok = egd:arc(Im, get_point(), get_point(), Fgc),
    ok = egd:arc(Im, get_point(), get_point(), 100, Fgc),
    Pt1 = get_point(),
    Pt2 = get_point(),
    ok = egd:filledRectangle(Im, Pt1, Pt2, Fgc),
    Bitmap = egd:render(Im, raw_bitmap),
    ok = bitmap_point_has_color(Bitmap, {W,H}, Pt2, Fgc),
    ok = bitmap_point_has_color(Bitmap, {W,H}, Pt1, Fgc),
    <<_/binary>> = egd:render(Im, raw_bitmap, [{render_engine,alpha}]),
    ok = egd:destroy(Im),
    erase(image_size),
    ok.

image_primitives(suite) ->
    [];
image_primitives(doc) ->
    ["Image shape api test."];
image_primitives(Config) when is_list(Config) ->
    {W,H} = get_size(test_server:lookup_config(max_size, Config)),
    put(image_size, {W,H}),
    Im0 = egd_primitives:create(W, H),
    Fgc = egd:color({25,25,255}),
    Bgc = egd:color({0,250,25}),
    Im1 =
        lists:foldl(fun({Function,Arguments}, Im) ->
                           apply(egd_primitives,
                                 Function,
                                 [Im|Arguments])
                    end,
                    Im0,
                    [ 
                     {Fs,[get_point(),get_point(),Bgc]} ||
                         Fs <- [line,rectangle,filledEllipse,arc]
                    ]
                    ++
                    [{pixel,[get_point(),Bgc]},
                     {filledTriangle,
                      [get_point(),get_point(),get_point(),Bgc]}]),
    Pt1 = get_point(),
    Pt2 = get_point(),
    Im2 = egd_primitives:filledRectangle(Im1, Pt1, Pt2, Fgc),
    Bitmap = egd_render:binary(Im2, opaque),
    ok = bitmap_point_has_color(Bitmap, {W,H}, Pt2, Fgc),
    ok = bitmap_point_has_color(Bitmap, {W,H}, Pt1, Fgc),
    <<_/binary>> = egd_render:binary(Im2, alpha),
    erase(image_size),
    ok.

image_font(suite) ->
    [];
image_font(doc) ->
    ["Image font test."];
image_font(Config) when is_list(Config) ->
    {W,H} = get_size(test_server:lookup_config(max_size, Config)),
    put(image_size, {W,H}),
    Im = egd:create(W, H),
    Fgc = egd:color({0,130,0}),
    Filename =
        filename:join([code:priv_dir(percept),
                       "fonts",
                       "6x11_latin1.wingsfont"]),
    Font = egd_font:load(Filename),
    ok = egd:text(Im, get_point(), Font, "Hello World", Fgc),
    <<_/binary>> = egd:render(Im, png),
    GlyphStr1 = " !\"#$%&'()*+,-./",
    NumericStr = "0123456789",
    GlyphStr2 = ":;<=>?@",
    AlphaBigStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    GlyphStr3 = "[\\]^_`",
    AlphaSmStr = "abcdefghijklmnopqrstuvwxyz",
    GlyphStr4 = "{|}~",
    ok = egd:text(Im, get_point(), Font, GlyphStr1, Fgc),
    <<_/binary>> = egd:render(Im, png),
    ok = egd:text(Im, get_point(), Font, NumericStr, Fgc),
    <<_/binary>> = egd:render(Im, png),
    ok = egd:text(Im, get_point(), Font, GlyphStr2, Fgc),
    <<_/binary>> = egd:render(Im, png),
    ok = egd:text(Im, get_point(), Font, AlphaBigStr, Fgc),
    <<_/binary>> = egd:render(Im, png),
    ok = egd:text(Im, get_point(), Font, GlyphStr3, Fgc),
    <<_/binary>> = egd:render(Im, png),
    ok = egd:text(Im, get_point(), Font, AlphaSmStr, Fgc),
    <<_/binary>> = egd:render(Im, png),
    ok = egd:text(Im, get_point(), Font, GlyphStr4, Fgc),
    <<_/binary>> = egd:render(Im, png),
    ok = egd:destroy(Im),
    erase(image_size),
    ok.

image_png_compliant(suite) ->
    [];
image_png_compliant(doc) ->
    ["Image png compliant test."];
image_png_compliant(Config) when is_list(Config) ->
    {W,H} = get_size(test_server:lookup_config(max_size, Config)),
    put(image_size, {W,H}),
    Im = egd:create(W, H),
    Fgc = egd:color({0,0,0}),
    ok = egd:filledRectangle(Im, get_point(), get_point(), Fgc),
    Bin = egd:render(Im, png),
    true = binary_is_png_compliant(Bin),
    ok = egd:destroy(Im),
    erase(image_size),
    ok.

bitmap_point_has_color(Bitmap, {W,_}, {X,Y}, C) ->
    {CR,CG,CB,_} = egd_primitives:rgb_float2byte(C),
    N = W * Y * 3 + X * 3,
    <<_:N/binary,R,G,B,_/binary>> = Bitmap,
    case {R,G,B} of
        {CR,CG,CB} ->
            ok;
        Other ->
            io:format("bitmap_point_has_color: error color was ~p, shou"
                      "ld be ~p~n",
                      [Other,{CR,CG,CB}]),
            {error,{Other,{CR,CG,CB}}}
    end.

binary_is_jfif_compliant(JpegBin) ->
    {Bin,_} = split_binary(JpegBin, 11),
    List = binary_to_list(Bin),
    case lists:sublist(List, 7, 4) of
        "JFIF" ->
            true;
        Other ->
            io:format("img -> ~p~n", [Other]),
            false
    end.

binary_is_gif_compliant(GifBin) ->
    {Bin,_} = split_binary(GifBin, 10),
    List = binary_to_list(Bin),
    case lists:sublist(List, 1, 5) of
        "GIF87" ->
            true;
        Other ->
            io:format("img -> ~p~n", [Other]),
            false
    end.

binary_is_png_compliant(PngBin) ->
    {Bin,_} = split_binary(PngBin, 10),
    List = binary_to_list(Bin),
    case lists:sublist(List, 2, 3) of
        "PNG" ->
            true;
        Other ->
            io:format("img -> ~p~n", [Other]),
            false
    end.

get_rgb() ->
    R = random(255),
    G = random(255),
    B = random(255),
    {R,G,B}.

get_angle() ->
    random(359).

get_point() ->
    get_point(get(image_size)).

get_point({W,H}) ->
    X = random(W - 1),
    Y = random(H - 1),
    {X,Y}.

get_size(Max) ->
    W = trunc(random(Max / 2) + Max / 2 + 1),
    H = trunc(random(Max / 2) + Max / 2 + 1),
    io:format("Image size will be ~p x ~p~n", [W,H]),
    {W,H}.

get_points(N) ->
    get_points(N, []).

get_points(0, Out) ->
    Out;
get_points(N, Out) ->
    get_points(N - 1, [get_point()|Out]).

random(N) ->
    trunc(random:uniform(trunc(N + 1)) - 1).



