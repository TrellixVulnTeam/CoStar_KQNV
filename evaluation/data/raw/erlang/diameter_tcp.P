-file("test/lib/diameter/src/transport/diameter_tcp.erl", 1).

-module(diameter_tcp).

-behaviour(gen_server).

-export([start/3]).

-export([start_link/1]).

-export([init/1]).

-export([handle_call/3,
         handle_cast/2,
         handle_info/2,
         code_change/3,
         terminate/2]).

-export([info/1]).

-export([ports/0,ports/1]).

-export_type([{connect_option,0},{listen_option,0}]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/diameter-1.3/include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options = [{answer_errors,report}]}).

-file("test/lib/diameter/src/transport/diameter_tcp.erl", 49).

-record(listener,{socket :: undefined | inet:socket(),
                  count = 1 :: non_neg_integer(),
                  tref :: undefined | reference()}).

-record(monitor,{parent :: undefined | pid(),
                 transport = self() :: pid()}).

-type length() :: 0..16777215.

-type size() :: non_neg_integer().

-type frag() :: {length(), size(), binary(), [binary()]} | binary().

-type connect_option() :: {raddr, inet:ip_address()}
                        | {rport, pos_integer()}
                        | {ssl_options, true | [ssl:connect_option()]}
                        | option()
                        | ssl:connect_option()
                        | gen_tcp:connect_option().

-type match() :: inet:ip_address() | string() | [match()].

-type listen_option() :: {accept, match()}
                       | {ssl_options, true | [ssl:listen_option()]}
                       | ssl:listen_option()
                       | gen_tcp:listen_option().

-type option() :: {port, non_neg_integer()}
                | {fragment_timer, 0..4294967295}.

-record(transport,{socket :: undefined | inet:socket() | ssl:sslsocket(),
                   parent :: undefined | pid(),
                   module :: undefined | module(),
                   frag = <<>> :: frag(),
                   ssl :: undefined | boolean() | [term()],
                   timeout :: undefined | infinity | 0..4294967295,
                   tref = false :: false | reference(),
                   flush = false :: boolean()}).

-spec start({accept, Ref}, #diameter_service{}, [listen_option()]) ->
               {ok, pid(), [inet:ip_address()]}
               when is_subtype(Ref, diameter:transport_ref());
           ({connect, Ref}, #diameter_service{}, [connect_option()]) ->
               {ok, pid(), [inet:ip_address()]} | {ok, pid()}
               when is_subtype(Ref, diameter:transport_ref()).

start({T,Ref}, #diameter_service{capabilities = Caps}, Opts) ->
    diameter_tcp_sup:start(),
    {Mod,Rest} = split(Opts),
    Addrs = Caps#diameter_caps.host_ip_address,
    Arg = {T,Ref,Mod,self(),Rest,Addrs},
    diameter_tcp_sup:start_child(Arg).

split([{module,M}|Opts]) ->
    {M,Opts};
split(Opts) ->
    {gen_tcp,Opts}.

start_link(T) ->
    proc_lib:start_link(diameter_tcp,
                        init,
                        [T],
                        infinity,
                        diameter_lib:spawn_opts(server, [])).

info({Mod,Sock}) ->
    lists:flatmap(fun(K) ->
                         info(Mod, K, Sock)
                  end,
                  [{socket,fun sockname/2},
                   {peer,fun peername/2},
                   {statistics,fun getstat/2}|
                   ssl_info(Mod, Sock)]).

info(Mod, {K,F}, Sock) ->
    case F(Mod, Sock) of
        {ok,V} ->
            [{K,V}];
        _ ->
            []
    end.

ssl_info(ssl = M, Sock) ->
    [{M,ssl_info(Sock)}];
ssl_info(_, _) ->
    [].

ssl_info(Sock) ->
    [ 
     {peercert,C} ||
         {ok,C} <- [ssl:peercert(Sock)]
    ].

init(T) ->
    gen_server:enter_loop(diameter_tcp, [], i(T)).

i({T,Ref,Mod,Pid,Opts,Addrs}) when T == accept; T == connect ->
    monitor(process, Pid),
    {ok,MPid} = diameter_tcp_sup:start_child(#monitor{parent = Pid}),
    {SslOpts,Rest0} = ssl(Opts),
    {OwnOpts,Rest} = own(Rest0),
    Tmo = proplists:get_value(fragment_timer, OwnOpts, 1000),
    (infinity == Tmo
     orelse
     is_integer(Tmo)
     andalso
     0 =< Tmo
     andalso
     0 == Tmo bsr 32)
    orelse
    error({{fragment_timer,Tmo},diameter_tcp,204}),
    Sock = init(T, Ref, Mod, Pid, SslOpts, Rest, Addrs),
    MPid ! {stop,self()},
    M = if
            SslOpts ->
                ssl;
            true ->
                Mod
        end,
    setopts(M, Sock),
    putr(ref, Ref),
    #transport{parent = Pid,
               module = M,
               socket = Sock,
               ssl = SslOpts,
               timeout = Tmo};
i(#monitor{parent = Pid,transport = TPid} = S) ->
    proc_lib:init_ack({ok,self()}),
    monitor(process, Pid),
    monitor(process, TPid),
    S;
i({listen,LRef,APid,{Mod,Opts,Addrs}}) ->
    {[LA,LP],Rest} = proplists:split(Opts, [ip,port]),
    LAddrOpt = get_addr(LA, Addrs),
    LPort = get_port(LP),
    {ok,LSock} = Mod:listen(LPort, gen_opts(LAddrOpt, Rest)),
    LAddr = laddr(LAddrOpt, Mod, LSock),
    true =
        diameter_reg:add_new({diameter_tcp,
                              listener,
                              {LRef,{LAddr,LSock}}}),
    proc_lib:init_ack({ok,self(),{LAddr,LSock}}),
    monitor(process, APid),
    start_timer(#listener{socket = LSock}).

laddr([], Mod, Sock) ->
    {ok,{Addr,_Port}} = sockname(Mod, Sock),
    Addr;
laddr([{ip,Addr}], _, _) ->
    Addr.

own(Opts) ->
    {[Own],Rest} = proplists:split(Opts, [fragment_timer]),
    {Own,Rest}.

ssl(Opts) ->
    {[SslOpts],Rest} = proplists:split(Opts, [ssl_options]),
    {ssl_opts(SslOpts),Rest}.

ssl_opts([]) ->
    false;
ssl_opts([{ssl_options,true}]) ->
    true;
ssl_opts([{ssl_options,Opts}]) when is_list(Opts) ->
    Opts;
ssl_opts(L) ->
    error({{ssl_options,L},diameter_tcp,263}).

init(Type, Ref, Mod, Pid, true, Opts, Addrs) ->
    init(Type,
         Ref,
         ssl,
         Pid,
         [{cb_info,{Mod,tcp,tcp_closed,tcp_error}}|Opts],
         Addrs);
init(Type, Ref, Mod, Pid, _, Opts, Addrs) ->
    init(Type, Ref, Mod, Pid, Opts, Addrs).

init(accept = T, Ref, Mod, Pid, Opts, Addrs) ->
    {[Matches],Rest} = proplists:split(Opts, [accept]),
    {LAddr,LSock} = listener(Ref, {Mod,Rest,Addrs}),
    proc_lib:init_ack({ok,self(),[LAddr]}),
    Sock = ok(accept(Mod, LSock)),
    ok = accept_peer(Mod, Sock, accept(Matches)),
    publish(Mod, T, Ref, Sock),
    diameter_peer:up(Pid),
    Sock;
init(connect = T, Ref, Mod, Pid, Opts, Addrs) ->
    {[LA,RA,RP],Rest} = proplists:split(Opts, [ip,raddr,rport]),
    LAddrOpt = get_addr(LA, Addrs),
    RAddr = get_addr(RA),
    RPort = get_port(RP),
    proc_lib:init_ack(init_rc(LAddrOpt)),
    Sock = ok(connect(Mod, RAddr, RPort, gen_opts(LAddrOpt, Rest))),
    publish(Mod, T, Ref, Sock),
    up(Pid, {RAddr,RPort}, LAddrOpt, Mod, Sock),
    Sock.

init_rc([{ip,Addr}]) ->
    {ok,self(),[Addr]};
init_rc([]) ->
    {ok,self()}.

up(Pid, Remote, [{ip,_Addr}], _, _) ->
    diameter_peer:up(Pid, Remote);
up(Pid, Remote, [], Mod, Sock) ->
    {Addr,_Port} = ok(sockname(Mod, Sock)),
    diameter_peer:up(Pid, Remote, [Addr]).

publish(Mod, T, Ref, Sock) ->
    true = diameter_reg:add_new({diameter_tcp,T,{Ref,Sock}}),
    putr(info, {Mod,Sock}).

ok({ok,T}) ->
    T;
ok(No) ->
    x(No).

x(Reason) ->
    exit({shutdown,Reason}).

accept_peer(_Mod, _Sock, []) ->
    ok;
accept_peer(Mod, Sock, Matches) ->
    {RAddr,_} = ok(peername(Mod, Sock)),
    diameter_peer:match([RAddr], Matches)
    orelse
    x({accept,RAddr,Matches}),
    ok.

accept(Opts) ->
    [ 
     [M] ||
         {accept,M} <- Opts
    ].

listener(LRef, T) ->
    l(diameter_reg:match({diameter_tcp,listener,{LRef,'_'}}), LRef, T).

l([{{diameter_tcp,listener,{_,AS}},LPid}], _, _) ->
    LPid ! {accept,self()},
    AS;
l([], LRef, T) ->
    {ok,_,AS} = diameter_tcp_sup:start_child({listen,LRef,self(),T}),
    AS.

get_addr(As) ->
    diameter_lib:ipaddr(addr(As, [])).

get_addr([], []) ->
    [];
get_addr(As, Def) ->
    [{ip,diameter_lib:ipaddr(addr(As, Def))}].

addr([], [Addr|_]) ->
    Addr;
addr([{_,Addr}], _) ->
    Addr;
addr(As, Addrs) ->
    error({{invalid_addrs,As,Addrs},diameter_tcp,370}).

get_port([{_,Port}]) ->
    Port;
get_port([]) ->
    3868;
get_port(Ps) ->
    error({{invalid_ports,Ps},diameter_tcp,379}).

gen_opts(LAddrOpt, Opts) ->
    {L,_} = proplists:split(Opts, [binary,packet,active]),
    [[],[],[]] == L
    orelse
    error({{reserved_options,Opts},diameter_tcp,385}),
    [binary,{packet,0},{active,once}] ++ LAddrOpt ++ Opts.

ports() ->
    Ts = diameter_reg:match({diameter_tcp,'_','_'}),
    [ 
     {type(T),resolve(T, S),Pid} ||
         {{diameter_tcp,T,{_,S}},Pid} <- Ts
    ].

ports(Ref) ->
    Ts = diameter_reg:match({diameter_tcp,'_',{Ref,'_'}}),
    [ 
     {type(T),resolve(T, S),Pid} ||
         {{diameter_tcp,T,{R,S}},Pid} <- Ts,
         R == Ref
    ].

type(listener) ->
    listen;
type(T) ->
    T.

sock(listener, {_LAddr,Sock}) ->
    Sock;
sock(_, Sock) ->
    Sock.

resolve(Type, S) ->
    Sock = sock(Type, S),
    try
        ok(portnr(Sock))
    catch
        _:_ ->
            Sock
    end.

portnr(Sock) when is_port(Sock) ->
    portnr(gen_tcp, Sock);
portnr(Sock) ->
    portnr(ssl, Sock).

handle_call(_, _, State) ->
    {reply,nok,State}.

handle_cast(_, State) ->
    {noreply,State}.

handle_info(T, #transport{} = S) ->
    {noreply,#transport{} = t(T, S)};
handle_info(T, #listener{} = S) ->
    {noreply,#listener{} = l(T, S)};
handle_info(T, #monitor{} = S) ->
    m(T, S),
    x(T).

code_change(_, State, _) ->
    {ok,State}.

terminate(_, _) ->
    ok.

putr(Key, Val) ->
    put({diameter_tcp,Key}, Val).

getr(Key) ->
    get({diameter_tcp,Key}).

start_timer(#listener{count = 0} = S) ->
    S#listener{tref = erlang:start_timer(30000, self(), close)};
start_timer(S) ->
    S.

m({stop,TPid}, #monitor{transport = TPid}) ->
    ok;
m({'DOWN',_,process,TPid,_}, #monitor{transport = TPid}) ->
    ok;
m({'DOWN',_,process,Pid,_}, #monitor{parent = Pid,transport = TPid}) ->
    exit(TPid, {shutdown,parent}).

l({accept,TPid}, #listener{count = N} = S) ->
    monitor(process, TPid),
    S#listener{count = N + 1};
l({'DOWN',_,process,_,_}, #listener{count = N} = S) ->
    start_timer(S#listener{count = N - 1});
l({timeout,TRef,close = T}, #listener{tref = TRef,count = 0}) ->
    x(T);
l({timeout,_,close}, #listener{} = S) ->
    S.

t(T, S) ->
    case transition(T, S) of
        ok ->
            S;
        #transport{} = NS ->
            NS;
        {stop,Reason} ->
            x(Reason);
        stop ->
            x(T)
    end.

transition({tcp,Sock,Bin},
           #transport{socket = Sock,
                      parent = Pid,
                      frag = Head,
                      module = M,
                      ssl = Opts} =
               S)
    when is_list(Opts) ->
    case rcv(Head, Bin) of
        {Msg,B} when is_binary(Msg) ->
            diameter_peer:recv(Pid, Msg),
            S#transport{frag = B};
        Frag ->
            setopts(M, Sock),
            start_fragment_timer(S#transport{frag = Frag})
    end;
transition({P,Sock,Bin},
           #transport{socket = Sock,module = M,ssl = B} = S)
    when P == tcp, not B; P == ssl, B ->
    setopts(M, Sock),
    start_fragment_timer(recv(Bin, S));
transition({diameter,{tls,Ref,Type,B}}, #transport{parent = Pid} = S) ->
    #transport{socket = Sock,module = M} =
        NS = tls_handshake(Type, B, S),
    Pid ! {diameter,{tls,Ref}},
    setopts(M, Sock),
    start_fragment_timer(NS#transport{ssl = B});
transition({C,Sock}, #transport{socket = Sock,ssl = B})
    when C == tcp_closed, not B; C == ssl_closed, B ->
    stop;
transition({E,Sock,_Reason} = T, #transport{socket = Sock,ssl = B} = S)
    when E == tcp_error, not B; E == ssl_error, B ->
    error({{T,S},diameter_tcp,588});
transition({diameter,{send,Bin}}, #transport{socket = Sock,module = M}) ->
    case send(M, Sock, Bin) of
        ok ->
            ok;
        {error,Reason} ->
            {stop,{send,Reason}}
    end;
transition({diameter,{close,Pid}},
           #transport{parent = Pid,socket = Sock,module = M}) ->
    M:close(Sock),
    stop;
transition({timeout,TRef,flush}, #transport{tref = TRef} = S) ->
    flush(S#transport{tref = false});
transition({resolve_port,Pid}, #transport{socket = Sock,module = M})
    when is_pid(Pid) ->
    Pid ! portnr(M, Sock),
    ok;
transition({'DOWN',_,process,Pid,_}, #transport{parent = Pid}) ->
    stop.

tls_handshake(_, _, #transport{ssl = true} = S) ->
    S;
tls_handshake(_, true, #transport{ssl = false}) ->
    error({no_ssl_options,diameter_tcp,638});
tls_handshake(Type,
              true,
              #transport{socket = Sock,module = M,ssl = Opts} = S) ->
    {ok,SSock} =
        tls(Type, Sock, [{cb_info,{M,tcp,tcp_closed,tcp_error}}|Opts]),
    Ref = getr(ref),
    true = diameter_reg:add_new({diameter_tcp,Type,{Ref,SSock}}),
    S#transport{socket = SSock,module = ssl};
tls_handshake(_, false, S) ->
    S.

tls(connect, Sock, Opts) ->
    ssl:connect(Sock, Opts);
tls(accept, Sock, Opts) ->
    ssl:ssl_accept(Sock, Opts).

recv(Bin, #transport{parent = Pid,frag = Head} = S) ->
    case rcv(Head, Bin) of
        {Msg,B} when is_binary(Msg) ->
            diameter_peer:recv(Pid, Msg),
            recv(B, S#transport{frag = <<>>});
        Frag ->
            S#transport{frag = Frag,flush = false}
    end.

rcv(<<>>, Bin) ->
    rcv(Bin);
rcv(Head, Bin) when is_binary(Head) ->
    rcv(<<Head/binary,Bin/binary>>);
rcv({Len,N,Head,Acc}, Bin) ->
    rcv(Len, N + size(Bin), Head, [Bin|Acc]).

rcv(Len, N, Head, Acc) when Len =< N ->
    recv1(Len, bin(Head, Acc));
rcv(Len, N, Head, Acc) ->
    {Len,N,Head,Acc}.

rcv(<<>> = Bin) ->
    Bin;
rcv(<<_:1/binary,Len:24,_/binary>> = Bin) when Len < 20 ->
    {Bin,<<>>};
rcv(<<_:1/binary,Len:24,_/binary>> = Bin) when Len =< size(Bin) ->
    recv1(Len, Bin);
rcv(<<_:1/binary,Len:24,_/binary>> = Head) ->
    {Len,size(Head),Head,[]};
rcv(Head) ->
    Head.

recv1(Len, Bin) ->
    <<Msg:Len/binary,Rest/binary>> = Bin,
    {Msg,Rest}.

bin(Head, Acc) ->
    list_to_binary([Head|lists:reverse(Acc)]).

bin({_,_,Head,Acc}) ->
    bin(Head, Acc);
bin(Bin) when is_binary(Bin) ->
    Bin.

flush(#transport{frag = <<>>} = S) ->
    S;
flush(#transport{flush = false} = S) ->
    start_fragment_timer(S#transport{flush = true});
flush(#transport{frag = Frag,parent = Pid} = S) ->
    diameter_peer:recv(Pid, bin(Frag)),
    S#transport{frag = <<>>}.

start_fragment_timer(#transport{frag = B,tref = TRef} = S)
    when B == <<>>; TRef /= false ->
    S;
start_fragment_timer(#transport{timeout = Tmo} = S) ->
    S#transport{tref = erlang:start_timer(Tmo, self(), flush)}.

accept(ssl, LSock) ->
    case ssl:transport_accept(LSock) of
        {ok,Sock} ->
            {ssl:ssl_accept(Sock),Sock};
        {error,_} = No ->
            No
    end;
accept(Mod, LSock) ->
    Mod:accept(LSock).

connect(Mod, Host, Port, Opts) ->
    Mod:connect(Host, Port, Opts).

send(gen_tcp, Sock, Bin) ->
    gen_tcp:send(Sock, Bin);
send(ssl, Sock, Bin) ->
    ssl:send(Sock, Bin);
send(M, Sock, Bin) ->
    M:send(Sock, Bin).

setopts(gen_tcp, Sock, Opts) ->
    inet:setopts(Sock, Opts);
setopts(ssl, Sock, Opts) ->
    ssl:setopts(Sock, Opts);
setopts(M, Sock, Opts) ->
    M:setopts(Sock, Opts).

setopts(M, Sock) ->
    case setopts(M, Sock, [{active,once}]) of
        ok ->
            ok;
        X ->
            x({setopts,M,Sock,X})
    end.

portnr(gen_tcp, Sock) ->
    inet:port(Sock);
portnr(M, Sock) ->
    case M:sockname(Sock) of
        {ok,{_Addr,PortNr}} ->
            {ok,PortNr};
        {error,_} = No ->
            No
    end.

sockname(gen_tcp, Sock) ->
    inet:sockname(Sock);
sockname(M, Sock) ->
    M:sockname(Sock).

peername(gen_tcp, Sock) ->
    inet:peername(Sock);
peername(M, Sock) ->
    M:peername(Sock).

getstat(gen_tcp, Sock) ->
    inet:getstat(Sock);
getstat(M, Sock) ->
    M:getstat(Sock).



