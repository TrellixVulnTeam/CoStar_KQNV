-file("test/lib/kernel/src/global_group.erl", 1).

-module(global_group).

-behaviour(gen_server).

-export([start/0,start_link/0,stop/0,init/1]).

-export([handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]).

-export([global_groups/0]).

-export([monitor_nodes/1]).

-export([own_nodes/0]).

-export([registered_names/1]).

-export([send/2]).

-export([send/3]).

-export([whereis_name/1]).

-export([whereis_name/2]).

-export([global_groups_changed/1]).

-export([global_groups_added/1]).

-export([global_groups_removed/1]).

-export([sync/0]).

-export([ng_add_check/2,ng_add_check/3]).

-export([info/0]).

-export([registered_names_test/1]).

-export([send_test/2]).

-export([whereis_name_test/1]).

-export([get_own_nodes/0,get_own_nodes_with_errors/0]).

-export([publish_on_nodes/0]).

-export([config_scan/1,config_scan/2]).

-export([sync_init/4]).

-type publish_type() :: hidden | normal.

-type sync_state() :: no_conf | synced.

-type group_name() :: atom().

-type group_tuple() :: {GroupName :: group_name(), [node()]}
                     | {GroupName :: group_name(),
                        PublishType :: publish_type(),
                        [node()]}.

-record(state,{sync_state = no_conf :: sync_state(),
               connect_all :: undefined | boolean(),
               group_name = [] :: group_name() | [],
               nodes = [] :: [node()],
               no_contact = [] :: [node()],
               sync_error = [],
               other_grps = [],
               node_name = node() :: node(),
               monitor = [],
               publish_type = normal :: publish_type(),
               group_publish_type = normal :: publish_type()}).

-spec global_groups() -> {GroupName, GroupNames} | undefined
                       when
                           is_subtype(GroupName, group_name()),
                           is_subtype(GroupNames, [GroupName]).

global_groups() ->
    request(global_groups).

-spec monitor_nodes(Flag) -> ok when is_subtype(Flag, boolean()).

monitor_nodes(Flag) ->
    case Flag of
        true ->
            request({monitor_nodes,Flag});
        false ->
            request({monitor_nodes,Flag});
        _ ->
            {error,not_boolean}
    end.

-spec own_nodes() -> Nodes when is_subtype(Nodes, [Node :: node()]).

own_nodes() ->
    request(own_nodes).

-type name() :: atom().

-type where() :: {node, node()} | {group, group_name()}.

-spec registered_names(Where) -> Names
                          when
                              is_subtype(Where, where()),
                              is_subtype(Names, [Name :: name()]).

registered_names(Arg) ->
    request({registered_names,Arg}).

-spec send(Name, Msg) -> pid() | {badarg, {Name, Msg}}
              when is_subtype(Name, name()), is_subtype(Msg, term()).

send(Name, Msg) ->
    request({send,Name,Msg}).

-spec send(Where, Name, Msg) -> pid() | {badarg, {Name, Msg}}
              when
                  is_subtype(Where, where()),
                  is_subtype(Name, name()),
                  is_subtype(Msg, term()).

send(Group, Name, Msg) ->
    request({send,Group,Name,Msg}).

-spec whereis_name(Name) -> pid() | undefined
                      when is_subtype(Name, name()).

whereis_name(Name) ->
    request({whereis_name,Name}).

-spec whereis_name(Where, Name) -> pid() | undefined
                      when
                          is_subtype(Where, where()),
                          is_subtype(Name, name()).

whereis_name(Group, Name) ->
    request({whereis_name,Group,Name}).

global_groups_changed(NewPara) ->
    request({global_groups_changed,NewPara}).

global_groups_added(NewPara) ->
    request({global_groups_added,NewPara}).

global_groups_removed(NewPara) ->
    request({global_groups_removed,NewPara}).

-spec sync() -> ok.

sync() ->
    request(sync).

ng_add_check(Node, OthersNG) ->
    ng_add_check(Node, normal, OthersNG).

ng_add_check(Node, PubType, OthersNG) ->
    request({ng_add_check,Node,PubType,OthersNG}).

-type info_item() :: {state, State :: sync_state()}
                   | {own_group_name, GroupName :: group_name()}
                   | {own_group_nodes, Nodes :: [node()]}
                   | {synched_nodes, Nodes :: [node()]}
                   | {sync_error, Nodes :: [node()]}
                   | {no_contact, Nodes :: [node()]}
                   | {other_groups, Groups :: [group_tuple()]}
                   | {monitoring, Pids :: [pid()]}.

-spec info() -> [info_item()].

info() ->
    request(info, 3000).

registered_names_test(Arg) ->
    request({registered_names_test,Arg}).

send_test(Name, Msg) ->
    request({send_test,Name,Msg}).

whereis_name_test(Name) ->
    request({whereis_name_test,Name}).

request(Req) ->
    request(Req, infinity).

request(Req, Time) ->
    case whereis(global_group) of
        P when is_pid(P) ->
            gen_server:call(global_group, Req, Time);
        _Other ->
            {error,global_group_not_runnig}
    end.

start() ->
    gen_server:start({local,global_group}, global_group, [], []).

start_link() ->
    gen_server:start_link({local,global_group}, global_group, [], []).

stop() ->
    gen_server:call(global_group, stop, infinity).

init([]) ->
    process_flag(priority, max),
    ok = net_kernel:monitor_nodes(true),
    put(registered_names, [undefined]),
    put(send, [undefined]),
    put(whereis_name, [undefined]),
    process_flag(trap_exit, true),
    Ca =
        case init:get_argument(connect_all) of
            {ok,[["false"]]} ->
                false;
            _ ->
                true
        end,
    PT = publish_arg(),
    case application:get_env(kernel, global_groups) of
        undefined ->
            update_publish_nodes(PT),
            {ok,#state{publish_type = PT,connect_all = Ca}};
        {ok,[]} ->
            update_publish_nodes(PT),
            {ok,#state{publish_type = PT,connect_all = Ca}};
        {ok,NodeGrps} ->
            {DefGroupName,PubTpGrp,DefNodes,DefOther} =
                case catch config_scan(NodeGrps, publish_type) of
                    {error,_Error2} ->
                        update_publish_nodes(PT),
                        exit({error,
                              {'invalid global_groups definition',
                               NodeGrps}});
                    {DefGroupNameT,PubType,DefNodesT,DefOtherT} ->
                        update_publish_nodes(PT, {PubType,DefNodesT}),
                        disconnect_nodes(nodes(connected) -- DefNodesT),
                        lists:foreach(fun(Node) ->
                                             monitor_node(Node, true)
                                      end,
                                      DefNodesT),
                        {DefGroupNameT,
                         PubType,
                         lists:delete(node(), DefNodesT),
                         DefOtherT}
                end,
            {ok,
             #state{publish_type = PT,
                    group_publish_type = PubTpGrp,
                    sync_state = synced,
                    group_name = DefGroupName,
                    no_contact = lists:sort(DefNodes),
                    other_grps = DefOther}}
    end.

handle_call(sync, _From, S) ->
    case application:get_env(kernel, global_groups) of
        undefined ->
            update_publish_nodes(S#state.publish_type),
            {reply,ok,S};
        {ok,[]} ->
            update_publish_nodes(S#state.publish_type),
            {reply,ok,S};
        {ok,NodeGrps} ->
            {DefGroupName,PubTpGrp,DefNodes,DefOther} =
                case catch config_scan(NodeGrps, publish_type) of
                    {error,_Error2} ->
                        exit({error,
                              {'invalid global_groups definition',
                               NodeGrps}});
                    {DefGroupNameT,PubType,DefNodesT,DefOtherT} ->
                        update_publish_nodes(S#state.publish_type,
                                             {PubType,DefNodesT}),
                        disconnect_nodes(nodes(connected) -- DefNodesT),
                        kill_global_group_check(),
                        Pid =
                            spawn_link(global_group,
                                       sync_init,
                                       [sync,
                                        DefGroupNameT,
                                        PubType,
                                        DefNodesT]),
                        register(global_group_check, Pid),
                        {DefGroupNameT,
                         PubType,
                         lists:delete(node(), DefNodesT),
                         DefOtherT}
                end,
            {reply,
             ok,
             S#state{sync_state = synced,
                     group_name = DefGroupName,
                     no_contact = lists:sort(DefNodes),
                     other_grps = DefOther,
                     group_publish_type = PubTpGrp}}
    end;
handle_call(global_groups, _From, S) ->
    Result =
        case S#state.sync_state of
            no_conf ->
                undefined;
            synced ->
                Other =
                    lists:foldl(fun({N,_L}, Acc) ->
                                       Acc ++ [N]
                                end,
                                [],
                                S#state.other_grps),
                {S#state.group_name,Other}
        end,
    {reply,Result,S};
handle_call({monitor_nodes,Flag}, {Pid,_}, StateIn) ->
    {Res,State} = monitor_nodes(Flag, Pid, StateIn),
    {reply,Res,State};
handle_call(own_nodes, _From, S) ->
    Nodes =
        case S#state.sync_state of
            no_conf ->
                [node()|nodes()];
            synced ->
                get_own_nodes()
        end,
    {reply,Nodes,S};
handle_call({registered_names,{group,Group}}, _From, S)
    when Group =:= S#state.group_name ->
    Res = global:registered_names(),
    {reply,Res,S};
handle_call({registered_names,{group,Group}}, From, S) ->
    case lists:keysearch(Group, 1, S#state.other_grps) of
        false ->
            {reply,[],S};
        {value,{Group,[]}} ->
            {reply,[],S};
        {value,{Group,Nodes}} ->
            Pid = global_search:start(names, {group,Nodes,From}),
            Wait = get(registered_names),
            put(registered_names, [{Pid,From}|Wait]),
            {noreply,S}
    end;
handle_call({registered_names,{node,Node}}, _From, S)
    when Node =:= node() ->
    Res = global:registered_names(),
    {reply,Res,S};
handle_call({registered_names,{node,Node}}, From, S) ->
    Pid = global_search:start(names, {node,Node,From}),
    Wait = get(registered_names),
    put(registered_names, [{Pid,From}|Wait]),
    {noreply,S};
handle_call({send,Name,Msg}, From, S) ->
    case global:whereis_name(Name) of
        undefined ->
            Pid =
                global_search:start(send,
                                    {any,
                                     S#state.other_grps,
                                     Name,
                                     Msg,
                                     From}),
            Wait = get(send),
            put(send, [{Pid,From,Name,Msg}|Wait]),
            {noreply,S};
        Found ->
            Found ! Msg,
            {reply,Found,S}
    end;
handle_call({send,{group,Grp},Name,Msg}, _From, S)
    when Grp =:= S#state.group_name ->
    case global:whereis_name(Name) of
        undefined ->
            {reply,{badarg,{Name,Msg}},S};
        Pid ->
            Pid ! Msg,
            {reply,Pid,S}
    end;
handle_call({send,{group,Group},Name,Msg}, From, S) ->
    case lists:keysearch(Group, 1, S#state.other_grps) of
        false ->
            {reply,{badarg,{Name,Msg}},S};
        {value,{Group,[]}} ->
            {reply,{badarg,{Name,Msg}},S};
        {value,{Group,Nodes}} ->
            Pid = global_search:start(send, {group,Nodes,Name,Msg,From}),
            Wait = get(send),
            put(send, [{Pid,From,Name,Msg}|Wait]),
            {noreply,S}
    end;
handle_call({send,{node,Node},Name,Msg}, From, S) ->
    Pid = global_search:start(send, {node,Node,Name,Msg,From}),
    Wait = get(send),
    put(send, [{Pid,From,Name,Msg}|Wait]),
    {noreply,S};
handle_call({whereis_name,Name}, From, S) ->
    case global:whereis_name(Name) of
        undefined ->
            Pid =
                global_search:start(whereis,
                                    {any,S#state.other_grps,Name,From}),
            Wait = get(whereis_name),
            put(whereis_name, [{Pid,From}|Wait]),
            {noreply,S};
        Found ->
            {reply,Found,S}
    end;
handle_call({whereis_name,{group,Group},Name}, _From, S)
    when Group =:= S#state.group_name ->
    Res = global:whereis_name(Name),
    {reply,Res,S};
handle_call({whereis_name,{group,Group},Name}, From, S) ->
    case lists:keysearch(Group, 1, S#state.other_grps) of
        false ->
            {reply,undefined,S};
        {value,{Group,[]}} ->
            {reply,undefined,S};
        {value,{Group,Nodes}} ->
            Pid = global_search:start(whereis, {group,Nodes,Name,From}),
            Wait = get(whereis_name),
            put(whereis_name, [{Pid,From}|Wait]),
            {noreply,S}
    end;
handle_call({whereis_name,{node,Node},Name}, From, S) ->
    Pid = global_search:start(whereis, {node,Node,Name,From}),
    Wait = get(whereis_name),
    put(whereis_name, [{Pid,From}|Wait]),
    {noreply,S};
handle_call({global_groups_changed,NewPara}, _From, S) ->
    {NewGroupName,PubTpGrp,NewNodes,NewOther} =
        case catch config_scan(NewPara, publish_type) of
            {error,_Error2} ->
                exit({error,
                      {'invalid global_groups definition',NewPara}});
            {DefGroupName,PubType,DefNodes,DefOther} ->
                update_publish_nodes(S#state.publish_type,
                                     {PubType,DefNodes}),
                {DefGroupName,PubType,DefNodes,DefOther}
        end,
    NN = NewNodes -- NewNodes -- S#state.nodes,
    NNC = (NewNodes -- S#state.nodes) -- S#state.sync_error,
    NSE = NewNodes -- NewNodes -- S#state.sync_error,
    force_nodedown(nodes(connected) -- NewNodes),
    NewS =
        S#state{group_name = NewGroupName,
                nodes = lists:sort(NN),
                no_contact = lists:sort(lists:delete(node(), NNC)),
                sync_error = lists:sort(NSE),
                other_grps = NewOther,
                group_publish_type = PubTpGrp},
    {reply,ok,NewS};
handle_call({global_groups_added,NewPara}, _From, S) ->
    {NewGroupName,PubTpGrp,NewNodes,NewOther} =
        case catch config_scan(NewPara, publish_type) of
            {error,_Error2} ->
                exit({error,
                      {'invalid global_groups definition',NewPara}});
            {DefGroupName,PubType,DefNodes,DefOther} ->
                update_publish_nodes(S#state.publish_type,
                                     {PubType,DefNodes}),
                {DefGroupName,PubType,DefNodes,DefOther}
        end,
    force_nodedown(nodes(connected) -- NewNodes),
    OwnNG = get_own_nodes(),
    NGACArgs =
        case S#state.group_publish_type of
            normal ->
                [node(),OwnNG];
            _ ->
                [node(),S#state.group_publish_type,OwnNG]
        end,
    {NN,NNC,NSE} =
        lists:foldl(fun(Node, {NN_acc,NNC_acc,NSE_acc}) ->
                           case
                               rpc:call(Node,
                                        global_group,
                                        ng_add_check,
                                        NGACArgs)
                           of
                               {badrpc,_} ->
                                   {NN_acc,[Node|NNC_acc],NSE_acc};
                               agreed ->
                                   {[Node|NN_acc],NNC_acc,NSE_acc};
                               not_agreed ->
                                   {NN_acc,NNC_acc,[Node|NSE_acc]}
                           end
                    end,
                    {[],[],[]},
                    lists:delete(node(), NewNodes)),
    NewS =
        S#state{sync_state = synced,
                group_name = NewGroupName,
                nodes = lists:sort(NN),
                sync_error = lists:sort(NSE),
                no_contact = lists:sort(NNC),
                other_grps = NewOther,
                group_publish_type = PubTpGrp},
    {reply,ok,NewS};
handle_call({global_groups_removed,_NewPara}, _From, S) ->
    update_publish_nodes(S#state.publish_type),
    NewS =
        S#state{sync_state = no_conf,
                group_name = [],
                nodes = [],
                sync_error = [],
                no_contact = [],
                other_grps = []},
    {reply,ok,NewS};
handle_call({ng_add_check,Node,PubType,OthersNG}, _From, S) ->
    OwnNG = get_own_nodes(),
    case S#state.group_publish_type =:= PubType of
        true ->
            case OwnNG of
                OthersNG ->
                    NN = [Node|S#state.nodes],
                    NSE = lists:delete(Node, S#state.sync_error),
                    NNC = lists:delete(Node, S#state.no_contact),
                    NewS =
                        S#state{nodes = lists:sort(NN),
                                sync_error = NSE,
                                no_contact = NNC},
                    {reply,agreed,NewS};
                _ ->
                    {reply,not_agreed,S}
            end;
        _ ->
            {reply,not_agreed,S}
    end;
handle_call(info, _From, S) ->
    Reply =
        [{state,S#state.sync_state},
         {own_group_name,S#state.group_name},
         {own_group_nodes,get_own_nodes()},
         {synced_nodes,S#state.nodes},
         {sync_error,S#state.sync_error},
         {no_contact,S#state.no_contact},
         {other_groups,S#state.other_grps},
         {monitoring,S#state.monitor}],
    {reply,Reply,S};
handle_call(get, _From, S) ->
    {reply,get(),S};
handle_call({registered_names_test,{node,test3844zty}}, From, S) ->
    Pid = global_search:start(names_test, {node,test3844zty}),
    Wait = get(registered_names),
    put(registered_names, [{Pid,From}|Wait]),
    {noreply,S};
handle_call({registered_names_test,{node,_Node}}, _From, S) ->
    {reply,{error,illegal_function_call},S};
handle_call({send_test,Name,test3844zty}, From, S) ->
    Pid = global_search:start(send_test, test3844zty),
    Wait = get(send),
    put(send, [{Pid,From,Name,test3844zty}|Wait]),
    {noreply,S};
handle_call({send_test,_Name,_Msg}, _From, S) ->
    {reply,{error,illegal_function_call},S};
handle_call({whereis_name_test,test3844zty}, From, S) ->
    Pid = global_search:start(whereis_test, test3844zty),
    Wait = get(whereis_name),
    put(whereis_name, [{Pid,From}|Wait]),
    {noreply,S};
handle_call({whereis_name_test,_Name}, _From, S) ->
    {reply,{error,illegal_function_call},S};
handle_call(Call, _From, S) ->
    {reply,{illegal_message,Call},S}.

handle_cast({registered_names,User}, S) ->
    Res = global:registered_names(),
    User ! {registered_names_res,Res},
    {noreply,S};
handle_cast({registered_names_res,Result,Pid,From}, S) ->
    unlink(Pid),
    exit(Pid, normal),
    Wait = get(registered_names),
    NewWait = lists:delete({Pid,From}, Wait),
    put(registered_names, NewWait),
    gen_server:reply(From, Result),
    {noreply,S};
handle_cast({send_res,Result,Name,Msg,Pid,From}, S) ->
    case Result of
        {badarg,{Name,Msg}} ->
            continue;
        ToPid ->
            ToPid ! Msg
    end,
    unlink(Pid),
    exit(Pid, normal),
    Wait = get(send),
    NewWait = lists:delete({Pid,From,Name,Msg}, Wait),
    put(send, NewWait),
    gen_server:reply(From, Result),
    {noreply,S};
handle_cast({find_name,User,Name}, S) ->
    Res = global:whereis_name(Name),
    User ! {find_name_res,Res},
    {noreply,S};
handle_cast({find_name_res,Result,Pid,From}, S) ->
    unlink(Pid),
    exit(Pid, normal),
    Wait = get(whereis_name),
    NewWait = lists:delete({Pid,From}, Wait),
    put(whereis_name, NewWait),
    gen_server:reply(From, Result),
    {noreply,S};
handle_cast({synced,NoContact}, S) ->
    kill_global_group_check(),
    Nodes = get_own_nodes() -- [node()|NoContact],
    {noreply,
     S#state{nodes = lists:sort(Nodes),
             sync_error = [],
             no_contact = NoContact}};
handle_cast({sync_error,NoContact,ErrorNodes}, S) ->
    Txt =
        io_lib:format("Global group: Could not synchronize with these n"
                      "odes ~p~nbecause global_groups were not in agree"
                      "ment. ~n",
                      [ErrorNodes]),
    error_logger:error_report(Txt),
    kill_global_group_check(),
    Nodes = (get_own_nodes() -- [node()|NoContact]) -- ErrorNodes,
    {noreply,
     S#state{nodes = lists:sort(Nodes),
             sync_error = ErrorNodes,
             no_contact = NoContact}};
handle_cast({conf_check,Vsn,Node,From,sync,CCName,CCNodes}, S) ->
    handle_cast({conf_check,Vsn,Node,From,sync,CCName,normal,CCNodes},
                S);
handle_cast({conf_check,Vsn,Node,From,sync,CCName,PubType,CCNodes}, S) ->
    CurNodes = S#state.nodes,
    NS =
        case application:get_env(kernel, global_groups) of
            undefined ->
                update_publish_nodes(S#state.publish_type),
                disconnect_nodes([Node]),
                {global_group_check,Node}
                !
                {config_error,Vsn,From,node()},
                S;
            {ok,[]} ->
                update_publish_nodes(S#state.publish_type),
                disconnect_nodes([Node]),
                {global_group_check,Node}
                !
                {config_error,Vsn,From,node()},
                S;
            {ok,NodeGrps} ->
                case catch config_scan(NodeGrps, publish_type) of
                    {error,_Error2} ->
                        disconnect_nodes([Node]),
                        {global_group_check,Node}
                        !
                        {config_error,Vsn,From,node()},
                        S#state{nodes = lists:delete(Node, CurNodes)};
                    {CCName,PubType,CCNodes,_OtherDef} ->
                        update_publish_nodes(S#state.publish_type,
                                             {PubType,CCNodes}),
                        global_name_server ! {nodeup,Node},
                        {global_group_check,Node}
                        !
                        {config_ok,Vsn,From,node()},
                        case lists:member(Node, CurNodes) of
                            false ->
                                NewNodes = lists:sort([Node|CurNodes]),
                                NSE =
                                    lists:delete(Node,
                                                 S#state.sync_error),
                                NNC =
                                    lists:delete(Node,
                                                 S#state.no_contact),
                                S#state{nodes = NewNodes,
                                        sync_error = NSE,
                                        no_contact = NNC};
                            true ->
                                S
                        end;
                    _ ->
                        disconnect_nodes([Node]),
                        {global_group_check,Node}
                        !
                        {config_error,Vsn,From,node()},
                        NN = lists:delete(Node, S#state.nodes),
                        NSE = lists:delete(Node, S#state.sync_error),
                        NNC = lists:delete(Node, S#state.no_contact),
                        S#state{nodes = NN,
                                sync_error = NSE,
                                no_contact = NNC}
                end
        end,
    {noreply,NS};
handle_cast(_Cast, S) ->
    {noreply,S}.

handle_info({nodeup,Node}, S) when S#state.sync_state =:= no_conf ->
    send_monitor(S#state.monitor, {nodeup,Node}, S#state.sync_state),
    global_name_server ! {nodeup,Node},
    {noreply,S};
handle_info({nodeup,Node}, S) ->
    OthersNG =
        case S#state.sync_state of
            synced ->
                X = (catch
                         rpc:call(Node, global_group, get_own_nodes, [])),
                case X of
                    X when is_list(X) ->
                        lists:sort(X);
                    _ ->
                        []
                end;
            no_conf ->
                []
        end,
    NNC = lists:delete(Node, S#state.no_contact),
    NSE = lists:delete(Node, S#state.sync_error),
    OwnNG = get_own_nodes(),
    case OwnNG of
        OthersNG ->
            send_monitor(S#state.monitor,
                         {nodeup,Node},
                         S#state.sync_state),
            global_name_server ! {nodeup,Node},
            case lists:member(Node, S#state.nodes) of
                false ->
                    NN = lists:sort([Node|S#state.nodes]),
                    {noreply,
                     S#state{nodes = NN,
                             no_contact = NNC,
                             sync_error = NSE}};
                true ->
                    {noreply,S#state{no_contact = NNC,sync_error = NSE}}
            end;
        _ ->
            case
                {lists:member(Node, get_own_nodes()),
                 lists:member(Node, S#state.sync_error)}
            of
                {true,false} ->
                    NSE2 = lists:sort([Node|S#state.sync_error]),
                    {noreply,
                     S#state{no_contact = NNC,sync_error = NSE2}};
                _ ->
                    {noreply,S}
            end
    end;
handle_info({nodedown,Node}, S) when S#state.sync_state =:= no_conf ->
    send_monitor(S#state.monitor, {nodedown,Node}, S#state.sync_state),
    global_name_server ! {nodedown,Node},
    {noreply,S};
handle_info({nodedown,Node}, S) ->
    send_monitor(S#state.monitor, {nodedown,Node}, S#state.sync_state),
    global_name_server ! {nodedown,Node},
    NN = lists:delete(Node, S#state.nodes),
    NSE = lists:delete(Node, S#state.sync_error),
    NNC =
        case
            {lists:member(Node, get_own_nodes()),
             lists:member(Node, S#state.no_contact)}
        of
            {true,false} ->
                [Node|S#state.no_contact];
            _ ->
                S#state.no_contact
        end,
    {noreply,S#state{nodes = NN,no_contact = NNC,sync_error = NSE}};
handle_info({disconnect_node,Node}, S) ->
    case {S#state.sync_state,lists:member(Node, S#state.nodes)} of
        {synced,true} ->
            send_monitor(S#state.monitor,
                         {nodedown,Node},
                         S#state.sync_state);
        _ ->
            cont
    end,
    global_name_server ! {nodedown,Node},
    NN = lists:delete(Node, S#state.nodes),
    NNC = lists:delete(Node, S#state.no_contact),
    NSE = lists:delete(Node, S#state.sync_error),
    {noreply,S#state{nodes = NN,no_contact = NNC,sync_error = NSE}};
handle_info({'EXIT',ExitPid,Reason}, S) ->
    check_exit(ExitPid, Reason),
    {noreply,S};
handle_info(_Info, S) ->
    {noreply,S}.

terminate(_Reason, _S) ->
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok,State}.

config_scan(NodeGrps) ->
    config_scan(NodeGrps, original).

config_scan(NodeGrps, original) ->
    case config_scan(NodeGrps, publish_type) of
        {DefGroupName,_,DefNodes,DefOther} ->
            {DefGroupName,DefNodes,DefOther};
        Error ->
            Error
    end;
config_scan(NodeGrps, publish_type) ->
    config_scan(node(), normal, NodeGrps, no_name, [], []).

config_scan(_MyNode, PubType, [], Own_name, OwnNodes, OtherNodeGrps) ->
    {Own_name,PubType,lists:sort(OwnNodes),lists:reverse(OtherNodeGrps)};
config_scan(MyNode,
            PubType,
            [GrpTuple|NodeGrps],
            Own_name,
            OwnNodes,
            OtherNodeGrps) ->
    {Name,PubTypeGroup,Nodes} = grp_tuple(GrpTuple),
    case lists:member(MyNode, Nodes) of
        true ->
            case Own_name of
                no_name ->
                    config_scan(MyNode,
                                PubTypeGroup,
                                NodeGrps,
                                Name,
                                Nodes,
                                OtherNodeGrps);
                _ ->
                    {error,{'node defined twice',{Own_name,Name}}}
            end;
        false ->
            config_scan(MyNode,
                        PubType,
                        NodeGrps,
                        Own_name,
                        OwnNodes,
                        [{Name,Nodes}|OtherNodeGrps])
    end.

grp_tuple({Name,Nodes}) ->
    {Name,normal,Nodes};
grp_tuple({Name,hidden,Nodes}) ->
    {Name,hidden,Nodes};
grp_tuple({Name,normal,Nodes}) ->
    {Name,normal,Nodes}.

-spec sync_init(_, _, _, _) -> no_return().

sync_init(Type, Cname, PubType, Nodes) ->
    {Up,Down} = sync_check_node(lists:delete(node(), Nodes), [], []),
    sync_check_init(Type, Up, Cname, Nodes, Down, PubType).

sync_check_node([], Up, Down) ->
    {Up,Down};
sync_check_node([Node|Nodes], Up, Down) ->
    case net_adm:ping(Node) of
        pang ->
            sync_check_node(Nodes, Up, [Node|Down]);
        pong ->
            sync_check_node(Nodes, [Node|Up], Down)
    end.

-spec sync_check_init(_, _, _, _, _, _) -> no_return().

sync_check_init(Type, Up, Cname, Nodes, Down, PubType) ->
    sync_check_init(Type, Up, Cname, Nodes, 3, [], Down, PubType).

-spec sync_check_init(_, _, _, _, _, _, _, _) -> no_return().

sync_check_init(_Type,
                NoContact,
                _Cname,
                _Nodes,
                0,
                ErrorNodes,
                Down,
                _PubType) ->
    case ErrorNodes of
        [] ->
            gen_server:cast(global_group,
                            {synced,lists:sort(NoContact ++ Down)});
        _ ->
            gen_server:cast(global_group,
                            {sync_error,
                             lists:sort(NoContact ++ Down),
                             ErrorNodes})
    end,
    receive
        kill ->
            exit(normal)
    after
        5000 -> exit(normal)
    end;
sync_check_init(Type, Up, Cname, Nodes, N, ErrorNodes, Down, PubType) ->
    ConfCheckMsg =
        case PubType of
            normal ->
                {conf_check,2,node(),self(),Type,Cname,Nodes};
            _ ->
                {conf_check,2,node(),self(),Type,Cname,PubType,Nodes}
        end,
    lists:foreach(fun(Node) ->
                         gen_server:cast({global_group,Node},
                                         ConfCheckMsg)
                  end,
                  Up),
    case sync_check(Up) of
        {ok,synced} ->
            sync_check_init(Type,
                            [],
                            Cname,
                            Nodes,
                            0,
                            ErrorNodes,
                            Down,
                            PubType);
        {error,NewErrorNodes} ->
            sync_check_init(Type,
                            [],
                            Cname,
                            Nodes,
                            0,
                            ErrorNodes ++ NewErrorNodes,
                            Down,
                            PubType);
        {more,Rem,NewErrorNodes} ->
            sync_check_init(Type,
                            Rem,
                            Cname,
                            Nodes,
                            N - 1,
                            ErrorNodes ++ NewErrorNodes,
                            Down,
                            PubType)
    end.

sync_check(Up) ->
    sync_check(Up, Up, []).

sync_check([], _Up, []) ->
    {ok,synced};
sync_check([], _Up, ErrorNodes) ->
    {error,ErrorNodes};
sync_check(Rem, Up, ErrorNodes) ->
    receive
        {config_ok,2,Pid,Node} when Pid =:= self() ->
            global_name_server ! {nodeup,Node},
            sync_check(Rem -- [Node], Up, ErrorNodes);
        {config_error,2,Pid,Node} when Pid =:= self() ->
            sync_check(Rem -- [Node], Up, [Node|ErrorNodes]);
        {no_global_group_configuration,2,Pid,Node} when Pid =:= self() ->
            sync_check(Rem -- [Node], Up, [Node|ErrorNodes]);
        _ ->
            sync_check(Rem, Up, ErrorNodes)
    after
        2000 -> {more,Rem,ErrorNodes}
    end.

monitor_nodes(true, Pid, State) ->
    link(Pid),
    Monitor = State#state.monitor,
    {ok,State#state{monitor = [Pid|Monitor]}};
monitor_nodes(false, Pid, State) ->
    Monitor = State#state.monitor,
    State1 = State#state{monitor = delete_all(Pid, Monitor)},
    do_unlink(Pid, State1),
    {ok,State1};
monitor_nodes(_, _, State) ->
    {error,State}.

delete_all(From, [From|Tail]) ->
    delete_all(From, Tail);
delete_all(From, [H|Tail]) ->
    [H|delete_all(From, Tail)];
delete_all(_, []) ->
    [].

do_unlink(Pid, State) ->
    case lists:member(Pid, State#state.monitor) of
        true ->
            false;
        _ ->
            unlink(Pid)
    end.

send_monitor([P|T], M, no_conf) ->
    safesend_nc(P, M),
    send_monitor(T, M, no_conf);
send_monitor([P|T], M, SyncState) ->
    safesend(P, M),
    send_monitor(T, M, SyncState);
send_monitor([], _, _) ->
    ok.

safesend(Name, {Msg,Node}) when is_atom(Name) ->
    case lists:member(Node, get_own_nodes()) of
        true ->
            case whereis(Name) of
                undefined ->
                    {Msg,Node};
                P when is_pid(P) ->
                    P ! {Msg,Node}
            end;
        false ->
            not_own_group
    end;
safesend(Pid, {Msg,Node}) ->
    case lists:member(Node, get_own_nodes()) of
        true ->
            Pid ! {Msg,Node};
        false ->
            not_own_group
    end.

safesend_nc(Name, {Msg,Node}) when is_atom(Name) ->
    case whereis(Name) of
        undefined ->
            {Msg,Node};
        P when is_pid(P) ->
            P ! {Msg,Node}
    end;
safesend_nc(Pid, {Msg,Node}) ->
    Pid ! {Msg,Node}.

check_exit(ExitPid, Reason) ->
    check_exit_reg(get(registered_names), ExitPid, Reason),
    check_exit_send(get(send), ExitPid, Reason),
    check_exit_where(get(whereis_name), ExitPid, Reason).

check_exit_reg(undefined, _ExitPid, _Reason) ->
    ok;
check_exit_reg(Reg, ExitPid, Reason) ->
    case lists:keysearch(ExitPid, 1, lists:delete(undefined, Reg)) of
        {value,{ExitPid,From}} ->
            NewReg = lists:delete({ExitPid,From}, Reg),
            put(registered_names, NewReg),
            gen_server:reply(From, {error,Reason});
        false ->
            not_found_ignored
    end.

check_exit_send(undefined, _ExitPid, _Reason) ->
    ok;
check_exit_send(Send, ExitPid, _Reason) ->
    case lists:keysearch(ExitPid, 1, lists:delete(undefined, Send)) of
        {value,{ExitPid,From,Name,Msg}} ->
            NewSend = lists:delete({ExitPid,From,Name,Msg}, Send),
            put(send, NewSend),
            gen_server:reply(From, {badarg,{Name,Msg}});
        false ->
            not_found_ignored
    end.

check_exit_where(undefined, _ExitPid, _Reason) ->
    ok;
check_exit_where(Where, ExitPid, Reason) ->
    case lists:keysearch(ExitPid, 1, lists:delete(undefined, Where)) of
        {value,{ExitPid,From}} ->
            NewWhere = lists:delete({ExitPid,From}, Where),
            put(whereis_name, NewWhere),
            gen_server:reply(From, {error,Reason});
        false ->
            not_found_ignored
    end.

kill_global_group_check() ->
    case whereis(global_group_check) of
        undefined ->
            ok;
        Pid ->
            unlink(Pid),
            global_group_check ! kill,
            unregister(global_group_check)
    end.

disconnect_nodes(DisconnectNodes) ->
    lists:foreach(fun(Node) ->
                         {global_group,Node} ! {disconnect_node,node()},
                         global:node_disconnected(Node)
                  end,
                  DisconnectNodes).

force_nodedown(DisconnectNodes) ->
    lists:foreach(fun(Node) ->
                         disconnect_node(Node),
                         global:node_disconnected(Node)
                  end,
                  DisconnectNodes).

get_own_nodes_with_errors() ->
    case application:get_env(kernel, global_groups) of
        undefined ->
            {ok,all};
        {ok,[]} ->
            {ok,all};
        {ok,NodeGrps} ->
            case catch config_scan(NodeGrps, publish_type) of
                {error,Error} ->
                    {error,Error};
                {_,_,NodesDef,_} ->
                    {ok,lists:sort(NodesDef)}
            end
    end.

get_own_nodes() ->
    case get_own_nodes_with_errors() of
        {ok,all} ->
            [];
        {error,_} ->
            [];
        {ok,Nodes} ->
            Nodes
    end.

publish_arg() ->
    case init:get_argument(hidden) of
        {ok,[[]]} ->
            hidden;
        {ok,[["true"]]} ->
            hidden;
        _ ->
            normal
    end.

own_group() ->
    case application:get_env(kernel, global_groups) of
        undefined ->
            no_group;
        {ok,[]} ->
            no_group;
        {ok,NodeGrps} ->
            case catch config_scan(NodeGrps, publish_type) of
                {error,_} ->
                    no_group;
                {_,PubTpGrp,NodesDef,_} ->
                    {PubTpGrp,NodesDef}
            end
    end.

publish_on_nodes(normal, no_group) ->
    all;
publish_on_nodes(hidden, no_group) ->
    [];
publish_on_nodes(normal, {normal,_}) ->
    all;
publish_on_nodes(hidden, {_,Nodes}) ->
    Nodes;
publish_on_nodes(_, {hidden,Nodes}) ->
    Nodes.

update_publish_nodes(PubArg) ->
    update_publish_nodes(PubArg, no_group).

update_publish_nodes(PubArg, MyGroup) ->
    net_kernel:update_publish_nodes(publish_on_nodes(PubArg, MyGroup)).

publish_on_nodes() ->
    publish_on_nodes(publish_arg(), own_group()).



