-file("test/lib/gs/src/gstk_window.erl", 1).

-module(gstk_window).

-compile([{nowarn_deprecated_function,{gs,destroy,1}}]).

-export([create/3,config/3,read/3,delete/2,event/5,destroy_win/1]).

-export([option/5,read_option/5,mk_create_opts_for_child/4]).

-file("test/lib/gs/src/gstk.hrl", 1).

-record(gstkid,{id = undefined,widget,widget_data,owner,parent,objtype}).

-record(so,{main,object,hscroll,vscroll,misc}).

-file("test/lib/gs/src/gstk_window.erl", 87).

create(DB, Gstkid, Opts) ->
    TkW = gstk_generic:mk_tkw_child(DB, Gstkid),
    NGstkid = Gstkid#gstkid{widget = TkW},
    case
        gstk_generic:make_command(transform_geometry_opts(Opts),
                                  NGstkid,
                                  TkW,
                                  "",
                                  ";",
                                  DB)
    of
        {error,Reason} ->
            {error,Reason};
        Cmd when is_list(Cmd) ->
            BindCmd =
                gstk_generic:bind(DB, Gstkid, TkW, configure, true),
            gstk:exec(["toplevel ",TkW,Cmd,$;,BindCmd]),
            NGstkid
    end.

mk_create_opts_for_child(DB, Cgstkid, Pgstkid, Opts) ->
    gstk_generic:mk_create_opts_for_child(DB, Cgstkid, Pgstkid, Opts).

config(DB, Gstkid, Opts) ->
    TkW = Gstkid#gstkid.widget,
    SimplePreCmd = [TkW," conf"],
    gstk_generic:mk_cmd_and_exec(transform_geometry_opts(Opts),
                                 Gstkid,
                                 TkW,
                                 SimplePreCmd,
                                 "",
                                 DB).

read(DB, Gstkid, Opt) ->
    gstk_generic:read_option(DB, Gstkid, Opt).

delete(DB, Gstkid) ->
    gstk_db:delete_widget(DB, Gstkid),
    Gstkid#gstkid.widget.

event(DB, Gstkid, configure, Edata, Args) ->
    [W,H|_] = Args,
    gstk_db:insert_opt(DB, Gstkid, {width,W}),
    gstk_db:insert_opt(DB, Gstkid, {height,H}),
    case gstk_db:opt(DB, Gstkid, configure) of
        true ->
            apply(gstk_generic, event, [DB,Gstkid,configure,Edata,Args]);
        false ->
            ok
    end;
event(DB, Gstkid, destroy, Edata, Args) ->
    spawn(gstk_window,
          destroy_win,
          [gstk:make_extern_id(Gstkid#gstkid.id, DB)]),
    gstk_generic:event(DB, Gstkid, destroy, Edata, Args);
event(DB, Gstkid, Etype, Edata, Args) ->
    gstk_generic:event(DB, Gstkid, Etype, Edata, Args).

destroy_win(ID) ->
    gs:destroy(ID).

option(Option, Gstkid, TkW, DB, _) ->
    case Option of
        {x,X} ->
            {c,
             ["regexp {(\\d+)x(\\d+)\\+(\\d+)\\+(\\d+)} ",
              "[wm ge ",
              TkW,
              "] g w h x y;wm ge ",
              TkW,
              " ${w}x$h",
              signed(X),
              "+$y;update idletasks"]};
        {y,Y} ->
            {c,
             ["regexp {(\\d+)x(\\d+)\\+(\\d+)\\+(\\d+)} ",
              "[wm ge ",
              TkW,
              "] g w h x y;wm ge ",
              TkW,
              " ${w}x$h+$x",
              signed(Y),
              "; update idletasks"]};
        {width,Width} when Width >= 0 ->
            case gstk_db:opt_or_not(DB, Gstkid, width) of
                {value,Width} ->
                    none;
                _Q ->
                    gstk_db:insert_opt(DB, Gstkid, {width,Width}),
                    {c,
                     ["regexp {(\\d+)x(\\d+)\\+(\\d+)\\+(\\d+)} ",
                      "[wm ge ",
                      TkW,
                      "] g w h x y;wm ge ",
                      TkW,
                      " ",
                      gstk:to_ascii(Width),
                      "x$h+$x+$y;update idletasks"]}
            end;
        {height,Height} when Height >= 0 ->
            case gstk_db:opt_or_not(DB, Gstkid, height) of
                {value,Height} ->
                    none;
                _Q ->
                    gstk_db:insert_opt(DB, Gstkid, {height,Height}),
                    {c,
                     ["wm ge ",
                      TkW,
                      " [winfo w ",
                      TkW,
                      "]x",
                      gstk:to_ascii(Height),
                      ";update idletasks"]}
            end;
        {width_height,{W,H}} when W >= 0, H >= 0 ->
            case
                {gstk_db:opt_or_not(DB, Gstkid, width),
                 gstk_db:opt_or_not(DB, Gstkid, height)}
            of
                {{value,W},{value,H}} ->
                    none;
                _OtherSize ->
                    gstk_db:insert_opt(DB, Gstkid, {height,H}),
                    gstk_db:insert_opt(DB, Gstkid, {width,W}),
                    {c,
                     ["update idletasks;wm ge ",
                      TkW,
                      " ",
                      gstk:to_ascii(W),
                      "x",
                      gstk:to_ascii(H),
                      ";update idletasks"]}
            end;
        {xy,{X,Y}} ->
            {c,
             ["regexp {(\\d+)x(\\d+)\\+(\\d+)\\+(\\d+)} ",
              "[wm ge ",
              TkW,
              "] g w h x y;wm ge ",
              TkW,
              " ${w}x$h",
              signed(X),
              signed(Y),
              ";update idletasks"]};
        {bg,Color} ->
            {s,[" -bg ",gstk:to_color(Color)]};
        {map,true} ->
            {c,["wm deiconify ",TkW]};
        {map,false} ->
            {c,["wm withdraw ",TkW]};
        {configure,On} ->
            gstk_db:insert_opt(DB, Gstkid, {configure,On}),
            none;
        {iconify,true} ->
            {c,["wm iconify ",TkW]};
        {iconify,false} ->
            {c,["wm deiconify ",TkW]};
        {title,Title} ->
            {c,["wm title ",TkW," ",gstk:to_ascii(Title)]};
        {iconname,Name} ->
            {c,["wm iconn ",TkW," ",gstk:to_ascii(Name)]};
        {iconbitmap,Bitmap} ->
            {c,["wm iconb ",TkW," ",gstk:to_ascii(Bitmap)]};
        {iconmask,Bitmap} ->
            {c,["wm iconm ",TkW," ",gstk:to_ascii(Bitmap)]};
        raise ->
            {c,["raise ",TkW]};
        lower ->
            {c,["lower ",TkW]};
        {setfocus,true} ->
            {c,["focus ",TkW]};
        {setfocus,false} ->
            {c,["focus {}"]};
        {buttonpress,On} ->
            Eref = mk_eref(On, DB, Gstkid, buttonpress),
            {c,
             ["bind ",
              TkW,
              " <ButtonPress> ",
              event_onoff(["{erlsend ",Eref," %b ",xy_abs_str(TkW),"};"],
                          On)]};
        {buttonrelease,On} ->
            Eref = mk_eref(On, DB, Gstkid, buttonrelease),
            {c,
             ["bind ",
              TkW,
              " <ButtonRelease> ",
              event_onoff(["{erlsend ",Eref," %b ",xy_abs_str(TkW),"};"],
                          On)]};
        {motion,On} ->
            Eref = mk_eref(On, DB, Gstkid, motion),
            {c,
             ["bind ",
              TkW,
              " <Motion> ",
              event_onoff(["{erlsend ",Eref," ",xy_abs_str(TkW),"};"],
                          On)]};
        _ ->
            invalid_option
    end.

xy_abs_str(TkW) ->
    ["[expr %X-[winfo rootx ",TkW,"]] [expr %Y-[winfo rooty ",TkW,"]]"].

event_onoff(Str, true) ->
    Str;
event_onoff(_, false) ->
    "{}".

mk_eref(false, DB, Gstkid, Etype) ->
    gstk_db:delete_event(DB, Gstkid, Etype),
    dummy;
mk_eref(true, DB, Gstkid, Etype) ->
    gstk_db:insert_event(DB, Gstkid, Etype, []).

read_option(Option, Gstkid, TkW, DB, _) ->
    case Option of
        x ->
            tcl2erl:ret_x(geo_str(TkW));
        y ->
            tcl2erl:ret_y(geo_str(TkW));
        width ->
            tcl2erl:ret_width(geo_str(TkW));
        height ->
            tcl2erl:ret_height(geo_str(TkW));
        configure ->
            gstk_db:opt(DB, Gstkid, configure);
        bg ->
            tcl2erl:ret_color([TkW," cg -bg"]);
        map ->
            tcl2erl:ret_mapped(["winfo is ",TkW]);
        iconify ->
            tcl2erl:ret_iconified(["wm st ",TkW]);
        title ->
            tcl2erl:ret_str(["wm ti ",TkW]);
        iconname ->
            tcl2erl:ret_str(["wm iconn ",TkW]);
        iconbitmap ->
            tcl2erl:ret_str(["wm iconb ",TkW]);
        iconmask ->
            tcl2erl:ret_str(["wm iconm ",TkW]);
        setfocus ->
            tcl2erl:ret_focus(TkW, "focus");
        _ ->
            {bad_result,{Gstkid#gstkid.objtype,invalid_option,Option}}
    end.

geo_str(TkW) ->
    ["update idletasks;",
     "regexp {(\\d+)x(\\d+)\\+(\\d+)\\+(\\d+)} ",
     "[wm geometry ",
     TkW,
     "] g w h x y;set tmp \"$w $h $x $y\""].

signed(X) when X >= 0 ->
    [$+,integer_to_list(X)];
signed(X) when X < 0 ->
    integer_to_list(X).

transform_geometry_opts(Opts) ->
    {Geo,RestOpts} = collect_geo_opts(Opts, [], []),
    Geo2 = make_atomic(lists:sort(Geo)),
    lists:append(Geo2, RestOpts).

make_atomic([{height,H},{width,W},{x,X},{y,Y}]) ->
    [{width_height,{W,H}},{xy,{X,Y}}];
make_atomic([{height,H},{width,W}|XY]) ->
    [{width_height,{W,H}}|XY];
make_atomic([WH,{x,X},{y,Y}]) ->
    [WH,{xy,{X,Y}}];
make_atomic(L) ->
    L.

collect_geo_opts([{x,X}|Opts], Geo, Rest) ->
    collect_geo_opts(Opts, [{x,X}|Geo], Rest);
collect_geo_opts([{y,Y}|Opts], Geo, Rest) ->
    collect_geo_opts(Opts, [{y,Y}|Geo], Rest);
collect_geo_opts([{height,H}|Opts], Geo, Rest) ->
    collect_geo_opts(Opts, [{height,H}|Geo], Rest);
collect_geo_opts([{width,W}|Opts], Geo, Rest) ->
    collect_geo_opts(Opts, [{width,W}|Geo], Rest);
collect_geo_opts([Opt|Opts], Geo, Rest) ->
    collect_geo_opts(Opts, Geo, [Opt|Rest]);
collect_geo_opts([], Geo, Rest) ->
    {Geo,Rest}.



