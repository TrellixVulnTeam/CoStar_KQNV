-file("test/lib/stdlib/src/gen.erl", 1).

-module(gen).

-compile({inline,[{get_node,1}]}).

-export([start/5,start/6,debug_options/1,call/3,call/4,reply/2]).

-export([init_it/6,init_it/7]).

-export([format_status_header/2]).

-type linkage() :: link | nolink.

-type emgr_name() :: {local, atom()}
                   | {global, term()}
                   | {via, atom(), term()}.

-type start_ret() :: {ok, pid()} | ignore | {error, term()}.

-type debug_flag() :: trace
                    | log
                    | statistics
                    | debug
                    | {logfile, string()}.

-type option() :: {timeout, timeout()}
                | {debug, [debug_flag()]}
                | {spawn_opt, [proc_lib:spawn_option()]}.

-type options() :: [option()].

-spec start(module(),
            linkage(),
            emgr_name(),
            module(),
            term(),
            options()) ->
               start_ret().

start(GenMod, LinkP, Name, Mod, Args, Options) ->
    case where(Name) of
        undefined ->
            do_spawn(GenMod, LinkP, Name, Mod, Args, Options);
        Pid ->
            {error,{already_started,Pid}}
    end.

-spec start(module(), linkage(), module(), term(), options()) ->
               start_ret().

start(GenMod, LinkP, Mod, Args, Options) ->
    do_spawn(GenMod, LinkP, Mod, Args, Options).

do_spawn(GenMod, link, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start_link(gen,
                        init_it,
                        [GenMod,self(),self(),Mod,Args,Options],
                        Time,
                        spawn_opts(Options));
do_spawn(GenMod, _, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start(gen,
                   init_it,
                   [GenMod,self(),self,Mod,Args,Options],
                   Time,
                   spawn_opts(Options)).

do_spawn(GenMod, link, Name, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start_link(gen,
                        init_it,
                        [GenMod,self(),self(),Name,Mod,Args,Options],
                        Time,
                        spawn_opts(Options));
do_spawn(GenMod, _, Name, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start(gen,
                   init_it,
                   [GenMod,self(),self,Name,Mod,Args,Options],
                   Time,
                   spawn_opts(Options)).

init_it(GenMod, Starter, Parent, Mod, Args, Options) ->
    init_it2(GenMod, Starter, Parent, self(), Mod, Args, Options).

init_it(GenMod, Starter, Parent, Name, Mod, Args, Options) ->
    case name_register(Name) of
        true ->
            init_it2(GenMod, Starter, Parent, Name, Mod, Args, Options);
        {false,Pid} ->
            proc_lib:init_ack(Starter, {error,{already_started,Pid}})
    end.

init_it2(GenMod, Starter, Parent, Name, Mod, Args, Options) ->
    GenMod:init_it(Starter, Parent, Name, Mod, Args, Options).

call(Process, Label, Request) ->
    call(Process, Label, Request, 5000).

call(Pid, Label, Request, Timeout)
    when
        is_pid(Pid), Timeout =:= infinity;
        is_pid(Pid), is_integer(Timeout), Timeout >= 0 ->
    do_call(Pid, Label, Request, Timeout);
call(Name, Label, Request, Timeout)
    when
        is_atom(Name), Timeout =:= infinity;
        is_atom(Name), is_integer(Timeout), Timeout >= 0 ->
    case whereis(Name) of
        Pid when is_pid(Pid) ->
            do_call(Pid, Label, Request, Timeout);
        undefined ->
            exit(noproc)
    end;
call(Process, Label, Request, Timeout)
    when
        (tuple_size(Process) == 2
         andalso
         element(1, Process) == global
         orelse
         tuple_size(Process) == 3
         andalso
         element(1, Process) == via)
        andalso
        (Timeout =:= infinity
         orelse
         is_integer(Timeout)
         andalso
         Timeout >= 0) ->
    case where(Process) of
        Pid when is_pid(Pid) ->
            Node = node(Pid),
            try
                do_call(Pid, Label, Request, Timeout)
            catch
                exit:{nodedown,Node} ->
                    exit(noproc)
            end;
        undefined ->
            exit(noproc)
    end;
call({Name,Node}, Label, Request, Timeout)
    when
        Node =:= node(), Timeout =:= infinity;
        Node =:= node(), is_integer(Timeout), Timeout >= 0 ->
    call(Name, Label, Request, Timeout);
call({_Name,Node} = Process, Label, Request, Timeout)
    when
        is_atom(Node), Timeout =:= infinity;
        is_atom(Node), is_integer(Timeout), Timeout >= 0 ->
    if
        node() =:= nonode@nohost ->
            exit({nodedown,Node});
        true ->
            do_call(Process, Label, Request, Timeout)
    end.

do_call(Process, Label, Request, Timeout) ->
    try monitor(process, Process) of
        Mref ->
            catch
                erlang:send(Process,
                            {Label,{self(),Mref},Request},
                            [noconnect]),
            receive
                {Mref,Reply} ->
                    demonitor(Mref, [flush]),
                    {ok,Reply};
                {'DOWN',Mref,_,_,noconnection} ->
                    Node = get_node(Process),
                    exit({nodedown,Node});
                {'DOWN',Mref,_,_,Reason} ->
                    exit(Reason)
            after
                Timeout ->
                    demonitor(Mref, [flush]),
                    exit(timeout)
            end
    catch
        error:_ ->
            Node = get_node(Process),
            monitor_node(Node, true),
            receive
                {nodedown,Node} ->
                    monitor_node(Node, false),
                    exit({nodedown,Node})
            after
                0 ->
                    Tag = make_ref(),
                    Process ! {Label,{self(),Tag},Request},
                    wait_resp(Node, Tag, Timeout)
            end
    end.

get_node(Process) ->
    case Process of
        {_S,N} when is_atom(N) ->
            N;
        _ when is_pid(Process) ->
            node(Process)
    end.

wait_resp(Node, Tag, Timeout) ->
    receive
        {Tag,Reply} ->
            monitor_node(Node, false),
            {ok,Reply};
        {nodedown,Node} ->
            monitor_node(Node, false),
            exit({nodedown,Node})
    after
        Timeout ->
            monitor_node(Node, false),
            exit(timeout)
    end.

reply({To,Tag}, Reply) ->
    Msg = {Tag,Reply},
    try
        To ! Msg
    catch
        _:_ ->
            Msg
    end.

where({global,Name}) ->
    global:whereis_name(Name);
where({via,Module,Name}) ->
    Module:whereis_name(Name);
where({local,Name}) ->
    whereis(Name).

name_register({local,Name} = LN) ->
    try register(Name, self()) of
        true ->
            true
    catch
        error:_ ->
            {false,where(LN)}
    end;
name_register({global,Name} = GN) ->
    case global:register_name(Name, self()) of
        yes ->
            true;
        no ->
            {false,where(GN)}
    end;
name_register({via,Module,Name} = GN) ->
    case Module:register_name(Name, self()) of
        yes ->
            true;
        no ->
            {false,where(GN)}
    end.

timeout(Options) ->
    case opt(timeout, Options) of
        {ok,Time} ->
            Time;
        _ ->
            infinity
    end.

spawn_opts(Options) ->
    case opt(spawn_opt, Options) of
        {ok,Opts} ->
            Opts;
        _ ->
            []
    end.

opt(Op, [{Op,Value}|_]) ->
    {ok,Value};
opt(Op, [_|Options]) ->
    opt(Op, Options);
opt(_, []) ->
    false.

debug_options(Opts) ->
    case opt(debug, Opts) of
        {ok,Options} ->
            sys:debug_options(Options);
        _ ->
            []
    end.

format_status_header(TagLine, Pid) when is_pid(Pid) ->
    lists:concat([TagLine," ",pid_to_list(Pid)]);
format_status_header(TagLine, RegName) when is_atom(RegName) ->
    lists:concat([TagLine," ",RegName]);
format_status_header(TagLine, Name) ->
    {TagLine,Name}.



