-file("test/lib/kernel/src/erts_debug.erl", 1).

-module(erts_debug).

-export([size/1,df/1,df/2,df/3]).

-export([breakpoint/2,
         disassemble/1,
         display/1,
         dist_ext_to_term/2,
         dump_monitors/1,
         dump_links/1,
         flat_size/1,
         get_internal_state/1,
         instructions/0,
         lock_counters/1,
         same/2,
         set_internal_state/2]).

-spec breakpoint(MFA, Flag) -> non_neg_integer()
                    when
                        is_subtype(MFA,
                                   {Module :: module(),
                                    Function :: atom(),
                                    Arity :: arity() | '_'}),
                        is_subtype(Flag, boolean()).

breakpoint(_, _) ->
    erlang:nif_error(undef).

-spec disassemble(What) -> false | undef | Result
                     when
                         is_subtype(What, MFA | Address),
                         is_subtype(Result, {Address, Code, MFA}),
                         is_subtype(MFA, mfa()),
                         is_subtype(Address, non_neg_integer()),
                         is_subtype(Code, binary()).

disassemble(_) ->
    erlang:nif_error(undef).

-spec display(Term) -> string() when is_subtype(Term, term()).

display(_) ->
    erlang:nif_error(undef).

-spec dist_ext_to_term(Tuple, Binary) -> term()
                          when
                              is_subtype(Tuple, tuple()),
                              is_subtype(Binary, binary()).

dist_ext_to_term(_, _) ->
    erlang:nif_error(undef).

-spec dump_monitors(Id) -> true when is_subtype(Id, pid() | atom()).

dump_monitors(_) ->
    erlang:nif_error(undef).

-spec dump_links(Id) -> true
                    when is_subtype(Id, pid() | port() | atom()).

dump_links(_) ->
    erlang:nif_error(undef).

-spec flat_size(Term) -> non_neg_integer() when is_subtype(Term, term()).

flat_size(_) ->
    erlang:nif_error(undef).

-spec get_internal_state(W) -> term()
                            when
                                is_subtype(W,
                                           reds_left |
                                           node_and_dist_references |
                                           monitoring_nodes |
                                           next_pid |
                                           'DbTable_words' |
                                           check_io_debug |
                                           process_info_args |
                                           processes |
                                           processes_bif_info |
                                           max_atom_out_cache_index |
                                           nbalance |
                                           available_internal_state |
                                           force_heap_frags |
                                           memory |
                                           {process_status, pid()} |
                                           {link_list,
                                            pid() | port() | node()} |
                                           {monitor_list,
                                            pid() | node()} |
                                           {channel_number,
                                            non_neg_integer()} |
                                           {have_pending_exit,
                                            pid() | port() | atom()} |
                                           {binary_info, binary()} |
                                           {term_to_binary_no_funs,
                                            term()} |
                                           {dist_port, port()} |
                                           {atom_out_cache_index,
                                            atom()} |
                                           {fake_scheduler_bindings,
                                            default_bind |
                                            spread |
                                            processor_spread |
                                            thread_spread |
                                            thread_no_node_processor_spread |
                                            no_node_processor_spread |
                                            no_node_thread_spread |
                                            no_spread |
                                            unbound} |
                                           {reader_groups_map,
                                            non_neg_integer()}).

get_internal_state(_) ->
    erlang:nif_error(undef).

-spec instructions() -> [string()].

instructions() ->
    erlang:nif_error(undef).

-spec lock_counters(info) -> term();
                   (clear) -> ok;
                   ({copy_save, boolean()}) -> boolean();
                   ({process_locks, boolean()}) -> boolean().

lock_counters(_) ->
    erlang:nif_error(undef).

-spec same(Term1, Term2) -> boolean()
              when is_subtype(Term1, term()), is_subtype(Term2, term()).

same(_, _) ->
    erlang:nif_error(undef).

-spec set_internal_state(available_internal_state, boolean()) ->
                            boolean();
                        (reds_left, non_neg_integer()) -> true;
                        (block, non_neg_integer()) -> true;
                        (sleep, non_neg_integer()) -> true;
                        (block_scheduler, non_neg_integer()) -> true;
                        (next_pid, non_neg_integer()) ->
                            false | integer();
                        (force_gc, pid() | atom()) -> boolean();
                        (send_fake_exit_signal,
                         {pid() | port(), pid(), term()}) ->
                            dead | message | unaffected | exit;
                        (colliding_names, {atom(), non_neg_integer()}) ->
                            [atom()];
                        (binary_loop_limit, default) -> - 1;
                        (binary_loop_limit, non_neg_integer()) ->
                            non_neg_integer();
                        (re_loop_limit, default) -> - 1;
                        (re_loop_limit, non_neg_integer()) ->
                            non_neg_integer();
                        (unicode_loop_limit, default) -> - 1;
                        (unicode_loop_limit, non_neg_integer()) ->
                            non_neg_integer();
                        (hipe_test_reschedule_suspend, term()) -> [];
                        (hipe_test_reschedule_resume, pid() | port()) ->
                            boolean();
                        (test_long_gc_sleep, non_neg_integer()) -> true;
                        (kill_dist_connection, port()) -> boolean();
                        (not_running_optimization, boolean()) ->
                            boolean();
                        (wait, deallocations) -> ok.

set_internal_state(_, _) ->
    erlang:nif_error(undef).

-spec size(term()) -> non_neg_integer().

size(Term) ->
    {Sum,_} = size(Term, gb_trees:empty(), 0),
    Sum.

size([H|T] = Term, Seen0, Sum0) ->
    case remember_term(Term, Seen0) of
        seen ->
            {Sum0,Seen0};
        Seen1 ->
            {Sum,Seen} = size(H, Seen1, Sum0 + 2),
            size(T, Seen, Sum)
    end;
size(Tuple, Seen0, Sum0) when is_tuple(Tuple) ->
    case remember_term(Tuple, Seen0) of
        seen ->
            {Sum0,Seen0};
        Seen ->
            Sum = Sum0 + 1 + tuple_size(Tuple),
            tuple_size(1, tuple_size(Tuple), Tuple, Seen, Sum)
    end;
size(Fun, Seen0, Sum) when is_function(Fun) ->
    case remember_term(Fun, Seen0) of
        seen ->
            {Sum,Seen0};
        Seen ->
            fun_size(Fun, Seen, Sum)
    end;
size(Term, Seen0, Sum) ->
    case erts_debug:flat_size(Term) of
        0 ->
            {Sum,Seen0};
        Sz ->
            case remember_term(Term, Seen0) of
                seen ->
                    {Sum,Seen0};
                Seen ->
                    {Sum + Sz,Seen}
            end
    end.

tuple_size(I, Sz, _, Seen, Sum) when I > Sz ->
    {Sum,Seen};
tuple_size(I, Sz, Tuple, Seen0, Sum0) ->
    {Sum,Seen} = size(element(I, Tuple), Seen0, Sum0),
    tuple_size(I + 1, Sz, Tuple, Seen, Sum).

fun_size(Fun, Seen, Sum) ->
    case erlang:fun_info(Fun, type) of
        {type,external} ->
            {Sum + erts_debug:flat_size(Fun),Seen};
        {type,local} ->
            Sz =
                erts_debug:flat_size(fun() ->
                                            ok
                                     end),
            {env,Env} = erlang:fun_info(Fun, env),
            fun_size_1(Env, Seen, Sum + Sz + length(Env))
    end.

fun_size_1([H|T], Seen0, Sum0) ->
    {Sum,Seen} = size(H, Seen0, Sum0),
    fun_size_1(T, Seen, Sum);
fun_size_1([], Seen, Sum) ->
    {Sum,Seen}.

remember_term(Term, Seen) ->
    case gb_trees:lookup(Term, Seen) of
        none ->
            gb_trees:insert(Term, [Term], Seen);
        {value,Terms} ->
            case is_term_seen(Term, Terms) of
                false ->
                    gb_trees:update(Term, [Term|Terms], Seen);
                true ->
                    seen
            end
    end.

-spec is_term_seen(term(), [term()]) -> boolean().

is_term_seen(Term, [H|T]) ->
    case erts_debug:same(Term, H) of
        true ->
            true;
        false ->
            is_term_seen(Term, T)
    end;
is_term_seen(_, []) ->
    false.

-type df_ret() :: ok | {error, {badopen, module()}} | {undef, module()}.

-spec df(module()) -> df_ret().

df(Mod) when is_atom(Mod) ->
    try Mod:module_info(functions) of
        Fs0 when is_list(Fs0) ->
            Name = lists:concat([Mod,".dis"]),
            Fs =
                [ 
                 {Mod,Func,Arity} ||
                     {Func,Arity} <- Fs0
                ],
            dff(Name, Fs)
    catch
        _:_ ->
            {undef,Mod}
    end.

-spec df(module(), atom()) -> df_ret().

df(Mod, Func) when is_atom(Mod), is_atom(Func) ->
    try Mod:module_info(functions) of
        Fs0 when is_list(Fs0) ->
            Name = lists:concat([Mod,"_",Func,".dis"]),
            Fs =
                [ 
                 {Mod,Func1,Arity} ||
                     {Func1,Arity} <- Fs0,
                     Func1 =:= Func
                ],
            dff(Name, Fs)
    catch
        _:_ ->
            {undef,Mod}
    end.

-spec df(module(), atom(), arity()) -> df_ret().

df(Mod, Func, Arity) when is_atom(Mod), is_atom(Func) ->
    try Mod:module_info(functions) of
        Fs0 when is_list(Fs0) ->
            Name = lists:concat([Mod,"_",Func,"_",Arity,".dis"]),
            Fs =
                [ 
                 {Mod,Func1,Arity1} ||
                     {Func1,Arity1} <- Fs0,
                     Func1 =:= Func,
                     Arity1 =:= Arity
                ],
            dff(Name, Fs)
    catch
        _:_ ->
            {undef,Mod}
    end.

dff(File, Fs) when is_pid(File), is_list(Fs) ->
    lists:foreach(fun(Mfa) ->
                         disassemble_function(File, Mfa),
                         io:nl(File)
                  end,
                  Fs);
dff(Name, Fs) when is_list(Name) ->
    case file:open(Name, [write]) of
        {ok,F} ->
            try dff(F, Fs) after file:close(F) end;
        {error,Reason} ->
            {error,{badopen,Reason}}
    end.

disassemble_function(File, {_,_,_} = MFA) ->
    cont_dis(File, erts_debug:disassemble(MFA), MFA).

cont_dis(_, false, _) ->
    ok;
cont_dis(File, {Addr,Str,MFA}, MFA) ->
    io:put_chars(File, binary_to_list(Str)),
    cont_dis(File, erts_debug:disassemble(Addr), MFA);
cont_dis(_, {_,_,_}, _) ->
    ok.



