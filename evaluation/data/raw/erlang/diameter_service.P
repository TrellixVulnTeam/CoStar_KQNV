-file("test/lib/diameter/src/base/diameter_service.erl", 1).

-module(diameter_service).

-behaviour(gen_server).

-export([start_link/1]).

-export([subscribe/1,unsubscribe/1,services/0,info/2]).

-export([start/1,stop/1,start_transport/2,stop_transport/2]).

-export([notify/2]).

-export([find_incoming_app/4,pick_peer/3]).

-export([services/1,
         subscriptions/1,
         subscriptions/0,
         call_module/3,
         whois/1,
         state/1,
         uptime/1]).

-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/diameter-1.3/include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options = [{answer_errors,report}]}).

-file("test/lib/diameter/src/base/diameter_service.erl", 67).

-file("test/lib/diameter/src/base/diameter_internal.hrl", 1).

-record(diameter_peer,{host_id,
                       statusT,
                       is_dynamic,
                       expiration,
                       tls_enabled}).

-record(diameter_realm,{name,
                        app_id,
                        local_action,
                        server_id,
                        is_dynamic,
                        expiration}).

-file("test/lib/diameter/src/base/diameter_service.erl", 68).

-type wd_state() :: initial | okay | suspect | down | reopen.

-type match(T) :: T | '_' | '$1' | '$2'.

-record(state,{id = now(),
               service_name :: undefined | diameter:service_name(),
               service :: undefined | #diameter_service{},
               watchdogT = ets_new(watchdogs) :: ets:tid(),
               peerT = ets_new(peers) :: ets:tid(),
               shared_peers = diameter_dict:new() :: ets:tid(),
               local_peers = diameter_dict:new() :: ets:tid(),
               monitor = false :: false | pid(),
               options :: undefined
                        | [{sequence, diameter:sequence()} |
                           {share_peers, diameter:remotes()} |
                           {use_shared_peers, diameter:remotes()} |
                           {restrict_connections,
                            diameter:restriction()}]}).

-record(watchdog,{pid :: undefined | match(pid()),
                  type :: undefined | match(connect | accept),
                  ref :: undefined | match(reference()),
                  options :: undefined
                           | match([diameter:transport_opt()]),
                  state = initial :: match(wd_state()),
                  started = now(),
                  peer = false :: match(boolean() | pid())}).

-record(peer,{pid :: undefined | pid(),
              apps :: undefined
                    | [{0..4294967295, diameter:app_alias()}],
              caps :: undefined | #diameter_caps{},
              started = now(),
              watchdog :: undefined | pid()}).

start(SvcName) ->
    diameter_service_sup:start_child(SvcName).

start_link(SvcName) ->
    Options = [{spawn_opt,diameter_lib:spawn_opts(server, [])}],
    gen_server:start_link(diameter_service, [SvcName], Options).

stop(SvcName) ->
    case whois(SvcName) of
        undefined ->
            {error,not_started};
        Pid ->
            stop(call_service(Pid, stop), Pid)
    end.

stop(ok, Pid) ->
    MRef = monitor(process, Pid),
    receive
        {'DOWN',MRef,process,_,_} ->
            ok
    end;
stop(No, _) ->
    No.

start_transport(SvcName, {_Ref,_Type,_Opts} = T) ->
    call_service_by_name(SvcName, {start,T}).

stop_transport(_, []) ->
    ok;
stop_transport(SvcName, [_|_] = Refs) ->
    call_service_by_name(SvcName, {stop,Refs}).

info(SvcName, Item) ->
    case lookup_state(SvcName) of
        [#state{} = S] ->
            service_info(Item, S);
        [] ->
            undefined
    end.

lookup_state(SvcName) ->
    ets:lookup(diameter_service, SvcName).

subscribe(SvcName) ->
    diameter_reg:add({diameter_service,subscriber,SvcName}).

unsubscribe(SvcName) ->
    diameter_reg:del({diameter_service,subscriber,SvcName}).

subscriptions(Pat) ->
    pmap(diameter_reg:match({diameter_service,subscriber,Pat})).

subscriptions() ->
    subscriptions('_').

pmap(Props) ->
    lists:map(fun({{diameter_service,_,Name},Pid}) ->
                     {Name,Pid}
              end,
              Props).

services(Pat) ->
    pmap(diameter_reg:match({diameter_service,service,Pat})).

services() ->
    services('_').

whois(SvcName) ->
    case diameter_reg:match({diameter_service,service,SvcName}) of
        [{_,Pid}] ->
            Pid;
        [] ->
            undefined
    end.

-spec pick_peer(SvcName, AppOrAlias, Opts) ->
                   {{TPid, Caps, App}, Mask} | false | {error, term()}
                   when
                       is_subtype(SvcName, diameter:service_name()),
                       is_subtype(AppOrAlias,
                                  {alias, diameter:app_alias()} |
                                  #diameter_app{}),
                       is_subtype(Opts, tuple()),
                       is_subtype(TPid, pid()),
                       is_subtype(Caps, #diameter_caps{}),
                       is_subtype(App, #diameter_app{}),
                       is_subtype(Mask, diameter:sequence()).

pick_peer(SvcName, App, Opts) ->
    pick(lookup_state(SvcName), App, Opts).

pick([], _, _) ->
    {error,no_service};
pick([S], App, Opts) ->
    pick(S, App, Opts);
pick(#state{service = #diameter_service{applications = Apps}} = S,
     {alias,Alias},
     Opts) ->
    pick(S, find_outgoing_app(Alias, Apps), Opts);
pick(_, false, _) ->
    false;
pick(#state{options = [{_,Mask}|_]} = S,
     #diameter_app{module = ModX,dictionary = Dict} = App0,
     {DestF,Filter,Xtra}) ->
    App = App0#diameter_app{module = ModX ++ Xtra},
    [_,_] = RealmAndHost = diameter_lib:eval([DestF,Dict]),
    case pick_peer(App, RealmAndHost, Filter, S) of
        {TPid,Caps} ->
            {{TPid,Caps,App},Mask};
        false = No ->
            No
    end.

-spec find_incoming_app(PeerT, TPid, Id, Apps) ->
                           {#diameter_app{}, #diameter_caps{}} |
                           #diameter_caps{} |
                           false
                           when
                               is_subtype(PeerT, ets:tid()),
                               is_subtype(TPid, pid()),
                               is_subtype(Id, non_neg_integer()),
                               is_subtype(Apps, [#diameter_app{}]).

find_incoming_app(PeerT, TPid, Id, Apps) ->
    try ets:lookup(PeerT, TPid) of
        [#peer{} = P] ->
            find_incoming_app(P, Id, Apps);
        [] ->
            false
    catch
        error:badarg ->
            false
    end.

notify(SvcName, Msg) ->
    Pid = whois(SvcName),
    is_pid(Pid)
    andalso
    (Pid ! Msg).

state(Svc) ->
    call_service(Svc, state).

uptime(Svc) ->
    call_service(Svc, uptime).

call_module(Service, AppMod, Request) ->
    call_service(Service, {call_module,AppMod,Request}).

init([SvcName]) ->
    process_flag(trap_exit, true),
    i(SvcName, diameter_reg:add_new({diameter_service,service,SvcName})).

i(SvcName, true) ->
    {ok,i(SvcName)};
i(_, false) ->
    {stop,{shutdown,already_started}}.

handle_call(state, _, S) ->
    {reply,S,S};
handle_call(uptime, _, #state{id = T} = S) ->
    {reply,diameter_lib:now_diff(T),S};
handle_call({start,{Ref,Type,Opts}}, _From, S) ->
    {reply,start(Ref, {Type,Opts}, S),S};
handle_call({stop,Refs}, _From, S) ->
    shutdown(Refs, S),
    {reply,ok,S};
handle_call({pick_peer,Local,Remote,App}, _From, S) ->
    #diameter_app{mutable = true} = App,
    {reply,
     pick_peer(Local, Remote, self(), S#state.service_name, App),
     S};
handle_call({call_module,AppMod,Req}, From, S) ->
    call_module(AppMod, Req, From, S);
handle_call(stop, _From, S) ->
    shutdown(service, S),
    {stop,normal,ok,S};
handle_call(Req, From, S) ->
    unexpected(handle_call, [Req,From], S),
    {reply,nok,S}.

handle_cast(Req, S) ->
    unexpected(handle_cast, [Req], S),
    {noreply,S}.

handle_info(T, #state{} = S) ->
    case transition(T, S) of
        ok ->
            {noreply,S};
        {stop,Reason} ->
            {stop,{shutdown,Reason},S}
    end.

transition({accepted,Pid,TPid}, S) ->
    accepted(Pid, TPid, S),
    ok;
transition({reconnect,Pid}, S) ->
    reconnect(Pid, S),
    ok;
transition({close,Pid,Reason},
           #state{service_name = SvcName,watchdogT = WatchdogT}) ->
    #watchdog{state = WS,ref = Ref,type = Type,options = Opts} =
        fetch(WatchdogT, Pid),
    WS /= okay
    andalso
    send_event(SvcName, {closed,Ref,Reason,{type(Type),Opts}}),
    ok;
transition({watchdog,Pid,{[TPid|Data],From,To}},
           #state{service_name = SvcName,watchdogT = WatchdogT} = S) ->
    #watchdog{ref = Ref,type = T,options = Opts} =
        Wd = fetch(WatchdogT, Pid),
    watchdog(TPid, Data, From, To, Wd, S),
    send_event(SvcName, {watchdog,Ref,TPid,{From,To},{T,Opts}}),
    ok;
transition({'DOWN',MRef,process,_,Reason}, #state{monitor = MRef}) ->
    {stop,{monitor,Reason}};
transition({'DOWN',_,process,Pid,_Reason}, S) when node(Pid) == node() ->
    watchdog_down(Pid, S),
    ok;
transition({service,Pid}, S) ->
    share_peers(Pid, S),
    ok;
transition({peer,TPid,Aliases,Caps}, S) ->
    remote_peer_up(TPid, Aliases, Caps, S),
    ok;
transition({'DOWN',_,process,TPid,_}, S) ->
    remote_peer_down(TPid, S),
    ok;
transition({tc_timeout,T}, S) ->
    tc_timeout(T, S),
    ok;
transition(Req, S) ->
    unexpected(handle_info, [Req], S),
    ok.

terminate(Reason, #state{service_name = Name} = S) ->
    send_event(Name, stop),
    ets:delete(diameter_service, Name),
    shutdown == Reason
    andalso
    shutdown(application, S).

code_change(FromVsn,
            #state{service_name = SvcName,
                   service = #diameter_service{applications = Apps}} =
                S,
            Extra) ->
    lists:foreach(fun(A) ->
                         code_change(FromVsn, SvcName, Extra, A)
                  end,
                  Apps),
    {ok,S}.

code_change(FromVsn, SvcName, Extra, #diameter_app{alias = Alias} = A) ->
    {ok,S} =
        cb(A, code_change, [FromVsn,mod_state(Alias),Extra,SvcName]),
    mod_state(Alias, S).

unexpected(F, A, #state{service_name = Name}) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_service,F,A ++ [Name]}).

cb(#diameter_app{module = [_|_] = M}, F, A) ->
    eval(M, F, A).

eval([M|X], F, A) ->
    apply(M, F, A ++ X).

state_cb(#diameter_app{module = ModX,mutable = false,init_state = S},
         pick_peer = F,
         A) ->
    eval(ModX, F, A ++ [S]);
state_cb(#diameter_app{module = ModX,alias = Alias}, F, A) ->
    eval(ModX, F, A ++ [mod_state(Alias)]).

choose(true, X, _) ->
    X;
choose(false, _, X) ->
    X.

ets_new(Tbl) ->
    ets:new(Tbl, [{keypos,2}]).

insert(Tbl, Rec) ->
    ets:insert(Tbl, Rec),
    Rec.

mod_state(Alias) ->
    get({diameter_service,mod_state,Alias}).

mod_state(Alias, ModS) ->
    put({diameter_service,mod_state,Alias}, ModS).

shutdown(Refs, #state{watchdogT = WatchdogT}) when is_list(Refs) ->
    ets:foldl(fun(P, ok) ->
                     st(P, Refs),
                     ok
              end,
              ok,
              WatchdogT);
shutdown(Reason, #state{watchdogT = WatchdogT})
    when Reason == application; Reason == service ->
    diameter_lib:wait(ets:foldl(fun(P, A) ->
                                       st(P, Reason, A)
                                end,
                                [],
                                WatchdogT)).

st(#watchdog{ref = Ref,pid = Pid}, Refs) ->
    lists:member(Ref, Refs)
    andalso
    (Pid ! {shutdown,self(),transport}).

st(#watchdog{pid = Pid}, Reason, Acc) ->
    Pid ! {shutdown,self(),Reason},
    [Pid|Acc].

call_service(Pid, Req) when is_pid(Pid) ->
    cs(Pid, Req);
call_service(SvcName, Req) ->
    call_service_by_name(SvcName, Req).

call_service_by_name(SvcName, Req) ->
    cs(whois(SvcName), Req).

cs(Pid, Req) when is_pid(Pid) ->
    try
        gen_server:call(Pid, Req, infinity)
    catch
        E:Reason when E == exit ->
            {error,{E,Reason}}
    end;
cs(undefined, _) ->
    {error,no_service}.

i(SvcName) ->
    {#state{} = S,CL} =
        lists:foldl(fun cfg_acc/2,
                    {false,[]},
                    diameter_config:lookup(SvcName)),
    true = ets:insert_new(diameter_service, S),
    send_event(SvcName, start),
    lists:foreach(fun(T) ->
                         start_fsm(T, S)
                  end,
                  CL),
    init_shared(S),
    S.

cfg_acc({SvcName,#diameter_service{applications = Apps} = Rec,Opts},
        {false,Acc}) ->
    lists:foreach(fun init_mod/1, Apps),
    S = #state{service_name = SvcName,
               service = Rec#diameter_service{pid = self()},
               monitor = mref(get_value(monitor, Opts)),
               options = service_options(Opts)},
    {S,Acc};
cfg_acc({_Ref,Type,_Opts} = T, {S,Acc})
    when Type == connect; Type == listen ->
    {S,[T|Acc]}.

service_options(Opts) ->
    [{sequence,proplists:get_value(sequence, Opts, {0,32})},
     {share_peers,get_value(share_peers, Opts)},
     {use_shared_peers,get_value(use_shared_peers, Opts)},
     {restrict_connections,
      proplists:get_value(restrict_connections, Opts, nodes)},
     {spawn_opt,proplists:get_value(spawn_opt, Opts, [])}].

mref(false = No) ->
    No;
mref(P) ->
    monitor(process, P).

init_shared(#state{options = [_,_,{_,T}|_],service_name = Svc}) ->
    notify(T, Svc, {service,self()}).

init_mod(#diameter_app{alias = Alias,init_state = S}) ->
    mod_state(Alias, S).

start_fsm({Ref,Type,Opts}, S) ->
    start(Ref, {Type,Opts}, S).

get_value(Key, Vs) ->
    {_,V} = lists:keyfind(Key, 1, Vs),
    V.

notify(Share, SvcName, T) ->
    Nodes = remotes(Share),
    [] /= Nodes
    andalso
    diameter_peer:notify(Nodes, SvcName, T).

remotes(false) ->
    [];
remotes(true) ->
    nodes();
remotes(Nodes) when is_atom(hd(Nodes)); Nodes == [] ->
    Nodes;
remotes(F) ->
    try diameter_lib:eval(F) of
        L when is_list(L) ->
            L;
        T ->
            diameter_lib:error_report({invalid_return,T}, F),
            []
    catch
        E:R ->
            diameter_lib:error_report({failure,
                                       {E,R,erlang:get_stacktrace()}},
                                      F),
            []
    end.

start(Ref, {T,Opts}, S) when T == connect; T == listen ->
    try
        {ok,start(Ref, type(T), Opts, S)}
    catch
        {{diameter_service},{Reason}} ->
            {error,Reason}
    end.

type(listen) ->
    accept;
type(accept) ->
    listen;
type(connect = T) ->
    T.

start(Ref,
      Type,
      Opts,
      #state{watchdogT = WatchdogT,
             peerT = PeerT,
             options = SvcOpts,
             service_name = SvcName,
             service = Svc0})
    when Type == connect; Type == accept ->
    #diameter_service{applications = Apps} =
        Svc = merge_service(Opts, Svc0),
    {_,_} = Mask = proplists:get_value(sequence, SvcOpts),
    RecvData = diameter_traffic:make_recvdata([SvcName,PeerT,Apps,Mask]),
    Pid =
        s(Type,
          Ref,
          {{spawn_opts([Opts,SvcOpts]),RecvData},Opts,SvcOpts,Svc}),
    insert(WatchdogT,
           #watchdog{pid = Pid,type = Type,ref = Ref,options = Opts}),
    Pid.

spawn_opts(Optss) ->
    SpawnOpts = get_value(spawn_opt, Optss, []),
    [ 
     T ||
         T <- SpawnOpts,
         T /= link,
         T /= monitor
    ].

s(Type, Ref, T) ->
    {_MRef,Pid} = diameter_watchdog:start({Type,Ref}, T),
    Pid.

merge_service(Opts, Svc) ->
    lists:foldl(fun ms/2, Svc, Opts).

ms({applications,As}, #diameter_service{applications = Apps} = S)
    when is_list(As) ->
    S#diameter_service{applications =
                           [ 
                            A ||
                                A <- Apps,
                                lists:member(A#diameter_app.alias, As)
                           ]};
ms({capabilities,Opts}, #diameter_service{capabilities = Caps0} = Svc)
    when is_list(Opts) ->
    {ok,Caps} = diameter_capx:make_caps(Caps0, Opts),
    Svc#diameter_service{capabilities = Caps};
ms(_, Svc) ->
    Svc.

accepted(Pid, _TPid, #state{watchdogT = WatchdogT} = S) ->
    #watchdog{ref = Ref,type = accept = T,peer = false,options = Opts} =
        Wd = fetch(WatchdogT, Pid),
    insert(WatchdogT, Wd#watchdog{peer = true}),
    start(Ref, T, Opts, S).

fetch(Tid, Key) ->
    [T] = ets:lookup(Tid, Key),
    T.

watchdog(TPid, [T], _, okay, Wd, State) ->
    connection_up({TPid,T}, Wd, State);
watchdog(TPid, [T], _, reopen, Wd, State) ->
    reopen({TPid,T}, Wd, State);
watchdog(TPid, [], suspect, okay, Wd, State) ->
    #watchdog{peer = TPid} = Wd,
    connection_up(Wd, State);
watchdog(TPid, [], okay, suspect = To, Wd, State) ->
    #watchdog{peer = TPid} = Wd,
    watchdog_down(Wd, To, State);
watchdog(TPid, [], _, down = To, Wd, #state{peerT = PeerT} = S) ->
    close(Wd, S),
    watchdog_down(Wd, To, S),
    ets:delete(PeerT, TPid);
watchdog(_, [], _, _, _, _) ->
    ok.

watchdog_down(Wd, To, #state{watchdogT = WatchdogT} = S) ->
    insert(WatchdogT, Wd#watchdog{state = To}),
    connection_down(Wd, To, S).

connection_up({TPid,{Caps,SupportedApps,Pkt}},
              #watchdog{pid = Pid} = Wd,
              #state{peerT = PeerT} = S) ->
    Pr =
        #peer{pid = TPid,
              apps = SupportedApps,
              caps = Caps,
              watchdog = Pid},
    insert(PeerT, Pr),
    connection_up([Pkt], Wd#watchdog{peer = TPid}, Pr, S).

reopen({TPid,{Caps,SupportedApps,_Pkt}},
       #watchdog{pid = Pid} = Wd,
       #state{watchdogT = WatchdogT,peerT = PeerT}) ->
    insert(PeerT,
           #peer{pid = TPid,
                 apps = SupportedApps,
                 caps = Caps,
                 watchdog = Pid}),
    insert(WatchdogT, Wd#watchdog{state = reopen,peer = TPid}).

connection_up(#watchdog{peer = TPid} = Wd, #state{peerT = PeerT} = S) ->
    connection_up([], Wd, fetch(PeerT, TPid), S).

connection_up(Extra,
              #watchdog{peer = TPid} = Wd,
              #peer{apps = SApps,caps = Caps} = Pr,
              #state{watchdogT = WatchdogT,
                     local_peers = LDict,
                     service_name = SvcName,
                     service = #diameter_service{applications = Apps}} =
                  S) ->
    insert(WatchdogT, Wd#watchdog{state = okay}),
    diameter_traffic:peer_up(TPid),
    insert_local_peer(SApps, {{TPid,Caps},{SvcName,Apps}}, LDict),
    report_status(up, Wd, Pr, S, Extra).

insert_local_peer(SApps, T, LDict) ->
    lists:foldl(fun(A, D) ->
                       ilp(A, T, D)
                end,
                LDict,
                SApps).

ilp({Id,Alias}, {TC,SA}, LDict) ->
    init_conn(Id, Alias, TC, SA),
    diameter_dict:append(Alias, TC, LDict).

init_conn(Id, Alias, {TPid,_} = TC, {SvcName,Apps}) ->
    #diameter_app{id = Id} = App = find_app(Alias, Apps),
    peer_cb(App, peer_up, [SvcName,TC])
    orelse
    exit(TPid, kill).

find_incoming_app(#peer{caps = Caps}, 4294967295, _) ->
    Caps;
find_incoming_app(Peer, Id, Apps) when is_integer(Id) ->
    find_incoming_app(Peer, [Id,4294967295], Apps);
find_incoming_app(#peer{apps = SApps,caps = Caps}, Ids, Apps) ->
    case keyfind(Ids, 1, SApps) of
        {_Id,Alias} ->
            {#diameter_app{} = find_app(Alias, Apps),Caps};
        false ->
            Caps
    end.

keyfind([], _, _) ->
    false;
keyfind([Key|Rest], Pos, L) ->
    case lists:keyfind(Key, Pos, L) of
        false ->
            keyfind(Rest, Pos, L);
        T ->
            T
    end.

get_value(_, [], Def) ->
    Def;
get_value(Key, [L|Rest], Def) ->
    case lists:keyfind(Key, 1, L) of
        {_,V} ->
            V;
        _ ->
            get_value(Key, Rest, Def)
    end.

find_outgoing_app(Alias, Apps) ->
    case find_app(Alias, Apps) of
        #diameter_app{id = 4294967295} ->
            false;
        A ->
            A
    end.

find_app(Alias, Apps) ->
    lists:keyfind(Alias, #diameter_app.alias, Apps).

peer_cb(App, F, A) ->
    try state_cb(App, F, A) of
        ModS ->
            mod_state(App#diameter_app.alias, ModS),
            true
    catch
        E:R ->
            diameter_lib:error_report({failure,
                                       {E,R,erlang:get_stacktrace()}},
                                      {App,F,A}),
            false
    end.

connection_down(#watchdog{state = okay,peer = TPid} = Wd,
                #peer{caps = Caps,apps = SApps} = Pr,
                #state{service_name = SvcName,
                       service = #diameter_service{applications = Apps},
                       local_peers = LDict} =
                    S) ->
    report_status(down, Wd, Pr, S, []),
    remove_local_peer(SApps, {{TPid,Caps},{SvcName,Apps}}, LDict),
    diameter_traffic:peer_down(TPid);
connection_down(#watchdog{state = okay,peer = TPid} = Wd,
                To,
                #state{peerT = PeerT} = S)
    when is_atom(To) ->
    connection_down(Wd, #peer{} = fetch(PeerT, TPid), S);
connection_down(#watchdog{}, _, _) ->
    ok.

remove_local_peer(SApps, T, LDict) ->
    lists:foldl(fun(A, D) ->
                       rlp(A, T, D)
                end,
                LDict,
                SApps).

rlp({Id,Alias}, {TC,SA}, LDict) ->
    L = diameter_dict:fetch(Alias, LDict),
    down_conn(Id, Alias, TC, SA),
    diameter_dict:store(Alias, lists:delete(TC, L), LDict).

down_conn(Id, Alias, TC, {SvcName,Apps}) ->
    #diameter_app{id = Id} = App = find_app(Alias, Apps),
    peer_cb(App, peer_down, [SvcName,TC]).

watchdog_down(Pid, #state{watchdogT = WatchdogT} = S) ->
    Wd = fetch(WatchdogT, Pid),
    ets:delete_object(WatchdogT, Wd),
    restart(Wd, S),
    wd_down(Wd, S).

wd_down(#watchdog{peer = B}, _) when is_boolean(B) ->
    ok;
wd_down(#watchdog{peer = TPid} = Wd, #state{peerT = PeerT} = S) ->
    connection_down(Wd, down, S),
    ets:delete(PeerT, TPid).

restart(Wd, S) ->
    q_restart(restart(Wd), S).

restart(#watchdog{ref = Ref,
                  type = connect = T,
                  options = Opts,
                  started = Time}) ->
    {Time,{Ref,T,Opts}};
restart(#watchdog{ref = Ref,
                  type = accept = T,
                  options = Opts,
                  peer = false,
                  started = Time}) ->
    {Time,{Ref,T,Opts}};
restart(#watchdog{type = accept}) ->
    false.

q_restart({Time,{_Ref,Type,Opts} = T}, S) ->
    start_tc(tc(Time, default_tc(Type, Opts)), T, S);
q_restart(false, _) ->
    ok.

default_tc(connect, Opts) ->
    proplists:get_value(reconnect_timer, Opts, 30000);
default_tc(accept, _) ->
    0.

tc(Time, Tc) ->
    choose(Tc > 1000
           orelse
           timer:now_diff(now(), Time) > 1000 * 1000,
           Tc,
           1000).

start_tc(0, T, S) ->
    tc_timeout(T, S);
start_tc(Tc, T, _) ->
    erlang:send_after(Tc, self(), {tc_timeout,T}).

tc_timeout({Ref,_Type,_Opts} = T, #state{service_name = SvcName} = S) ->
    tc(diameter_config:have_transport(SvcName, Ref), T, S).

tc(true, {Ref,Type,Opts}, #state{service_name = SvcName} = S) ->
    send_event(SvcName, {reconnect,Ref,Opts}),
    start(Ref, Type, Opts, S);
tc(false = No, _, _) ->
    No.

close(#watchdog{type = connect}, _) ->
    ok;
close(#watchdog{type = accept,pid = Pid,ref = Ref,options = Opts},
      #state{service_name = SvcName}) ->
    c(Pid, diameter_config:have_transport(SvcName, Ref), Opts).

c(Pid, true, Opts) ->
    Tc = proplists:get_value(reconnect_timer, Opts, 2 * 30000),
    erlang:send_after(Tc, Pid, close);
c(Pid, false, _Opts) ->
    Pid ! close.

reconnect(Pid, #state{service_name = SvcName,watchdogT = WatchdogT}) ->
    #watchdog{ref = Ref,type = connect,options = Opts} =
        fetch(WatchdogT, Pid),
    send_event(SvcName, {reconnect,Ref,Opts}).

call_module(Mod,
            Req,
            From,
            #state{service = #diameter_service{applications = Apps},
                   service_name = Svc} =
                S) ->
    case
        cm([ 
            A ||
                A <- Apps,
                Mod == hd(A#diameter_app.module)
           ],
           Req,
           From,
           Svc)
    of
        {reply = T,RC} ->
            {T,RC,S};
        noreply = T ->
            {T,S};
        Reason ->
            {reply,{error,Reason},S}
    end.

cm([#diameter_app{alias = Alias} = App], Req, From, Svc) ->
    Args = [Req,From,Svc],
    try state_cb(App, handle_call, Args) of
        {noreply = T,ModS} ->
            mod_state(Alias, ModS),
            T;
        {reply = T,RC,ModS} ->
            mod_state(Alias, ModS),
            {T,RC};
        T ->
            diameter_lib:error_report({invalid,T},
                                      {App,handle_call,Args}),
            invalid
    catch
        E:Reason ->
            diameter_lib:error_report({failure,
                                       {E,
                                        Reason,
                                        erlang:get_stacktrace()}},
                                      {App,handle_call,Args}),
            failure
    end;
cm([], _, _, _) ->
    unknown;
cm([_,_|_], _, _, _) ->
    multiple.

report_status(Status,
              #watchdog{ref = Ref,
                        peer = TPid,
                        type = Type,
                        options = Opts},
              #peer{apps = [_|_] = Apps,caps = Caps},
              #state{service_name = SvcName} = S,
              Extra) ->
    share_peer(Status, Caps, Apps, TPid, S),
    Info = [Status,Ref,{TPid,Caps},{type(Type),Opts}|Extra],
    send_event(SvcName, list_to_tuple(Info)).

send_event(SvcName, Info) ->
    send_event(#diameter_event{service = SvcName,info = Info}).

send_event(#diameter_event{service = SvcName} = E) ->
    lists:foreach(fun({_,Pid}) ->
                         Pid ! E
                  end,
                  subscriptions(SvcName)).

share_peer(up,
           Caps,
           Apps,
           TPid,
           #state{options = [_,{_,T}|_],service_name = Svc}) ->
    notify(T,
           Svc,
           {peer,
            TPid,
            [ 
             A ||
                 {_,A} <- Apps
            ],
            Caps});
share_peer(_, _, _, _, _) ->
    ok.

share_peers(Pid, #state{options = [_,{_,T}|_],local_peers = PDict}) ->
    is_remote(Pid, T)
    andalso
    diameter_dict:fold(fun(A, Ps, ok) ->
                              sp(Pid, A, Ps),
                              ok
                       end,
                       ok,
                       PDict).

sp(Pid, Alias, Peers) ->
    lists:foreach(fun({P,C}) ->
                         Pid ! {peer,P,[Alias],C}
                  end,
                  Peers).

is_remote(Pid, T) ->
    Node = node(Pid),
    Node /= node()
    andalso
    lists:member(Node, remotes(T)).

remote_peer_up(Pid, Aliases, Caps, #state{options = [_,_,{_,T}|_]} = S) ->
    is_remote(Pid, T)
    andalso
    rpu(Pid, Aliases, Caps, S).

rpu(Pid, Aliases, Caps, #state{service = Svc,shared_peers = PDict}) ->
    #diameter_service{applications = Apps} = Svc,
    Key = #diameter_app.alias,
    F = fun(A) ->
               lists:keymember(A, Key, Apps)
        end,
    rpu(Pid, lists:filter(F, Aliases), Caps, PDict);
rpu(_, [] = No, _, _) ->
    No;
rpu(Pid, Aliases, Caps, PDict) ->
    monitor(process, Pid),
    T = {Pid,Caps},
    lists:foreach(fun(A) ->
                         diameter_dict:append(A, T, PDict)
                  end,
                  Aliases).

remote_peer_down(Pid, #state{shared_peers = PDict}) ->
    lists:foreach(fun(A) ->
                         rpd(Pid, A, PDict)
                  end,
                  diameter_dict:fetch_keys(PDict)).

rpd(Pid, Alias, PDict) ->
    diameter_dict:update(Alias,
                         fun(Ps) ->
                                lists:keydelete(Pid, 1, Ps)
                         end,
                         PDict).

pick_peer(#diameter_app{alias = Alias} = App,
          RealmAndHost,
          Filter,
          #state{local_peers = L,
                 shared_peers = S,
                 service_name = SvcName,
                 service = #diameter_service{pid = Pid}}) ->
    pick_peer(peers(Alias, RealmAndHost, Filter, L),
              peers(Alias, RealmAndHost, Filter, S),
              Pid,
              SvcName,
              App).

pick_peer([], [], _, _, _) ->
    false;
pick_peer(Local,
          Remote,
          Pid,
          _SvcName,
          #diameter_app{mutable = true} = App)
    when self() /= Pid ->
    case call_service(Pid, {pick_peer,Local,Remote,App}) of
        {TPid,_} = T when is_pid(TPid) ->
            T;
        {error,_} ->
            false
    end;
pick_peer(Local,
          Remote,
          _Pid,
          SvcName,
          #diameter_app{alias = Alias,init_state = S,mutable = M} = App) ->
    Args = [Local,Remote,SvcName],
    try state_cb(App, pick_peer, Args) of
        {ok,{TPid,#diameter_caps{}} = T} when is_pid(TPid) ->
            T;
        {{TPid,#diameter_caps{}} = T,ModS} when is_pid(TPid), M ->
            mod_state(Alias, ModS),
            T;
        {false = No,ModS} when M ->
            mod_state(Alias, ModS),
            No;
        {ok,false = No} ->
            No;
        false = No ->
            No;
        {{TPid,#diameter_caps{}} = T,S} when is_pid(TPid) ->
            T;
        {false = No,S} ->
            No;
        T ->
            diameter_lib:error_report({invalid,T,App},
                                      {App,pick_peer,Args})
    catch
        E:Reason ->
            diameter_lib:error_report({failure,
                                       {E,
                                        Reason,
                                        erlang:get_stacktrace()}},
                                      {App,pick_peer,Args})
    end.

peers(Alias, RH, Filter, Peers) ->
    case diameter_dict:find(Alias, Peers) of
        {ok,L} ->
            ps(L, RH, Filter, {[],[]});
        error ->
            []
    end.

ps([], _, _, {Ys,Ns}) ->
    lists:reverse(Ys, Ns);
ps([{_TPid,#diameter_caps{} = Caps} = TC|Rest], RH, Filter, Acc) ->
    ps(Rest,
       RH,
       Filter,
       pacc(caps_filter(Caps, RH, Filter),
            caps_filter(Caps, RH, {all,[host,realm]}),
            TC,
            Acc)).

pacc(true, true, Peer, {Ts,Fs}) ->
    {[Peer|Ts],Fs};
pacc(true, false, Peer, {Ts,Fs}) ->
    {Ts,[Peer|Fs]};
pacc(_, _, _, Acc) ->
    Acc.

caps_filter(C, RH, {neg,F}) ->
    not caps_filter(C, RH, F);
caps_filter(C, RH, {all,L}) when is_list(L) ->
    lists:all(fun(F) ->
                     caps_filter(C, RH, F)
              end,
              L);
caps_filter(C, RH, {any,L}) when is_list(L) ->
    lists:any(fun(F) ->
                     caps_filter(C, RH, F)
              end,
              L);
caps_filter(#diameter_caps{origin_host = {_,OH}}, [_,DH], host) ->
    eq(undefined, DH, OH);
caps_filter(#diameter_caps{origin_realm = {_,OR}}, [DR,_], realm) ->
    eq(undefined, DR, OR);
caps_filter(C, _, Filter) ->
    caps_filter(C, Filter).

caps_filter(_, none) ->
    true;
caps_filter(#diameter_caps{origin_host = {_,OH}}, {host,H}) ->
    eq(any, H, OH);
caps_filter(#diameter_caps{origin_realm = {_,OR}}, {realm,R}) ->
    eq(any, R, OR);
caps_filter(C, T) ->
    try
        {eval,F} = T,
        diameter_lib:eval([F,C])
    catch
        _:_ ->
            false
    end.

eq(Any, Id, PeerId) ->
    Any == Id
    orelse
    try
        iolist_to_binary(Id) == iolist_to_binary(PeerId)
    catch
        _:_ ->
            false
    end.

transports(#state{watchdogT = WatchdogT}) ->
    ets:select(WatchdogT,
               [{#watchdog{peer = '$1',_ = '_'},[{is_pid,'$1'}],['$1']}]).

service_info(Item, S) when is_atom(Item) ->
    case tagged_info(Item, S) of
        {_,T} ->
            T;
        undefined = No ->
            No
    end;
service_info(Items, S) ->
    tagged_info(Items, S).

tagged_info(Item, S) when is_atom(Item) ->
    case complete(Item) of
        {value,I} ->
            {I,complete_info(I, S)};
        false ->
            undefined
    end;
tagged_info(TPid, #state{watchdogT = WatchdogT,peerT = PeerT})
    when is_pid(TPid) ->
    try
        [#peer{watchdog = Pid}] = ets:lookup(PeerT, TPid),
        [#watchdog{ref = Ref,type = Type,options = Opts}] =
            ets:lookup(WatchdogT, Pid),
        [{ref,Ref},{type,Type},{options,Opts}]
    catch
        error:_ ->
            []
    end;
tagged_info(Items, S) when is_list(Items) ->
    [ 
     T ||
         I <- Items,
         T <- [tagged_info(I, S)],
         T /= undefined,
         T /= []
    ];
tagged_info(_, _) ->
    undefined.

complete_info(Item, #state{service = Svc} = S) ->
    case Item of
        name ->
            S#state.service_name;
        'Origin-Host' ->
            (Svc#diameter_service.capabilities)#diameter_caps.origin_host;
        'Origin-Realm' ->
            (Svc#diameter_service.capabilities)#diameter_caps.origin_realm;
        'Vendor-Id' ->
            (Svc#diameter_service.capabilities)#diameter_caps.vendor_id;
        'Product-Name' ->
            (Svc#diameter_service.capabilities)#diameter_caps.product_name;
        'Origin-State-Id' ->
            (Svc#diameter_service.capabilities)#diameter_caps.origin_state_id;
        'Host-IP-Address' ->
            (Svc#diameter_service.capabilities)#diameter_caps.host_ip_address;
        'Supported-Vendor-Id' ->
            (Svc#diameter_service.capabilities)#diameter_caps.supported_vendor_id;
        'Auth-Application-Id' ->
            (Svc#diameter_service.capabilities)#diameter_caps.auth_application_id;
        'Inband-Security-Id' ->
            (Svc#diameter_service.capabilities)#diameter_caps.inband_security_id;
        'Acct-Application-Id' ->
            (Svc#diameter_service.capabilities)#diameter_caps.acct_application_id;
        'Vendor-Specific-Application-Id' ->
            (Svc#diameter_service.capabilities)#diameter_caps.vendor_specific_application_id;
        'Firmware-Revision' ->
            (Svc#diameter_service.capabilities)#diameter_caps.firmware_revision;
        capabilities ->
            service_info(['Origin-Host',
                          'Origin-Realm',
                          'Vendor-Id',
                          'Product-Name',
                          'Origin-State-Id',
                          'Host-IP-Address',
                          'Supported-Vendor-Id',
                          'Auth-Application-Id',
                          'Inband-Security-Id',
                          'Acct-Application-Id',
                          'Vendor-Specific-Application-Id',
                          'Firmware-Revision'],
                         S);
        applications ->
            info_apps(S);
        transport ->
            info_transport(S);
        options ->
            info_options(S);
        pending ->
            info_pending(S);
        keys ->
            [capabilities,applications,transport,pending,options]
            ++
            ['Origin-Host',
             'Origin-Realm',
             'Vendor-Id',
             'Product-Name',
             'Origin-State-Id',
             'Host-IP-Address',
             'Supported-Vendor-Id',
             'Auth-Application-Id',
             'Inband-Security-Id',
             'Acct-Application-Id',
             'Vendor-Specific-Application-Id',
             'Firmware-Revision']
            ++
            [connections,name,peers,statistics];
        all ->
            service_info([capabilities,
                          applications,
                          transport,
                          pending,
                          options],
                         S);
        statistics ->
            info_stats(S);
        connections ->
            info_connections(S);
        peers ->
            info_peers(S)
    end.

complete(I) when I == keys; I == all ->
    {value,I};
complete(Pre) ->
    P = atom_to_list(Pre),
    case
        [ 
         I ||
             I <-
                 [capabilities,applications,transport,pending,options]
                 ++
                 ['Origin-Host',
                  'Origin-Realm',
                  'Vendor-Id',
                  'Product-Name',
                  'Origin-State-Id',
                  'Host-IP-Address',
                  'Supported-Vendor-Id',
                  'Auth-Application-Id',
                  'Inband-Security-Id',
                  'Acct-Application-Id',
                  'Vendor-Specific-Application-Id',
                  'Firmware-Revision']
                 ++
                 [connections,name,peers,statistics],
             lists:prefix(P, atom_to_list(I))
        ]
    of
        [I] ->
            {value,I};
        _ ->
            false
    end.

info_stats(#state{watchdogT = WatchdogT}) ->
    MatchSpec =
        [{#watchdog{ref = '$1',peer = '$2',_ = '_'},
          [{is_pid,'$2'}],
          [['$1','$2']]}],
    try ets:select(WatchdogT, MatchSpec) of
        L ->
            diameter_stats:read(lists:append(L))
    catch
        error:badarg ->
            []
    end.

info_transport(S) ->
    PeerD = peer_dict(S, config_dict(S)),
    Stats = diameter_stats:sum(dict:fetch_keys(PeerD)),
    dict:fold(fun(R, Ls, A) ->
                     Cs = proplists:get_value(R, Stats, []),
                     [[{ref,R}|transport(Ls)] ++ [{statistics,Cs}]|A]
              end,
              [],
              PeerD).

transport([[{type,listen},_] = L]) ->
    L ++ [{accept,[]}];
transport([[{type,connect}|_] = L]) ->
    L;
transport([[_,_]|L]) ->
    transport(L);
transport([[{type,accept},{options,Opts}|_]|_] = Ls) ->
    [{type,listen},
     {options,Opts},
     {accept,
      [ 
       lists:nthtail(2, L) ||
           L <- Ls
      ]}].

peer_dict(#state{watchdogT = WatchdogT,peerT = PeerT}, Dict0) ->
    try ets:tab2list(WatchdogT) of
        L ->
            lists:foldl(fun(T, A) ->
                               peer_acc(PeerT, A, T)
                        end,
                        Dict0,
                        L)
    catch
        error:badarg ->
            Dict0
    end.

peer_acc(PeerT,
         Acc,
         #watchdog{pid = Pid,
                   type = Type,
                   ref = Ref,
                   options = Opts,
                   state = WS,
                   started = At,
                   peer = TPid}) ->
    dict:append(Ref,
                [{type,Type},
                 {options,Opts},
                 {watchdog,{Pid,At,WS}}|
                 info_peer(PeerT, TPid, WS)],
                Acc).

info_peer(PeerT, TPid, WS) when is_pid(TPid), WS /= down ->
    try ets:lookup(PeerT, TPid) of
        T ->
            info_peer(T)
    catch
        error:badarg ->
            []
    end;
info_peer(_, _, _) ->
    [].

config_dict(#state{service_name = SvcName}) ->
    lists:foldl(fun config_acc/2,
                dict:new(),
                diameter_config:lookup(SvcName)).

config_acc({Ref,T,Opts}, Dict) when T == listen; T == connect ->
    dict:store(Ref, [[{type,T},{options,Opts}]], Dict);
config_acc(_, Dict) ->
    Dict.

info_peer([#peer{pid = Pid,apps = SApps,caps = Caps,started = T}]) ->
    [{peer,{Pid,T}},
     {apps,SApps},
     {caps,info_caps(Caps)}|
     try
         [{port,info_port(Pid)}]
     catch
         _:_ ->
             []
     end];
info_peer([] = No) ->
    No.

info_port(Pid) ->
    {_,PD} = process_info(Pid, dictionary),
    {_,T} = lists:keyfind({diameter_peer_fsm,start}, 1, PD),
    {TPid,{_Type,TMod,_Cfg}} = T,
    {_,TD} = process_info(TPid, dictionary),
    {_,Data} = lists:keyfind({TMod,info}, 1, TD),
    [{owner,TPid},
     {module,TMod}|
     try
         TMod:info(Data)
     catch
         _:_ ->
             []
     end].

info_caps(#diameter_caps{} = C) ->
    lists:zip(record_info(fields, diameter_caps), tl(tuple_to_list(C))).

info_apps(#state{service = #diameter_service{applications = Apps}}) ->
    lists:map(fun mk_app/1, Apps).

mk_app(#diameter_app{} = A) ->
    lists:zip(record_info(fields, diameter_app), tl(tuple_to_list(A))).

info_pending(#state{} = S) ->
    diameter_traffic:pending(transports(S)).

info_connections(S) ->
    ConnL = conn_list(S),
    Stats =
        diameter_stats:read([ 
                             P ||
                                 L <- ConnL,
                                 {peer,{P,_}} <- L
                            ]),
    [ 
     L ++ [stats([P], Stats)] ||
         L <- ConnL,
         {peer,{P,_}} <- L
    ].

conn_list(S) ->
    lists:append(dict:fold(fun conn_acc/3, [], peer_dict(S, dict:new()))).

conn_acc(Ref, Peers, Acc) ->
    [[ 
      [{ref,Ref}|L] ||
          L <- Peers,
          lists:keymember(peer, 1, L)
     ]|
     Acc].

stats(Refs, Stats) ->
    {statistics,
     dict:to_list(lists:foldl(fun(R, D) ->
                                     stats_acc(R, D, Stats)
                              end,
                              dict:new(),
                              Refs))}.

stats_acc(Ref, Dict, Stats) ->
    lists:foldl(fun({C,N}, D) ->
                       dict:update_counter(C, N, D)
                end,
                Dict,
                proplists:get_value(Ref, Stats, [])).

info_peers(S) ->
    {PeerD,RefD} =
        lists:foldl(fun peer_acc/2,
                    {dict:new(),dict:new()},
                    conn_list(S)),
    Refs =
        lists:append(dict:fold(fun(_, Rs, A) ->
                                      [Rs|A]
                               end,
                               [],
                               RefD)),
    Stats = diameter_stats:read(Refs),
    dict:fold(fun(OH, Cs, A) ->
                     Rs = dict:fetch(OH, RefD),
                     [{OH,[{connections,Cs},stats(Rs, Stats)]}|A]
              end,
              [],
              PeerD).

peer_acc(Peer, {PeerD,RefD}) ->
    [{TPid,_},[{origin_host,{_,OH}}|_]] =
        [ 
         proplists:get_value(K, Peer) ||
             K <- [peer,caps]
        ],
    {dict:append(OH, Peer, PeerD),dict:append(OH, TPid, RefD)}.

info_options(S) ->
    S#state.options.



