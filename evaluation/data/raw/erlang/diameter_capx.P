-file("test/lib/diameter/src/base/diameter_capx.erl", 1).

-module(diameter_capx).

-export([build_CER/2,recv_CER/3,recv_CEA/3,make_caps/2]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/diameter-1.3/include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options = [{answer_errors,report}]}).

-file("test/lib/diameter/src/base/diameter_capx.erl", 56).

-file("test/lib/diameter/src/base/diameter_internal.hrl", 1).

-record(diameter_peer,{host_id,
                       statusT,
                       is_dynamic,
                       expiration,
                       tls_enabled}).

-record(diameter_realm,{name,
                        app_id,
                        local_action,
                        server_id,
                        is_dynamic,
                        expiration}).

-file("test/lib/diameter/src/base/diameter_capx.erl", 57).

-type tried(T) :: {ok, T} | {error, {term(), list()}}.

-spec build_CER(#diameter_caps{}, module()) -> tried(CER)
                   when is_subtype(CER, tuple()).

build_CER(Caps, Dict) ->
    try_it([fun bCER/2,Caps,Dict]).

-spec recv_CER(CER, #diameter_service{}, module()) ->
                  tried({[diameter:'Unsigned32'()],
                         #diameter_caps{},
                         CEA})
                  when
                      is_subtype(CER, tuple()), is_subtype(CEA, tuple()).

recv_CER(CER, Svc, Dict) ->
    try_it([fun rCER/3,CER,Svc,Dict]).

-spec recv_CEA(CEA, #diameter_service{}, module()) ->
                  tried({[diameter:'Unsigned32'()],
                         [diameter:'Unsigned32'()],
                         #diameter_caps{}})
                  when is_subtype(CEA, tuple()).

recv_CEA(CEA, Svc, Dict) ->
    try_it([fun rCEA/3,CEA,Svc,Dict]).

make_caps(Caps, Opts) ->
    try_it([fun mk_caps/2,Caps,Opts]).

try_it([Fun|Args]) ->
    try apply(Fun, Args) of
        T ->
            {ok,T}
    catch
        {{diameter_capx},{Reason}} ->
            {error,Reason}
    end.

mk_caps(Caps0, Opts) ->
    {Caps,_} =
        lists:foldl(fun set_cap/2,
                    {Caps0,#diameter_caps{_ = false}},
                    Opts),
    Caps.

set_cap({'Origin-Host',Val},
        {Caps,#diameter_caps{origin_host = false} = C}) ->
    {Caps#diameter_caps{origin_host = cap('Origin-Host', Val)},
     C#diameter_caps{origin_host = true}};
set_cap({'Origin-Realm',Val},
        {Caps,#diameter_caps{origin_realm = false} = C}) ->
    {Caps#diameter_caps{origin_realm = cap('Origin-Realm', Val)},
     C#diameter_caps{origin_realm = true}};
set_cap({'Host-IP-Address',Val},
        {Caps,#diameter_caps{host_ip_address = false} = C}) ->
    {Caps#diameter_caps{host_ip_address = cap('Host-IP-Address', Val)},
     C#diameter_caps{host_ip_address = true}};
set_cap({'Vendor-Id',Val}, {Caps,#diameter_caps{vendor_id = false} = C}) ->
    {Caps#diameter_caps{vendor_id = cap('Vendor-Id', Val)},
     C#diameter_caps{vendor_id = true}};
set_cap({'Product-Name',Val},
        {Caps,#diameter_caps{product_name = false} = C}) ->
    {Caps#diameter_caps{product_name = cap('Product-Name', Val)},
     C#diameter_caps{product_name = true}};
set_cap({'Origin-State-Id',Val},
        {Caps,#diameter_caps{origin_state_id = false} = C}) ->
    {Caps#diameter_caps{origin_state_id = cap('Origin-State-Id', Val)},
     C#diameter_caps{origin_state_id = true}};
set_cap({'Supported-Vendor-Id',Val},
        {Caps,#diameter_caps{supported_vendor_id = false} = C}) ->
    {Caps#diameter_caps{supported_vendor_id =
                            cap('Supported-Vendor-Id', Val)},
     C#diameter_caps{supported_vendor_id = true}};
set_cap({'Auth-Application-Id',Val},
        {Caps,#diameter_caps{auth_application_id = false} = C}) ->
    {Caps#diameter_caps{auth_application_id =
                            cap('Auth-Application-Id', Val)},
     C#diameter_caps{auth_application_id = true}};
set_cap({'Inband-Security-Id',Val},
        {Caps,#diameter_caps{inband_security_id = false} = C}) ->
    {Caps#diameter_caps{inband_security_id =
                            cap('Inband-Security-Id', Val)},
     C#diameter_caps{inband_security_id = true}};
set_cap({'Acct-Application-Id',Val},
        {Caps,#diameter_caps{acct_application_id = false} = C}) ->
    {Caps#diameter_caps{acct_application_id =
                            cap('Acct-Application-Id', Val)},
     C#diameter_caps{acct_application_id = true}};
set_cap({'Vendor-Specific-Application-Id',Val},
        {Caps,
         #diameter_caps{vendor_specific_application_id = false} = C}) ->
    {Caps#diameter_caps{vendor_specific_application_id =
                            cap('Vendor-Specific-Application-Id', Val)},
     C#diameter_caps{vendor_specific_application_id = true}};
set_cap({'Firmware-Revision',Val},
        {Caps,#diameter_caps{firmware_revision = false} = C}) ->
    {Caps#diameter_caps{firmware_revision =
                            cap('Firmware-Revision', Val)},
     C#diameter_caps{firmware_revision = true}};
set_cap({Key,_}, _) ->
    throw({{diameter_capx},{{duplicate,Key}}}).

cap(K, V)
    when
        K == 'Origin-Host';
        K == 'Origin-Realm';
        K == 'Vendor-Id';
        K == 'Product-Name' ->
    V;
cap('Host-IP-Address', Vs) when is_list(Vs) ->
    lists:map(fun ipaddr/1, Vs);
cap(K, V) when K == 'Firmware-Revision'; K == 'Origin-State-Id' ->
    [V];
cap(_, Vs) when is_list(Vs) ->
    Vs;
cap(K, V) ->
    throw({{diameter_capx},{{invalid,{K,V}}}}).

ipaddr(A) ->
    try
        diameter_lib:ipaddr(A)
    catch
        error:{invalid_address,_} = T ->
            throw({{diameter_capx},{T}})
    end.

bCER(#diameter_caps{} = Rec, Dict) ->
    Values =
        lists:zip(Dict:'#info-'(diameter_base_CER, fields),
                  tl(tuple_to_list(Rec))),
    Dict:'#new-'(diameter_base_CER,
                 [ 
                  {K,map(K, V, Dict)} ||
                      {K,V} <- Values
                 ]).

map('Vendor-Specific-Application-Id', L, Dict) ->
    Rec =
        Dict:'#new-'('diameter_base_Vendor-Specific-Application-Id', []),
    Def = Dict:'#get-'('Vendor-Id', Rec),
    [ 
     vsa(V, Def) ||
         V <- L
    ];
map(_, V, _) ->
    V.

vsa({_,N,_,_} = Rec, []) when is_integer(N) ->
    setelement(2, Rec, [N]);
vsa({_,[N],_,_} = Rec, undefined) when is_integer(N) ->
    setelement(2, Rec, N);
vsa([_|_] = L, Def) ->
    [ 
     vid(T, Def) ||
         T <- L
    ];
vsa(T, _) ->
    T.

vid({'Vendor-Id' = K,N}, []) when is_integer(N) ->
    {K,[N]};
vid({'Vendor-Id' = K,[N]}, undefined) ->
    {K,N};
vid(T, _) ->
    T.

rCER(CER, #diameter_service{capabilities = LCaps} = Svc, Dict) ->
    CEA = cea_from_cer(bCER(LCaps, Dict), Dict),
    RCaps = capx_to_caps(CER, Dict),
    SApps = common_applications(LCaps, RCaps, Svc),
    {SApps,
     RCaps,
     build_CEA(SApps,
               LCaps,
               RCaps,
               Dict,
               Dict:'#set-'({'Result-Code',2001}, CEA))}.

build_CEA([], _, _, Dict, CEA) ->
    Dict:'#set-'({'Result-Code',5010}, CEA);
build_CEA(_, LCaps, RCaps, Dict, CEA) ->
    case common_security(LCaps, RCaps) of
        [] ->
            Dict:'#set-'({'Result-Code',5017}, CEA);
        [_] = IS ->
            Dict:'#set-'({'Inband-Security-Id',inband_security(IS)},
                         CEA)
    end.

inband_security([0]) ->
    [];
inband_security([_] = IS) ->
    IS.

common_security(#diameter_caps{inband_security_id = LS},
                #diameter_caps{inband_security_id = RS}) ->
    cs(LS, RS).

cs([], RS) ->
    cs([0], RS);
cs(LS, []) ->
    cs(LS, [0]);
cs(LS, RS) ->
    Is =
        ordsets:to_list(ordsets:intersection(ordsets:from_list(LS),
                                             ordsets:from_list(RS))),
    case lists:member(1, Is) of
        true ->
            [1];
        false when [] == Is ->
            Is;
        false ->
            [hd(Is)]
    end.

cea_from_cer(CER, Dict) ->
    [diameter_base_CER|Values] = Dict:'#get-'(CER),
    Dict:'#set-'(Values, Dict:'#new-'(diameter_base_CEA)).

rCEA(CEA, #diameter_service{capabilities = LCaps} = Svc, Dict) ->
    RCaps = capx_to_caps(CEA, Dict),
    SApps = common_applications(LCaps, RCaps, Svc),
    IS = common_security(LCaps, RCaps),
    {SApps,IS,RCaps}.

capx_to_caps(CEX, Dict) ->
    [OH,OR,IP,VId,PN,OSI,SV,Auth,IS,Acct,VSA,FR,X] =
        Dict:'#get-'(['Origin-Host',
                      'Origin-Realm',
                      'Host-IP-Address',
                      'Vendor-Id',
                      'Product-Name',
                      'Origin-State-Id',
                      'Supported-Vendor-Id',
                      'Auth-Application-Id',
                      'Inband-Security-Id',
                      'Acct-Application-Id',
                      'Vendor-Specific-Application-Id',
                      'Firmware-Revision',
                      'AVP'],
                     CEX),
    #diameter_caps{origin_host = OH,
                   origin_realm = OR,
                   vendor_id = VId,
                   product_name = PN,
                   origin_state_id = OSI,
                   host_ip_address = IP,
                   supported_vendor_id = SV,
                   auth_application_id = Auth,
                   inband_security_id = IS,
                   acct_application_id = Acct,
                   vendor_specific_application_id = VSA,
                   firmware_revision = FR,
                   avp = X}.

common_applications(LCaps,
                    RCaps,
                    #diameter_service{applications = Apps}) ->
    LA = app_union(LCaps),
    RA = app_union(RCaps),
    lists:foldl(fun(I, A) ->
                       ca(I, Apps, RA, A)
                end,
                [],
                LA).

ca(Id, Apps, RA, Acc) ->
    Relay = lists:member(4294967295, RA),
    #diameter_app{alias = Alias} = find_app(Id, Apps),
    tcons(Relay
          orelse
          4294967295 == Id
          orelse
          lists:member(Id, RA),
          Id,
          Alias,
          Acc).

app_union(#diameter_caps{auth_application_id = U,
                         acct_application_id = C,
                         vendor_specific_application_id = V}) ->
    set_list(U ++ C ++ lists:flatmap(fun vsa_apps/1, V)).

vsa_apps(Vals) when is_list(Vals) ->
    lists:flatmap(fun({'Vendor-Id',_}) ->
                         [];
                     ({_,Ids}) ->
                         Ids
                  end,
                  Vals);
vsa_apps(Rec) when is_tuple(Rec) ->
    [_Name,_VendorId|Idss] = tuple_to_list(Rec),
    lists:append(Idss).

find_app(Id, Apps) ->
    case lists:keyfind(Id, #diameter_app.id, Apps) of
        #diameter_app{} = A ->
            A;
        false ->
            throw({{diameter_capx},{{app_not_configured,Id}}})
    end.

set_list(L) ->
    sets:to_list(sets:from_list(L)).

tcons(true, K, V, Acc) ->
    [{K,V}|Acc];
tcons(false, _, _, Acc) ->
    Acc.



