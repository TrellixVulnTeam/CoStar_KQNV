-file("test/lib/common_test/test/ct_hooks_SUITE_data/cth/tests/empty_cth.erl",
      1).

-module(empty_cth).

-export([id/1]).

-export([init/2]).

-export([pre_init_per_suite/3]).

-export([post_init_per_suite/4]).

-export([pre_end_per_suite/3]).

-export([post_end_per_suite/4]).

-export([pre_init_per_group/3]).

-export([post_init_per_group/4]).

-export([pre_end_per_group/3]).

-export([post_end_per_group/4]).

-export([pre_init_per_testcase/3]).

-export([post_end_per_testcase/4]).

-export([on_tc_fail/3]).

-export([on_tc_skip/3]).

-export([terminate/1]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/common_test-1.6.3/src/ct_util.hrl",
      1).

-record(conn,{handle,targetref,address,callback}).

-record(testspec,{spec_dir,
                  nodes = [],
                  init = [],
                  label = [],
                  profile = [],
                  logdir = ["."],
                  logopts = [],
                  basic_html = [],
                  verbosity = [],
                  silent_connections = [],
                  cover = [],
                  config = [],
                  userconfig = [],
                  event_handler = [],
                  ct_hooks = [],
                  enable_builtin_hooks = true,
                  release_shell = false,
                  include = [],
                  auto_compile = [],
                  stylesheet = [],
                  multiply_timetraps = [],
                  scale_timetraps = [],
                  create_priv_dir = [],
                  alias = [],
                  tests = [],
                  merge_tests = true}).

-record(cover,{app = none,
               level = details,
               excl_mods = [],
               incl_mods = [],
               cross = [],
               src = []}).

-record(conn_log,{client,name,address,action,module}).

-file("test/lib/common_test/test/ct_hooks_SUITE_data/cth/tests/empty_cth.erl",
      60).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/common_test-1.6.3/include/ct_event.hrl",
      1).

-record(event,{name,node,data}).

-file("test/lib/common_test/test/ct_hooks_SUITE_data/cth/tests/empty_cth.erl",
      61).

-type config() :: proplists:proplist().

-type reason() :: term().

-type skip_or_fail() :: {skip, reason()}
                      | {auto_skip, reason()}
                      | {fail, reason()}
                      | {'EXIT', reason()}.

-record(state,{id = empty_cth :: term()}).

-spec init(Id :: term(), Opts :: proplists:proplist()) ->
              {ok, State :: #state{}}.

init(Id, Opts) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data = {empty_cth,init,[Id,Opts]}}),
    {ok,Opts}.

-spec id(Opts :: proplists:proplist()) -> Id :: term().

id(Opts) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data = {empty_cth,id,[Opts]}}),
    now().

-spec pre_init_per_suite(Suite :: atom(),
                         Config :: config(),
                         State :: #state{}) ->
                            {config() | skip_or_fail(),
                             NewState :: #state{}}.

pre_init_per_suite(Suite, Config, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 pre_init_per_suite,
                                 [Suite,Config,State]}}),
    {Config,State}.

-spec post_init_per_suite(Suite :: atom(),
                          Config :: config(),
                          Return :: config() | skip_or_fail(),
                          State :: #state{}) ->
                             {config() | skip_or_fail(),
                              NewState :: #state{}}.

post_init_per_suite(Suite, Config, Return, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 post_init_per_suite,
                                 [Suite,Config,Return,State]}}),
    {Return,State}.

-spec pre_end_per_suite(Suite :: atom(),
                        Config :: config() | skip_or_fail(),
                        State :: #state{}) ->
                           {ok | skip_or_fail(), NewState :: #state{}}.

pre_end_per_suite(Suite, Config, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 pre_end_per_suite,
                                 [Suite,Config,State]}}),
    {Config,State}.

-spec post_end_per_suite(Suite :: atom(),
                         Config :: config(),
                         Return :: term(),
                         State :: #state{}) ->
                            {ok | skip_or_fail(), NewState :: #state{}}.

post_end_per_suite(Suite, Config, Return, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 post_end_per_suite,
                                 [Suite,Config,Return,State]}}),
    {Return,State}.

-spec pre_init_per_group(Group :: atom(),
                         Config :: config(),
                         State :: #state{}) ->
                            {config() | skip_or_fail(),
                             NewState :: #state{}}.

pre_init_per_group(Group, Config, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 pre_init_per_group,
                                 [Group,Config,State]}}),
    {Config,State}.

-spec post_init_per_group(Group :: atom(),
                          Config :: config(),
                          Return :: config() | skip_or_fail(),
                          State :: #state{}) ->
                             {config() | skip_or_fail(),
                              NewState :: #state{}}.

post_init_per_group(Group, Config, Return, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 post_init_per_group,
                                 [Group,Config,Return,State]}}),
    {Return,State}.

-spec pre_end_per_group(Group :: atom(),
                        Config :: config() | skip_or_fail(),
                        State :: #state{}) ->
                           {ok | skip_or_fail(), NewState :: #state{}}.

pre_end_per_group(Group, Config, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 pre_end_per_group,
                                 [Group,Config,State]}}),
    {Config,State}.

-spec post_end_per_group(Group :: atom(),
                         Config :: config(),
                         Return :: term(),
                         State :: #state{}) ->
                            {ok | skip_or_fail(), NewState :: #state{}}.

post_end_per_group(Group, Config, Return, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 post_end_per_group,
                                 [Group,Config,Return,State]}}),
    {Return,State}.

-spec pre_init_per_testcase(TC :: atom(),
                            Config :: config(),
                            State :: #state{}) ->
                               {config() | skip_or_fail(),
                                NewState :: #state{}}.

pre_init_per_testcase(TC, Config, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 pre_init_per_testcase,
                                 [TC,Config,State]}}),
    {Config,State}.

-spec post_end_per_testcase(TC :: atom(),
                            Config :: config(),
                            Return :: term(),
                            State :: #state{}) ->
                               {ok | skip_or_fail(),
                                NewState :: #state{}}.

post_end_per_testcase(TC, Config, Return, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,
                                 post_end_per_testcase,
                                 [TC,Config,Return,State]}}),
    {Return,State}.

-spec on_tc_fail(TC :: init_per_suite
                     | end_per_suite
                     | init_per_group
                     | end_per_group
                     | atom(),
                 Reason :: term(),
                 State :: #state{}) ->
                    NewState :: #state{}.

on_tc_fail(TC, Reason, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,on_tc_fail,[TC,Reason,State]}}),
    State.

-spec on_tc_skip(TC :: end_per_suite
                     | init_per_group
                     | end_per_group
                     | atom(),
                 {tc_auto_skip,
                  {failed,
                   {Mod :: atom(), Function :: atom(), Reason :: term()}}} |
                 {tc_user_skip, {skipped, Reason :: term()}},
                 State :: #state{}) ->
                    NewState :: #state{}.

on_tc_skip(TC, Reason, State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data =
                                {empty_cth,on_tc_skip,[TC,Reason,State]}}),
    State.

-spec terminate(State :: #state{}) -> term().

terminate(State) ->
    gen_event:notify(ct_event,
                     #event{name = cth,
                            node = node(),
                            data = {empty_cth,terminate,[State]}}),
    ok.



