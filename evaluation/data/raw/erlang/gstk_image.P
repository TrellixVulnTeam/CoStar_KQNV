-file("test/lib/gs/src/gstk_image.erl", 1).

-module(gstk_image).

-compile([{nowarn_deprecated_function,{gs,pair,2}}]).

-export([create/3,
         config/3,
         read/3,
         delete/2,
         destroy/3,
         event/5,
         option/5,
         read_option/5]).

-file("test/lib/gs/src/gstk.hrl", 1).

-record(gstkid,{id = undefined,widget,widget_data,owner,parent,objtype}).

-record(so,{main,object,hscroll,vscroll,misc}).

-file("test/lib/gs/src/gstk_image.erl", 74).

create(DB, Gstkid, Opts) ->
    case pickout_type(Opts) of
        bitmap ->
            create(bitmap, DB, Gstkid, Opts);
        _gif ->
            create(gif, DB, Gstkid, Opts)
    end.

create(gif, DB, Gstkid, Opts) ->
    case pickout_coords(Opts, []) of
        {error,Error} ->
            {bad_result,Error};
        {Coords,NewOpts} ->
            CCmd = "image create photo",
            case tcl2erl:ret_atom(CCmd) of
                Photo_item when is_atom(Photo_item) ->
                    #gstkid{parent = Parent,owner = Owner,id = Id} =
                        Gstkid,
                    Pgstkid = gstk_db:lookup_gstkid(DB, Parent, Owner),
                    SO = Pgstkid#gstkid.widget_data,
                    CanvasTkW = SO#so.object,
                    Photo_item_s = atom_to_list(Photo_item),
                    gstk_db:insert_opt(DB, Id, gs:pair(coords, Opts)),
                    Ngstkid =
                        Gstkid#gstkid{widget = CanvasTkW,
                                      widget_data =
                                          {Photo_item_s,unknown}},
                    gstk_db:update_widget(DB, Ngstkid),
                    MCmd =
                        [CanvasTkW,
                         " create image ",
                         Coords,
                         " -image ",
                         Photo_item_s,
                         " -anchor nw"],
                    case
                        gstk_canvas:make_command(NewOpts,
                                                 Ngstkid,
                                                 CanvasTkW,
                                                 MCmd,
                                                 DB)
                    of
                        {error,Reason} ->
                            {error,Reason};
                        Cmd when is_list(Cmd) ->
                            case tcl2erl:ret_int(Cmd) of
                                Item when is_integer(Item) ->
                                    G2 = gstk_db:lookup_gstkid(DB, Id),
                                    NewWidget = {Photo_item_s,Item},
                                    NewGstkid =
                                        G2#gstkid{widget_data =
                                                      NewWidget},
                                    gstk_db:insert_widget(DB, NewGstkid),
                                    NewGstkid;
                                Bad_result ->
                                    {error,Bad_result}
                            end
                    end;
                Bad_result ->
                    {error,Bad_result}
            end
    end;
create(bitmap, DB, Gstkid, Opts) ->
    case pickout_coords(Opts, []) of
        {error,Error} ->
            {bad_result,Error};
        {Coords,NewOpts} ->
            #gstkid{parent = Parent,owner = Owner,id = Id} = Gstkid,
            Pgstkid = gstk_db:lookup_gstkid(DB, Parent, Owner),
            SO = Pgstkid#gstkid.widget_data,
            CanvasTkW = SO#so.object,
            gstk_db:insert_opt(DB, Id, gs:pair(coords, Opts)),
            Ngstkid =
                Gstkid#gstkid{widget = CanvasTkW,widget_data = no_item},
            gstk_db:update_widget(DB, Ngstkid),
            MCmd = [CanvasTkW," create bi ",Coords],
            gstk_canvas:mk_cmd_and_call(NewOpts,
                                        Ngstkid,
                                        CanvasTkW,
                                        MCmd,
                                        DB)
    end.

config(DB, Gstkid, Opts) ->
    {Canvas,Item} = get_widget(Gstkid),
    AItem = gstk:to_ascii(Item),
    SCmd = [Canvas," itemconf ",AItem],
    gstk_canvas:mk_cmd_and_exec(Opts, Gstkid, Canvas, AItem, SCmd, DB).

read(DB, Gstkid, Opt) ->
    {_,Item} = get_widget(Gstkid),
    gstk_generic:read_option(DB, Gstkid, Opt, [gstk:to_ascii(Item)]).

delete(DB, Gstkid) ->
    gstk_db:delete_widget(DB, Gstkid),
    #gstkid{parent = P,id = ID} = Gstkid,
    {Canvas,Item} = get_widget(Gstkid),
    {P,ID,gstk_image,[Canvas,Item]}.

destroy(_DB, Canvas, Item) ->
    gstk:exec([Canvas," delete ",gstk:to_ascii(Item)]).

event(DB, Gstkid, Etype, Edata, Args) ->
    gstk_generic:event(DB, Gstkid, Etype, Edata, Args).

option(Option, Gstkid, _Canvas, _DB, _AItem) ->
    case Option of
        {bitmap,Bitmap} ->
            BF =
                re:replace(Bitmap, [92,92], "/", [global,{return,list}]),
            {s,[" -bi @",BF]};
        {load_gif,File} ->
            F2 = re:replace(File, [92,92], "/", [global,{return,list}]),
            {Photo_item,_item} = Gstkid#gstkid.widget_data,
            {c,[Photo_item," configure -file ",gstk:to_ascii(F2)]};
        {pix_val,{Coords,Color}} ->
            {Photo_item,_item} = Gstkid#gstkid.widget_data,
            {c,
             [Photo_item,
              " put ",
              gstk:to_color(Color),
              " -to ",
              coords(Coords)]};
        {save_gif,Name} ->
            {Photo_item,_item} = Gstkid#gstkid.widget_data,
            {c,[Photo_item," write ",gstk:to_ascii(Name)]};
        {fg,Color} ->
            {s,[" -fo ",gstk:to_color(Color)]};
        {bg,Color} ->
            {s,[" -ba ",gstk:to_color(Color)]};
        {anchor,How} ->
            {s,[" -anchor ",gstk:to_ascii(How)]};
        _ ->
            invalid_option
    end.

read_option(Option, Gstkid, Canvas, _DB, AItem) ->
    case Option of
        anchor ->
            tcl2erl:ret_atom([Canvas," itemcget ",AItem," -anchor"]);
        bg ->
            tcl2erl:ret_color([Canvas," itemcget ",AItem," -ba"]);
        bitmap ->
            tcl2erl:ret_file([Canvas," itemcget ",AItem," -bi"]);
        fg ->
            tcl2erl:ret_color([Canvas," itemcget ",AItem," -fo"]);
        {pix_val,{X,Y}} ->
            {Photo_item,_item} = Gstkid#gstkid.widget_data,
            ret_photo_color([Photo_item," get ",coords({X,Y})]);
        _ ->
            {bad_result,{Gstkid#gstkid.objtype,invalid_option,Option}}
    end.

ret_photo_color(Cmd) ->
    case gstk:call(Cmd) of
        {result,Str} ->
            {ok,[R,G,B],[]} = io_lib:fread("~d ~d ~d", Str),
            {R,G,B};
        Bad_result ->
            Bad_result
    end.

get_widget(#gstkid{widget = Canvas,widget_data = {_Photo_item,Item}}) ->
    {Canvas,Item};
get_widget(#gstkid{widget = Canvas,widget_data = Item}) ->
    {Canvas,Item}.

pickout_coords([{coords,Coords}|Rest], Opts) when length(Coords) == 1 ->
    case coords(Coords) of
        invalid ->
            {error,"An image must have two coordinates"};
        RealCoords ->
            {RealCoords,lists:append(Rest, Opts)}
    end;
pickout_coords([Opt|Rest], Opts) ->
    pickout_coords(Rest, [Opt|Opts]);
pickout_coords([], _Opts) ->
    {error,"An image must have two coordinates"}.

coords({X,Y}) when is_number(X), is_number(Y) ->
    [gstk:to_ascii(X)," ",gstk:to_ascii(Y)," "];
coords([{X,Y}|R]) when is_number(X), is_number(Y) ->
    [gstk:to_ascii(X)," ",gstk:to_ascii(Y)," ",coords(R)];
coords({{X1,Y1},{X2,Y2}})
    when is_number(X1), is_number(Y1), is_number(X2), is_number(Y2) ->
    [gstk:to_ascii(X1),
     " ",
     gstk:to_ascii(Y1),
     " ",
     gstk:to_ascii(X2),
     " ",
     gstk:to_ascii(Y2)];
coords([_]) ->
    invalid;
coords([]) ->
    [].

pickout_type([{bitmap,_Str}|_Options]) ->
    bitmap;
pickout_type([{gif,_Str}|_Options]) ->
    gif;
pickout_type([]) ->
    none;
pickout_type([_|Tail]) ->
    pickout_type(Tail).



