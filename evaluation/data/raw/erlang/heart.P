-file("test/lib/kernel/src/heart.erl", 1).

-module(heart).

-compile(no_native).

-export([start/0,init/2,set_cmd/1,clear_cmd/0,get_cmd/0,cycle/0]).

-spec start() -> ignore | {error, term()} | {ok, pid()}.

start() ->
    case whereis(heart) of
        undefined ->
            Pid = spawn(heart, init, [self(),whereis(init)]),
            wait_for_init_ack(Pid);
        Pid ->
            {ok,Pid}
    end.

wait_for_init_ack(From) ->
    receive
        {ok,From} = Ok ->
            Ok;
        {no_heart,From} ->
            ignore;
        {Error,From} ->
            {error,Error}
    end.

-spec init(pid(), pid()) -> {no_heart, pid()} | {start_error, pid()}.

init(Starter, Parent) ->
    process_flag(trap_exit, true),
    process_flag(priority, max),
    register(heart, self()),
    case catch start_portprogram() of
        {ok,Port} ->
            Starter ! {ok,self()},
            loop(Parent, Port, "");
        no_heart ->
            Starter ! {no_heart,self()};
        error ->
            Starter ! {start_error,self()}
    end.

-spec set_cmd(Cmd) -> ok | {error, {bad_cmd, Cmd}}
                 when is_subtype(Cmd, string()).

set_cmd(Cmd) ->
    heart ! {self(),set_cmd,Cmd},
    wait().

-spec get_cmd() -> {ok, Cmd} when is_subtype(Cmd, string()).

get_cmd() ->
    heart ! {self(),get_cmd},
    wait().

-spec clear_cmd() -> ok.

clear_cmd() ->
    heart ! {self(),clear_cmd},
    wait().

-spec cycle() -> ok | {error, term()}.

cycle() ->
    heart ! {self(),cycle},
    wait().

wait() ->
    receive
        {heart,Res} ->
            Res
    end.

start_portprogram() ->
    check_start_heart(),
    HeartCmd =
        "heart -pid " ++ os:getpid() ++ " " ++ get_heart_timeouts(),
    try open_port({spawn,HeartCmd}, [{packet,2}]) of
        Port when is_port(Port) ->
            case wait_ack(Port) of
                ok ->
                    register(heart_port, Port),
                    {ok,Port};
                {error,Reason} ->
                    report_problem({{port_problem,Reason},
                                    {heart,start_portprogram,[]}}),
                    error
            end
    catch
        _:Reason ->
            report_problem({{open_port,Reason},
                            {heart,start_portprogram,[]}}),
            error
    end.

get_heart_timeouts() ->
    HeartOpts =
        case os:getenv("HEART_BEAT_TIMEOUT") of
            false ->
                "";
            H when is_list(H) ->
                "-ht " ++ H
        end,
    HeartOpts
    ++
    case os:getenv("HEART_BEAT_BOOT_DELAY") of
        false ->
            "";
        W when is_list(W) ->
            " -wt " ++ W
    end.

check_start_heart() ->
    case init:get_argument(heart) of
        {ok,[[]]} ->
            ok;
        error ->
            throw(no_heart);
        {ok,[[X|_]|_]} ->
            report_problem({{bad_heart_flag,list_to_atom(X)},
                            {heart,check_start_heart,[]}}),
            throw(error)
    end.

wait_ack(Port) ->
    receive
        {Port,{data,[1]}} ->
            ok;
        {'EXIT',Port,badsig} ->
            wait_ack(Port);
        {'EXIT',Port,Reason} ->
            {error,Reason}
    end.

loop(Parent, Port, Cmd) ->
    send_heart_beat(Port),
    receive
        {From,set_cmd,NewCmd} when length(NewCmd) < 2047 ->
            send_heart_cmd(Port, NewCmd),
            wait_ack(Port),
            From ! {heart,ok},
            loop(Parent, Port, NewCmd);
        {From,set_cmd,NewCmd} ->
            From ! {heart,{error,{bad_cmd,NewCmd}}},
            loop(Parent, Port, Cmd);
        {From,clear_cmd} ->
            From ! {heart,ok},
            send_heart_cmd(Port, ""),
            wait_ack(Port),
            loop(Parent, Port, "");
        {From,get_cmd} ->
            From ! {heart,get_heart_cmd(Port)},
            loop(Parent, Port, Cmd);
        {From,cycle} ->
            do_cycle_port_program(From, Parent, Port, Cmd);
        {'EXIT',Parent,shutdown} ->
            no_reboot_shutdown(Port);
        {'EXIT',Parent,Reason} ->
            exit(Port, Reason),
            exit(Reason);
        {'EXIT',Port,badsig} ->
            loop(Parent, Port, Cmd);
        {'EXIT',Port,_Reason} ->
            exit({port_terminated,{heart,loop,[Parent,Port,Cmd]}});
        _ ->
            loop(Parent, Port, Cmd)
    after
        5000 -> loop(Parent, Port, Cmd)
    end.

-spec no_reboot_shutdown(port()) -> no_return().

no_reboot_shutdown(Port) ->
    send_shutdown(Port),
    receive
        {'EXIT',Port,Reason} when Reason =/= badsig ->
            exit(normal)
    end.

do_cycle_port_program(Caller, Parent, Port, Cmd) ->
    unregister(heart_port),
    case catch start_portprogram() of
        {ok,NewPort} ->
            send_shutdown(Port),
            receive
                {'EXIT',Port,_Reason} ->
                    send_heart_cmd(NewPort, Cmd),
                    Caller ! {heart,ok},
                    loop(Parent, NewPort, Cmd)
            after
                10000 ->
                    send_heart_cmd(NewPort, Cmd),
                    Caller ! {heart,{error,stop_error}},
                    loop(Parent, NewPort, Cmd)
            end;
        no_heart ->
            Caller ! {heart,{error,no_heart}},
            loop(Parent, Port, Cmd);
        error ->
            Caller ! {heart,{error,start_error}},
            loop(Parent, Port, Cmd)
    end.

send_heart_beat(Port) ->
    Port ! {self(),{command,[2]}}.

send_heart_cmd(Port, []) ->
    Port ! {self(),{command,[5]}};
send_heart_cmd(Port, Cmd) ->
    Port ! {self(),{command,[4|Cmd]}}.

get_heart_cmd(Port) ->
    Port ! {self(),{command,[6]}},
    receive
        {Port,{data,[7|Cmd]}} ->
            {ok,Cmd}
    end.

send_shutdown(Port) ->
    Port ! {self(),{command,[3]}}.

report_problem(Error) ->
    erlang:display(Error).



