-file("test/erts/emulator/test/erl_link_SUITE.erl", 1).

-module(erl_link_SUITE).

-author('rickard.green@uab.ericsson.se').

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/erts/emulator/test/erl_link_SUITE.erl", 32).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2]).

-export([links/1,
         dist_links/1,
         monitor_nodes/1,
         process_monitors/1,
         dist_process_monitors/1,
         busy_dist_port_monitor/1,
         busy_dist_port_link/1,
         otp_5772_link/1,
         otp_5772_dist_link/1,
         otp_5772_monitor/1,
         otp_5772_dist_monitor/1,
         otp_7946/1]).

-export([init_per_testcase/2,end_per_testcase/2]).

-export([test_proc/0]).

-record(erl_link,{type = 0,pid = [],targets = []}).

-record(erl_monitor,{type,ref,pid,name = []}).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [links,
     dist_links,
     monitor_nodes,
     process_monitors,
     dist_process_monitors,
     busy_dist_port_monitor,
     busy_dist_port_link,
     otp_5772_link,
     otp_5772_dist_link,
     otp_5772_monitor,
     otp_5772_dist_monitor,
     otp_7946].

groups() ->
    [].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    catch erts_debug:set_internal_state(available_internal_state, false).

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

links(doc) ->
    ["Tests node local links"];
links(suite) ->
    [];
links(Config) when is_list(Config) ->
    common_link_test(node(), node()),
    true = link(self()),
    [] = find_erl_link(self(), 1, self()),
    true = unlink(self()),
    ok.

dist_links(doc) ->
    ["Tests distributed links"];
dist_links(suite) ->
    [];
dist_links(Config) when is_list(Config) ->
    [NodeName] = get_names(1, dist_link),
    {ok,Node} = start_node(NodeName),
    common_link_test(node(), Node),
    TP4 = spawn(erl_link_SUITE, test_proc, []),
    TP5 = spawn(erl_link_SUITE, test_proc, []),
    TP6 = spawn(Node, erl_link_SUITE, test_proc, []),
    true =
        tp_call(TP6,
                fun() ->
                       link(TP4)
                end),
    check_link(TP4, TP6),
    true =
        tp_call(TP5,
                fun() ->
                       process_flag(trap_exit, true),
                       link(TP6)
                end),
    check_link(TP5, TP6),
    rpc:cast(Node, erlang, halt, []),
    wait_until(fun() ->
                      is_proc_dead(TP4)
               end),
    check_unlink(TP4, TP6),
    true =
        tp_call(TP5,
                fun() ->
                       receive
                           {'EXIT',TP6,noconnection} ->
                               true
                       end
                end),
    check_unlink(TP5, TP6),
    tp_cast(TP5,
            fun() ->
                   exit(normal)
            end),
    ok.

common_link_test(NodeA, NodeB) ->
    TP1 = spawn(NodeA, erl_link_SUITE, test_proc, []),
    check_unlink(TP1, self()),
    TP2 =
        tp_call(TP1,
                fun() ->
                       spawn_link(NodeB, erl_link_SUITE, test_proc, [])
                end),
    check_link(TP1, TP2),
    true =
        tp_call(TP2,
                fun() ->
                       unlink(TP1)
                end),
    check_unlink(TP1, TP2),
    true =
        tp_call(TP2,
                fun() ->
                       link(TP1)
                end),
    check_link(TP1, TP2),
    false =
        tp_call(TP2,
                fun() ->
                       process_flag(trap_exit, true)
                end),
    tp_cast(TP1,
            fun() ->
                   exit(died)
            end),
    true =
        tp_call(TP2,
                fun() ->
                       receive
                           {'EXIT',TP1,died} ->
                               true
                       end
                end),
    check_unlink(TP1, TP2),
    TP3 =
        tp_call(TP2,
                fun() ->
                       spawn_link(NodeA, erl_link_SUITE, test_proc, [])
                end),
    check_link(TP3, TP2),
    tp_cast(TP2,
            fun() ->
                   exit(died)
            end),
    wait_until(fun() ->
                      is_proc_dead(TP3)
               end),
    check_unlink(TP3, TP2),
    ok.

monitor_nodes(doc) ->
    ["Tests monitor of nodes"];
monitor_nodes(suite) ->
    [];
monitor_nodes(Config) when is_list(Config) ->
    [An,Bn,Cn,Dn] = get_names(4, dist_link),
    {ok,A} = start_node(An),
    {ok,B} = start_node(Bn),
    C = list_to_atom(lists:concat([Cn,"@",hostname()])),
    D = list_to_atom(lists:concat([Dn,"@",hostname()])),
    0 = no_of_monitor_node(self(), A),
    0 = no_of_monitor_node(self(), B),
    monitor_node(A, true),
    monitor_node(B, true),
    monitor_node(D, true),
    monitor_node(D, true),
    {memory,_} = process_info(self(), memory),
    monitor_node(A, false),
    monitor_node(B, true),
    monitor_node(C, true),
    monitor_node(C, false),
    monitor_node(C, true),
    monitor_node(B, true),
    monitor_node(A, false),
    monitor_node(B, true),
    monitor_node(B, false),
    monitor_node(A, true),
    check_monitor_node(self(), A, 1),
    check_monitor_node(self(), B, 3),
    check_monitor_node(self(), C, 0),
    check_monitor_node(self(), D, 0),
    receive
        {nodedown,C} ->
            ok
    end,
    receive
        {nodedown,C} ->
            ok
    end,
    receive
        {nodedown,C} ->
            ok
    end,
    receive
        {nodedown,D} ->
            ok
    end,
    receive
        {nodedown,D} ->
            ok
    end,
    stop_node(A),
    receive
        {nodedown,A} ->
            ok
    end,
    check_monitor_node(self(), A, 0),
    check_monitor_node(self(), B, 3),
    stop_node(B),
    receive
        {nodedown,B} ->
            ok
    end,
    receive
        {nodedown,B} ->
            ok
    end,
    receive
        {nodedown,B} ->
            ok
    end,
    check_monitor_node(self(), B, 0),
    receive
        {nodedown,X} ->
            test_server:fail({unexpected_nodedown,X})
    after
        0 -> ok
    end,
    ok.

process_monitors(doc) ->
    ["Tests node local process monitors"];
process_monitors(suite) ->
    [];
process_monitors(Config) when is_list(Config) ->
    common_process_monitors(node(), node()),
    Mon1 = monitor(process, self()),
    [] = find_erl_monitor(self(), Mon1),
    [Name] = get_names(1, process_monitors),
    true = register(Name, self()),
    Mon2 = monitor(process, Name),
    [] = find_erl_monitor(self(), Mon2),
    receive
        {'DOWN',Mon1,_,_,_} = Msg ->
            test_server:fail({unexpected_down_msg,Msg});
        {'DOWN',Mon2,_,_,_} = Msg ->
            test_server:fail({unexpected_down_msg,Msg})
    after
        500 ->
            true = demonitor(Mon1),
            true = demonitor(Mon2),
            ok
    end.

dist_process_monitors(doc) ->
    ["Tests distributed process monitors"];
dist_process_monitors(suite) ->
    [];
dist_process_monitors(Config) when is_list(Config) ->
    [Name] = get_names(1, dist_process_monitors),
    {ok,Node} = start_node(Name),
    common_process_monitors(node(), Node),
    TP1 = spawn(Node, erl_link_SUITE, test_proc, []),
    R1 = monitor(process, TP1),
    TP1O = get_down_object(TP1, self()),
    check_process_monitor(self(), TP1, R1),
    tp_cast(TP1,
            fun() ->
                   halt()
            end),
    receive
        {'DOWN',R1,process,TP1O,noconnection} ->
            ok
    end,
    check_process_demonitor(self(), TP1, R1),
    R2 = monitor(process, TP1),
    receive
        {'DOWN',R2,process,TP1O,noconnection} ->
            ok
    end,
    check_process_demonitor(self(), TP1, R2),
    ok.

common_process_monitors(NodeA, NodeB) ->
    TP1 = spawn(NodeA, erl_link_SUITE, test_proc, []),
    TP2 = spawn(NodeB, erl_link_SUITE, test_proc, []),
    run_common_process_monitors(TP1, TP2),
    TP3 = spawn(NodeA, erl_link_SUITE, test_proc, []),
    TP4 = spawn(NodeB, erl_link_SUITE, test_proc, []),
    [TP4N] = get_names(1, common_process_monitors),
    true =
        tp_call(TP4,
                fun() ->
                       register(TP4N, self())
                end),
    run_common_process_monitors(TP3,
                                case node() == node(TP4) of
                                    true ->
                                        TP4N;
                                    false ->
                                        {TP4N,node(TP4)}
                                end),
    ok.

run_common_process_monitors(TP1, TP2) ->
    R1 =
        tp_call(TP1,
                fun() ->
                       monitor(process, TP2)
                end),
    check_process_monitor(TP1, TP2, R1),
    tp_call(TP2,
            fun() ->
                   catch demonitor(R1)
            end),
    check_process_monitor(TP1, TP2, R1),
    true =
        tp_call(TP1,
                fun() ->
                       demonitor(R1)
                end),
    check_process_demonitor(TP1, TP2, R1),
    R2 =
        tp_call(TP1,
                fun() ->
                       monitor(process, TP2)
                end),
    TP2O = get_down_object(TP2, TP1),
    check_process_monitor(TP1, TP2, R2),
    tp_cast(TP2,
            fun() ->
                   exit(bye)
            end),
    wait_until(fun() ->
                      is_proc_dead(TP2)
               end),
    ok =
        tp_call(TP1,
                fun() ->
                       receive
                           {'DOWN',R2,process,TP2O,bye} ->
                               ok
                       end
                end),
    check_process_demonitor(TP1, TP2, R2),
    R3 =
        tp_call(TP1,
                fun() ->
                       monitor(process, TP2)
                end),
    ok =
        tp_call(TP1,
                fun() ->
                       receive
                           {'DOWN',R3,process,TP2O,noproc} ->
                               ok
                       end
                end),
    check_process_demonitor(TP1, TP2, R3),
    tp_cast(TP1,
            fun() ->
                   exit(normal)
            end),
    wait_until(fun() ->
                      is_proc_dead(TP1)
               end),
    ok.

busy_dist_port_monitor(doc) ->
    ["Tests distributed monitor/2, demonitor/1, and 'DOWN' message over"
     " busy distribution port"];
busy_dist_port_monitor(suite) ->
    [];
busy_dist_port_monitor(Config) when is_list(Config) ->
    Tracer =
        case os:getenv("TRACE_BUSY_DIST_PORT") of
            "true" ->
                start_busy_dist_port_tracer();
            _ ->
                false
        end,
    [An] = get_names(1, busy_dist_port_monitor),
    {ok,A} = start_node(An),
    TP1 = spawn(A, erl_link_SUITE, test_proc, []),
    M1 =
        suspend_on_busy_test(A,
                             "erlang:monitor(process, TP1)",
                             fun() ->
                                    monitor(process, TP1)
                             end),
    check_process_monitor(self(), TP1, M1),
    suspend_on_busy_test(A,
                         "erlang:demonitor(M1)",
                         fun() ->
                                demonitor(M1)
                         end),
    check_process_demonitor(self(), TP1, M1),
    TP2 = spawn(erl_link_SUITE, test_proc, []),
    M2 =
        tp_call(TP1,
                fun() ->
                       monitor(process, TP2)
                end),
    check_process_monitor(TP1, TP2, M2),
    Ref = make_ref(),
    Busy = make_busy(A, 1000),
    receive after 100 -> ok end,
    tp_cast(TP2,
            fun() ->
                   exit(Ref)
            end),
    receive after 100 -> ok end,
    unmake_busy(Busy),
    Ref =
        tp_call(TP1,
                fun() ->
                       receive
                           {'DOWN',M2,process,TP2,Ref} ->
                               Ref
                       end
                end),
    tp_cast(TP1,
            fun() ->
                   exit(normal)
            end),
    stop_node(A),
    stop_busy_dist_port_tracer(Tracer),
    ok.

busy_dist_port_link(doc) ->
    ["Tests distributed link/1, unlink/1, and 'EXIT'",
     " message over busy distribution port"];
busy_dist_port_link(suite) ->
    [];
busy_dist_port_link(Config) when is_list(Config) ->
    Tracer =
        case os:getenv("TRACE_BUSY_DIST_PORT") of
            "true" ->
                start_busy_dist_port_tracer();
            _ ->
                false
        end,
    [An] = get_names(1, busy_dist_port_link),
    {ok,A} = start_node(An),
    TP1 = spawn(A, erl_link_SUITE, test_proc, []),
    suspend_on_busy_test(A,
                         "link(TP1)",
                         fun() ->
                                link(TP1)
                         end),
    check_link(self(), TP1),
    suspend_on_busy_test(A,
                         "unlink(TP1)",
                         fun() ->
                                unlink(TP1)
                         end),
    check_unlink(self(), TP1),
    TP2 = spawn(erl_link_SUITE, test_proc, []),
    ok =
        tp_call(TP1,
                fun() ->
                       process_flag(trap_exit, true),
                       link(TP2),
                       ok
                end),
    check_link(TP1, TP2),
    Ref = make_ref(),
    Busy = make_busy(A, 1000),
    receive after 100 -> ok end,
    tp_cast(TP2,
            fun() ->
                   exit(Ref)
            end),
    receive after 100 -> ok end,
    unmake_busy(Busy),
    Ref =
        tp_call(TP1,
                fun() ->
                       receive
                           {'EXIT',TP2,Ref} ->
                               Ref
                       end
                end),
    tp_cast(TP1,
            fun() ->
                   exit(normal)
            end),
    stop_node(A),
    stop_busy_dist_port_tracer(Tracer),
    ok.

otp_5772_link(doc) ->
    [];
otp_5772_link(suite) ->
    [];
otp_5772_link(Config) when is_list(Config) ->
    otp_5772_link_test(node()).

otp_5772_dist_link(doc) ->
    [];
otp_5772_dist_link(suite) ->
    [];
otp_5772_dist_link(Config) when is_list(Config) ->
    [An] = get_names(1, otp_5772_dist_link),
    {ok,A} = start_node(An),
    otp_5772_link_test(A),
    stop_node(A).

otp_5772_link_test(Node) ->
    Prio = process_flag(priority, high),
    TE = process_flag(trap_exit, true),
    TP1 =
        spawn_opt(Node,
                  erl_link_SUITE,
                  test_proc,
                  [],
                  [link,{priority,low}]),
    exit(TP1, bang),
    unlink(TP1),
    receive
        {'EXIT',TP1,_} ->
            ok
    after
        0 -> ok
    end,
    receive
        {'EXIT',TP1,_} = Exit ->
            test_server:fail({got_late_exit_message,Exit})
    after
        1000 -> ok
    end,
    process_flag(trap_exit, TE),
    process_flag(priority, Prio),
    ok.

otp_5772_monitor(doc) ->
    [];
otp_5772_monitor(suite) ->
    [];
otp_5772_monitor(Config) when is_list(Config) ->
    otp_5772_monitor_test(node()).

otp_5772_dist_monitor(doc) ->
    [];
otp_5772_dist_monitor(suite) ->
    [];
otp_5772_dist_monitor(Config) when is_list(Config) ->
    [An] = get_names(1, otp_5772_dist_monitor),
    {ok,A} = start_node(An),
    otp_5772_monitor_test(A),
    stop_node(A),
    ok.

otp_5772_monitor_test(Node) ->
    Prio = process_flag(priority, high),
    TP1 =
        spawn_opt(Node, erl_link_SUITE, test_proc, [], [{priority,low}]),
    M1 = monitor(process, TP1),
    exit(TP1, bang),
    demonitor(M1),
    receive
        {'DOWN',M1,_,_,_} ->
            ok
    after
        0 -> ok
    end,
    receive
        {'DOWN',M1,_,_,_} = Down ->
            test_server:fail({got_late_down_message,Down})
    after
        1000 -> ok
    end,
    process_flag(priority, Prio),
    ok.

otp_7946(Config) when is_list(Config) ->
    [NodeName] = get_names(1, otp_7946),
    {ok,Node} = start_node(NodeName),
    Proc = rpc:call(Node, erlang, whereis, [net_kernel]),
    Mon = monitor(process, Proc),
    rpc:cast(Node, erlang, halt, []),
    receive
        {'DOWN',Mon,process,Proc,_} ->
            ok
    end,
    {Linker,LMon} =
        spawn_monitor(fun() ->
                             link(Proc),
                             receive after infinity -> ok end
                      end),
    receive
        {'DOWN',LMon,process,Linker,Reason} ->
            test_server:format("Reason=~p~n", [Reason]),
            Reason = noconnection
    end.

busy_data() ->
    case get('__busy__port__data__') of
        undefined ->
            set_busy_data([]);
        Data ->
            true = is_binary(Data),
            true = size(Data) == 1024 * 1024,
            Data
    end.

set_busy_data(SetData) ->
    case get('__busy__port__data__') of
        undefined ->
            Data =
                case SetData of
                    D when is_binary(D), size(D) == 1024 * 1024 ->
                        SetData;
                    _ ->
                        list_to_binary(lists:duplicate(1024 * 1024, 253))
                end,
            put('__busy__port__data__', Data),
            Data;
        OldData ->
            OldData
    end.

freeze_node(Node, MS) ->
    Own = 500,
    DoingIt = make_ref(),
    Freezer = self(),
    spawn_link(Node,
               fun() ->
                      erts_debug:set_internal_state(available_internal_state,
                                                    true),
                      dport_send(Freezer, DoingIt),
                      receive after Own -> ok end,
                      erts_debug:set_internal_state(block, MS + Own)
               end),
    receive
        DoingIt ->
            ok
    end,
    receive after Own -> ok end.

make_busy(Node, Time) when is_integer(Time) ->
    Own = 500,
    freeze_node(Node, Time + Own),
    Data = busy_data(),
    Pid =
        spawn_link(fun() ->
                          forever(fun() ->
                                         dport_reg_send(Node,
                                                        '__noone__',
                                                        Data)
                                  end)
                   end),
    receive after Own -> ok end,
    wait_until(fun() ->
                      case process_info(Pid, status) of
                          {status,suspended} ->
                              true;
                          _ ->
                              false
                      end
               end),
    make_busy(Node, [nosuspend], Data),
    Pid.

make_busy(Node, Opts, Data) ->
    case erlang:send({'__noone__',Node}, Data, Opts) of
        nosuspend ->
            nosuspend;
        _ ->
            make_busy(Node, Opts, Data)
    end.

unmake_busy(Pid) ->
    unlink(Pid),
    exit(Pid, bang).

suspend_on_busy_test(Node, Doing, Fun) ->
    Tester = self(),
    DoIt = make_ref(),
    Done = make_ref(),
    Data = busy_data(),
    spawn_link(fun() ->
                      set_busy_data(Data),
                      Busy = make_busy(Node, 1000),
                      Tester ! DoIt,
                      receive after 100 -> ok end,
                      Info =
                          process_info(Tester,
                                       [status,current_function]),
                      unmake_busy(Busy),
                      test_server:format("~p doing ~s: ~p~n",
                                         [Tester,Doing,Info]),
                      Tester ! {Done,Info}
               end),
    receive
        DoIt ->
            ok
    end,
    Res = Fun(),
    receive
        {Done,MyInfo} ->
            [{status,suspended},
             {current_function,{erlang,bif_return_trap,_}}] =
                MyInfo,
            ok
    end,
    Res.

get_down_object(Item, _) when is_pid(Item) ->
    Item;
get_down_object({Name,Node} = Item, _) when is_atom(Name); is_atom(Node) ->
    Item;
get_down_object(Item, Watcher) when is_atom(Item), is_pid(Watcher) ->
    {Item,node(Watcher)};
get_down_object(Item, {_,Node}) when is_atom(Item), is_atom(Node) ->
    {Item,Node};
get_down_object(Item, Watcher) when is_atom(Item), is_atom(Watcher) ->
    {Item,node()}.

is_proc_dead(P) ->
    case is_proc_alive(P) of
        true ->
            false;
        false ->
            true
    end.

is_proc_alive(Pid) when is_pid(Pid), node(Pid) == node() ->
    is_process_alive(Pid);
is_proc_alive(Name) when is_atom(Name) ->
    case catch whereis(Name) of
        Pid when is_pid(Pid) ->
            is_proc_alive(Pid);
        _ ->
            false
    end;
is_proc_alive({Name,Node}) when is_atom(Name), Node == node() ->
    is_proc_alive(Name);
is_proc_alive(Proc) ->
    is_remote_proc_alive(Proc).

is_remote_proc_alive({Name,Node}) when is_atom(Name), is_atom(Node) ->
    is_remote_proc_alive(Name, Node);
is_remote_proc_alive(Pid) when is_pid(Pid) ->
    is_remote_proc_alive(Pid, node(Pid));
is_remote_proc_alive(_) ->
    false.

is_remote_proc_alive(PN, Node) ->
    S = self(),
    R = make_ref(),
    monitor_node(Node, true),
    _P =
        spawn(Node,
              fun() ->
                     S ! {R,is_proc_alive(PN)}
              end),
    receive
        {R,Bool} ->
            monitor_node(Node, false),
            Bool;
        {nodedown,Node} ->
            false
    end.

wait_until(Fun) ->
    case Fun() of
        true ->
            ok;
        _ ->
            receive after 100 -> wait_until(Fun) end
    end.

forever(Fun) ->
    Fun(),
    forever(Fun).

init_per_testcase(Func, Config) when is_atom(Func), is_list(Config) ->
    Dog = test_server:timetrap(test_server:minutes(1)),
    case
        catch erts_debug:get_internal_state(available_internal_state)
    of
        true ->
            ok;
        _ ->
            erts_debug:set_internal_state(available_internal_state,
                                          true)
    end,
    [{watchdog,Dog}|Config].

end_per_testcase(_Func, Config) ->
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog).

tp_call(Tp, Fun) ->
    R = make_ref(),
    Tp ! {call,self(),R,Fun},
    receive
        {R,Res} ->
            Res
    end.

tp_cast(Tp, Fun) ->
    Tp ! {cast,Fun}.

test_proc() ->
    receive
        {call,From,Ref,Fun} ->
            From ! {Ref,Fun()};
        {cast,Fun} ->
            Fun()
    end,
    test_proc().

expand_link_list([#erl_link{type = 3,targets = N} = Rec|T]) ->
    lists:duplicate(N, Rec#erl_link{targets = []})
    ++
    expand_link_list(T);
expand_link_list([#erl_link{targets = [#erl_link{pid = Pid}]} = Rec|T]) ->
    [Rec#erl_link{targets = [Pid]}|expand_link_list(T)];
expand_link_list([#erl_link{targets = [#erl_link{pid = Pid}|TT]} = Rec|
                  T]) ->
    [Rec#erl_link{targets = [Pid]}|
     expand_link_list([Rec#erl_link{targets = TT}|T])];
expand_link_list([#erl_link{targets = []} = Rec|T]) ->
    [Rec|expand_link_list(T)];
expand_link_list([]) ->
    [].

get_local_link_list(Obj) ->
    case catch erts_debug:get_internal_state({link_list,Obj}) of
        LL when is_list(LL) ->
            expand_link_list(LL);
        _ ->
            []
    end.

get_remote_link_list(Node, Obj) ->
    case
        catch
            rpc:call(Node,
                     erts_debug,
                     get_internal_state,
                     [{link_list,Obj}])
    of
        LL when is_list(LL) ->
            expand_link_list(LL);
        _ ->
            []
    end.

get_link_list({Node,DistEntry}) when Node == node(), is_atom(DistEntry) ->
    get_local_link_list(DistEntry);
get_link_list({Node,DistEntry}) when is_atom(Node), is_atom(DistEntry) ->
    get_remote_link_list(Node, DistEntry);
get_link_list(P) when is_pid(P); is_port(P) ->
    case node(P) of
        Node when Node == node() ->
            get_local_link_list(P);
        Node ->
            get_remote_link_list(Node, P)
    end;
get_link_list(undefined) ->
    [].

get_local_monitor_list(Obj) ->
    case catch erts_debug:get_internal_state({monitor_list,Obj}) of
        LL when is_list(LL) ->
            LL;
        _ ->
            []
    end.

get_remote_monitor_list(Node, Obj) ->
    case
        catch
            rpc:call(Node,
                     erts_debug,
                     get_internal_state,
                     [{monitor_list,Obj}])
    of
        LL when is_list(LL) ->
            LL;
        _ ->
            []
    end.

get_monitor_list({Node,DistEntry})
    when Node == node(), is_atom(DistEntry) ->
    get_local_monitor_list(DistEntry);
get_monitor_list({Node,DistEntry})
    when is_atom(Node), is_atom(DistEntry) ->
    get_remote_monitor_list(Node, DistEntry);
get_monitor_list(P) when is_pid(P) ->
    case node(P) of
        Node when Node == node() ->
            get_local_monitor_list(P);
        Node ->
            get_remote_monitor_list(Node, P)
    end;
get_monitor_list(undefined) ->
    [].

find_erl_monitor(Pid, Ref) when is_reference(Ref) ->
    lists:foldl(fun(#erl_monitor{ref = R} = EL, Acc) when R == Ref ->
                       [EL|Acc];
                   (_, Acc) ->
                       Acc
                end,
                [],
                get_monitor_list(Pid)).

find_erl_link(Obj, Type, [Item,Data])
    when is_pid(Item); is_port(Item); is_atom(Item) ->
    lists:foldl(fun(#erl_link{type = T,pid = I,targets = D} = EL, Acc)
                       when T == Type, I == Item ->
                       case Data of
                           D ->
                               [EL|Acc];
                           [] ->
                               [EL|Acc];
                           _ ->
                               Acc
                       end;
                   (_, Acc) ->
                       Acc
                end,
                [],
                get_link_list(Obj));
find_erl_link(Obj, Type, Item)
    when is_pid(Item); is_port(Item); is_atom(Item) ->
    find_erl_link(Obj, Type, [Item,[]]).

check_link(A, B) ->
    [#erl_link{type = 1,pid = B,targets = []}] = find_erl_link(A, 1, B),
    [#erl_link{type = 1,pid = A,targets = []}] = find_erl_link(B, 1, A),
    case node(A) == node(B) of
        false ->
            [#erl_link{type = 1,pid = A,targets = [B]}] =
                find_erl_link({node(A),node(B)}, 1, [A,[B]]),
            [#erl_link{type = 1,pid = B,targets = [A]}] =
                find_erl_link({node(B),node(A)}, 1, [B,[A]]);
        true ->
            [] = find_erl_link({node(A),node(B)}, 1, [A,[B]]),
            [] = find_erl_link({node(B),node(A)}, 1, [B,[A]])
    end,
    ok.

check_unlink(A, B) ->
    [] = find_erl_link(A, 1, B),
    [] = find_erl_link(B, 1, A),
    [] = find_erl_link({node(A),node(B)}, 1, [A,[B]]),
    [] = find_erl_link({node(B),node(A)}, 1, [B,[A]]),
    ok.

check_process_monitor(From, {Name,Node}, Ref)
    when
        is_pid(From),
        is_atom(Name),
        Node == node(From),
        is_reference(Ref) ->
    check_process_monitor(From, Name, Ref);
check_process_monitor(From, {Name,Node}, Ref)
    when is_pid(From), is_atom(Name), is_atom(Node), is_reference(Ref) ->
    MonitoredPid = rpc:call(Node, erlang, whereis, [Name]),
    [#erl_monitor{type = 1,ref = Ref,pid = Node,name = Name}] =
        find_erl_monitor(From, Ref),
    [#erl_monitor{type = 3,ref = Ref,pid = From,name = Name}] =
        find_erl_monitor({node(From),Node}, Ref),
    [#erl_monitor{type = 1,ref = Ref,pid = MonitoredPid,name = Name}] =
        find_erl_monitor({Node,node(From)}, Ref),
    [#erl_monitor{type = 3,ref = Ref,pid = From,name = Name}] =
        find_erl_monitor(MonitoredPid, Ref),
    ok;
check_process_monitor(From, Name, Ref)
    when
        is_pid(From),
        is_atom(Name),
        undefined /= Name,
        is_reference(Ref) ->
    MonitoredPid = rpc:call(node(From), erlang, whereis, [Name]),
    [#erl_monitor{type = 1,ref = Ref,pid = MonitoredPid,name = Name}] =
        find_erl_monitor(From, Ref),
    [#erl_monitor{type = 3,ref = Ref,pid = From,name = Name}] =
        find_erl_monitor(MonitoredPid, Ref),
    ok;
check_process_monitor(From, To, Ref)
    when is_pid(From), is_pid(To), is_reference(Ref) ->
    OriMon = [#erl_monitor{type = 1,ref = Ref,pid = To}],
    OriMon = find_erl_monitor(From, Ref),
    TargMon = [#erl_monitor{type = 3,ref = Ref,pid = From}],
    TargMon = find_erl_monitor(To, Ref),
    case node(From) == node(To) of
        false ->
            TargMon = find_erl_monitor({node(From),node(To)}, Ref),
            OriMon = find_erl_monitor({node(To),node(From)}, Ref);
        true ->
            [] = find_erl_monitor({node(From),node(From)}, Ref)
    end,
    ok.

check_process_demonitor(From, {undefined,Node}, Ref)
    when is_pid(From), is_reference(Ref) ->
    [] = find_erl_monitor(From, Ref),
    case node(From) == Node of
        false ->
            [] = find_erl_monitor({node(From),Node}, Ref),
            [] = find_erl_monitor({Node,node(From)}, Ref);
        true ->
            [] = find_erl_monitor({Node,Node}, Ref)
    end,
    ok;
check_process_demonitor(From, {Name,Node}, Ref)
    when
        is_pid(From),
        is_atom(Name),
        Node == node(From),
        is_reference(Ref) ->
    MonitoredPid = rpc:call(Node, erlang, whereis, [Name]),
    case rpc:call(Node, erlang, whereis, [Name]) of
        undefined ->
            check_process_demonitor(From, {undefined,Node}, Ref);
        MonitoredPid ->
            check_process_demonitor(From, MonitoredPid, Ref)
    end;
check_process_demonitor(From, {Name,Node}, Ref)
    when is_pid(From), is_atom(Name), is_atom(Node), is_reference(Ref) ->
    MonitoredPid = rpc:call(Node, erlang, whereis, [Name]),
    [] = find_erl_monitor(From, Ref),
    [] = find_erl_monitor({node(From),Node}, Ref),
    [] = find_erl_monitor({Node,node(From)}, Ref),
    [] = find_erl_monitor(MonitoredPid, Ref),
    ok;
check_process_demonitor(From, undefined, Ref)
    when is_pid(From), is_reference(Ref) ->
    [] = find_erl_monitor(From, Ref),
    case node(From) == node() of
        false ->
            [] = find_erl_monitor({node(From),node()}, Ref),
            [] = find_erl_monitor({node(),node(From)}, Ref);
        true ->
            [] = find_erl_monitor({node(),node()}, Ref)
    end,
    ok;
check_process_demonitor(From, Name, Ref)
    when
        is_pid(From),
        is_atom(Name),
        undefined /= Name,
        is_reference(Ref) ->
    check_process_demonitor(From, {Name,node()}, Ref);
check_process_demonitor(From, To, Ref)
    when is_pid(From), is_pid(To), is_reference(Ref) ->
    [] = find_erl_monitor(From, Ref),
    [] = find_erl_monitor(To, Ref),
    case node(From) == node(To) of
        false ->
            [] = find_erl_monitor({node(From),node(To)}, Ref),
            [] = find_erl_monitor({node(To),node(From)}, Ref);
        true ->
            [] = find_erl_monitor({node(From),node(From)}, Ref)
    end,
    ok.

no_of_monitor_node(From, Node) when is_pid(From), is_atom(Node) ->
    length(find_erl_link(From, 3, Node)).

check_monitor_node(From, Node, No)
    when is_pid(From), is_atom(Node), is_integer(No), No >= 0 ->
    LL = lists:duplicate(No, #erl_link{type = 3,pid = Node}),
    DLL = lists:duplicate(No, #erl_link{type = 3,pid = From}),
    LL = find_erl_link(From, 3, Node),
    DLL = find_erl_link({node(From),Node}, 3, From),
    ok.

hostname() ->
    from($@, atom_to_list(node())).

from(H, [H|T]) ->
    T;
from(H, [_|T]) ->
    from(H, T);
from(_H, []) ->
    [].

get_names(N, T) when is_atom(T) ->
    get_names(N, T, []).

get_names(0, _, Acc) ->
    Acc;
get_names(N, T, Acc) ->
    {A,B,C} = now(),
    get_names(N - 1,
              T,
              [list_to_atom(atom_to_list(erl_link_SUITE)
                            ++
                            "-"
                            ++
                            atom_to_list(T)
                            ++
                            "-"
                            ++
                            integer_to_list(A)
                            ++
                            "-"
                            ++
                            integer_to_list(B)
                            ++
                            "-" ++ integer_to_list(C))|
               Acc]).

start_node(Name) ->
    start_node(Name, "").

start_node(Name, Args) ->
    Pa = filename:dirname(code:which(erl_link_SUITE)),
    Res =
        test_server:start_node(Name,
                               slave,
                               [{args,Args ++ " -pa " ++ Pa}]),
    {ok,Node} = Res,
    rpc:call(Node,
             erts_debug,
             set_internal_state,
             [available_internal_state,true]),
    Res.

stop_node(Node) ->
    test_server:stop_node(Node).

dport_send(To, Msg) ->
    Node = node(To),
    DPrt =
        case dport(Node) of
            undefined ->
                pong = net_adm:ping(Node),
                dport(Node);
            Prt ->
                Prt
        end,
    port_command(DPrt, [dmsg_hdr(),dmsg_ext({2,'',To}),dmsg_ext(Msg)]).

dport_reg_send(Node, Name, Msg) ->
    DPrt =
        case dport(Node) of
            undefined ->
                pong = net_adm:ping(Node),
                dport(Node);
            Prt ->
                Prt
        end,
    port_command(DPrt,
                 [dmsg_hdr(),dmsg_ext({6,self(),'',Name}),dmsg_ext(Msg)]).

dport(Node) when is_atom(Node) ->
    case
        catch erts_debug:get_internal_state(available_internal_state)
    of
        true ->
            true;
        _ ->
            erts_debug:set_internal_state(available_internal_state,
                                          true)
    end,
    erts_debug:get_internal_state({dist_port,Node}).

dmsg_hdr() ->
    [131,$D,0].

dmsg_ext(Term) ->
    <<131,Res/binary>> = term_to_binary(Term),
    Res.

start_busy_dist_port_tracer() ->
    Tracer =
        spawn_link(fun() ->
                          busy_dist_port_tracer()
                   end),
    erlang:system_monitor(Tracer, [busy_dist_port]),
    Tracer.

stop_busy_dist_port_tracer(Tracer) when is_pid(Tracer) ->
    unlink(Tracer),
    exit(Tracer, bye);
stop_busy_dist_port_tracer(_) ->
    true.

busy_dist_port_tracer() ->
    receive
        {monitor,_SuspendedProcess,busy_dist_port,_Port} = M ->
            erlang:display(M),
            busy_dist_port_tracer()
    end.



