-file("test/lib/diameter/src/transport/diameter_etcp.erl", 1).

-module(diameter_etcp).

-behaviour(gen_server).

-export([start/3]).

-export([listen/2,
         accept/1,
         connect/3,
         send/2,
         close/1,
         setopts/2,
         sockname/1,
         peername/1,
         getstat/1]).

-export([start_link/1]).

-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         code_change/3,
         terminate/2]).

-record(listener,{acceptors = [] :: [pid()]}).

-record(connection,{parent :: undefined | pid(),
                    peer :: undefined
                          | {connect, reference()}
                          | accept
                          | pid()}).

start(T, Svc, Opts) when is_list(Opts) ->
    diameter_etcp_sup:start(),
    diameter_tcp:start(T, Svc, [{module,diameter_etcp}|Opts]).

listen(LPort, Opts) ->
    Parent = self(),
    diameter_etcp_sup:start_child({listen,Parent,LPort,Opts}).

accept(LPid) ->
    start(fun(Ref, Parent) ->
                 acceptor(LPid, Ref, Parent)
          end).

connect(RAddr, RPort, _Opts) ->
    start(fun(Ref, Parent) ->
                 connector(RAddr, RPort, Ref, Parent)
          end).

send(Pid, Bin) ->
    Pid ! {send,Bin},
    ok.

close(Pid) ->
    Pid ! close,
    monitor(Pid),
    receive
        {'DOWN',_,process,Pid,_} ->
            ok
    end.

setopts(_, _) ->
    ok.

sockname(_) ->
    {error,diameter_etcp}.

peername(_) ->
    {error,diameter_etcp}.

getstat(_) ->
    {error,diameter_etcp}.

start_link(T) ->
    gen_server:start_link(diameter_etcp, T, []).

init({listen,Parent,LPort,Opts}) ->
    monitor(Parent),
    {ip,LAddr} = lists:keyfind(ip, 1, Opts),
    true = diameter_reg:add_new({diameter_etcp,listener,LAddr,LPort}),
    {ok,#listener{}};
init({connect,Fun,Ref,Parent}) ->
    {ok,#connection{parent = Parent,peer = Fun(Ref, Parent)}}.

handle_call(_, _, State) ->
    {reply,nok,State}.

handle_cast(_, State) ->
    {noreply,State}.

handle_info(T, #listener{acceptors = L} = S) ->
    {noreply,S#listener{acceptors = l(T, L)}};
handle_info(T, State) ->
    {noreply,transition(T, State)}.

code_change(_, State, _) ->
    {ok,State}.

terminate(_, _) ->
    ok.

monitor(Pid) ->
    monitor(process, Pid).

putr(Key, Val) ->
    put({diameter_etcp,Key}, Val).

eraser(Key) ->
    erase({diameter_etcp,Key}).

l({'DOWN',_,process,_,_} = T, _) ->
    x(T);
l({accept,APid}, As) ->
    As ++ [APid];
l({connect,Peer}, [] = As) ->
    Peer ! {refused,self()},
    As;
l({connect,Peer}, [APid|Rest]) ->
    Peer ! {accepted,APid},
    Rest.

x(T) ->
    exit({shutdown,T}).

start(Fun) ->
    Ref = make_ref(),
    {ok,Pid} =
        T = diameter_etcp_sup:start_child({connect,Fun,Ref,self()}),
    MRef = monitor(Pid),
    receive
        {ok,Ref} ->
            T;
        {'DOWN',MRef,process,_,Reason} ->
            {error,Reason}
    end.

acceptor(LPid, Ref, Parent) ->
    LPid ! {accept,self()},
    putr(ref, {ok,Ref}),
    monitor(Parent),
    monitor(LPid),
    accept.

connector(RAddr, RPort, Ref, Parent) ->
    c(match(RAddr, RPort), Ref, Parent).

c([], _, _) ->
    x(refused);
c([{_,LPid}], Ref, Parent) ->
    LPid ! {connect,self()},
    putr(ref, {ok,Ref}),
    monitor(Parent),
    {connect,monitor(LPid)}.

match({Node,RAddr}, RPort) ->
    rpc:call(Node,
             diameter_reg,
             match,
             [{diameter_etcp,listener,RAddr,RPort}]);
match(RAddr, RPort) ->
    match({node(),RAddr}, RPort).

transition({'DOWN',_,process,_,_} = T, S) ->
    element(2, S) ! {tcp_error,self(),T},
    x(T);
transition({accepted,Peer},
           #connection{parent = Parent,peer = {connect,MRef}}) ->
    monitor(Peer),
    demonitor(MRef, [flush]),
    Peer ! {connect,self()},
    Parent ! {ok,_} = eraser(ref),
    #connection{parent = Parent,peer = Peer};
transition({refused,_} = T, #connection{peer = {connect,_}}) ->
    x(T);
transition({connect,Peer}, #connection{parent = Parent,peer = accept}) ->
    monitor(Peer),
    Parent ! {ok,_} = eraser(ref),
    #connection{parent = Parent,peer = Peer};
transition({recv,Bin}, #connection{parent = Parent} = S) ->
    Parent ! {tcp,self(),Bin},
    S;
transition({send,Bin}, #connection{peer = Peer} = S) ->
    Peer ! {recv,Bin},
    S;
transition(close = T, #connection{peer = Peer}) when is_pid(Peer) ->
    Peer ! {close,self()},
    x(T);
transition(close = T, #connection{}) ->
    x(T);
transition({close,Peer} = T, #connection{parent = Parent,peer = Peer})
    when is_pid(Peer) ->
    Parent ! {tcp_closed,self()},
    x(T).



