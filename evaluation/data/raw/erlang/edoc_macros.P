-file("test/lib/edoc/src/edoc_macros.erl", 1).

-module(edoc_macros).

-export([expand_tags/3,std_macros/1,check_defs/1]).

-import(edoc_report, [report/2,error/3,warning/4]).

-file("test/lib/edoc/src/edoc.hrl", 1).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/edoc/src/../include/edoc_doclet.hrl",
      1).

-record(context,{dir = "",env,opts = []}).

-record(doclet_gen,{sources = [],
                    app = [],
                    packages = [],
                    modules = [],
                    filemap}).

-record(doclet_toc,{paths,indir}).

-file("test/lib/edoc/src/edoc.hrl", 43).

-file([], 43).

-record(module,{name = [],
                parameters = none,
                functions = [],
                exports = [],
                attributes = [],
                records = [],
                encoding = latin1}).

-record(env,{module = [],
             package = [],
             root = "",
             file_suffix,
             package_summary,
             apps,
             modules,
             packages,
             app_default,
             macros = [],
             includes = []}).

-record(comment,{line = 0,text}).

-record(entry,{name,args = [],line = 0,export,data}).

-record(tag,{name,line = 0,origin = comment,data}).

-file("test/lib/edoc/src/edoc_macros.erl", 33).

-file("test/lib/edoc/src/edoc_types.hrl", 1).

-record(t_spec,{name,type,defs = []}).

-record(t_typedef,{name,args,type,defs = []}).

-record(t_throws,{type,defs = []}).

-record(t_def,{name,type}).

-record(t_name,{app = [],module = [],name = []}).

-record(t_var,{a = [],name = []}).

-record(t_type,{a = [],name,args = []}).

-record(t_union,{a = [],types = []}).

-record(t_fun,{a = [],args,range}).

-record(t_tuple,{a = [],types = []}).

-record(t_list,{a = [],type}).

-record(t_nil,{a = []}).

-record(t_nonempty_list,{a = [],type}).

-record(t_atom,{a = [],val}).

-record(t_integer,{a = [],val}).

-record(t_integer_range,{a = [],from,to}).

-record(t_binary,{a = [],base_size = 0,unit_size = 0}).

-record(t_float,{a = [],val}).

-record(t_record,{a = [],name,fields = []}).

-record(t_field,{a = [],name,type}).

-record(t_paren,{a = [],type}).

-file("test/lib/edoc/src/edoc_macros.erl", 34).

std_macros(Env) ->
    if
        Env#env.module =:= [] ->
            [];
        true ->
            [{module,atom_to_list(Env#env.module)}]
    end
    ++
    if
        Env#env.package =:= [] ->
            [];
        true ->
            [{package,atom_to_list(Env#env.package)}]
    end
    ++
    [{date,fun date_macro/3},
     {docRoot,Env#env.root},
     {link,fun link_macro/3},
     {section,fun section_macro/3},
     {time,fun time_macro/3},
     {type,fun type_macro/3},
     {version,fun version_macro/3}].

check_defs([{K,D}|Ds]) when is_atom(K), is_list(D) ->
    check_defs(Ds);
check_defs([X|_Ds]) ->
    report("bad macro definition: ~P.", [X,10]),
    exit(error);
check_defs([]) ->
    ok.

date_macro(_S, _Line, _Env) ->
    edoc_lib:datestr(date()).

time_macro(_S, _Line, _Env) ->
    edoc_lib:timestr(time()).

version_macro(S, Line, Env) ->
    date_macro(S, Line, Env) ++ " " ++ time_macro(S, Line, Env).

link_macro(S, Line, Env) ->
    {S1,S2} = edoc_lib:split_at_stop(S),
    Ref = edoc_parser:parse_ref(S1, Line),
    URI = edoc_refs:get_uri(Ref, Env),
    Txt =
        if
            S2 =:= [] ->
                "<code>" ++ S1 ++ "</code>";
            true ->
                S2
        end,
    Target =
        case edoc_refs:is_top(Ref, Env) of
            true ->
                " target=\"_top\"";
            false ->
                ""
        end,
    lists:flatten(io_lib:fwrite("<a href=\"~ts\"~ts>~ts</a>",
                                [URI,Target,Txt])).

section_macro(S, _Line, _Env) ->
    S1 =
        lists:reverse(edoc_lib:strip_space(lists:reverse(edoc_lib:strip_space(S)))),
    lists:flatten(io_lib:format("<a href=\"#~ts\">~ts</a>",
                                [edoc_lib:to_label(S1),S1])).

type_macro(S, Line, Env) ->
    S1 = "t()=" ++ S,
    Def = edoc_parser:parse_typedef(S1, Line),
    {#t_typedef{type = T},_} = Def,
    Txt = edoc_layout:type(edoc_data:type(T, Env)),
    lists:flatten(io_lib:fwrite("<code>~ts</code>", [Txt])).

expand_tags(Ts, Env, Where) ->
    Defs = dict:from_list(lists:reverse(Env#env.macros)),
    expand_tags(Ts, Defs, Env, Where).

expand_tags([#tag{data = Cs,line = L} = T|Ts], Defs, Env, Where) ->
    [T#tag{data = expand_tag(Cs, L, Defs, Env, Where)}|
     expand_tags(Ts, Defs, Env, Where)];
expand_tags([T|Ts], Defs, Env, Where) ->
    [T|expand_tags(Ts, Defs, Env, Where)];
expand_tags([], _, _, _) ->
    [].

expand_tag(Cs, L, Defs, Env, Where) ->
    case catch {ok,expand_text(Cs, L, Defs, Env, Where)} of
        {ok,Cs1} ->
            lists:reverse(Cs1);
        {'EXIT',R} ->
            exit(R);
        {error,L1,Error} ->
            error(L1, Where, Error),
            exit(error);
        Other ->
            throw(Other)
    end.

-record(state,{where,env,seen}).

expand_text(Cs, L, Defs, Env, Where) ->
    St = #state{where = Where,env = Env,seen = sets:new()},
    expand(Cs, L, Defs, St, []).

expand([$@,$@|Cs], L, Defs, St, As) ->
    expand(Cs, L, Defs, St, [$@|As]);
expand([$@,${|Cs], L, Defs, St, As) ->
    expand(Cs, L, Defs, St, [${|As]);
expand([$@,$}|Cs], L, Defs, St, As) ->
    expand(Cs, L, Defs, St, [$}|As]);
expand([${,$@|Cs], L, Defs, St, As) ->
    expand_macro(Cs, L, Defs, St, As);
expand([$\n = C|Cs], L, Defs, St, As) ->
    expand(Cs, L + 1, Defs, St, [C|As]);
expand([C|Cs], L, Defs, St, As) ->
    expand(Cs, L, Defs, St, [C|As]);
expand([], _, _, _, As) ->
    As.

expand_macro(Cs, L, Defs, St, As) ->
    {M,Cs1,L1} = macro_name(Cs, L),
    {Arg,Cs2,L2} = macro_content(Cs1, L1),
    As1 = expand_macro_def(M, Arg, L, Defs, St, As),
    expand(Cs2, L2, Defs, St, As1).

expand_macro_def(M, Arg, L, Defs, St, As) ->
    Seen = St#state.seen,
    case sets:is_element(M, Seen) of
        true ->
            throw_error(L, {"recursive macro expansion of {@~s}.",[M]});
        false ->
            Arg1 = lists:reverse(expand(Arg, L, Defs, St, [])),
            Defs1 = dict:store('?', Arg1, Defs),
            St1 = St#state{seen = sets:add_element(M, Seen)},
            case dict:find(M, Defs) of
                {ok,Def} ->
                    Txt =
                        if
                            is_function(Def) ->
                                Def(Arg1, L, St1#state.env);
                            is_list(Def) ->
                                Def
                        end,
                    expand(Txt, L, Defs1, St1, As);
                error ->
                    warning(L,
                            St1#state.where,
                            "undefined macro {@~s}.",
                            [M]),
                    "??"
            end
    end.

macro_name(Cs, L) ->
    macro_name(Cs, [], L).

macro_name([C|Cs], As, L) when C >= $a, C =< $z ->
    macro_name_1(Cs, [C|As], L);
macro_name([C|Cs], As, L) when C >= $A, C =< $Z ->
    macro_name_1(Cs, [C|As], L);
macro_name([C|Cs], As, L) when C >= $À, C =< $ÿ, C =/= $×, C =/= $÷ ->
    macro_name_1(Cs, [C|As], L);
macro_name([$_|Cs], As, L) ->
    macro_name_1(Cs, [$_|As], L);
macro_name([$?|Cs], As, L) ->
    macro_name_1(Cs, [$?|As], L);
macro_name([$\s|_Cs], _As, L) ->
    throw_error(L, macro_name);
macro_name([$\t|_Cs], _As, L) ->
    throw_error(L, macro_name);
macro_name([$\n|_Cs], _As, L) ->
    throw_error(L, macro_name);
macro_name([C|_Cs], As, L) ->
    throw_error(L, {macro_name,[C|As]});
macro_name([], _As, L) ->
    throw_error(L, macro_name).

macro_name_1([C|Cs], As, L) when C >= $a, C =< $z ->
    macro_name_1(Cs, [C|As], L);
macro_name_1([C|Cs], As, L) when C >= $A, C =< $Z ->
    macro_name_1(Cs, [C|As], L);
macro_name_1([C|Cs], As, L) when C >= $0, C =< $9 ->
    macro_name_1(Cs, [C|As], L);
macro_name_1([C|Cs], As, L) when C >= $À, C =< $ÿ, C =/= $×, C =/= $÷ ->
    macro_name_1(Cs, [C|As], L);
macro_name_1([$_|Cs], As, L) ->
    macro_name_1(Cs, [$_|As], L);
macro_name_1([$\s|Cs], As, L) ->
    macro_name_2(Cs, As, L);
macro_name_1([$\t|Cs], As, L) ->
    macro_name_2(Cs, As, L);
macro_name_1([$\n|Cs], As, L) ->
    macro_name_2(Cs, As, L + 1);
macro_name_1([$}|_] = Cs, As, L) ->
    macro_name_3(Cs, As, L);
macro_name_1([C|_Cs], As, L) ->
    throw_error(L, {macro_name,[C|As]});
macro_name_1([], _As, L) ->
    throw_error(L, unterminated_macro).

macro_name_2([$\s|Cs], As, L) ->
    macro_name_2(Cs, As, L);
macro_name_2([$\t|Cs], As, L) ->
    macro_name_2(Cs, As, L);
macro_name_2([$\n|Cs], As, L) ->
    macro_name_2(Cs, As, L + 1);
macro_name_2([_|_] = Cs, As, L) ->
    macro_name_3(Cs, As, L);
macro_name_2([], _As, L) ->
    throw_error(L, unterminated_macro).

macro_name_3(Cs, As, L) ->
    {list_to_atom(lists:reverse(As)),Cs,L}.

macro_content(Cs, L) ->
    case catch {ok,macro_content(Cs, [], L, 0)} of
        {ok,X} ->
            X;
        {'EXIT',R} ->
            exit(R);
        'end' ->
            throw_error(L, unterminated_macro);
        Other ->
            throw(Other)
    end.

macro_content([$@,$@|Cs], As, L, N) ->
    macro_content(Cs, [$@,$@|As], L, N);
macro_content([$@,$}|Cs], As, L, N) ->
    macro_content(Cs, [$},$@|As], L, N);
macro_content([$@,${|Cs], As, L, N) ->
    macro_content(Cs, [${,$@|As], L, N);
macro_content([${,$@|Cs], As, L, N) ->
    macro_content(Cs, [$@,${|As], L, N + 1);
macro_content([$}|Cs], As, L, 0) ->
    {lists:reverse(As),Cs,L};
macro_content([$}|Cs], As, L, N) ->
    macro_content(Cs, [$}|As], L, N - 1);
macro_content([$\n = C|Cs], As, L, N) ->
    macro_content(Cs, [C|As], L + 1, N);
macro_content([C|Cs], As, L, N) ->
    macro_content(Cs, [C|As], L, N);
macro_content([], _As, _L, _N) ->
    throw('end').

-type line() :: erl_scan:line().

-type err() :: unterminated_macro
             | macro_name
             | {macro_name, string()}
             | {string(), [string()]}.

-spec throw_error(line(), err()) -> no_return().

throw_error(L, unterminated_macro) ->
    throw_error(L, {"unexpected end of macro.",[]});
throw_error(L, macro_name) ->
    throw_error(L, {"missing macro name.",[]});
throw_error(L, {macro_name,S}) ->
    throw_error(L, {"bad macro name: '@~s...'.",[lists:reverse(S)]});
throw_error(L, D) ->
    throw({error,L,D}).



