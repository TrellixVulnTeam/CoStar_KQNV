-file("test/lib/hipe/cerl/erl_types.erl", 1).

-module(erl_types).

-export([any_none/1,
         any_none_or_unit/1,
         lookup_record/3,
         max/2,
         module_builtin_opaques/1,
         min/2,
         number_max/1,
         number_min/1,
         t_abstract_records/2,
         t_any/0,
         t_arity/0,
         t_atom/0,
         t_atom/1,
         t_atoms/1,
         t_atom_vals/1,
         t_binary/0,
         t_bitstr/0,
         t_bitstr/2,
         t_bitstr_base/1,
         t_bitstr_concat/1,
         t_bitstr_concat/2,
         t_bitstr_match/2,
         t_bitstr_unit/1,
         t_bitstrlist/0,
         t_boolean/0,
         t_byte/0,
         t_char/0,
         t_collect_vars/1,
         t_cons/0,
         t_cons/2,
         t_cons_hd/1,
         t_cons_tl/1,
         t_constant/0,
         t_contains_opaque/1,
         t_elements/1,
         t_find_opaque_mismatch/2,
         t_fixnum/0,
         t_map/2,
         t_non_neg_fixnum/0,
         t_pos_fixnum/0,
         t_float/0,
         t_form_to_string/1,
         t_from_form/1,
         t_from_form/2,
         t_from_form/3,
         t_from_range/2,
         t_from_range_unsafe/2,
         t_from_term/1,
         t_fun/0,
         t_fun/1,
         t_fun/2,
         t_fun_args/1,
         t_fun_arity/1,
         t_fun_range/1,
         t_has_opaque_subtype/1,
         t_has_var/1,
         t_identifier/0,
         t_inf/2,
         t_inf/3,
         t_inf_lists/2,
         t_inf_lists/3,
         t_inf_lists_masked/3,
         t_integer/0,
         t_integer/1,
         t_non_neg_integer/0,
         t_pos_integer/0,
         t_integers/1,
         t_iodata/0,
         t_iolist/0,
         t_is_any/1,
         t_is_atom/1,
         t_is_atom/2,
         t_is_binary/1,
         t_is_bitstr/1,
         t_is_bitwidth/1,
         t_is_boolean/1,
         t_is_cons/1,
         t_is_constant/1,
         t_is_equal/2,
         t_is_fixnum/1,
         t_is_float/1,
         t_is_fun/1,
         t_is_instance/2,
         t_is_integer/1,
         t_is_list/1,
         t_is_matchstate/1,
         t_is_nil/1,
         t_is_non_neg_integer/1,
         t_is_none/1,
         t_is_none_or_unit/1,
         t_is_number/1,
         t_is_opaque/1,
         t_is_pid/1,
         t_is_port/1,
         t_is_maybe_improper_list/1,
         t_is_reference/1,
         t_is_remote/1,
         t_is_string/1,
         t_is_subtype/2,
         t_is_tuple/1,
         t_is_unit/1,
         t_is_var/1,
         t_limit/2,
         t_list/0,
         t_list/1,
         t_list_elements/1,
         t_list_termination/1,
         t_matchstate/0,
         t_matchstate/2,
         t_matchstate_present/1,
         t_matchstate_slot/2,
         t_matchstate_slots/1,
         t_matchstate_update_present/2,
         t_matchstate_update_slot/3,
         t_mfa/0,
         t_module/0,
         t_nil/0,
         t_node/0,
         t_none/0,
         t_nonempty_list/0,
         t_nonempty_list/1,
         t_nonempty_string/0,
         t_number/0,
         t_number/1,
         t_number_vals/1,
         t_opaque_from_records/1,
         t_opaque_match_atom/2,
         t_opaque_match_record/2,
         t_opaque_matching_structure/2,
         t_opaque_structure/1,
         t_pid/0,
         t_port/0,
         t_maybe_improper_list/0,
         t_product/1,
         t_reference/0,
         t_remote/3,
         t_string/0,
         t_struct_from_opaque/2,
         t_solve_remote/3,
         t_subst/2,
         t_subtract/2,
         t_subtract_list/2,
         t_sup/1,
         t_sup/2,
         t_tid/0,
         t_timeout/0,
         t_to_string/1,
         t_to_string/2,
         t_to_tlist/1,
         t_tuple/0,
         t_tuple/1,
         t_tuple_args/1,
         t_tuple_size/1,
         t_tuple_sizes/1,
         t_tuple_subtypes/1,
         t_unify/2,
         t_unify/3,
         t_unit/0,
         t_unopaque/1,
         t_unopaque/2,
         t_unopaque_on_mismatch/3,
         t_var/1,
         t_var_name/1,
         type_is_defined/4,
         record_field_diffs_to_string/2,
         subst_all_vars_to_any/1,
         lift_list_to_pos_empty/1,
         is_erl_type/1,
         atom_to_string/1]).

-compile({no_auto_import,[{min,2},{max,2}]}).

-export_type([{erl_type,0}]).

-type tag() :: atom
             | binary
             | function
             | identifier
             | list
             | matchstate
             | nil
             | number
             | opaque
             | product
             | remote
             | tuple
             | tuple_set
             | union
             | var.

-type qual() :: float
              | integer
              | nonempty
              | pid
              | port
              | reference
              | unknown
              | {_, _}.

-record(c,{tag :: undefined | tag(),
           elements = [] :: term(),
           qualifier = unknown :: qual()}).

-opaque erl_type() :: any | none | unit | #c{}.

-type parse_form() :: {atom(), _, _}
                    | {atom(), _, _, _}
                    | {op, _, _, _, _}.

-type rng_elem() :: pos_inf | neg_inf | integer().

-record(int_set,{set :: undefined | [integer()]}).

-record(int_rng,{from :: undefined | rng_elem(),
                 to :: undefined | rng_elem()}).

-record(opaque,{mod :: undefined | module(),
                name :: undefined | atom(),
                args = [] :: [erl_type()],
                struct :: undefined | erl_type()}).

-record(remote,{mod :: undefined | module(),
                name :: undefined | atom(),
                args = [] :: [erl_type()]}).

-spec t_any() -> erl_type().

t_any() ->
    any.

-spec t_is_any(erl_type()) -> boolean().

t_is_any(any) ->
    true;
t_is_any(_) ->
    false.

-spec t_none() -> erl_type().

t_none() ->
    none.

-spec t_is_none(erl_type()) -> boolean().

t_is_none(none) ->
    true;
t_is_none(_) ->
    false.

-spec t_opaque(module(), atom(), [_], erl_type()) -> erl_type().

t_opaque(Mod, Name, Args, Struct) ->
    O = #opaque{mod = Mod,name = Name,args = Args,struct = Struct},
    #c{tag = opaque,elements = set_singleton(O)}.

-spec t_is_opaque(erl_type()) -> boolean().

t_is_opaque(#c{tag = opaque,elements = _}) ->
    true;
t_is_opaque(_) ->
    false.

-spec t_has_opaque_subtype(erl_type()) -> boolean().

t_has_opaque_subtype(#c{tag = union,
                        elements = [_,_,_,_,_,_,_,_,_,_] = Ts}) ->
    lists:any(fun t_is_opaque/1, Ts);
t_has_opaque_subtype(T) ->
    t_is_opaque(T).

-spec t_opaque_structure(erl_type()) -> erl_type().

t_opaque_structure(#c{tag = opaque,elements = Elements}) ->
    t_sup([ 
           Struct ||
               #opaque{struct = Struct} <- ordsets:to_list(Elements)
          ]).

-spec t_opaque_module(erl_type()) -> module().

t_opaque_module(#c{tag = opaque,elements = Elements}) ->
    case ordsets:size(Elements) of
        1 ->
            [#opaque{mod = Module}] = ordsets:to_list(Elements),
            Module;
        _ ->
            throw({error,"Unexpected multiple opaque types"})
    end.

-spec t_opaque_matching_structure(erl_type(), erl_type()) -> erl_type().

t_opaque_matching_structure(Type, Opaque) ->
    OpaqueStruct = t_opaque_structure(Opaque),
    case OpaqueStruct of
        #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = L1} ->
            case Type of
                #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = _L2} ->
                    OpaqueStruct;
                _OtherType ->
                    t_opaque_matching_structure_list(Type, L1)
            end;
        #c{tag = tuple_set,elements = _Set1} = TupleSet ->
            case Type of
                #c{tag = tuple_set,elements = _Set2} ->
                    OpaqueStruct;
                _ ->
                    t_opaque_matching_structure_list(Type,
                                                     t_tuple_subtypes(TupleSet))
            end;
        _Other ->
            OpaqueStruct
    end.

t_opaque_matching_structure_list(Type, List) ->
    NewList =
        [ 
         t_inf(Element, Type) ||
             Element <- List
        ],
    Results =
        [ 
         NotNone ||
             NotNone <- NewList,
             NotNone =/= none
        ],
    case Results of
        [] ->
            none;
        [First|_] ->
            First
    end.

-spec t_contains_opaque(erl_type()) -> boolean().

t_contains_opaque(any) ->
    false;
t_contains_opaque(none) ->
    false;
t_contains_opaque(unit) ->
    false;
t_contains_opaque(#c{tag = atom,elements = _Set}) ->
    false;
t_contains_opaque(#c{tag = binary,elements = [_Unit,_Base]}) ->
    false;
t_contains_opaque(#c{tag = number,elements = any,qualifier = float}) ->
    false;
t_contains_opaque(#c{tag = function,elements = [Domain,Range]}) ->
    t_contains_opaque(Domain)
    orelse
    t_contains_opaque(Range);
t_contains_opaque(#c{tag = identifier,elements = _Types}) ->
    false;
t_contains_opaque(#c{tag = number,elements = _Types,qualifier = integer}) ->
    false;
t_contains_opaque(#c{tag = number,
                     elements = #int_rng{from = _From,to = _To},
                     qualifier = integer}) ->
    false;
t_contains_opaque(#c{tag = number,
                     elements = #int_set{set = _Set},
                     qualifier = integer}) ->
    false;
t_contains_opaque(#c{tag = list,elements = [Type,_],qualifier = _}) ->
    t_contains_opaque(Type);
t_contains_opaque(#c{tag = matchstate,elements = [_P,_Slots]}) ->
    false;
t_contains_opaque(#c{tag = nil}) ->
    false;
t_contains_opaque(#c{tag = number,elements = _Set,qualifier = _Tag}) ->
    false;
t_contains_opaque(#c{tag = opaque,elements = _}) ->
    true;
t_contains_opaque(#c{tag = product,elements = Types}) ->
    list_contains_opaque(Types);
t_contains_opaque(#c{tag = tuple,elements = any,qualifier = {_,_}}) ->
    false;
t_contains_opaque(#c{tag = tuple,elements = Types,qualifier = {_,_}}) ->
    list_contains_opaque(Types);
t_contains_opaque(#c{tag = tuple_set,elements = _Set} = T) ->
    list_contains_opaque(t_tuple_subtypes(T));
t_contains_opaque(#c{tag = union,
                     elements = [_,_,_,_,_,_,_,_,_,_] = List}) ->
    list_contains_opaque(List);
t_contains_opaque(#c{tag = var,elements = _Id}) ->
    false.

-spec list_contains_opaque([erl_type()]) -> boolean().

list_contains_opaque(List) ->
    lists:any(fun t_contains_opaque/1, List).

-spec t_find_opaque_mismatch(erl_type(), erl_type()) ->
                                error | {ok, erl_type(), erl_type()}.

t_find_opaque_mismatch(T1, T2) ->
    t_find_opaque_mismatch(T1, T2, T2).

t_find_opaque_mismatch(any, _Type, _TopType) ->
    error;
t_find_opaque_mismatch(none, _Type, _TopType) ->
    error;
t_find_opaque_mismatch(#c{tag = list,elements = [T1,_],qualifier = _},
                       #c{tag = list,elements = [T2,_],qualifier = _},
                       TopType) ->
    t_find_opaque_mismatch(T1, T2, TopType);
t_find_opaque_mismatch(_T1, #c{tag = opaque,elements = _} = T2, TopType) ->
    {ok,TopType,T2};
t_find_opaque_mismatch(#c{tag = product,elements = T1},
                       #c{tag = product,elements = T2},
                       TopType) ->
    t_find_opaque_mismatch_ordlists(T1, T2, TopType);
t_find_opaque_mismatch(#c{tag = tuple,
                          elements = T1,
                          qualifier = {Arity,_}},
                       #c{tag = tuple,
                          elements = T2,
                          qualifier = {Arity,_}},
                       TopType) ->
    t_find_opaque_mismatch_ordlists(T1, T2, TopType);
t_find_opaque_mismatch(#c{tag = tuple,elements = _,qualifier = {_,_}} =
                           T1,
                       #c{tag = tuple_set,elements = _} = T2,
                       TopType) ->
    Tuples1 = t_tuple_subtypes(T1),
    Tuples2 = t_tuple_subtypes(T2),
    t_find_opaque_mismatch_lists(Tuples1, Tuples2, TopType);
t_find_opaque_mismatch(T1,
                       #c{tag = union,
                          elements = [_,_,_,_,_,_,_,_,_,_] = U2},
                       TopType) ->
    t_find_opaque_mismatch_lists([T1], U2, TopType);
t_find_opaque_mismatch(_T1, _T2, _TopType) ->
    error.

t_find_opaque_mismatch_ordlists(L1, L2, TopType) ->
    List =
        lists:zipwith(fun(T1, T2) ->
                             t_find_opaque_mismatch(T1, T2, TopType)
                      end,
                      L1,
                      L2),
    t_find_opaque_mismatch_list(List).

t_find_opaque_mismatch_lists(L1, L2, _TopType) ->
    List =
        [ 
         t_find_opaque_mismatch(T1, T2, T2) ||
             T1 <- L1,
             T2 <- L2
        ],
    t_find_opaque_mismatch_list(List).

t_find_opaque_mismatch_list([]) ->
    error;
t_find_opaque_mismatch_list([H|T]) ->
    case H of
        {ok,_T1,_T2} ->
            H;
        error ->
            t_find_opaque_mismatch_list(T)
    end.

-spec t_opaque_from_records(dict()) -> [erl_type()].

t_opaque_from_records(RecDict) ->
    OpaqueRecDict =
        dict:filter(fun(Key, _Value) ->
                           case Key of
                               {opaque,_Name,_Arity} ->
                                   true;
                               _ ->
                                   false
                           end
                    end,
                    RecDict),
    OpaqueTypeDict =
        dict:map(fun({opaque,Name,_Arity}, {Module,Type,ArgNames}) ->
                        case ArgNames of
                            [] ->
                                t_opaque(Module,
                                         Name,
                                         [],
                                         t_from_form(Type, RecDict));
                            _ ->
                                throw({error,
                                       "Polymorphic opaque types not su"
                                       "pported yet"})
                        end
                 end,
                 OpaqueRecDict),
    [ 
     OpaqueType ||
         {_Key,OpaqueType} <- dict:to_list(OpaqueTypeDict)
    ].

-spec t_opaque_match_atom(erl_type(), [erl_type()]) -> [erl_type()].

t_opaque_match_atom(#c{tag = atom,elements = _} = Atom, Opaques) ->
    case t_atom_vals(Atom) of
        unknown ->
            [];
        _ ->
            [ 
             O ||
                 O <- Opaques,
                 t_inf(Atom, O, opaque) =/= none,
                 t_opaque_atom_vals(t_opaque_structure(O)) =/= unknown
            ]
    end;
t_opaque_match_atom(_, _) ->
    [].

-spec t_opaque_atom_vals(erl_type()) -> unknown | [atom(), ...].

t_opaque_atom_vals(OpaqueStruct) ->
    case OpaqueStruct of
        #c{tag = atom,elements = _} ->
            t_atom_vals(OpaqueStruct);
        #c{tag = union,
           elements = [_,_,_,_,_,_,_,_,_,_] = [Atom,_,_,_,_,_,_,_,_,_]} ->
            t_atom_vals(Atom);
        _ ->
            unknown
    end.

-spec t_opaque_match_record(erl_type(), [erl_type()]) -> [erl_type()].

t_opaque_match_record(#c{tag = tuple,
                         elements =
                             [#c{tag = atom,elements = _} = Tag|_Fields],
                         qualifier = {_,_}} =
                          Rec,
                      Opaques) ->
    [ 
     O ||
         O <- Opaques,
         t_inf(Rec, O, opaque) =/= none,
         lists:member(Tag, t_opaque_tuple_tags(t_opaque_structure(O)))
    ];
t_opaque_match_record(_, _) ->
    [].

-spec t_opaque_tuple_tags(erl_type()) -> [erl_type()].

t_opaque_tuple_tags(OpaqueStruct) ->
    case OpaqueStruct of
        #c{tag = tuple,
           elements = [#c{tag = atom,elements = _} = Tag|_Fields],
           qualifier = {_,_}} ->
            [Tag];
        #c{tag = tuple_set,elements = _} = TupleSet ->
            Tuples = t_tuple_subtypes(TupleSet),
            lists:flatten([ 
                           t_opaque_tuple_tags(T) ||
                               T <- Tuples
                          ]);
        #c{tag = union,
           elements = [_,_,_,_,_,_,_,_,_,_] = [_,_,_,_,_,_,Tuples,_,_,_]} ->
            t_opaque_tuple_tags(Tuples);
        _ ->
            []
    end.

-spec t_struct_from_opaque(erl_type(), [erl_type()]) -> erl_type().

t_struct_from_opaque(#c{tag = function,elements = [Domain,Range]},
                     Opaques) ->
    #c{tag = function,
       elements =
           [t_struct_from_opaque(Domain, Opaques),
            t_struct_from_opaque(Range, Opaques)]};
t_struct_from_opaque(#c{tag = list,
                        elements = [Types,Term],
                        qualifier = Size},
                     Opaques) ->
    #c{tag = list,
       elements = [t_struct_from_opaque(Types, Opaques),Term],
       qualifier = Size};
t_struct_from_opaque(#c{tag = opaque,elements = _} = T, Opaques) ->
    case lists:member(T, Opaques) of
        true ->
            t_opaque_structure(T);
        false ->
            T
    end;
t_struct_from_opaque(#c{tag = product,elements = Types}, Opaques) ->
    #c{tag = product,elements = list_struct_from_opaque(Types, Opaques)};
t_struct_from_opaque(#c{tag = tuple,elements = any,qualifier = {_,_}} =
                         T,
                     _Opaques) ->
    T;
t_struct_from_opaque(#c{tag = tuple,
                        elements = Types,
                        qualifier = {Arity,Tag}},
                     Opaques) ->
    #c{tag = tuple,
       elements = list_struct_from_opaque(Types, Opaques),
       qualifier = {Arity,Tag}};
t_struct_from_opaque(#c{tag = tuple_set,elements = Set}, Opaques) ->
    NewSet =
        [ 
         {Sz,
          [ 
           t_struct_from_opaque(T, Opaques) ||
               T <- Tuples
          ]} ||
             {Sz,Tuples} <- Set
        ],
    #c{tag = tuple_set,elements = NewSet};
t_struct_from_opaque(#c{tag = union,
                        elements = [_,_,_,_,_,_,_,_,_,_] = List},
                     Opaques) ->
    t_sup(list_struct_from_opaque(List, Opaques));
t_struct_from_opaque(Type, _Opaques) ->
    Type.

list_struct_from_opaque(Types, Opaques) ->
    [ 
     t_struct_from_opaque(Type, Opaques) ||
         Type <- Types
    ].

-spec t_unopaque_on_mismatch(erl_type(), erl_type(), [erl_type()]) ->
                                erl_type().

t_unopaque_on_mismatch(GenType, Type, Opaques) ->
    case t_inf(GenType, Type) of
        none ->
            Unopaqued = t_unopaque(Type, Opaques),
            case t_inf(GenType, Unopaqued) of
                none ->
                    Type;
                _ ->
                    Unopaqued
            end;
        _ ->
            Type
    end.

-spec module_builtin_opaques(module()) -> [erl_type()].

module_builtin_opaques(Module) ->
    [ 
     O ||
         O <- all_opaque_builtins(),
         t_opaque_module(O) =:= Module
    ].

-spec t_remote(atom(), atom(), [erl_type()]) -> erl_type().

t_remote(Mod, Name, Args) ->
    #c{tag = remote,
       elements =
           set_singleton(#remote{mod = Mod,name = Name,args = Args})}.

-spec t_is_remote(erl_type()) -> boolean().

t_is_remote(#c{tag = remote,elements = _}) ->
    true;
t_is_remote(_) ->
    false.

-spec t_solve_remote(erl_type(), set(), dict()) -> erl_type().

t_solve_remote(Type, ExpTypes, Records) ->
    {RT,_RR} = t_solve_remote(Type, ExpTypes, Records, []),
    RT.

t_solve_remote(#c{tag = function,elements = [Domain,Range]}, ET, R, C) ->
    {RT1,RR1} = t_solve_remote(Domain, ET, R, C),
    {RT2,RR2} = t_solve_remote(Range, ET, R, C),
    {#c{tag = function,elements = [RT1,RT2]},RR1 ++ RR2};
t_solve_remote(#c{tag = list,elements = [Types,Term],qualifier = Size},
               ET,
               R,
               C) ->
    {RT1,RR1} = t_solve_remote(Types, ET, R, C),
    {RT2,RR2} = t_solve_remote(Term, ET, R, C),
    {#c{tag = list,elements = [RT1,RT2],qualifier = Size},RR1 ++ RR2};
t_solve_remote(#c{tag = product,elements = Types}, ET, R, C) ->
    {RL,RR} = list_solve_remote(Types, ET, R, C),
    {#c{tag = product,elements = RL},RR};
t_solve_remote(#c{tag = opaque,elements = Set}, ET, R, C) ->
    List = ordsets:to_list(Set),
    {NewList,RR} = opaques_solve_remote(List, ET, R, C),
    {#c{tag = opaque,elements = ordsets:from_list(NewList)},RR};
t_solve_remote(#c{tag = tuple,elements = any,qualifier = {_,_}} = T,
               _ET,
               _R,
               _C) ->
    {T,[]};
t_solve_remote(#c{tag = tuple,
                  elements = Types,
                  qualifier = {_Arity,_Tag}},
               ET,
               R,
               C) ->
    {RL,RR} = list_solve_remote(Types, ET, R, C),
    {t_tuple(RL),RR};
t_solve_remote(#c{tag = tuple_set,elements = Set}, ET, R, C) ->
    {NewTuples,RR} = tuples_solve_remote(Set, ET, R, C),
    {t_sup(NewTuples),RR};
t_solve_remote(#c{tag = remote,elements = Set}, ET, R, C) ->
    RemoteList = ordsets:to_list(Set),
    {RL,RR} = list_solve_remote_type(RemoteList, ET, R, C),
    {t_sup(RL),RR};
t_solve_remote(#c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = List},
               ET,
               R,
               C) ->
    {RL,RR} = list_solve_remote(List, ET, R, C),
    {t_sup(RL),RR};
t_solve_remote(T, _ET, _R, _C) ->
    {T,[]}.

t_solve_remote_type(#remote{mod = RemMod,name = Name,args = Args} =
                        RemType,
                    ET,
                    R,
                    C) ->
    ArgsLen = length(Args),
    case dict:find(RemMod, R) of
        error ->
            self() ! {self(),ext_types,{RemMod,Name,ArgsLen}},
            {t_any(),[]};
        {ok,RemDict} ->
            MFA = {RemMod,Name,ArgsLen},
            case sets:is_element(MFA, ET) of
                true ->
                    case lookup_type(Name, ArgsLen, RemDict) of
                        {type,{_Mod,Type,ArgNames}} ->
                            {NewType,NewCycle,NewRR} =
                                case can_unfold_more(RemType, C) of
                                    true ->
                                        List = lists:zip(ArgNames, Args),
                                        TmpVarDict =
                                            dict:from_list(List),
                                        {t_from_form(Type,
                                                     RemDict,
                                                     TmpVarDict),
                                         [RemType|C],
                                         []};
                                    false ->
                                        {t_any(),C,[RemType]}
                                end,
                            {RT,RR} =
                                t_solve_remote(NewType, ET, R, NewCycle),
                            RetRR = NewRR ++ RR,
                            RT1 =
                                case lists:member(RemType, RetRR) of
                                    true ->
                                        t_limit(RT, 2);
                                    false ->
                                        RT
                                end,
                            {RT1,RetRR};
                        {opaque,{Mod,Type,ArgNames}} ->
                            List = lists:zip(ArgNames, Args),
                            TmpVarDict = dict:from_list(List),
                            {Rep,NewCycle,NewRR} =
                                case can_unfold_more(RemType, C) of
                                    true ->
                                        {t_from_form(Type,
                                                     RemDict,
                                                     TmpVarDict),
                                         [RemType|C],
                                         []};
                                    false ->
                                        {t_any(),C,[RemType]}
                                end,
                            {NewRep,RR} =
                                t_solve_remote(Rep, ET, R, NewCycle),
                            RetRR = NewRR ++ RR,
                            RT1 =
                                case lists:member(RemType, RetRR) of
                                    true ->
                                        t_limit(NewRep, 2);
                                    false ->
                                        NewRep
                                end,
                            {t_from_form({opaque,
                                          - 1,
                                          Name,
                                          {Mod,Args,RT1}},
                                         RemDict,
                                         TmpVarDict),
                             RetRR};
                        error ->
                            Msg =
                                io_lib:format("Unable to find remote ty"
                                              "pe ~w:~w()\n",
                                              [RemMod,Name]),
                            throw({error,Msg})
                    end;
                false ->
                    self() ! {self(),ext_types,{RemMod,Name,ArgsLen}},
                    {t_any(),[]}
            end
    end.

list_solve_remote([], _ET, _R, _C) ->
    {[],[]};
list_solve_remote([Type|Types], ET, R, C) ->
    {RT,RR1} = t_solve_remote(Type, ET, R, C),
    {RL,RR2} = list_solve_remote(Types, ET, R, C),
    {[RT|RL],RR1 ++ RR2}.

list_solve_remote_type([], _ET, _R, _C) ->
    {[],[]};
list_solve_remote_type([Type|Types], ET, R, C) ->
    {RT,RR1} = t_solve_remote_type(Type, ET, R, C),
    {RL,RR2} = list_solve_remote_type(Types, ET, R, C),
    {[RT|RL],RR1 ++ RR2}.

opaques_solve_remote([], _ET, _R, _C) ->
    {[],[]};
opaques_solve_remote([#opaque{struct = Struct} = Remote|Tail], ET, R, C) ->
    {RT,RR1} = t_solve_remote(Struct, ET, R, C),
    {LOp,RR2} = opaques_solve_remote(Tail, ET, R, C),
    {[Remote#opaque{struct = RT}|LOp],RR1 ++ RR2}.

tuples_solve_remote([], _ET, _R, _C) ->
    {[],[]};
tuples_solve_remote([{_Sz,Tuples}|Tail], ET, R, C) ->
    {RL,RR1} = list_solve_remote(Tuples, ET, R, C),
    {LSzTpls,RR2} = tuples_solve_remote(Tail, ET, R, C),
    {RL ++ LSzTpls,RR1 ++ RR2}.

-spec t_unit() -> erl_type().

t_unit() ->
    unit.

-spec t_is_unit(erl_type()) -> boolean().

t_is_unit(unit) ->
    true;
t_is_unit(_) ->
    false.

-spec t_is_none_or_unit(erl_type()) -> boolean().

t_is_none_or_unit(none) ->
    true;
t_is_none_or_unit(unit) ->
    true;
t_is_none_or_unit(_) ->
    false.

-spec t_atom() -> erl_type().

t_atom() ->
    #c{tag = atom,elements = any}.

-spec t_atom(atom()) -> erl_type().

t_atom(A) when is_atom(A) ->
    #c{tag = atom,elements = set_singleton(A)}.

-spec t_atoms([atom()]) -> erl_type().

t_atoms(List) when is_list(List) ->
    t_sup([ 
           t_atom(A) ||
               A <- List
          ]).

-spec t_atom_vals(erl_type()) -> unknown | [atom(), ...].

t_atom_vals(#c{tag = atom,elements = any}) ->
    unknown;
t_atom_vals(#c{tag = atom,elements = Set}) ->
    set_to_list(Set);
t_atom_vals(Other) ->
    #c{tag = atom,elements = _} = Atm = t_inf(t_atom(), Other),
    t_atom_vals(Atm).

-spec t_is_atom(erl_type()) -> boolean().

t_is_atom(#c{tag = atom,elements = _}) ->
    true;
t_is_atom(_) ->
    false.

-spec t_is_atom(atom(), erl_type()) -> boolean().

t_is_atom(Atom, #c{tag = atom,elements = any}) when is_atom(Atom) ->
    false;
t_is_atom(Atom, #c{tag = atom,elements = Set}) when is_atom(Atom) ->
    set_is_singleton(Atom, Set);
t_is_atom(Atom, _) when is_atom(Atom) ->
    false.

-spec t_boolean() -> erl_type().

t_boolean() ->
    #c{tag = atom,elements = set_from_list([false,true])}.

-spec t_is_boolean(erl_type()) -> boolean().

t_is_boolean(#c{tag = atom,elements = any}) ->
    false;
t_is_boolean(#c{tag = atom,elements = Set}) ->
    case set_size(Set) of
        1 ->
            set_is_element(true, Set)
            orelse
            set_is_element(false, Set);
        2 ->
            set_is_element(true, Set)
            andalso
            set_is_element(false, Set);
        N when is_integer(N), N > 2 ->
            false
    end;
t_is_boolean(_) ->
    false.

-spec t_binary() -> erl_type().

t_binary() ->
    #c{tag = binary,elements = [8,0]}.

-spec t_is_binary(erl_type()) -> boolean().

t_is_binary(#c{tag = binary,elements = [U,B]}) ->
    U rem 8 =:= 0
    andalso
    B rem 8 =:= 0;
t_is_binary(_) ->
    false.

-spec t_bitstr() -> erl_type().

t_bitstr() ->
    #c{tag = binary,elements = [1,0]}.

-spec t_bitstr(non_neg_integer(), non_neg_integer()) -> erl_type().

t_bitstr(U, B) ->
    NewB =
        if
            U =:= 0 ->
                B;
            B >= U * (8 + 1) ->
                B rem U + U * 8;
            true ->
                B
        end,
    #c{tag = binary,elements = [U,NewB]}.

-spec t_bitstr_unit(erl_type()) -> non_neg_integer().

t_bitstr_unit(#c{tag = binary,elements = [U,_]}) ->
    U.

-spec t_bitstr_base(erl_type()) -> non_neg_integer().

t_bitstr_base(#c{tag = binary,elements = [_,B]}) ->
    B.

-spec t_bitstr_concat([erl_type()]) -> erl_type().

t_bitstr_concat(List) ->
    t_bitstr_concat_1(List, t_bitstr(0, 0)).

t_bitstr_concat_1([T|Left], Acc) ->
    t_bitstr_concat_1(Left, t_bitstr_concat(Acc, T));
t_bitstr_concat_1([], Acc) ->
    Acc.

-spec t_bitstr_concat(erl_type(), erl_type()) -> erl_type().

t_bitstr_concat(T1, T2) ->
    T1p = t_inf(t_bitstr(), T1),
    T2p = t_inf(t_bitstr(), T2),
    bitstr_concat(T1p, T2p).

-spec t_bitstr_match(erl_type(), erl_type()) -> erl_type().

t_bitstr_match(T1, T2) ->
    T1p = t_inf(t_bitstr(), T1),
    T2p = t_inf(t_bitstr(), T2),
    bitstr_match(T1p, T2p).

-spec t_is_bitstr(erl_type()) -> boolean().

t_is_bitstr(#c{tag = binary,elements = [_,_]}) ->
    true;
t_is_bitstr(_) ->
    false.

-spec t_matchstate() -> erl_type().

t_matchstate() ->
    #c{tag = matchstate,elements = [t_bitstr(),any]}.

-spec t_matchstate(erl_type(), non_neg_integer()) -> erl_type().

t_matchstate(Init, 0) ->
    #c{tag = matchstate,elements = [Init,Init]};
t_matchstate(Init, Max) when is_integer(Max) ->
    Slots =
        [Init|
         [ 
          none ||
              _ <- lists:seq(1, Max)
         ]],
    #c{tag = matchstate,elements = [Init,t_product(Slots)]}.

-spec t_is_matchstate(erl_type()) -> boolean().

t_is_matchstate(#c{tag = matchstate,elements = [_,_]}) ->
    true;
t_is_matchstate(_) ->
    false.

-spec t_matchstate_present(erl_type()) -> erl_type().

t_matchstate_present(Type) ->
    case t_inf(t_matchstate(), Type) of
        #c{tag = matchstate,elements = [P,_]} ->
            P;
        _ ->
            none
    end.

-spec t_matchstate_slot(erl_type(), non_neg_integer()) -> erl_type().

t_matchstate_slot(Type, Slot) ->
    RealSlot = Slot + 1,
    case t_inf(t_matchstate(), Type) of
        #c{tag = matchstate,elements = [_,any]} ->
            any;
        #c{tag = matchstate,
           elements = [_,#c{tag = product,elements = Vals}]}
            when length(Vals) >= RealSlot ->
            lists:nth(RealSlot, Vals);
        #c{tag = matchstate,
           elements = [_,#c{tag = product,elements = _}]} ->
            none;
        #c{tag = matchstate,elements = [_,SlotType]} when RealSlot =:= 1 ->
            SlotType;
        _ ->
            none
    end.

-spec t_matchstate_slots(erl_type()) -> erl_type().

t_matchstate_slots(#c{tag = matchstate,elements = [_,Slots]}) ->
    Slots.

-spec t_matchstate_update_present(erl_type(), erl_type()) -> erl_type().

t_matchstate_update_present(New, Type) ->
    case t_inf(t_matchstate(), Type) of
        #c{tag = matchstate,elements = [_,Slots]} ->
            #c{tag = matchstate,elements = [New,Slots]};
        _ ->
            none
    end.

-spec t_matchstate_update_slot(erl_type(),
                               erl_type(),
                               non_neg_integer()) ->
                                  erl_type().

t_matchstate_update_slot(New, Type, Slot) ->
    RealSlot = Slot + 1,
    case t_inf(t_matchstate(), Type) of
        #c{tag = matchstate,elements = [Pres,Slots]} ->
            NewSlots =
                case Slots of
                    any ->
                        any;
                    #c{tag = product,elements = Vals}
                        when length(Vals) >= RealSlot ->
                        NewTuple =
                            setelement(RealSlot,
                                       list_to_tuple(Vals),
                                       New),
                        NewVals = tuple_to_list(NewTuple),
                        #c{tag = product,elements = NewVals};
                    #c{tag = product,elements = _} ->
                        none;
                    _ when RealSlot =:= 1 ->
                        New;
                    _ ->
                        none
                end,
            #c{tag = matchstate,elements = [Pres,NewSlots]};
        _ ->
            none
    end.

-spec t_fun() -> erl_type().

t_fun() ->
    #c{tag = function,elements = [any,any]}.

-spec t_fun(erl_type()) -> erl_type().

t_fun(Range) ->
    #c{tag = function,elements = [any,Range]}.

-spec t_fun([erl_type()] | arity(), erl_type()) -> erl_type().

t_fun(Domain, Range) when is_list(Domain) ->
    #c{tag = function,
       elements = [#c{tag = product,elements = Domain},Range]};
t_fun(Arity, Range) when is_integer(Arity), 0 =< Arity, Arity =< 255 ->
    #c{tag = function,
       elements =
           [#c{tag = product,elements = lists:duplicate(Arity, any)},
            Range]}.

-spec t_fun_args(erl_type()) -> unknown | [erl_type()].

t_fun_args(#c{tag = function,elements = [any,_]}) ->
    unknown;
t_fun_args(#c{tag = function,
              elements = [#c{tag = product,elements = Domain},_]})
    when is_list(Domain) ->
    Domain.

-spec t_fun_arity(erl_type()) -> unknown | non_neg_integer().

t_fun_arity(#c{tag = function,elements = [any,_]}) ->
    unknown;
t_fun_arity(#c{tag = function,
               elements = [#c{tag = product,elements = Domain},_]}) ->
    length(Domain).

-spec t_fun_range(erl_type()) -> erl_type().

t_fun_range(#c{tag = function,elements = [_,Range]}) ->
    Range.

-spec t_is_fun(erl_type()) -> boolean().

t_is_fun(#c{tag = function,elements = [_,_]}) ->
    true;
t_is_fun(_) ->
    false.

-spec t_identifier() -> erl_type().

t_identifier() ->
    #c{tag = identifier,elements = any}.

-spec t_port() -> erl_type().

t_port() ->
    #c{tag = identifier,elements = set_singleton(port)}.

-spec t_is_port(erl_type()) -> boolean().

t_is_port(#c{tag = identifier,elements = any}) ->
    false;
t_is_port(#c{tag = identifier,elements = Set}) ->
    set_is_singleton(port, Set);
t_is_port(_) ->
    false.

-spec t_pid() -> erl_type().

t_pid() ->
    #c{tag = identifier,elements = set_singleton(pid)}.

-spec t_is_pid(erl_type()) -> boolean().

t_is_pid(#c{tag = identifier,elements = any}) ->
    false;
t_is_pid(#c{tag = identifier,elements = Set}) ->
    set_is_singleton(pid, Set);
t_is_pid(_) ->
    false.

-spec t_reference() -> erl_type().

t_reference() ->
    #c{tag = identifier,elements = set_singleton(reference)}.

-spec t_is_reference(erl_type()) -> boolean().

t_is_reference(#c{tag = identifier,elements = any}) ->
    false;
t_is_reference(#c{tag = identifier,elements = Set}) ->
    set_is_singleton(reference, Set);
t_is_reference(_) ->
    false.

-spec t_number() -> erl_type().

t_number() ->
    #c{tag = number,elements = any,qualifier = unknown}.

-spec t_number(integer()) -> erl_type().

t_number(X) when is_integer(X) ->
    t_integer(X).

-spec t_is_number(erl_type()) -> boolean().

t_is_number(#c{tag = number,elements = _,qualifier = _}) ->
    true;
t_is_number(_) ->
    false.

-spec t_number_vals(erl_type()) -> unknown | [integer(), ...].

t_number_vals(#c{tag = number,
                 elements = #int_set{set = any},
                 qualifier = integer}) ->
    unknown;
t_number_vals(#c{tag = number,
                 elements = #int_set{set = Set},
                 qualifier = integer}) ->
    set_to_list(Set);
t_number_vals(#c{tag = number,elements = _,qualifier = _}) ->
    unknown;
t_number_vals(Other) ->
    Inf = t_inf(Other, t_number()),
    false = t_is_none(Inf),
    t_number_vals(Inf).

-spec t_float() -> erl_type().

t_float() ->
    #c{tag = number,elements = any,qualifier = float}.

-spec t_is_float(erl_type()) -> boolean().

t_is_float(#c{tag = number,elements = any,qualifier = float}) ->
    true;
t_is_float(_) ->
    false.

-spec t_integer() -> erl_type().

t_integer() ->
    #c{tag = number,elements = any,qualifier = integer}.

-spec t_integer(integer()) -> erl_type().

t_integer(I) when is_integer(I) ->
    #c{tag = number,
       elements = #int_set{set = set_singleton(I)},
       qualifier = integer}.

-spec t_integers([integer()]) -> erl_type().

t_integers(List) when is_list(List) ->
    t_sup([ 
           t_integer(I) ||
               I <- List
          ]).

-spec t_is_integer(erl_type()) -> boolean().

t_is_integer(#c{tag = number,elements = _,qualifier = integer}) ->
    true;
t_is_integer(_) ->
    false.

-spec t_byte() -> erl_type().

t_byte() ->
    #c{tag = number,
       elements = #int_rng{from = 0,to = 255},
       qualifier = integer}.

-spec t_char() -> erl_type().

t_char() ->
    #c{tag = number,
       elements = #int_rng{from = 0,to = 1114111},
       qualifier = integer}.

-spec t_is_char(erl_type()) -> boolean().

t_is_char(#c{tag = number,
             elements = #int_rng{from = neg_inf,to = _},
             qualifier = integer}) ->
    false;
t_is_char(#c{tag = number,
             elements = #int_rng{from = _,to = pos_inf},
             qualifier = integer}) ->
    false;
t_is_char(#c{tag = number,
             elements = #int_rng{from = From,to = To},
             qualifier = integer})
    when is_integer(From), From >= 0, is_integer(To), To =< 1114111 ->
    true;
t_is_char(#c{tag = number,
             elements = #int_set{set = Set},
             qualifier = integer}) ->
    set_min(Set) >= 0
    andalso
    set_max(Set) =< 1114111;
t_is_char(_) ->
    false.

-spec t_cons() -> erl_type().

t_cons() ->
    #c{tag = list,elements = [any,any],qualifier = nonempty}.

-spec t_cons(erl_type(), erl_type()) -> erl_type().

t_cons(none, _) ->
    none;
t_cons(_, none) ->
    none;
t_cons(unit, _) ->
    none;
t_cons(_, unit) ->
    none;
t_cons(Hd, #c{tag = nil}) ->
    #c{tag = list,elements = [Hd,#c{tag = nil}],qualifier = nonempty};
t_cons(Hd,
       #c{tag = list,elements = [Contents,Termination],qualifier = _}) ->
    #c{tag = list,
       elements = [t_sup(Contents, Hd),Termination],
       qualifier = nonempty};
t_cons(Hd, Tail) ->
    case t_inf(Tail, t_maybe_improper_list()) of
        #c{tag = list,
           elements = [Contents,Termination],
           qualifier = _Size} ->
            NewTermination =
                t_sup(t_subtract(Tail, t_maybe_improper_list()),
                      Termination),
            #c{tag = list,
               elements = [t_sup(Hd, Contents),NewTermination],
               qualifier = nonempty};
        #c{tag = nil} ->
            #c{tag = list,elements = [Hd,Tail],qualifier = nonempty};
        none ->
            #c{tag = list,elements = [Hd,Tail],qualifier = nonempty};
        unit ->
            none
    end.

-spec t_is_cons(erl_type()) -> boolean().

t_is_cons(#c{tag = list,elements = [_,_],qualifier = nonempty}) ->
    true;
t_is_cons(_) ->
    false.

-spec t_cons_hd(erl_type()) -> erl_type().

t_cons_hd(#c{tag = list,
             elements = [Contents,_Termination],
             qualifier = nonempty}) ->
    Contents.

-spec t_cons_tl(erl_type()) -> erl_type().

t_cons_tl(#c{tag = list,
             elements = [_Contents,Termination],
             qualifier = nonempty} =
              T) ->
    t_sup(Termination, T).

-spec t_nil() -> erl_type().

t_nil() ->
    #c{tag = nil}.

-spec t_is_nil(erl_type()) -> boolean().

t_is_nil(#c{tag = nil}) ->
    true;
t_is_nil(_) ->
    false.

-spec t_list() -> erl_type().

t_list() ->
    #c{tag = list,elements = [any,#c{tag = nil}],qualifier = unknown}.

-spec t_list(erl_type()) -> erl_type().

t_list(none) ->
    none;
t_list(unit) ->
    none;
t_list(Contents) ->
    #c{tag = list,
       elements = [Contents,#c{tag = nil}],
       qualifier = unknown}.

-spec t_list_elements(erl_type()) -> erl_type().

t_list_elements(#c{tag = list,elements = [Contents,_],qualifier = _}) ->
    Contents;
t_list_elements(#c{tag = nil}) ->
    none.

-spec t_list_termination(erl_type()) -> erl_type().

t_list_termination(#c{tag = nil}) ->
    #c{tag = nil};
t_list_termination(#c{tag = list,elements = [_,Term],qualifier = _}) ->
    Term.

-spec t_is_list(erl_type()) -> boolean().

t_is_list(#c{tag = list,
             elements = [_Contents,#c{tag = nil}],
             qualifier = _}) ->
    true;
t_is_list(#c{tag = nil}) ->
    true;
t_is_list(_) ->
    false.

-spec t_nonempty_list() -> erl_type().

t_nonempty_list() ->
    t_cons(any, #c{tag = nil}).

-spec t_nonempty_list(erl_type()) -> erl_type().

t_nonempty_list(Type) ->
    t_cons(Type, #c{tag = nil}).

-spec t_nonempty_string() -> erl_type().

t_nonempty_string() ->
    t_nonempty_list(t_char()).

-spec t_string() -> erl_type().

t_string() ->
    t_list(t_char()).

-spec t_is_string(erl_type()) -> boolean().

t_is_string(X) ->
    t_is_list(X)
    andalso
    t_is_char(t_list_elements(X)).

-spec t_maybe_improper_list() -> erl_type().

t_maybe_improper_list() ->
    #c{tag = list,elements = [any,any],qualifier = unknown}.

-spec t_maybe_improper_list(erl_type(), erl_type()) -> erl_type().

t_maybe_improper_list(_Content, unit) ->
    none;
t_maybe_improper_list(unit, _Termination) ->
    none;
t_maybe_improper_list(Content, Termination) ->
    #c{tag = list,elements = [Content,Termination],qualifier = unknown}.

-spec t_is_maybe_improper_list(erl_type()) -> boolean().

t_is_maybe_improper_list(#c{tag = list,elements = [_,_],qualifier = _}) ->
    true;
t_is_maybe_improper_list(#c{tag = nil}) ->
    true;
t_is_maybe_improper_list(_) ->
    false.

-spec lift_list_to_pos_empty(erl_type()) -> erl_type().

lift_list_to_pos_empty(#c{tag = nil}) ->
    #c{tag = nil};
lift_list_to_pos_empty(#c{tag = list,
                          elements = [Content,Termination],
                          qualifier = _}) ->
    #c{tag = list,elements = [Content,Termination],qualifier = unknown}.

-spec t_tuple() -> erl_type().

t_tuple() ->
    #c{tag = tuple,elements = any,qualifier = {any,any}}.

-spec t_tuple(non_neg_integer() | [erl_type()]) -> erl_type().

t_tuple(N) when is_integer(N) ->
    #c{tag = tuple,
       elements = lists:duplicate(N, any),
       qualifier = {N,any}};
t_tuple(List) ->
    case any_none_or_unit(List) of
        true ->
            t_none();
        false ->
            Arity = length(List),
            case get_tuple_tags(List) of
                [Tag] ->
                    #c{tag = tuple,
                       elements = List,
                       qualifier = {Arity,Tag}};
                TagList ->
                    SortedTagList = lists:sort(TagList),
                    Tuples =
                        [ 
                         #c{tag = tuple,
                            elements = [T|tl(List)],
                            qualifier = {Arity,T}} ||
                             T <- SortedTagList
                        ],
                    #c{tag = tuple_set,elements = [{Arity,Tuples}]}
            end
    end.

-spec get_tuple_tags([erl_type()]) -> [erl_type(), ...].

get_tuple_tags([#c{tag = atom,elements = any}|_]) ->
    [any];
get_tuple_tags([#c{tag = atom,elements = Set}|_]) ->
    case set_size(Set) > 5 of
        true ->
            [any];
        false ->
            [ 
             t_atom(A) ||
                 A <- set_to_list(Set)
            ]
    end;
get_tuple_tags(_) ->
    [any].

-spec t_tuple_args(erl_type()) -> [erl_type()].

t_tuple_args(#c{tag = tuple,elements = Args,qualifier = {_,_}})
    when is_list(Args) ->
    Args.

-spec t_tuple_size(erl_type()) -> non_neg_integer().

t_tuple_size(#c{tag = tuple,elements = _,qualifier = {Size,_}})
    when is_integer(Size) ->
    Size.

-spec t_tuple_sizes(erl_type()) -> unknown | [non_neg_integer(), ...].

t_tuple_sizes(#c{tag = tuple,elements = any,qualifier = {any,any}}) ->
    unknown;
t_tuple_sizes(#c{tag = tuple,elements = _,qualifier = {Size,_}})
    when is_integer(Size) ->
    [Size];
t_tuple_sizes(#c{tag = tuple_set,elements = List}) ->
    [ 
     Size ||
         {Size,_} <- List
    ].

-spec t_tuple_subtypes(erl_type()) -> unknown | [erl_type(), ...].

t_tuple_subtypes(#c{tag = tuple,elements = any,qualifier = {any,any}}) ->
    unknown;
t_tuple_subtypes(#c{tag = tuple,elements = _,qualifier = {_,_}} = T) ->
    [T];
t_tuple_subtypes(#c{tag = tuple_set,elements = List}) ->
    lists:append([ 
                  Tuples ||
                      {_Size,Tuples} <- List
                 ]).

-spec t_is_tuple(erl_type()) -> boolean().

t_is_tuple(#c{tag = tuple,elements = _,qualifier = {_,_}}) ->
    true;
t_is_tuple(#c{tag = tuple_set,elements = _}) ->
    true;
t_is_tuple(_) ->
    false.

-spec t_bitstrlist() -> erl_type().

t_bitstrlist() ->
    t_iolist(1, t_bitstr()).

-spec t_constant() -> erl_type().

t_constant() ->
    t_sup([t_number(),t_identifier(),t_atom(),t_fun(),t_binary()]).

-spec t_is_constant(erl_type()) -> boolean().

t_is_constant(X) ->
    t_is_subtype(X, t_constant()).

-spec t_arity() -> erl_type().

t_arity() ->
    t_from_range(0, 255).

-spec t_pos_integer() -> erl_type().

t_pos_integer() ->
    t_from_range(1, pos_inf).

-spec t_non_neg_integer() -> erl_type().

t_non_neg_integer() ->
    t_from_range(0, pos_inf).

-spec t_is_non_neg_integer(erl_type()) -> boolean().

t_is_non_neg_integer(#c{tag = number,elements = _,qualifier = integer} =
                         T) ->
    t_is_subtype(T, t_non_neg_integer());
t_is_non_neg_integer(_) ->
    false.

-spec t_neg_integer() -> erl_type().

t_neg_integer() ->
    t_from_range(neg_inf, - 1).

-spec t_fixnum() -> erl_type().

t_fixnum() ->
    t_integer().

-spec t_pos_fixnum() -> erl_type().

t_pos_fixnum() ->
    t_pos_integer().

-spec t_non_neg_fixnum() -> erl_type().

t_non_neg_fixnum() ->
    t_non_neg_integer().

-spec t_mfa() -> erl_type().

t_mfa() ->
    t_tuple([t_atom(),t_atom(),t_arity()]).

-spec t_module() -> erl_type().

t_module() ->
    t_sup(t_atom(), t_parameterized_module()).

-spec t_node() -> erl_type().

t_node() ->
    t_atom().

-spec t_iodata() -> erl_type().

t_iodata() ->
    t_sup(t_iolist(), t_binary()).

-spec t_iolist() -> erl_type().

t_iolist() ->
    t_iolist(1, t_binary()).

-spec t_iolist(non_neg_integer(), erl_type()) -> erl_type().

t_iolist(N, T) when N > 0 ->
    t_maybe_improper_list(t_sup([t_iolist(N - 1, T),T,t_byte()]),
                          t_sup(T, t_nil()));
t_iolist(0, T) ->
    t_maybe_improper_list(t_any(), t_sup(T, t_nil())).

-spec t_parameterized_module() -> erl_type().

t_parameterized_module() ->
    t_tuple().

-spec t_timeout() -> erl_type().

t_timeout() ->
    t_sup(t_non_neg_integer(), t_atom(infinity)).

-spec t_array() -> erl_type().

t_array() ->
    t_opaque(array,
             array,
             [],
             t_tuple([t_atom(array),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_any(),
                      t_any()])).

-spec t_dict() -> erl_type().

t_dict() ->
    t_opaque(dict,
             dict,
             [],
             t_tuple([t_atom(dict),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_tuple(),
                      t_tuple()])).

-spec t_digraph() -> erl_type().

t_digraph() ->
    t_opaque(digraph,
             digraph,
             [],
             t_tuple([t_atom(digraph),
                      t_sup(t_atom(), t_tid()),
                      t_sup(t_atom(), t_tid()),
                      t_sup(t_atom(), t_tid()),
                      t_boolean()])).

-spec t_gb_set() -> erl_type().

t_gb_set() ->
    t_opaque(gb_sets,
             gb_set,
             [],
             t_tuple([t_non_neg_integer(),
                      t_sup(t_atom(nil), t_tuple(3))])).

-spec t_gb_tree() -> erl_type().

t_gb_tree() ->
    t_opaque(gb_trees,
             gb_tree,
             [],
             t_tuple([t_non_neg_integer(),
                      t_sup(t_atom(nil), t_tuple(4))])).

-spec t_queue() -> erl_type().

t_queue() ->
    t_opaque(queue, queue, [], t_tuple([t_list(),t_list()])).

-spec t_set() -> erl_type().

t_set() ->
    t_opaque(sets,
             set,
             [],
             t_tuple([t_atom(set),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_pos_integer(),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_non_neg_integer(),
                      t_tuple(),
                      t_tuple()])).

-spec t_tid() -> erl_type().

t_tid() ->
    t_opaque(ets, tid, [], t_integer()).

-spec all_opaque_builtins() -> [erl_type(), ...].

all_opaque_builtins() ->
    [t_array(),
     t_dict(),
     t_digraph(),
     t_gb_set(),
     t_gb_tree(),
     t_queue(),
     t_set(),
     t_tid()].

-spec is_opaque_builtin(atom(), atom()) -> boolean().

is_opaque_builtin(array, array) ->
    true;
is_opaque_builtin(dict, dict) ->
    true;
is_opaque_builtin(digraph, digraph) ->
    true;
is_opaque_builtin(gb_sets, gb_set) ->
    true;
is_opaque_builtin(gb_trees, gb_tree) ->
    true;
is_opaque_builtin(queue, queue) ->
    true;
is_opaque_builtin(sets, set) ->
    true;
is_opaque_builtin(ets, tid) ->
    true;
is_opaque_builtin(_, _) ->
    false.

-spec t_product([erl_type()]) -> erl_type().

t_product([T]) ->
    T;
t_product(Types) when is_list(Types) ->
    #c{tag = product,elements = Types}.

-spec t_to_tlist(erl_type()) -> [erl_type()].

t_to_tlist(#c{tag = product,elements = Types}) ->
    Types;
t_to_tlist(T)
    when
        T =/= any
        orelse
        T =/= none
        orelse
        T =/= unit ->
    [T].

-spec t_var(atom() | integer()) -> erl_type().

t_var(Atom) when is_atom(Atom) ->
    #c{tag = var,elements = Atom};
t_var(Int) when is_integer(Int) ->
    #c{tag = var,elements = Int}.

-spec t_is_var(erl_type()) -> boolean().

t_is_var(#c{tag = var,elements = _}) ->
    true;
t_is_var(_) ->
    false.

-spec t_var_name(erl_type()) -> atom() | integer().

t_var_name(#c{tag = var,elements = Id}) ->
    Id.

-spec t_has_var(erl_type()) -> boolean().

t_has_var(#c{tag = var,elements = _}) ->
    true;
t_has_var(#c{tag = function,elements = [Domain,Range]}) ->
    t_has_var(Domain)
    orelse
    t_has_var(Range);
t_has_var(#c{tag = list,elements = [Contents,Termination],qualifier = _}) ->
    t_has_var(Contents)
    orelse
    t_has_var(Termination);
t_has_var(#c{tag = product,elements = Types}) ->
    t_has_var_list(Types);
t_has_var(#c{tag = tuple,elements = any,qualifier = {any,any}}) ->
    false;
t_has_var(#c{tag = tuple,elements = Elements,qualifier = {_,_}}) ->
    t_has_var_list(Elements);
t_has_var(#c{tag = tuple_set,elements = _} = T) ->
    t_has_var_list(t_tuple_subtypes(T));
t_has_var(_) ->
    false.

-spec t_has_var_list([erl_type()]) -> boolean().

t_has_var_list([T|Ts]) ->
    t_has_var(T)
    orelse
    t_has_var_list(Ts);
t_has_var_list([]) ->
    false.

-spec t_collect_vars(erl_type()) -> [erl_type()].

t_collect_vars(T) ->
    t_collect_vars(T, []).

-spec t_collect_vars(erl_type(), [erl_type()]) -> [erl_type()].

t_collect_vars(#c{tag = var,elements = _} = Var, Acc) ->
    ordsets:add_element(Var, Acc);
t_collect_vars(#c{tag = function,elements = [Domain,Range]}, Acc) ->
    ordsets:union(t_collect_vars(Domain, Acc),
                  t_collect_vars(Range, []));
t_collect_vars(#c{tag = list,
                  elements = [Contents,Termination],
                  qualifier = _},
               Acc) ->
    ordsets:union(t_collect_vars(Contents, Acc),
                  t_collect_vars(Termination, []));
t_collect_vars(#c{tag = product,elements = Types}, Acc) ->
    lists:foldl(fun(T, TmpAcc) ->
                       t_collect_vars(T, TmpAcc)
                end,
                Acc,
                Types);
t_collect_vars(#c{tag = tuple,elements = any,qualifier = {any,any}},
               Acc) ->
    Acc;
t_collect_vars(#c{tag = tuple,elements = Types,qualifier = {_,_}}, Acc) ->
    lists:foldl(fun(T, TmpAcc) ->
                       t_collect_vars(T, TmpAcc)
                end,
                Acc,
                Types);
t_collect_vars(#c{tag = tuple_set,elements = _} = TS, Acc) ->
    lists:foldl(fun(T, TmpAcc) ->
                       t_collect_vars(T, TmpAcc)
                end,
                Acc,
                t_tuple_subtypes(TS));
t_collect_vars(_, Acc) ->
    Acc.

-spec t_from_term(term()) -> erl_type().

t_from_term([H|T]) ->
    t_cons(t_from_term(H), t_from_term(T));
t_from_term([]) ->
    t_nil();
t_from_term(T) when is_atom(T) ->
    t_atom(T);
t_from_term(T) when is_bitstring(T) ->
    t_bitstr(0, bit_size(T));
t_from_term(T) when is_float(T) ->
    t_float();
t_from_term(T) when is_function(T) ->
    {arity,Arity} = erlang:fun_info(T, arity),
    t_fun(Arity, t_any());
t_from_term(T) when is_integer(T) ->
    t_integer(T);
t_from_term(T) when is_pid(T) ->
    t_pid();
t_from_term(T) when is_port(T) ->
    t_port();
t_from_term(T) when is_reference(T) ->
    t_reference();
t_from_term(T) when is_tuple(T) ->
    t_tuple([ 
             t_from_term(E) ||
                 E <- tuple_to_list(T)
            ]).

-spec t_from_range(rng_elem(), rng_elem()) -> erl_type().

t_from_range(neg_inf, pos_inf) ->
    t_integer();
t_from_range(neg_inf, Y) when is_integer(Y), Y < 0 ->
    #c{tag = number,
       elements = #int_rng{from = neg_inf,to = - 1},
       qualifier = integer};
t_from_range(neg_inf, Y) when is_integer(Y), Y >= 0 ->
    t_integer();
t_from_range(X, pos_inf) when is_integer(X), X >= 1 ->
    #c{tag = number,
       elements = #int_rng{from = 1,to = pos_inf},
       qualifier = integer};
t_from_range(X, pos_inf) when is_integer(X), X >= 0 ->
    #c{tag = number,
       elements = #int_rng{from = 0,to = pos_inf},
       qualifier = integer};
t_from_range(X, pos_inf) when is_integer(X), X < 0 ->
    t_integer();
t_from_range(X, Y) when is_integer(X), is_integer(Y), X > Y ->
    t_none();
t_from_range(X, Y) when is_integer(X), is_integer(Y) ->
    case Y - X < 13 of
        true ->
            t_integers(lists:seq(X, Y));
        false ->
            case X >= 0 of
                false ->
                    if
                        Y < 0 ->
                            #c{tag = number,
                               elements =
                                   #int_rng{from = neg_inf,to = - 1},
                               qualifier = integer};
                        true ->
                            t_integer()
                    end;
                true ->
                    if
                        Y =< 255, X >= 1 ->
                            #c{tag = number,
                               elements = #int_rng{from = 1,to = 255},
                               qualifier = integer};
                        Y =< 255 ->
                            t_byte();
                        Y =< 1114111, X >= 1 ->
                            #c{tag = number,
                               elements =
                                   #int_rng{from = 1,to = 1114111},
                               qualifier = integer};
                        Y =< 1114111 ->
                            t_char();
                        X >= 1 ->
                            #c{tag = number,
                               elements =
                                   #int_rng{from = 1,to = pos_inf},
                               qualifier = integer};
                        X >= 0 ->
                            #c{tag = number,
                               elements =
                                   #int_rng{from = 0,to = pos_inf},
                               qualifier = integer}
                    end
            end
    end;
t_from_range(pos_inf, neg_inf) ->
    t_none().

-spec t_from_range_unsafe(rng_elem(), rng_elem()) -> erl_type().

t_from_range_unsafe(neg_inf, pos_inf) ->
    t_integer();
t_from_range_unsafe(neg_inf, Y) ->
    #c{tag = number,
       elements = #int_rng{from = neg_inf,to = Y},
       qualifier = integer};
t_from_range_unsafe(X, pos_inf) ->
    #c{tag = number,
       elements = #int_rng{from = X,to = pos_inf},
       qualifier = integer};
t_from_range_unsafe(X, Y) when is_integer(X), is_integer(Y), X =< Y ->
    if
        Y - X < 13 ->
            t_integers(lists:seq(X, Y));
        true ->
            #c{tag = number,
               elements = #int_rng{from = X,to = Y},
               qualifier = integer}
    end;
t_from_range_unsafe(X, Y) when is_integer(X), is_integer(Y) ->
    t_none();
t_from_range_unsafe(pos_inf, neg_inf) ->
    t_none().

-spec t_is_fixnum(erl_type()) -> boolean().

t_is_fixnum(#c{tag = number,
               elements = #int_rng{from = neg_inf,to = _},
               qualifier = integer}) ->
    false;
t_is_fixnum(#c{tag = number,
               elements = #int_rng{from = _,to = pos_inf},
               qualifier = integer}) ->
    false;
t_is_fixnum(#c{tag = number,
               elements = #int_rng{from = From,to = To},
               qualifier = integer}) ->
    is_fixnum(From)
    andalso
    is_fixnum(To);
t_is_fixnum(#c{tag = number,
               elements = #int_set{set = Set},
               qualifier = integer}) ->
    is_fixnum(set_min(Set))
    andalso
    is_fixnum(set_max(Set));
t_is_fixnum(_) ->
    false.

-spec is_fixnum(integer()) -> boolean().

is_fixnum(N) when is_integer(N) ->
    Bits = erlang:system_info(wordsize) * 8 - 4,
    N =< 1 bsl (Bits - 1) - 1
    andalso
    N >= - (1 bsl (Bits - 1)).

infinity_geq(pos_inf, _) ->
    true;
infinity_geq(_, pos_inf) ->
    false;
infinity_geq(_, neg_inf) ->
    true;
infinity_geq(neg_inf, _) ->
    false;
infinity_geq(A, B) ->
    A >= B.

-spec t_is_bitwidth(erl_type()) -> boolean().

t_is_bitwidth(#c{tag = number,
                 elements = #int_rng{from = neg_inf,to = _},
                 qualifier = integer}) ->
    false;
t_is_bitwidth(#c{tag = number,
                 elements = #int_rng{from = _,to = pos_inf},
                 qualifier = integer}) ->
    false;
t_is_bitwidth(#c{tag = number,
                 elements = #int_rng{from = From,to = To},
                 qualifier = integer}) ->
    infinity_geq(From, 0)
    andalso
    infinity_geq(erlang:system_info(wordsize) * 8 - 4, To);
t_is_bitwidth(#c{tag = number,
                 elements = #int_set{set = Set},
                 qualifier = integer}) ->
    infinity_geq(set_min(Set), 0)
    andalso
    infinity_geq(erlang:system_info(wordsize) * 8 - 4, set_max(Set));
t_is_bitwidth(_) ->
    false.

-spec number_min(erl_type()) -> rng_elem().

number_min(#c{tag = number,
              elements = #int_rng{from = From,to = _},
              qualifier = integer}) ->
    From;
number_min(#c{tag = number,
              elements = #int_set{set = Set},
              qualifier = integer}) ->
    set_min(Set);
number_min(#c{tag = number,elements = any,qualifier = _Tag}) ->
    neg_inf.

-spec number_max(erl_type()) -> rng_elem().

number_max(#c{tag = number,
              elements = #int_rng{from = _,to = To},
              qualifier = integer}) ->
    To;
number_max(#c{tag = number,
              elements = #int_set{set = Set},
              qualifier = integer}) ->
    set_max(Set);
number_max(#c{tag = number,elements = any,qualifier = _Tag}) ->
    pos_inf.

in_range(_,
         #c{tag = number,
            elements = #int_rng{from = neg_inf,to = pos_inf},
            qualifier = integer}) ->
    true;
in_range(X,
         #c{tag = number,
            elements = #int_rng{from = From,to = pos_inf},
            qualifier = integer}) ->
    X >= From;
in_range(X,
         #c{tag = number,
            elements = #int_rng{from = neg_inf,to = To},
            qualifier = integer}) ->
    X =< To;
in_range(X,
         #c{tag = number,
            elements = #int_rng{from = From,to = To},
            qualifier = integer}) ->
    X >= From
    andalso
    X =< To.

-spec min(rng_elem(), rng_elem()) -> rng_elem().

min(neg_inf, _) ->
    neg_inf;
min(_, neg_inf) ->
    neg_inf;
min(pos_inf, Y) ->
    Y;
min(X, pos_inf) ->
    X;
min(X, Y) when X =< Y ->
    X;
min(_, Y) ->
    Y.

-spec max(rng_elem(), rng_elem()) -> rng_elem().

max(neg_inf, Y) ->
    Y;
max(X, neg_inf) ->
    X;
max(pos_inf, _) ->
    pos_inf;
max(_, pos_inf) ->
    pos_inf;
max(X, Y) when X =< Y ->
    Y;
max(X, _) ->
    X.

expand_range_from_set(Range =
                          #c{tag = number,
                             elements = #int_rng{from = From,to = To},
                             qualifier = integer},
                      Set) ->
    Min = min(set_min(Set), From),
    Max = max(set_max(Set), To),
    if
        From =:= Min, To =:= Max ->
            Range;
        true ->
            t_from_range(Min, Max)
    end.

-spec t_sup([erl_type()]) -> erl_type().

t_sup([any|_]) ->
    any;
t_sup([H1,H2|T]) ->
    t_sup([t_sup(H1, H2)|T]);
t_sup([H]) ->
    subst_all_vars_to_any(H);
t_sup([]) ->
    none.

-spec t_sup(erl_type(), erl_type()) -> erl_type().

t_sup(any, _) ->
    any;
t_sup(_, any) ->
    any;
t_sup(none, T) ->
    T;
t_sup(T, none) ->
    T;
t_sup(unit, T) ->
    T;
t_sup(T, unit) ->
    T;
t_sup(T, T) ->
    subst_all_vars_to_any(T);
t_sup(#c{tag = var,elements = _}, _) ->
    any;
t_sup(_, #c{tag = var,elements = _}) ->
    any;
t_sup(#c{tag = atom,elements = Set1}, #c{tag = atom,elements = Set2}) ->
    #c{tag = atom,elements = set_union(Set1, Set2)};
t_sup(#c{tag = binary,elements = [U1,B1]},
      #c{tag = binary,elements = [U2,B2]}) ->
    t_bitstr(gcd(gcd(U1, U2), abs(B1 - B2)), lists:min([B1,B2]));
t_sup(#c{tag = function,elements = [Domain1,Range1]},
      #c{tag = function,elements = [Domain2,Range2]}) ->
    #c{tag = function,
       elements = [t_sup(Domain1, Domain2),t_sup(Range1, Range2)]};
t_sup(#c{tag = identifier,elements = Set1},
      #c{tag = identifier,elements = Set2}) ->
    #c{tag = identifier,elements = set_union(Set1, Set2)};
t_sup(#c{tag = opaque,elements = Set1},
      #c{tag = opaque,elements = Set2}) ->
    #c{tag = opaque,elements = set_union_no_limit(Set1, Set2)};
t_sup(#c{tag = remote,elements = Set1},
      #c{tag = remote,elements = Set2}) ->
    #c{tag = remote,elements = set_union_no_limit(Set1, Set2)};
t_sup(#c{tag = matchstate,elements = [Pres1,Slots1]},
      #c{tag = matchstate,elements = [Pres2,Slots2]}) ->
    #c{tag = matchstate,
       elements = [t_sup(Pres1, Pres2),t_sup(Slots1, Slots2)]};
t_sup(#c{tag = nil}, #c{tag = nil}) ->
    #c{tag = nil};
t_sup(#c{tag = nil},
      #c{tag = list,elements = [Contents,Termination],qualifier = _}) ->
    #c{tag = list,
       elements = [Contents,t_sup(#c{tag = nil}, Termination)],
       qualifier = unknown};
t_sup(#c{tag = list,elements = [Contents,Termination],qualifier = _},
      #c{tag = nil}) ->
    #c{tag = list,
       elements = [Contents,t_sup(#c{tag = nil}, Termination)],
       qualifier = unknown};
t_sup(#c{tag = list,
         elements = [Contents1,Termination1],
         qualifier = Size1},
      #c{tag = list,
         elements = [Contents2,Termination2],
         qualifier = Size2}) ->
    NewSize =
        case {Size1,Size2} of
            {unknown,unknown} ->
                unknown;
            {unknown,nonempty} ->
                unknown;
            {nonempty,unknown} ->
                unknown;
            {nonempty,nonempty} ->
                nonempty
        end,
    NewContents = t_sup(Contents1, Contents2),
    NewTermination = t_sup(Termination1, Termination2),
    TmpList = t_cons(NewContents, NewTermination),
    case NewSize of
        nonempty ->
            TmpList;
        unknown ->
            #c{tag = list,
               elements = [FinalContents,FinalTermination],
               qualifier = _} =
                TmpList,
            #c{tag = list,
               elements = [FinalContents,FinalTermination],
               qualifier = unknown}
    end;
t_sup(#c{tag = number,elements = _,qualifier = _},
      #c{tag = number,elements = any,qualifier = unknown} = T) ->
    T;
t_sup(#c{tag = number,elements = any,qualifier = unknown} = T,
      #c{tag = number,elements = _,qualifier = _}) ->
    T;
t_sup(#c{tag = number,elements = any,qualifier = float},
      #c{tag = number,elements = any,qualifier = float}) ->
    #c{tag = number,elements = any,qualifier = float};
t_sup(#c{tag = number,elements = any,qualifier = float},
      #c{tag = number,elements = _,qualifier = integer}) ->
    t_number();
t_sup(#c{tag = number,elements = _,qualifier = integer},
      #c{tag = number,elements = any,qualifier = float}) ->
    t_number();
t_sup(#c{tag = number,elements = any,qualifier = integer} = T,
      #c{tag = number,elements = _,qualifier = integer}) ->
    T;
t_sup(#c{tag = number,elements = _,qualifier = integer},
      #c{tag = number,elements = any,qualifier = integer} = T) ->
    T;
t_sup(#c{tag = number,
         elements = #int_set{set = Set1},
         qualifier = integer},
      #c{tag = number,
         elements = #int_set{set = Set2},
         qualifier = integer}) ->
    case set_union(Set1, Set2) of
        any ->
            t_from_range(min(set_min(Set1), set_min(Set2)),
                         max(set_max(Set1), set_max(Set2)));
        Set ->
            #c{tag = number,
               elements = #int_set{set = Set},
               qualifier = integer}
    end;
t_sup(#c{tag = number,
         elements = #int_rng{from = From1,to = To1},
         qualifier = integer},
      #c{tag = number,
         elements = #int_rng{from = From2,to = To2},
         qualifier = integer}) ->
    t_from_range(min(From1, From2), max(To1, To2));
t_sup(Range =
          #c{tag = number,
             elements = #int_rng{from = _,to = _},
             qualifier = integer},
      #c{tag = number,
         elements = #int_set{set = Set},
         qualifier = integer}) ->
    expand_range_from_set(Range, Set);
t_sup(#c{tag = number,
         elements = #int_set{set = Set},
         qualifier = integer},
      Range =
          #c{tag = number,
             elements = #int_rng{from = _,to = _},
             qualifier = integer}) ->
    expand_range_from_set(Range, Set);
t_sup(#c{tag = product,elements = Types1},
      #c{tag = product,elements = Types2}) ->
    L1 = length(Types1),
    L2 = length(Types2),
    if
        L1 =:= L2 ->
            #c{tag = product,elements = t_sup_lists(Types1, Types2)};
        true ->
            any
    end;
t_sup(#c{tag = product,elements = _}, _) ->
    any;
t_sup(_, #c{tag = product,elements = _}) ->
    any;
t_sup(#c{tag = tuple,elements = any,qualifier = {any,any}} = T,
      #c{tag = tuple,elements = _,qualifier = {_,_}}) ->
    T;
t_sup(#c{tag = tuple,elements = _,qualifier = {_,_}},
      #c{tag = tuple,elements = any,qualifier = {any,any}} = T) ->
    T;
t_sup(#c{tag = tuple,elements = any,qualifier = {any,any}} = T,
      #c{tag = tuple_set,elements = _}) ->
    T;
t_sup(#c{tag = tuple_set,elements = _},
      #c{tag = tuple,elements = any,qualifier = {any,any}} = T) ->
    T;
t_sup(#c{tag = tuple,elements = Elements1,qualifier = {Arity,Tag1}} = T1,
      #c{tag = tuple,elements = Elements2,qualifier = {Arity,Tag2}} = T2) ->
    if
        Tag1 =:= Tag2 ->
            t_tuple(t_sup_lists(Elements1, Elements2));
        Tag1 =:= any ->
            t_tuple(t_sup_lists(Elements1, Elements2));
        Tag2 =:= any ->
            t_tuple(t_sup_lists(Elements1, Elements2));
        Tag1 < Tag2 ->
            #c{tag = tuple_set,elements = [{Arity,[T1,T2]}]};
        Tag1 > Tag2 ->
            #c{tag = tuple_set,elements = [{Arity,[T2,T1]}]}
    end;
t_sup(#c{tag = tuple,elements = _,qualifier = {Arity1,_}} = T1,
      #c{tag = tuple,elements = _,qualifier = {Arity2,_}} = T2) ->
    sup_tuple_sets([{Arity1,[T1]}], [{Arity2,[T2]}]);
t_sup(#c{tag = tuple_set,elements = List1},
      #c{tag = tuple_set,elements = List2}) ->
    sup_tuple_sets(List1, List2);
t_sup(#c{tag = tuple_set,elements = List1},
      T2 = #c{tag = tuple,elements = _,qualifier = {Arity,_}}) ->
    sup_tuple_sets(List1, [{Arity,[T2]}]);
t_sup(#c{tag = tuple,elements = _,qualifier = {Arity,_}} = T1,
      #c{tag = tuple_set,elements = List2}) ->
    sup_tuple_sets([{Arity,[T1]}], List2);
t_sup(T1, T2) ->
    #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U1} =
        force_union(T1),
    #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U2} =
        force_union(T2),
    sup_union(U1, U2).

-spec t_sup_lists([erl_type()], [erl_type()]) -> [erl_type()].

t_sup_lists([T1|Left1], [T2|Left2]) ->
    [t_sup(T1, T2)|t_sup_lists(Left1, Left2)];
t_sup_lists([], []) ->
    [].

sup_tuple_sets(L1, L2) ->
    TotalArities =
        ordsets:union([ 
                       Arity ||
                           {Arity,_} <- L1
                      ],
                      [ 
                       Arity ||
                           {Arity,_} <- L2
                      ]),
    if
        length(TotalArities) > 8 ->
            t_tuple();
        true ->
            case sup_tuple_sets(L1, L2, []) of
                [{_Arity,
                  [OneTuple =
                       #c{tag = tuple,elements = _,qualifier = {_,_}}]}] ->
                    OneTuple;
                List ->
                    #c{tag = tuple_set,elements = List}
            end
    end.

sup_tuple_sets([{Arity,Tuples1}|Left1], [{Arity,Tuples2}|Left2], Acc) ->
    NewAcc = [{Arity,sup_tuples_in_set(Tuples1, Tuples2)}|Acc],
    sup_tuple_sets(Left1, Left2, NewAcc);
sup_tuple_sets([{Arity1,_} = T1|Left1] = L1,
               [{Arity2,_} = T2|Left2] = L2,
               Acc) ->
    if
        Arity1 < Arity2 ->
            sup_tuple_sets(Left1, L2, [T1|Acc]);
        Arity1 > Arity2 ->
            sup_tuple_sets(L1, Left2, [T2|Acc])
    end;
sup_tuple_sets([], L2, Acc) ->
    lists:reverse(Acc, L2);
sup_tuple_sets(L1, [], Acc) ->
    lists:reverse(Acc, L1).

sup_tuples_in_set([#c{tag = tuple,elements = _,qualifier = {_,any}} = T],
                  L) ->
    [t_tuple(sup_tuple_elements([T|L]))];
sup_tuples_in_set(L,
                  [#c{tag = tuple,elements = _,qualifier = {_,any}} = T]) ->
    [t_tuple(sup_tuple_elements([T|L]))];
sup_tuples_in_set(L1, L2) ->
    FoldFun =
        fun(#c{tag = tuple,elements = _,qualifier = {_,Tag}}, AccTag) ->
               t_sup(Tag, AccTag)
        end,
    TotalTag0 = lists:foldl(FoldFun, none, L1),
    TotalTag = lists:foldl(FoldFun, TotalTag0, L2),
    case TotalTag of
        #c{tag = atom,elements = any} ->
            [t_tuple(sup_tuple_elements(L1 ++ L2))];
        #c{tag = atom,elements = Set} ->
            case set_size(Set) > 5 of
                true ->
                    [t_tuple(sup_tuple_elements(L1 ++ L2))];
                false ->
                    sup_tuples_in_set(L1, L2, [])
            end
    end.

sup_tuple_elements([#c{tag = tuple,
                       elements = Elements,
                       qualifier = {_,_}}|
                    L]) ->
    lists:foldl(fun(#c{tag = tuple,elements = Es,qualifier = {_,_}},
                    Acc) ->
                       t_sup_lists(Es, Acc)
                end,
                Elements,
                L).

sup_tuples_in_set([#c{tag = tuple,
                      elements = Elements1,
                      qualifier = {Arity,Tag1}} =
                       T1|
                   Left1] =
                      L1,
                  [#c{tag = tuple,
                      elements = Elements2,
                      qualifier = {Arity,Tag2}} =
                       T2|
                   Left2] =
                      L2,
                  Acc) ->
    if
        Tag1 < Tag2 ->
            sup_tuples_in_set(Left1, L2, [T1|Acc]);
        Tag1 > Tag2 ->
            sup_tuples_in_set(L1, Left2, [T2|Acc]);
        Tag2 =:= Tag2 ->
            NewElements = t_sup_lists(Elements1, Elements2),
            NewAcc =
                [#c{tag = tuple,
                    elements = NewElements,
                    qualifier = {Arity,Tag1}}|
                 Acc],
            sup_tuples_in_set(Left1, Left2, NewAcc)
    end;
sup_tuples_in_set([], L2, Acc) ->
    lists:reverse(Acc, L2);
sup_tuples_in_set(L1, [], Acc) ->
    lists:reverse(Acc, L1).

sup_union(U1, U2) ->
    sup_union(U1, U2, 0, []).

sup_union([none|Left1], [none|Left2], N, Acc) ->
    sup_union(Left1, Left2, N, [none|Acc]);
sup_union([T1|Left1], [T2|Left2], N, Acc) ->
    sup_union(Left1, Left2, N + 1, [t_sup(T1, T2)|Acc]);
sup_union([], [], N, Acc) ->
    if
        N =:= 0 ->
            none;
        N =:= 1 ->
            [Type] =
                [ 
                 T ||
                     T <- Acc,
                     T =/= none
                ],
            Type;
        N =:= length(Acc) ->
            any;
        true ->
            #c{tag = union,
               elements = [_,_,_,_,_,_,_,_,_,_] = lists:reverse(Acc)}
    end.

force_union(T = #c{tag = atom,elements = _}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [T,none,none,none,none,none,none,none,none,none]};
force_union(T = #c{tag = binary,elements = [_,_]}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,T,none,none,none,none,none,none,none,none]};
force_union(T = #c{tag = function,elements = [_,_]}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,T,none,none,none,none,none,none,none]};
force_union(T = #c{tag = identifier,elements = _}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,T,none,none,none,none,none,none]};
force_union(T = #c{tag = list,elements = [_,_],qualifier = _}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,T,none,none,none,none,none]};
force_union(T = #c{tag = nil}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,T,none,none,none,none,none]};
force_union(T = #c{tag = number,elements = _,qualifier = _}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,none,T,none,none,none,none]};
force_union(T = #c{tag = opaque,elements = _}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,none,none,none,none,T,none]};
force_union(T = #c{tag = remote,elements = _}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,none,none,none,none,none,T]};
force_union(T = #c{tag = tuple,elements = _,qualifier = {_,_}}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,none,none,T,none,none,none]};
force_union(T = #c{tag = tuple_set,elements = _}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,none,none,T,none,none,none]};
force_union(T = #c{tag = matchstate,elements = [_,_]}) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [none,none,none,none,none,none,none,T,none,none]};
force_union(T = #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = _}) ->
    T.

-spec t_elements(erl_type()) -> [erl_type()].

t_elements(none) ->
    [];
t_elements(unit) ->
    [];
t_elements(any = T) ->
    [T];
t_elements(#c{tag = nil} = T) ->
    [T];
t_elements(#c{tag = atom,elements = any} = T) ->
    [T];
t_elements(#c{tag = atom,elements = Atoms}) ->
    [ 
     t_atom(A) ||
         A <- Atoms
    ];
t_elements(#c{tag = binary,elements = [_,_]} = T) ->
    [T];
t_elements(#c{tag = function,elements = [_,_]} = T) ->
    [T];
t_elements(#c{tag = identifier,elements = any} = T) ->
    [T];
t_elements(#c{tag = identifier,elements = IDs}) ->
    [ 
     #c{tag = identifier,elements = [T]} ||
         T <- IDs
    ];
t_elements(#c{tag = list,elements = [_,_],qualifier = _} = T) ->
    [T];
t_elements(#c{tag = number,elements = _,qualifier = _} = T) ->
    case T of
        #c{tag = number,elements = any,qualifier = unknown} ->
            [#c{tag = number,elements = any,qualifier = float},
             #c{tag = number,elements = any,qualifier = integer}];
        #c{tag = number,elements = any,qualifier = float} ->
            [T];
        #c{tag = number,elements = any,qualifier = integer} ->
            [T];
        #c{tag = number,
           elements = #int_rng{from = _,to = _},
           qualifier = integer} ->
            [T];
        #c{tag = number,
           elements = #int_set{set = Set},
           qualifier = integer} ->
            [ 
             t_integer(I) ||
                 I <- Set
            ]
    end;
t_elements(#c{tag = opaque,elements = _} = T) ->
    [T];
t_elements(#c{tag = tuple,elements = _,qualifier = {_,_}} = T) ->
    [T];
t_elements(#c{tag = tuple_set,elements = _} = TS) ->
    case t_tuple_subtypes(TS) of
        unknown ->
            [];
        Elems ->
            Elems
    end;
t_elements(#c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = List}) ->
    lists:append([ 
                  t_elements(T) ||
                      T <- List
                 ]);
t_elements(#c{tag = var,elements = _}) ->
    [any].

-spec t_inf([erl_type()]) -> erl_type().

t_inf([H1,H2|T]) ->
    case t_inf(H1, H2) of
        none ->
            none;
        NewH ->
            t_inf([NewH|T])
    end;
t_inf([H]) ->
    H;
t_inf([]) ->
    none.

-spec t_inf(erl_type(), erl_type()) -> erl_type().

t_inf(T1, T2) ->
    t_inf(T1, T2, structured).

-type t_inf_mode() :: opaque | structured.

-spec t_inf(erl_type(), erl_type(), t_inf_mode()) -> erl_type().

t_inf(#c{tag = var,elements = _}, #c{tag = var,elements = _}, _Mode) ->
    any;
t_inf(#c{tag = var,elements = _}, T, _Mode) ->
    subst_all_vars_to_any(T);
t_inf(T, #c{tag = var,elements = _}, _Mode) ->
    subst_all_vars_to_any(T);
t_inf(any, T, _Mode) ->
    subst_all_vars_to_any(T);
t_inf(T, any, _Mode) ->
    subst_all_vars_to_any(T);
t_inf(none, _, _Mode) ->
    none;
t_inf(_, none, _Mode) ->
    none;
t_inf(unit, _, _Mode) ->
    unit;
t_inf(_, unit, _Mode) ->
    unit;
t_inf(T, T, _Mode) ->
    subst_all_vars_to_any(T);
t_inf(#c{tag = atom,elements = Set1}, #c{tag = atom,elements = Set2}, _) ->
    case set_intersection(Set1, Set2) of
        none ->
            none;
        NewSet ->
            #c{tag = atom,elements = NewSet}
    end;
t_inf(#c{tag = binary,elements = [U1,B1]},
      #c{tag = binary,elements = [0,B2]},
      _Mode) ->
    if
        B2 >= B1
        andalso
        (B2 - B1) rem U1 =:= 0 ->
            t_bitstr(0, B2);
        true ->
            none
    end;
t_inf(#c{tag = binary,elements = [0,B1]},
      #c{tag = binary,elements = [U2,B2]},
      _Mode) ->
    if
        B1 >= B2
        andalso
        (B1 - B2) rem U2 =:= 0 ->
            t_bitstr(0, B1);
        true ->
            none
    end;
t_inf(#c{tag = binary,elements = [U1,B1]},
      #c{tag = binary,elements = [U1,B1]},
      _Mode) ->
    t_bitstr(U1, B1);
t_inf(#c{tag = binary,elements = [U1,B1]},
      #c{tag = binary,elements = [U2,B2]},
      _Mode)
    when U2 > U1 ->
    inf_bitstr(U2, B2, U1, B1);
t_inf(#c{tag = binary,elements = [U1,B1]},
      #c{tag = binary,elements = [U2,B2]},
      _Mode) ->
    inf_bitstr(U1, B1, U2, B2);
t_inf(#c{tag = function,elements = [Domain1,Range1]},
      #c{tag = function,elements = [Domain2,Range2]},
      Mode) ->
    case t_inf(Domain1, Domain2, Mode) of
        none ->
            none;
        Domain ->
            #c{tag = function,
               elements = [Domain,t_inf(Range1, Range2, Mode)]}
    end;
t_inf(#c{tag = identifier,elements = Set1},
      #c{tag = identifier,elements = Set2},
      _Mode) ->
    case set_intersection(Set1, Set2) of
        none ->
            none;
        Set ->
            #c{tag = identifier,elements = Set}
    end;
t_inf(#c{tag = matchstate,elements = [Pres1,Slots1]},
      #c{tag = matchstate,elements = [Pres2,Slots2]},
      _Mode) ->
    #c{tag = matchstate,
       elements = [t_inf(Pres1, Pres2),t_inf(Slots1, Slots2)]};
t_inf(#c{tag = nil}, #c{tag = nil}, _Mode) ->
    #c{tag = nil};
t_inf(#c{tag = nil},
      #c{tag = list,elements = [_,_],qualifier = nonempty},
      _Mode) ->
    none;
t_inf(#c{tag = list,elements = [_,_],qualifier = nonempty},
      #c{tag = nil},
      _Mode) ->
    none;
t_inf(#c{tag = nil},
      #c{tag = list,elements = [_Contents,Termination],qualifier = _},
      Mode) ->
    t_inf(#c{tag = nil}, Termination, Mode);
t_inf(#c{tag = list,elements = [_Contents,Termination],qualifier = _},
      #c{tag = nil},
      Mode) ->
    t_inf(#c{tag = nil}, Termination, Mode);
t_inf(#c{tag = list,
         elements = [Contents1,Termination1],
         qualifier = Size1},
      #c{tag = list,
         elements = [Contents2,Termination2],
         qualifier = Size2},
      Mode) ->
    case t_inf(Termination1, Termination2, Mode) of
        none ->
            none;
        Termination ->
            case t_inf(Contents1, Contents2, Mode) of
                none ->
                    case
                        Size1 =:= unknown
                        andalso
                        Size2 =:= unknown
                    of
                        true ->
                            t_nil();
                        false ->
                            none
                    end;
                Contents ->
                    Size =
                        case {Size1,Size2} of
                            {unknown,unknown} ->
                                unknown;
                            {unknown,nonempty} ->
                                nonempty;
                            {nonempty,unknown} ->
                                nonempty;
                            {nonempty,nonempty} ->
                                nonempty
                        end,
                    #c{tag = list,
                       elements = [Contents,Termination],
                       qualifier = Size}
            end
    end;
t_inf(#c{tag = number,elements = _,qualifier = _} = T1,
      #c{tag = number,elements = _,qualifier = _} = T2,
      _Mode) ->
    case {T1,T2} of
        {T,T} ->
            T;
        {_,#c{tag = number,elements = any,qualifier = unknown}} ->
            T1;
        {#c{tag = number,elements = any,qualifier = unknown},_} ->
            T2;
        {#c{tag = number,elements = any,qualifier = float},
         #c{tag = number,elements = _,qualifier = integer}} ->
            none;
        {#c{tag = number,elements = _,qualifier = integer},
         #c{tag = number,elements = any,qualifier = float}} ->
            none;
        {#c{tag = number,elements = any,qualifier = integer},
         #c{tag = number,elements = _,qualifier = integer}} ->
            T2;
        {#c{tag = number,elements = _,qualifier = integer},
         #c{tag = number,elements = any,qualifier = integer}} ->
            T1;
        {#c{tag = number,
            elements = #int_set{set = Set1},
            qualifier = integer},
         #c{tag = number,
            elements = #int_set{set = Set2},
            qualifier = integer}} ->
            case set_intersection(Set1, Set2) of
                none ->
                    none;
                Set ->
                    #c{tag = number,
                       elements = #int_set{set = Set},
                       qualifier = integer}
            end;
        {#c{tag = number,
            elements = #int_rng{from = From1,to = To1},
            qualifier = integer},
         #c{tag = number,
            elements = #int_rng{from = From2,to = To2},
            qualifier = integer}} ->
            t_from_range(max(From1, From2), min(To1, To2));
        {Range =
             #c{tag = number,
                elements = #int_rng{from = _,to = _},
                qualifier = integer},
         #c{tag = number,
            elements = #int_set{set = Set},
            qualifier = integer}} ->
            Ans2 =
                case
                    set_filter(fun(X) ->
                                      in_range(X, Range)
                               end,
                               Set)
                of
                    none ->
                        none;
                    NewSet ->
                        #c{tag = number,
                           elements = #int_set{set = NewSet},
                           qualifier = integer}
                end,
            Ans2;
        {#c{tag = number,
            elements = #int_set{set = Set},
            qualifier = integer},
         #c{tag = number,
            elements = #int_rng{from = _,to = _},
            qualifier = integer} =
             Range} ->
            case
                set_filter(fun(X) ->
                                  in_range(X, Range)
                           end,
                           Set)
            of
                none ->
                    none;
                NewSet ->
                    #c{tag = number,
                       elements = #int_set{set = NewSet},
                       qualifier = integer}
            end
    end;
t_inf(#c{tag = product,elements = Types1},
      #c{tag = product,elements = Types2},
      Mode) ->
    L1 = length(Types1),
    L2 = length(Types2),
    if
        L1 =:= L2 ->
            #c{tag = product,
               elements = t_inf_lists(Types1, Types2, Mode)};
        true ->
            none
    end;
t_inf(#c{tag = product,elements = _}, _, _Mode) ->
    none;
t_inf(_, #c{tag = product,elements = _}, _Mode) ->
    none;
t_inf(#c{tag = tuple,elements = any,qualifier = {any,any}},
      #c{tag = tuple,elements = _,qualifier = {_,_}} = T,
      _Mode) ->
    subst_all_vars_to_any(T);
t_inf(#c{tag = tuple,elements = _,qualifier = {_,_}} = T,
      #c{tag = tuple,elements = any,qualifier = {any,any}},
      _Mode) ->
    subst_all_vars_to_any(T);
t_inf(#c{tag = tuple,elements = any,qualifier = {any,any}},
      #c{tag = tuple_set,elements = _} = T,
      _Mode) ->
    subst_all_vars_to_any(T);
t_inf(#c{tag = tuple_set,elements = _} = T,
      #c{tag = tuple,elements = any,qualifier = {any,any}},
      _Mode) ->
    subst_all_vars_to_any(T);
t_inf(#c{tag = tuple,elements = Elements1,qualifier = {Arity,_Tag1}},
      #c{tag = tuple,elements = Elements2,qualifier = {Arity,_Tag2}},
      Mode) ->
    case t_inf_lists_strict(Elements1, Elements2, Mode) of
        bottom ->
            none;
        NewElements ->
            t_tuple(NewElements)
    end;
t_inf(#c{tag = tuple_set,elements = List1},
      #c{tag = tuple_set,elements = List2},
      Mode) ->
    inf_tuple_sets(List1, List2, Mode);
t_inf(#c{tag = tuple_set,elements = List},
      #c{tag = tuple,elements = _,qualifier = {Arity,_}} = T,
      Mode) ->
    inf_tuple_sets(List, [{Arity,[T]}], Mode);
t_inf(#c{tag = tuple,elements = _,qualifier = {Arity,_}} = T,
      #c{tag = tuple_set,elements = List},
      Mode) ->
    inf_tuple_sets(List, [{Arity,[T]}], Mode);
t_inf(#c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U1}, T, Mode) ->
    #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U2} =
        force_union(T),
    inf_union(U1, U2, Mode);
t_inf(T, #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U2}, Mode) ->
    #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U1} =
        force_union(T),
    inf_union(U1, U2, Mode);
t_inf(#c{tag = opaque,elements = Set1} = T1,
      #c{tag = opaque,elements = Set2} = T2,
      Mode) ->
    case set_intersection(Set1, Set2) of
        none ->
            case Mode =:= opaque of
                true ->
                    Struct1 = t_opaque_structure(T1),
                    case t_inf(Struct1, T2) of
                        none ->
                            Struct2 = t_opaque_structure(T2),
                            case t_inf(Struct2, T1) of
                                none ->
                                    none;
                                _ ->
                                    T2
                            end;
                        _ ->
                            T1
                    end;
                false ->
                    none
            end;
        NewSet ->
            #c{tag = opaque,elements = NewSet}
    end;
t_inf(#c{tag = opaque,elements = _} = T1, T2, opaque) ->
    case t_inf(t_opaque_structure(T1), T2, structured) of
        none ->
            none;
        _Type ->
            T1
    end;
t_inf(T1, #c{tag = opaque,elements = _} = T2, opaque) ->
    case t_inf(T1, t_opaque_structure(T2), structured) of
        none ->
            none;
        _Type ->
            T2
    end;
t_inf(#c{}, #c{}, _) ->
    none.

-spec t_inf_lists([erl_type()], [erl_type()]) -> [erl_type()].

t_inf_lists(L1, L2) ->
    t_inf_lists(L1, L2, structured).

-spec t_inf_lists([erl_type()], [erl_type()], t_inf_mode()) ->
                     [erl_type()].

t_inf_lists(L1, L2, Mode) ->
    t_inf_lists(L1, L2, [], Mode).

-spec t_inf_lists([erl_type()],
                  [erl_type()],
                  [erl_type()],
                  t_inf_mode()) ->
                     [erl_type()].

t_inf_lists([T1|Left1], [T2|Left2], Acc, Mode) ->
    t_inf_lists(Left1, Left2, [t_inf(T1, T2, Mode)|Acc], Mode);
t_inf_lists([], [], Acc, _Mode) ->
    lists:reverse(Acc).

-spec t_inf_lists_strict([erl_type()], [erl_type()], t_inf_mode()) ->
                            bottom | [erl_type()].

t_inf_lists_strict(L1, L2, Mode) ->
    t_inf_lists_strict(L1, L2, [], Mode).

-spec t_inf_lists_strict([erl_type()],
                         [erl_type()],
                         [erl_type()],
                         t_inf_mode()) ->
                            bottom | [erl_type()].

t_inf_lists_strict([T1|Left1], [T2|Left2], Acc, Mode) ->
    case t_inf(T1, T2, Mode) of
        none ->
            bottom;
        T ->
            t_inf_lists_strict(Left1, Left2, [T|Acc], Mode)
    end;
t_inf_lists_strict([], [], Acc, _Mode) ->
    lists:reverse(Acc).

-spec t_inf_lists_masked([erl_type()], [erl_type()], [t_inf_mode()]) ->
                            [erl_type()].

t_inf_lists_masked(List1, List2, Mask) ->
    List = lists:zip3(List1, List2, Mask),
    [ 
     t_inf(T1, T2, Mode) ||
         {T1,T2,Mode} <- List
    ].

inf_tuple_sets(L1, L2, Mode) ->
    case inf_tuple_sets(L1, L2, [], Mode) of
        [] ->
            none;
        [{_Arity,
          [#c{tag = tuple,elements = _,qualifier = {_,_}} = OneTuple]}] ->
            OneTuple;
        List ->
            #c{tag = tuple_set,elements = List}
    end.

inf_tuple_sets([{Arity,Tuples1}|Ts1], [{Arity,Tuples2}|Ts2], Acc, Mode) ->
    case inf_tuples_in_sets(Tuples1, Tuples2, Mode) of
        [] ->
            inf_tuple_sets(Ts1, Ts2, Acc, Mode);
        [#c{tag = tuple_set,elements = [{Arity,NewTuples}]}] ->
            inf_tuple_sets(Ts1, Ts2, [{Arity,NewTuples}|Acc], Mode);
        NewTuples ->
            inf_tuple_sets(Ts1, Ts2, [{Arity,NewTuples}|Acc], Mode)
    end;
inf_tuple_sets([{Arity1,_}|Ts1] = L1, [{Arity2,_}|Ts2] = L2, Acc, Mode) ->
    if
        Arity1 < Arity2 ->
            inf_tuple_sets(Ts1, L2, Acc, Mode);
        Arity1 > Arity2 ->
            inf_tuple_sets(L1, Ts2, Acc, Mode)
    end;
inf_tuple_sets([], _, Acc, _Mode) ->
    lists:reverse(Acc);
inf_tuple_sets(_, [], Acc, _Mode) ->
    lists:reverse(Acc).

inf_tuples_in_sets([#c{tag = tuple,
                       elements = Elements1,
                       qualifier = {_,any}}],
                   L2,
                   Mode) ->
    NewList =
        [ 
         t_inf_lists_strict(Elements1, Elements2, Mode) ||
             #c{tag = tuple,elements = Elements2,qualifier = {_,_}} <-
                 L2
        ],
    [ 
     t_tuple(Es) ||
         Es <- NewList,
         Es =/= bottom
    ];
inf_tuples_in_sets(L1,
                   [#c{tag = tuple,
                       elements = Elements2,
                       qualifier = {_,any}}],
                   Mode) ->
    NewList =
        [ 
         t_inf_lists_strict(Elements1, Elements2, Mode) ||
             #c{tag = tuple,elements = Elements1,qualifier = {_,_}} <-
                 L1
        ],
    [ 
     t_tuple(Es) ||
         Es <- NewList,
         Es =/= bottom
    ];
inf_tuples_in_sets(L1, L2, Mode) ->
    inf_tuples_in_sets(L1, L2, [], Mode).

inf_tuples_in_sets([#c{tag = tuple,
                       elements = Elements1,
                       qualifier = {Arity,Tag}}|
                    Ts1],
                   [#c{tag = tuple,
                       elements = Elements2,
                       qualifier = {Arity,Tag}}|
                    Ts2],
                   Acc,
                   Mode) ->
    case t_inf_lists_strict(Elements1, Elements2, Mode) of
        bottom ->
            inf_tuples_in_sets(Ts1, Ts2, Acc, Mode);
        NewElements ->
            inf_tuples_in_sets(Ts1,
                               Ts2,
                               [#c{tag = tuple,
                                   elements = NewElements,
                                   qualifier = {Arity,Tag}}|
                                Acc],
                               Mode)
    end;
inf_tuples_in_sets([#c{tag = tuple,elements = _,qualifier = {_,Tag1}}|
                    Ts1] =
                       L1,
                   [#c{tag = tuple,elements = _,qualifier = {_,Tag2}}|
                    Ts2] =
                       L2,
                   Acc,
                   Mode) ->
    if
        Tag1 < Tag2 ->
            inf_tuples_in_sets(Ts1, L2, Acc, Mode);
        Tag1 > Tag2 ->
            inf_tuples_in_sets(L1, Ts2, Acc, Mode)
    end;
inf_tuples_in_sets([], _, Acc, _Mode) ->
    lists:reverse(Acc);
inf_tuples_in_sets(_, [], Acc, _Mode) ->
    lists:reverse(Acc).

inf_union(U1, U2, opaque) ->
    inf_union(U1, U2, 0, [], opaque);
inf_union(U1, U2, OtherMode) ->
    inf_union(U1, U2, 0, [], OtherMode).

inf_union([none|Left1], [none|Left2], N, Acc, Mode) ->
    inf_union(Left1, Left2, N, [none|Acc], Mode);
inf_union([T1|Left1], [T2|Left2], N, Acc, Mode) ->
    case t_inf(T1, T2, Mode) of
        none ->
            inf_union(Left1, Left2, N, [none|Acc], Mode);
        T ->
            inf_union(Left1, Left2, N + 1, [T|Acc], Mode)
    end;
inf_union([], [], N, Acc, _Mode) ->
    if
        N =:= 0 ->
            none;
        N =:= 1 ->
            [Type] =
                [ 
                 T ||
                     T <- Acc,
                     T =/= none
                ],
            Type;
        N >= 2 ->
            #c{tag = union,
               elements = [_,_,_,_,_,_,_,_,_,_] = lists:reverse(Acc)}
    end.

inf_bitstr(U1, B1, U2, B2) ->
    GCD = gcd(U1, U2),
    case (B2 - B1) rem GCD of
        0 ->
            U = U1 * U2 div GCD,
            B = findfirst(0, 0, U1, B1, U2, B2),
            t_bitstr(U, B);
        _ ->
            none
    end.

findfirst(N1, N2, U1, B1, U2, B2) ->
    Val1 = U1 * N1 + B1,
    Val2 = U2 * N2 + B2,
    if
        Val1 =:= Val2 ->
            Val1;
        Val1 > Val2 ->
            findfirst(N1, N2 + 1, U1, B1, U2, B2);
        Val1 < Val2 ->
            findfirst(N1 + 1, N2, U1, B1, U2, B2)
    end.

-spec t_subst(erl_type(), dict()) -> erl_type().

t_subst(T, Dict) ->
    case t_has_var(T) of
        true ->
            t_subst_dict(T, Dict);
        false ->
            T
    end.

t_subst_dict(#c{tag = var,elements = Id}, Dict) ->
    case dict:find(Id, Dict) of
        error ->
            any;
        {ok,Type} ->
            Type
    end;
t_subst_dict(#c{tag = list,
                elements = [Contents,Termination],
                qualifier = Size},
             Dict) ->
    case t_subst_dict(Contents, Dict) of
        none ->
            none;
        NewContents ->
            case t_subst_dict(Termination, Dict) of
                #c{tag = nil} ->
                    #c{tag = list,
                       elements = [NewContents,#c{tag = nil}],
                       qualifier = Size};
                any ->
                    #c{tag = list,
                       elements = [NewContents,any],
                       qualifier = Size};
                Other ->
                    #c{tag = list,
                       elements = [NewContents2,NewTermination],
                       qualifier = _} =
                        t_cons(NewContents, Other),
                    #c{tag = list,
                       elements = [NewContents2,NewTermination],
                       qualifier = Size}
            end
    end;
t_subst_dict(#c{tag = function,elements = [Domain,Range]}, Dict) ->
    #c{tag = function,
       elements = [t_subst_dict(Domain, Dict),t_subst_dict(Range, Dict)]};
t_subst_dict(#c{tag = product,elements = Types}, Dict) ->
    #c{tag = product,
       elements =
           [ 
            t_subst_dict(T, Dict) ||
                T <- Types
           ]};
t_subst_dict(#c{tag = tuple,elements = any,qualifier = {any,any}} = T,
             _Dict) ->
    T;
t_subst_dict(#c{tag = tuple,
                elements = Elements,
                qualifier = {_Arity,_Tag}},
             Dict) ->
    t_tuple([ 
             t_subst_dict(E, Dict) ||
                 E <- Elements
            ]);
t_subst_dict(#c{tag = tuple_set,elements = _} = TS, Dict) ->
    t_sup([ 
           t_subst_dict(T, Dict) ||
               T <- t_tuple_subtypes(TS)
          ]);
t_subst_dict(T, _Dict) ->
    T.

-spec subst_all_vars_to_any(erl_type()) -> erl_type().

subst_all_vars_to_any(T) ->
    t_subst_kv(T, []).

t_subst_kv(T, KVMap) ->
    case t_has_var(T) of
        true ->
            t_subst_aux(T, KVMap);
        false ->
            T
    end.

t_subst_aux(#c{tag = var,elements = Id}, VarMap) ->
    case lists:keyfind(Id, 1, VarMap) of
        false ->
            any;
        {Id,Type} ->
            Type
    end;
t_subst_aux(#c{tag = list,
               elements = [Contents,Termination],
               qualifier = Size},
            VarMap) ->
    case t_subst_aux(Contents, VarMap) of
        none ->
            none;
        NewContents ->
            case t_subst_aux(Termination, VarMap) of
                #c{tag = nil} ->
                    #c{tag = list,
                       elements = [NewContents,#c{tag = nil}],
                       qualifier = Size};
                any ->
                    #c{tag = list,
                       elements = [NewContents,any],
                       qualifier = Size};
                Other ->
                    #c{tag = list,
                       elements = [NewContents2,NewTermination],
                       qualifier = _} =
                        t_cons(NewContents, Other),
                    #c{tag = list,
                       elements = [NewContents2,NewTermination],
                       qualifier = Size}
            end
    end;
t_subst_aux(#c{tag = function,elements = [Domain,Range]}, VarMap) ->
    #c{tag = function,
       elements =
           [t_subst_aux(Domain, VarMap),t_subst_aux(Range, VarMap)]};
t_subst_aux(#c{tag = product,elements = Types}, VarMap) ->
    #c{tag = product,
       elements =
           [ 
            t_subst_aux(T, VarMap) ||
                T <- Types
           ]};
t_subst_aux(#c{tag = tuple,elements = any,qualifier = {any,any}} = T,
            _VarMap) ->
    T;
t_subst_aux(#c{tag = tuple,
               elements = Elements,
               qualifier = {_Arity,_Tag}},
            VarMap) ->
    t_tuple([ 
             t_subst_aux(E, VarMap) ||
                 E <- Elements
            ]);
t_subst_aux(#c{tag = tuple_set,elements = _} = TS, VarMap) ->
    t_sup([ 
           t_subst_aux(T, VarMap) ||
               T <- t_tuple_subtypes(TS)
          ]);
t_subst_aux(T, _VarMap) ->
    T.

-type t_unify_ret() :: {erl_type(), [{_, erl_type()}]}.

-spec t_unify(erl_type(), erl_type()) -> t_unify_ret().

t_unify(T1, T2) ->
    t_unify(T1, T2, []).

-spec t_unify(erl_type(), erl_type(), [erl_type()]) -> t_unify_ret().

t_unify(T1, T2, Opaques) ->
    {T,VarMap} = t_unify(T1, T2, [], Opaques),
    {t_subst_kv(T, VarMap),lists:keysort(1, VarMap)}.

t_unify(#c{tag = var,elements = Id} = T,
        #c{tag = var,elements = Id},
        VarMap,
        _Opaques) ->
    {T,VarMap};
t_unify(#c{tag = var,elements = Id1} = T,
        #c{tag = var,elements = Id2},
        VarMap,
        Opaques) ->
    case lists:keyfind(Id1, 1, VarMap) of
        false ->
            case lists:keyfind(Id2, 1, VarMap) of
                false ->
                    {T,[{Id2,T}|VarMap]};
                {Id2,Type} ->
                    t_unify(T, Type, VarMap, Opaques)
            end;
        {Id1,Type1} ->
            case lists:keyfind(Id2, 1, VarMap) of
                false ->
                    {Type1,[{Id2,T}|VarMap]};
                {Id2,Type2} ->
                    t_unify(Type1, Type2, VarMap, Opaques)
            end
    end;
t_unify(#c{tag = var,elements = Id}, Type, VarMap, Opaques) ->
    case lists:keyfind(Id, 1, VarMap) of
        false ->
            {Type,[{Id,Type}|VarMap]};
        {Id,VarType} ->
            t_unify(VarType, Type, VarMap, Opaques)
    end;
t_unify(Type, #c{tag = var,elements = Id}, VarMap, Opaques) ->
    case lists:keyfind(Id, 1, VarMap) of
        false ->
            {Type,[{Id,Type}|VarMap]};
        {Id,VarType} ->
            t_unify(VarType, Type, VarMap, Opaques)
    end;
t_unify(#c{tag = function,elements = [Domain1,Range1]},
        #c{tag = function,elements = [Domain2,Range2]},
        VarMap,
        Opaques) ->
    {Domain,VarMap1} = t_unify(Domain1, Domain2, VarMap, Opaques),
    {Range,VarMap2} = t_unify(Range1, Range2, VarMap1, Opaques),
    {#c{tag = function,elements = [Domain,Range]},VarMap2};
t_unify(#c{tag = list,
           elements = [Contents1,Termination1],
           qualifier = Size},
        #c{tag = list,
           elements = [Contents2,Termination2],
           qualifier = Size},
        VarMap,
        Opaques) ->
    {Contents,VarMap1} = t_unify(Contents1, Contents2, VarMap, Opaques),
    {Termination,VarMap2} =
        t_unify(Termination1, Termination2, VarMap1, Opaques),
    {#c{tag = list,elements = [Contents,Termination],qualifier = Size},
     VarMap2};
t_unify(#c{tag = product,elements = Types1},
        #c{tag = product,elements = Types2},
        VarMap,
        Opaques) ->
    {Types,VarMap1} = unify_lists(Types1, Types2, VarMap, Opaques),
    {#c{tag = product,elements = Types},VarMap1};
t_unify(#c{tag = tuple,elements = any,qualifier = {any,any}} = T,
        #c{tag = tuple,elements = any,qualifier = {any,any}},
        VarMap,
        _Opaques) ->
    {T,VarMap};
t_unify(#c{tag = tuple,elements = Elements1,qualifier = {Arity,_}},
        #c{tag = tuple,elements = Elements2,qualifier = {Arity,_}},
        VarMap,
        Opaques)
    when Arity =/= any ->
    {NewElements,VarMap1} =
        unify_lists(Elements1, Elements2, VarMap, Opaques),
    {t_tuple(NewElements),VarMap1};
t_unify(#c{tag = tuple_set,elements = [{Arity,_}]} = T1,
        #c{tag = tuple,elements = _,qualifier = {Arity,_}} = T2,
        VarMap,
        Opaques)
    when Arity =/= any ->
    unify_tuple_set_and_tuple(T1, T2, VarMap, Opaques);
t_unify(#c{tag = tuple,elements = _,qualifier = {Arity,_}} = T1,
        #c{tag = tuple_set,elements = [{Arity,_}]} = T2,
        VarMap,
        Opaques)
    when Arity =/= any ->
    unify_tuple_set_and_tuple(T2, T1, VarMap, Opaques);
t_unify(#c{tag = tuple_set,elements = List1},
        #c{tag = tuple_set,elements = List2},
        VarMap,
        Opaques) ->
    {Tuples,NewVarMap} =
        unify_lists(lists:append([ 
                                  T ||
                                      {_Arity,T} <- List1
                                 ]),
                    lists:append([ 
                                  T ||
                                      {_Arity,T} <- List2
                                 ]),
                    VarMap,
                    Opaques),
    {t_sup(Tuples),NewVarMap};
t_unify(#c{tag = opaque,elements = Elements} = T,
        #c{tag = opaque,elements = Elements},
        VarMap,
        _Opaques) ->
    {T,VarMap};
t_unify(#c{tag = opaque,elements = _} = T1,
        #c{tag = opaque,elements = _} = T2,
        _VarMap,
        _Opaques) ->
    throw({mismatch,T1,T2});
t_unify(Type, #c{tag = opaque,elements = _} = OpType, VarMap, Opaques) ->
    t_unify_with_opaque(Type, OpType, VarMap, Opaques);
t_unify(#c{tag = opaque,elements = _} = OpType, Type, VarMap, Opaques) ->
    t_unify_with_opaque(Type, OpType, VarMap, Opaques);
t_unify(T, T, VarMap, _Opaques) ->
    {T,VarMap};
t_unify(T1, T2, _, _) ->
    throw({mismatch,T1,T2}).

t_unify_with_opaque(Type, OpType, VarMap, Opaques) ->
    case lists:member(OpType, Opaques) of
        true ->
            Struct = t_opaque_structure(OpType),
            try t_unify(Type, Struct, VarMap, Opaques) of
                {_T,VarMap1} ->
                    {OpType,VarMap1}
            catch
                {mismatch,_T1,_T2} ->
                    case t_inf(OpType, Type, opaque) of
                        none ->
                            throw({mismatch,Type,OpType});
                        _ ->
                            {OpType,VarMap}
                    end
            end;
        false ->
            throw({mismatch,Type,OpType})
    end.

unify_tuple_set_and_tuple(#c{tag = tuple_set,elements = [{Arity,List}]},
                          #c{tag = tuple,
                             elements = Elements2,
                             qualifier = {Arity,_}},
                          VarMap,
                          Opaques) ->
    {NewElements,VarMap1} =
        unify_lists(sup_tuple_elements(List),
                    Elements2,
                    VarMap,
                    Opaques),
    {t_tuple(NewElements),VarMap1}.

unify_lists(L1, L2, VarMap, Opaques) ->
    unify_lists(L1, L2, VarMap, [], Opaques).

unify_lists([T1|Left1], [T2|Left2], VarMap, Acc, Opaques) ->
    {NewT,NewVarMap} = t_unify(T1, T2, VarMap, Opaques),
    unify_lists(Left1, Left2, NewVarMap, [NewT|Acc], Opaques);
unify_lists([], [], VarMap, Acc, _Opaques) ->
    {lists:reverse(Acc),VarMap}.

-spec t_subtract_list(erl_type(), [erl_type()]) -> erl_type().

t_subtract_list(T1, [T2|Left]) ->
    t_subtract_list(t_subtract(T1, T2), Left);
t_subtract_list(T, []) ->
    T.

-spec t_subtract(erl_type(), erl_type()) -> erl_type().

t_subtract(_, any) ->
    none;
t_subtract(_, #c{tag = var,elements = _}) ->
    none;
t_subtract(any, _) ->
    any;
t_subtract(#c{tag = var,elements = _} = T, _) ->
    T;
t_subtract(T, unit) ->
    T;
t_subtract(unit, _) ->
    unit;
t_subtract(none, _) ->
    none;
t_subtract(T, none) ->
    T;
t_subtract(#c{tag = atom,elements = Set1},
           #c{tag = atom,elements = Set2}) ->
    case set_subtract(Set1, Set2) of
        none ->
            none;
        Set ->
            #c{tag = atom,elements = Set}
    end;
t_subtract(#c{tag = binary,elements = [U1,B1]},
           #c{tag = binary,elements = [U2,B2]}) ->
    subtract_bin(t_bitstr(U1, B1),
                 t_inf(t_bitstr(U1, B1), t_bitstr(U2, B2)));
t_subtract(#c{tag = function,elements = [_,_]} = T1,
           #c{tag = function,elements = [_,_]} = T2) ->
    case t_is_subtype(T1, T2) of
        true ->
            none;
        false ->
            T1
    end;
t_subtract(#c{tag = identifier,elements = Set1},
           #c{tag = identifier,elements = Set2}) ->
    case set_subtract(Set1, Set2) of
        none ->
            none;
        Set ->
            #c{tag = identifier,elements = Set}
    end;
t_subtract(#c{tag = opaque,elements = Set1},
           #c{tag = opaque,elements = Set2}) ->
    case set_subtract(Set1, Set2) of
        none ->
            none;
        Set ->
            #c{tag = opaque,elements = Set}
    end;
t_subtract(#c{tag = matchstate,elements = [Pres1,Slots1]},
           #c{tag = matchstate,elements = [Pres2,_Slots2]}) ->
    Pres = t_subtract(Pres1, Pres2),
    case t_is_none(Pres) of
        true ->
            none;
        false ->
            #c{tag = matchstate,elements = [Pres,Slots1]}
    end;
t_subtract(#c{tag = matchstate,elements = [Present,Slots]}, _) ->
    #c{tag = matchstate,elements = [Present,Slots]};
t_subtract(#c{tag = nil}, #c{tag = nil}) ->
    none;
t_subtract(#c{tag = nil},
           #c{tag = list,elements = [_,_],qualifier = nonempty}) ->
    #c{tag = nil};
t_subtract(#c{tag = nil}, #c{tag = list,elements = [_,_],qualifier = _}) ->
    none;
t_subtract(#c{tag = list,
              elements = [Contents,Termination],
              qualifier = _Size} =
               T,
           #c{tag = nil}) ->
    case Termination =:= #c{tag = nil} of
        true ->
            #c{tag = list,
               elements = [Contents,Termination],
               qualifier = nonempty};
        false ->
            T
    end;
t_subtract(#c{tag = list,
              elements = [Contents1,Termination1],
              qualifier = Size1} =
               T,
           #c{tag = list,
              elements = [Contents2,Termination2],
              qualifier = Size2}) ->
    case t_is_subtype(Contents1, Contents2) of
        true ->
            case t_is_subtype(Termination1, Termination2) of
                true ->
                    case {Size1,Size2} of
                        {nonempty,unknown} ->
                            none;
                        {unknown,nonempty} ->
                            #c{tag = nil};
                        {S,S} ->
                            none
                    end;
                false ->
                    T
            end;
        false ->
            T
    end;
t_subtract(#c{tag = number,elements = any,qualifier = float},
           #c{tag = number,elements = any,qualifier = float}) ->
    none;
t_subtract(#c{tag = number,elements = _,qualifier = _} = T1,
           #c{tag = number,elements = any,qualifier = float}) ->
    t_inf(T1, t_integer());
t_subtract(#c{tag = number,elements = any,qualifier = float},
           #c{tag = number,elements = _Set,qualifier = Tag}) ->
    case Tag of
        unknown ->
            none;
        _ ->
            #c{tag = number,elements = any,qualifier = float}
    end;
t_subtract(#c{tag = number,elements = _,qualifier = _},
           #c{tag = number,elements = any,qualifier = unknown}) ->
    none;
t_subtract(#c{tag = number,elements = _,qualifier = _} = T1,
           #c{tag = number,elements = any,qualifier = integer}) ->
    t_inf(#c{tag = number,elements = any,qualifier = float}, T1);
t_subtract(#c{tag = number,
              elements = #int_set{set = Set1},
              qualifier = integer},
           #c{tag = number,
              elements = #int_set{set = Set2},
              qualifier = integer}) ->
    case set_subtract(Set1, Set2) of
        none ->
            none;
        Set ->
            #c{tag = number,
               elements = #int_set{set = Set},
               qualifier = integer}
    end;
t_subtract(#c{tag = number,
              elements = #int_rng{from = From1,to = To1},
              qualifier = integer} =
               T1,
           #c{tag = number,
              elements = #int_rng{from = _,to = _},
              qualifier = integer} =
               T2) ->
    case t_inf(T1, T2) of
        none ->
            T1;
        #c{tag = number,
           elements = #int_rng{from = From1,to = To1},
           qualifier = integer} ->
            none;
        #c{tag = number,
           elements = #int_rng{from = neg_inf,to = To},
           qualifier = integer} ->
            t_from_range(To + 1, To1);
        #c{tag = number,
           elements = #int_rng{from = From,to = pos_inf},
           qualifier = integer} ->
            t_from_range(From1, From - 1);
        #c{tag = number,
           elements = #int_rng{from = From,to = To},
           qualifier = integer} ->
            t_sup(t_from_range(From1, From - 1),
                  t_from_range(To + 1, To))
    end;
t_subtract(#c{tag = number,
              elements = #int_rng{from = From,to = To},
              qualifier = integer} =
               T1,
           #c{tag = number,
              elements = #int_set{set = Set},
              qualifier = integer}) ->
    NewFrom =
        case set_is_element(From, Set) of
            true ->
                From + 1;
            false ->
                From
        end,
    NewTo =
        case set_is_element(To, Set) of
            true ->
                To - 1;
            false ->
                To
        end,
    if
        (NewFrom =:= From) and (NewTo =:= To) ->
            T1;
        true ->
            t_from_range(NewFrom, NewTo)
    end;
t_subtract(#c{tag = number,
              elements = #int_set{set = Set},
              qualifier = integer},
           #c{tag = number,
              elements = #int_rng{from = From,to = To},
              qualifier = integer}) ->
    case
        set_filter(fun(X) ->
                          not (X =< From
                               orelse
                               X >= To)
                   end,
                   Set)
    of
        none ->
            none;
        NewSet ->
            #c{tag = number,
               elements = #int_set{set = NewSet},
               qualifier = integer}
    end;
t_subtract(#c{tag = number,elements = any,qualifier = integer} = T1,
           #c{tag = number,elements = _,qualifier = integer}) ->
    T1;
t_subtract(#c{tag = number,elements = _,qualifier = _} = T1,
           #c{tag = number,elements = _,qualifier = _}) ->
    T1;
t_subtract(#c{tag = tuple,elements = _,qualifier = {_,_}},
           #c{tag = tuple,elements = any,qualifier = {any,any}}) ->
    none;
t_subtract(#c{tag = tuple_set,elements = _},
           #c{tag = tuple,elements = any,qualifier = {any,any}}) ->
    none;
t_subtract(#c{tag = tuple,elements = any,qualifier = {any,any}} = T1,
           #c{tag = tuple_set,elements = _}) ->
    T1;
t_subtract(#c{tag = tuple,
              elements = Elements1,
              qualifier = {Arity1,_Tag1}} =
               T1,
           #c{tag = tuple,
              elements = Elements2,
              qualifier = {Arity2,_Tag2}}) ->
    if
        Arity1 =/= Arity2 ->
            T1;
        Arity1 =:= Arity2 ->
            NewElements = t_subtract_lists(Elements1, Elements2),
            case
                [ 
                 E ||
                     E <- NewElements,
                     E =/= none
                ]
            of
                [] ->
                    none;
                [_] ->
                    t_tuple(replace_nontrivial_element(Elements1,
                                                       NewElements));
                _ ->
                    T1
            end
    end;
t_subtract(#c{tag = tuple_set,elements = List1} = T1,
           #c{tag = tuple,elements = _,qualifier = {Arity,_}} = T2) ->
    case orddict:find(Arity, List1) of
        error ->
            T1;
        {ok,List2} ->
            TuplesLeft0 =
                [ 
                 Tuple ||
                     {_Arity,Tuple} <- orddict:erase(Arity, List1)
                ],
            TuplesLeft1 = lists:append(TuplesLeft0),
            t_sup([ 
                   t_subtract(L, T2) ||
                       L <- List2
                  ]
                  ++
                  TuplesLeft1)
    end;
t_subtract(#c{tag = tuple,elements = _,qualifier = {Arity,_}} = T1,
           #c{tag = tuple_set,elements = List1}) ->
    case orddict:find(Arity, List1) of
        error ->
            T1;
        {ok,List2} ->
            t_inf([ 
                   t_subtract(T1, L) ||
                       L <- List2
                  ])
    end;
t_subtract(#c{tag = tuple_set,elements = _} = T1,
           #c{tag = tuple_set,elements = _} = T2) ->
    t_sup([ 
           t_subtract(T, T2) ||
               T <- t_tuple_subtypes(T1)
          ]);
t_subtract(#c{tag = product,elements = Elements1} = T1,
           #c{tag = product,elements = Elements2}) ->
    Arity1 = length(Elements1),
    Arity2 = length(Elements2),
    if
        Arity1 =/= Arity2 ->
            T1;
        Arity1 =:= Arity2 ->
            NewElements = t_subtract_lists(Elements1, Elements2),
            case
                [ 
                 E ||
                     E <- NewElements,
                     E =/= none
                ]
            of
                [] ->
                    none;
                [_] ->
                    t_product(replace_nontrivial_element(Elements1,
                                                         NewElements));
                _ ->
                    T1
            end
    end;
t_subtract(#c{tag = product,elements = P1}, _) ->
    #c{tag = product,elements = P1};
t_subtract(T, #c{tag = product,elements = _}) ->
    T;
t_subtract(#c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U1},
           #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U2}) ->
    subtract_union(U1, U2);
t_subtract(T1, T2) ->
    #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U1} =
        force_union(T1),
    #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = U2} =
        force_union(T2),
    subtract_union(U1, U2).

-spec t_subtract_lists([erl_type()], [erl_type()]) -> [erl_type()].

t_subtract_lists(L1, L2) ->
    t_subtract_lists(L1, L2, []).

-spec t_subtract_lists([erl_type()], [erl_type()], [erl_type()]) ->
                          [erl_type()].

t_subtract_lists([T1|Left1], [T2|Left2], Acc) ->
    t_subtract_lists(Left1, Left2, [t_subtract(T1, T2)|Acc]);
t_subtract_lists([], [], Acc) ->
    lists:reverse(Acc).

-spec subtract_union([erl_type(), ...], [erl_type(), ...]) -> erl_type().

subtract_union(U1, U2) ->
    subtract_union(U1, U2, 0, []).

-spec subtract_union([erl_type()],
                     [erl_type()],
                     non_neg_integer(),
                     [erl_type()]) ->
                        erl_type().

subtract_union([T1|Left1], [T2|Left2], N, Acc) ->
    case t_subtract(T1, T2) of
        none ->
            subtract_union(Left1, Left2, N, [none|Acc]);
        T ->
            subtract_union(Left1, Left2, N + 1, [T|Acc])
    end;
subtract_union([], [], 0, _Acc) ->
    none;
subtract_union([], [], 1, Acc) ->
    [T] =
        [ 
         X ||
             X <- Acc,
             X =/= none
        ],
    T;
subtract_union([], [], N, Acc) when is_integer(N), N > 1 ->
    #c{tag = union,
       elements = [_,_,_,_,_,_,_,_,_,_] = lists:reverse(Acc)}.

replace_nontrivial_element(El1, El2) ->
    replace_nontrivial_element(El1, El2, []).

replace_nontrivial_element([T1|Left1], [none|Left2], Acc) ->
    replace_nontrivial_element(Left1, Left2, [T1|Acc]);
replace_nontrivial_element([_|Left1], [T2|_], Acc) ->
    lists:reverse(Acc) ++ [T2|Left1].

subtract_bin(#c{tag = binary,elements = [U1,B1]},
             #c{tag = binary,elements = [U1,B1]}) ->
    none;
subtract_bin(#c{tag = binary,elements = [U1,B1]}, none) ->
    t_bitstr(U1, B1);
subtract_bin(#c{tag = binary,elements = [U1,B1]},
             #c{tag = binary,elements = [0,B1]}) ->
    t_bitstr(U1, B1 + U1);
subtract_bin(#c{tag = binary,elements = [U1,B1]},
             #c{tag = binary,elements = [U1,B2]}) ->
    if
        B1 + U1 =/= B2 ->
            t_bitstr(0, B1);
        true ->
            t_bitstr(U1, B1)
    end;
subtract_bin(#c{tag = binary,elements = [U1,B1]},
             #c{tag = binary,elements = [U2,B2]}) ->
    if
        2 * U1 =:= U2 ->
            if
                B1 =:= B2 ->
                    t_bitstr(U2, B1 + U1);
                B1 + U1 =:= B2 ->
                    t_bitstr(U2, B1);
                true ->
                    t_bitstr(U1, B1)
            end;
        true ->
            t_bitstr(U1, B1)
    end.

-spec t_is_equal(erl_type(), erl_type()) -> boolean().

t_is_equal(T, T) ->
    true;
t_is_equal(_, _) ->
    false.

-spec t_is_subtype(erl_type(), erl_type()) -> boolean().

t_is_subtype(T1, T2) ->
    Inf = t_inf(T1, T2),
    t_is_equal(T1, Inf).

-spec t_is_instance(erl_type(), erl_type()) -> boolean().

t_is_instance(ConcreteType, Type) ->
    t_is_subtype(ConcreteType, t_unopaque(Type)).

-spec t_unopaque(erl_type()) -> erl_type().

t_unopaque(T) ->
    t_unopaque(T, universe).

-spec t_unopaque(erl_type(), universe | [erl_type()]) -> erl_type().

t_unopaque(#c{tag = opaque,elements = _} = T, Opaques) ->
    case
        Opaques =:= universe
        orelse
        lists:member(T, Opaques)
    of
        true ->
            t_unopaque(t_opaque_structure(T), Opaques);
        false ->
            T
    end;
t_unopaque(#c{tag = list,elements = [ElemT,Termination],qualifier = Sz},
           Opaques) ->
    #c{tag = list,
       elements = [t_unopaque(ElemT, Opaques),Termination],
       qualifier = Sz};
t_unopaque(#c{tag = tuple,elements = any,qualifier = {_,_}} = T, _) ->
    T;
t_unopaque(#c{tag = tuple,elements = ArgTs,qualifier = {Sz,Tag}},
           Opaques)
    when is_list(ArgTs) ->
    NewArgTs =
        [ 
         t_unopaque(A, Opaques) ||
             A <- ArgTs
        ],
    #c{tag = tuple,elements = NewArgTs,qualifier = {Sz,Tag}};
t_unopaque(#c{tag = tuple_set,elements = Set}, Opaques) ->
    NewSet =
        [ 
         {Sz,
          [ 
           t_unopaque(T, Opaques) ||
               T <- Tuples
          ]} ||
             {Sz,Tuples} <- Set
        ],
    #c{tag = tuple_set,elements = NewSet};
t_unopaque(#c{tag = union,
              elements = [_,_,_,_,_,_,_,_,_,_] = [A,B,F,I,L,N,T,M,O,R]},
           Opaques) ->
    UL = t_unopaque(L, Opaques),
    UT = t_unopaque(T, Opaques),
    UO =
        case O of
            none ->
                [];
            #c{tag = opaque,elements = Os} ->
                [ 
                 t_unopaque(S, Opaques) ||
                     #opaque{struct = S} <- Os
                ]
        end,
    t_sup([#c{tag = union,
              elements =
                  [_,_,_,_,_,_,_,_,_,_] = [A,B,F,I,UL,N,UT,M,none,R]}|
           UO]);
t_unopaque(T, _) ->
    T.

-spec t_limit(erl_type(), integer()) -> erl_type().

t_limit(Term, K) when is_integer(K) ->
    t_limit_k(Term, K).

t_limit_k(_, K) when K =< 0 ->
    any;
t_limit_k(#c{tag = tuple,elements = any,qualifier = {any,any}} = T, _K) ->
    T;
t_limit_k(#c{tag = tuple,elements = Elements,qualifier = {Arity,_}}, K) ->
    if
        K =:= 1 ->
            t_tuple(Arity);
        true ->
            t_tuple([ 
                     t_limit_k(E, K - 1) ||
                         E <- Elements
                    ])
    end;
t_limit_k(#c{tag = tuple_set,elements = _} = T, K) ->
    t_sup([ 
           t_limit_k(Tuple, K) ||
               Tuple <- t_tuple_subtypes(T)
          ]);
t_limit_k(#c{tag = list,
             elements = [Elements,Termination],
             qualifier = Size},
          K) ->
    NewTermination =
        if
            K =:= 1 ->
                t_limit_k(Termination, K);
            true ->
                t_limit_k(Termination, K - 1)
        end,
    NewElements = t_limit_k(Elements, K - 1),
    TmpList = t_cons(NewElements, NewTermination),
    case Size of
        nonempty ->
            TmpList;
        unknown ->
            #c{tag = list,
               elements = [NewElements1,NewTermination1],
               qualifier = _} =
                TmpList,
            #c{tag = list,
               elements = [NewElements1,NewTermination1],
               qualifier = unknown}
    end;
t_limit_k(#c{tag = function,elements = [Domain,Range]}, K) ->
    #c{tag = function,
       elements = [t_limit_k(Domain, K),t_limit_k(Range, K - 1)]};
t_limit_k(#c{tag = product,elements = Elements}, K) ->
    #c{tag = product,
       elements =
           [ 
            t_limit_k(X, K - 1) ||
                X <- Elements
           ]};
t_limit_k(#c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = Elements},
          K) ->
    #c{tag = union,
       elements =
           [_,_,_,_,_,_,_,_,_,_] =
               [ 
                t_limit_k(X, K) ||
                    X <- Elements
               ]};
t_limit_k(T, _K) ->
    T.

-spec t_abstract_records(erl_type(), dict()) -> erl_type().

t_abstract_records(#c{tag = list,
                      elements = [Contents,Termination],
                      qualifier = Size},
                   RecDict) ->
    case t_abstract_records(Contents, RecDict) of
        none ->
            none;
        NewContents ->
            case t_abstract_records(Termination, RecDict) of
                #c{tag = nil} ->
                    #c{tag = list,
                       elements = [NewContents,#c{tag = nil}],
                       qualifier = Size};
                any ->
                    #c{tag = list,
                       elements = [NewContents,any],
                       qualifier = Size};
                Other ->
                    #c{tag = list,
                       elements = [NewContents2,NewTermination],
                       qualifier = _} =
                        t_cons(NewContents, Other),
                    #c{tag = list,
                       elements = [NewContents2,NewTermination],
                       qualifier = Size}
            end
    end;
t_abstract_records(#c{tag = function,elements = [Domain,Range]},
                   RecDict) ->
    #c{tag = function,
       elements =
           [t_abstract_records(Domain, RecDict),
            t_abstract_records(Range, RecDict)]};
t_abstract_records(#c{tag = product,elements = Types}, RecDict) ->
    #c{tag = product,
       elements =
           [ 
            t_abstract_records(T, RecDict) ||
                T <- Types
           ]};
t_abstract_records(#c{tag = union,
                      elements = [_,_,_,_,_,_,_,_,_,_] = Types},
                   RecDict) ->
    t_sup([ 
           t_abstract_records(T, RecDict) ||
               T <- Types
          ]);
t_abstract_records(#c{tag = tuple,elements = any,qualifier = {any,any}} =
                       T,
                   _RecDict) ->
    T;
t_abstract_records(#c{tag = tuple,
                      elements = Elements,
                      qualifier =
                          {Arity,#c{tag = atom,elements = _} = Tag}},
                   RecDict) ->
    [TagAtom] = t_atom_vals(Tag),
    case lookup_record(TagAtom, Arity - 1, RecDict) of
        error ->
            t_tuple([ 
                     t_abstract_records(E, RecDict) ||
                         E <- Elements
                    ]);
        {ok,Fields} ->
            t_tuple([Tag|
                     [ 
                      T ||
                          {_Name,T} <- Fields
                     ]])
    end;
t_abstract_records(#c{tag = tuple,
                      elements = Elements,
                      qualifier = {_Arity,_Tag}},
                   RecDict) ->
    t_tuple([ 
             t_abstract_records(E, RecDict) ||
                 E <- Elements
            ]);
t_abstract_records(#c{tag = tuple_set,elements = _} = Tuples, RecDict) ->
    t_sup([ 
           t_abstract_records(T, RecDict) ||
               T <- t_tuple_subtypes(Tuples)
          ]);
t_abstract_records(T, _RecDict) ->
    T.

-spec t_map(fun((erl_type()) -> erl_type()), erl_type()) -> erl_type().

t_map(Fun,
      #c{tag = list,elements = [Contents,Termination],qualifier = Size}) ->
    Fun(#c{tag = list,
           elements = [t_map(Fun, Contents),t_map(Fun, Termination)],
           qualifier = Size});
t_map(Fun, #c{tag = function,elements = [Domain,Range]}) ->
    Fun(#c{tag = function,
           elements = [t_map(Fun, Domain),t_map(Fun, Range)]});
t_map(Fun, #c{tag = product,elements = Types}) ->
    Fun(#c{tag = product,
           elements =
               [ 
                t_map(Fun, T) ||
                    T <- Types
               ]});
t_map(Fun, #c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = Types}) ->
    Fun(t_sup([ 
               t_map(Fun, T) ||
                   T <- Types
              ]));
t_map(Fun, #c{tag = tuple,elements = any,qualifier = {any,any}} = T) ->
    Fun(T);
t_map(Fun,
      #c{tag = tuple,elements = Elements,qualifier = {_Arity,_Tag}}) ->
    Fun(t_tuple([ 
                 t_map(Fun, E) ||
                     E <- Elements
                ]));
t_map(Fun, #c{tag = tuple_set,elements = _} = Tuples) ->
    Fun(t_sup([ 
               t_map(Fun, T) ||
                   T <- t_tuple_subtypes(Tuples)
              ]));
t_map(Fun, T) ->
    Fun(T).

-spec t_to_string(erl_type()) -> string().

t_to_string(T) ->
    t_to_string(T, dict:new()).

-spec t_to_string(erl_type(), dict()) -> string().

t_to_string(any, _RecDict) ->
    "any()";
t_to_string(none, _RecDict) ->
    "none()";
t_to_string(unit, _RecDict) ->
    "no_return()";
t_to_string(#c{tag = atom,elements = any}, _RecDict) ->
    "atom()";
t_to_string(#c{tag = atom,elements = Set}, _RecDict) ->
    case set_size(Set) of
        2 ->
            case
                set_is_element(true, Set)
                andalso
                set_is_element(false, Set)
            of
                true ->
                    "boolean()";
                false ->
                    set_to_string(Set)
            end;
        _ ->
            set_to_string(Set)
    end;
t_to_string(#c{tag = binary,elements = [0,0]}, _RecDict) ->
    "<<>>";
t_to_string(#c{tag = binary,elements = [8,0]}, _RecDict) ->
    "binary()";
t_to_string(#c{tag = binary,elements = [1,0]}, _RecDict) ->
    "bitstring()";
t_to_string(#c{tag = binary,elements = [0,B]}, _RecDict) ->
    lists:flatten(io_lib:format("<<_:~w>>", [B]));
t_to_string(#c{tag = binary,elements = [U,0]}, _RecDict) ->
    lists:flatten(io_lib:format("<<_:_*~w>>", [U]));
t_to_string(#c{tag = binary,elements = [U,B]}, _RecDict) ->
    lists:flatten(io_lib:format("<<_:~w,_:_*~w>>", [B,U]));
t_to_string(#c{tag = function,elements = [any,any]}, _RecDict) ->
    "fun()";
t_to_string(#c{tag = function,elements = [any,Range]}, RecDict) ->
    "fun((...) -> " ++ t_to_string(Range, RecDict) ++ ")";
t_to_string(#c{tag = function,
               elements = [#c{tag = product,elements = ArgList},Range]},
            RecDict) ->
    "fun(("
    ++
    comma_sequence(ArgList, RecDict)
    ++
    ") -> " ++ t_to_string(Range, RecDict) ++ ")";
t_to_string(#c{tag = identifier,elements = Set}, _RecDict) ->
    case Set of
        any ->
            "identifier()";
        _ ->
            string:join([ 
                         io_lib:format("~w()", [T]) ||
                             T <- set_to_list(Set)
                        ],
                        " | ")
    end;
t_to_string(#c{tag = opaque,elements = Set}, _RecDict) ->
    string:join([ 
                 case is_opaque_builtin(Mod, Name) of
                     true ->
                         io_lib:format("~w()", [Name]);
                     false ->
                         io_lib:format("~w:~w()", [Mod,Name])
                 end ||
                     #opaque{mod = Mod,name = Name} <- set_to_list(Set)
                ],
                " | ");
t_to_string(#c{tag = matchstate,elements = [Pres,Slots]}, RecDict) ->
    io_lib:format("ms(~s,~s)",
                  [t_to_string(Pres, RecDict),
                   t_to_string(Slots, RecDict)]);
t_to_string(#c{tag = nil}, _RecDict) ->
    "[]";
t_to_string(#c{tag = list,
               elements = [Contents,Termination],
               qualifier = nonempty},
            RecDict) ->
    ContentString = t_to_string(Contents, RecDict),
    case Termination of
        #c{tag = nil} ->
            case Contents of
                #c{tag = number,
                   elements = #int_rng{from = 0,to = 1114111},
                   qualifier = integer} ->
                    "nonempty_string()";
                _ ->
                    "[" ++ ContentString ++ ",...]"
            end;
        any ->
            case Contents =:= any of
                true ->
                    ok;
                false ->
                    error({illegal_list,
                           #c{tag = list,
                              elements = [Contents,Termination],
                              qualifier = nonempty}})
            end,
            "nonempty_maybe_improper_list()";
        _ ->
            case t_is_subtype(t_nil(), Termination) of
                true ->
                    "nonempty_maybe_improper_list("
                    ++
                    ContentString
                    ++
                    "," ++ t_to_string(Termination, RecDict) ++ ")";
                false ->
                    "nonempty_improper_list("
                    ++
                    ContentString
                    ++
                    "," ++ t_to_string(Termination, RecDict) ++ ")"
            end
    end;
t_to_string(#c{tag = list,
               elements = [Contents,Termination],
               qualifier = unknown},
            RecDict) ->
    ContentString = t_to_string(Contents, RecDict),
    case Termination of
        #c{tag = nil} ->
            case Contents of
                #c{tag = number,
                   elements = #int_rng{from = 0,to = 1114111},
                   qualifier = integer} ->
                    "string()";
                _ ->
                    "[" ++ ContentString ++ "]"
            end;
        any ->
            case Contents =:= any of
                true ->
                    ok;
                false ->
                    L = #c{tag = list,
                           elements = [Contents,Termination],
                           qualifier = unknown},
                    error({illegal_list,L})
            end,
            "maybe_improper_list()";
        _ ->
            case t_is_subtype(t_nil(), Termination) of
                true ->
                    "maybe_improper_list("
                    ++
                    ContentString
                    ++
                    "," ++ t_to_string(Termination, RecDict) ++ ")";
                false ->
                    "improper_list("
                    ++
                    ContentString
                    ++
                    "," ++ t_to_string(Termination, RecDict) ++ ")"
            end
    end;
t_to_string(#c{tag = number,
               elements = #int_set{set = Set},
               qualifier = integer},
            _RecDict) ->
    set_to_string(Set);
t_to_string(#c{tag = number,
               elements = #int_rng{from = 0,to = 255},
               qualifier = integer},
            _RecDict) ->
    "byte()";
t_to_string(#c{tag = number,
               elements = #int_rng{from = 0,to = 1114111},
               qualifier = integer},
            _RecDict) ->
    "char()";
t_to_string(#c{tag = number,
               elements = #int_rng{from = 1,to = pos_inf},
               qualifier = integer},
            _RecDict) ->
    "pos_integer()";
t_to_string(#c{tag = number,
               elements = #int_rng{from = 0,to = pos_inf},
               qualifier = integer},
            _RecDict) ->
    "non_neg_integer()";
t_to_string(#c{tag = number,
               elements = #int_rng{from = neg_inf,to = - 1},
               qualifier = integer},
            _RecDict) ->
    "neg_integer()";
t_to_string(#c{tag = number,
               elements = #int_rng{from = From,to = To},
               qualifier = integer},
            _RecDict) ->
    lists:flatten(io_lib:format("~w..~w", [From,To]));
t_to_string(#c{tag = number,elements = any,qualifier = integer},
            _RecDict) ->
    "integer()";
t_to_string(#c{tag = number,elements = any,qualifier = float}, _RecDict) ->
    "float()";
t_to_string(#c{tag = number,elements = any,qualifier = unknown},
            _RecDict) ->
    "number()";
t_to_string(#c{tag = product,elements = List}, RecDict) ->
    "<" ++ comma_sequence(List, RecDict) ++ ">";
t_to_string(#c{tag = remote,elements = Set}, RecDict) ->
    string:join([ 
                 case Args =:= [] of
                     true ->
                         io_lib:format("~w:~w()", [Mod,Name]);
                     false ->
                         ArgString = comma_sequence(Args, RecDict),
                         io_lib:format("~w:~w(~s)",
                                       [Mod,Name,ArgString])
                 end ||
                     #remote{mod = Mod,name = Name,args = Args} <-
                         set_to_list(Set)
                ],
                " | ");
t_to_string(#c{tag = tuple,elements = any,qualifier = {any,any}},
            _RecDict) ->
    "tuple()";
t_to_string(#c{tag = tuple,elements = Elements,qualifier = {_Arity,any}},
            RecDict) ->
    "{" ++ comma_sequence(Elements, RecDict) ++ "}";
t_to_string(#c{tag = tuple,elements = Elements,qualifier = {Arity,Tag}},
            RecDict) ->
    [TagAtom] = t_atom_vals(Tag),
    case lookup_record(TagAtom, Arity - 1, RecDict) of
        error ->
            "{" ++ comma_sequence(Elements, RecDict) ++ "}";
        {ok,FieldNames} ->
            record_to_string(TagAtom, Elements, FieldNames, RecDict)
    end;
t_to_string(#c{tag = tuple_set,elements = _} = T, RecDict) ->
    union_sequence(t_tuple_subtypes(T), RecDict);
t_to_string(#c{tag = union,elements = [_,_,_,_,_,_,_,_,_,_] = Types},
            RecDict) ->
    union_sequence([ 
                    T ||
                        T <- Types,
                        T =/= none
                   ],
                   RecDict);
t_to_string(#c{tag = var,elements = Id}, _RecDict) when is_atom(Id) ->
    io_lib:format("~s", [atom_to_list(Id)]);
t_to_string(#c{tag = var,elements = Id}, _RecDict) when is_integer(Id) ->
    io_lib:format("var(~w)", [Id]).

record_to_string(Tag, [_|Fields], FieldNames, RecDict) ->
    FieldStrings =
        record_fields_to_string(Fields, FieldNames, RecDict, []),
    "#"
    ++
    atom_to_string(Tag) ++ "{" ++ string:join(FieldStrings, ",") ++ "}".

record_fields_to_string([F|Fs], [{FName,_DefType}|FDefs], RecDict, Acc) ->
    NewAcc =
        case
            t_is_any(F)
            orelse
            t_is_atom(undefined, F)
        of
            true ->
                Acc;
            false ->
                StrFV =
                    atom_to_string(FName)
                    ++
                    "::" ++ t_to_string(F, RecDict),
                [StrFV|Acc]
        end,
    record_fields_to_string(Fs, FDefs, RecDict, NewAcc);
record_fields_to_string([], [], _RecDict, Acc) ->
    lists:reverse(Acc).

-spec record_field_diffs_to_string(erl_type(), dict()) -> string().

record_field_diffs_to_string(#c{tag = tuple,
                                elements = [_|Fs],
                                qualifier = {Arity,Tag}},
                             RecDict) ->
    [TagAtom] = t_atom_vals(Tag),
    {ok,FieldNames} = lookup_record(TagAtom, Arity - 1, RecDict),
    FieldDiffs = field_diffs(Fs, FieldNames, RecDict, []),
    string:join(FieldDiffs, " and ").

field_diffs([F|Fs], [{FName,DefType}|FDefs], RecDict, Acc) ->
    NewAcc =
        case not t_is_none(t_inf(F, DefType)) of
            true ->
                Acc;
            false ->
                Str =
                    atom_to_string(FName)
                    ++
                    "::" ++ t_to_string(DefType, RecDict),
                [Str|Acc]
        end,
    field_diffs(Fs, FDefs, RecDict, NewAcc);
field_diffs([], [], _, Acc) ->
    lists:reverse(Acc).

comma_sequence(Types, RecDict) ->
    List =
        [ 
         case T =:= any of
             true ->
                 "_";
             false ->
                 t_to_string(T, RecDict)
         end ||
             T <- Types
        ],
    string:join(List, ",").

union_sequence(Types, RecDict) ->
    List =
        [ 
         t_to_string(T, RecDict) ||
             T <- Types
        ],
    string:join(List, " | ").

-spec t_from_form(parse_form()) -> erl_type().

t_from_form(Form) ->
    t_from_form(Form, dict:new()).

-spec t_from_form(parse_form(), dict()) -> erl_type().

t_from_form(Form, RecDict) ->
    t_from_form(Form, RecDict, dict:new()).

-spec t_from_form(parse_form(), dict(), dict()) -> erl_type().

t_from_form(Form, RecDict, VarDict) ->
    {T,_R} = t_from_form(Form, [], false, RecDict, VarDict),
    T.

-type type_names() :: [{type | opaque | record, atom()}].

-spec t_from_form(parse_form(), type_names(), boolean(), dict(), dict()) ->
                     {erl_type(), type_names()}.

t_from_form({var,_L,'_'}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_any(),[]};
t_from_form({var,_L,Name}, _TypeNames, _InOpaque, _RecDict, VarDict) ->
    case dict:find(Name, VarDict) of
        error ->
            {t_var(Name),[]};
        {ok,Val} ->
            {Val,[]}
    end;
t_from_form({ann_type,_L,[_Var,Type]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    t_from_form(Type, TypeNames, InOpaque, RecDict, VarDict);
t_from_form({paren_type,_L,[Type]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    t_from_form(Type, TypeNames, InOpaque, RecDict, VarDict);
t_from_form({remote_type,_L,[{atom,_,Module},{atom,_,Type},Args]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {L,R} = list_from_form(Args, TypeNames, InOpaque, RecDict, VarDict),
    {t_remote(Module, Type, L),R};
t_from_form({atom,_L,Atom}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_atom(Atom),[]};
t_from_form({integer,_L,Int}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_integer(Int),[]};
t_from_form({op,_L,_Op,_Arg} = Op,
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    case erl_eval:partial_eval(Op) of
        {integer,_,Val} ->
            {t_integer(Val),[]};
        _ ->
            throw({error,
                   io_lib:format("Unable to evaluate type ~w\n", [Op])})
    end;
t_from_form({op,_L,_Op,_Arg1,_Arg2} = Op,
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    case erl_eval:partial_eval(Op) of
        {integer,_,Val} ->
            {t_integer(Val),[]};
        _ ->
            throw({error,
                   io_lib:format("Unable to evaluate type ~w\n", [Op])})
    end;
t_from_form({type,_L,any,[]}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_any(),[]};
t_from_form({type,_L,arity,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_arity(),[]};
t_from_form({type,_L,array,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_array(),[]};
t_from_form({type,_L,atom,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_atom(),[]};
t_from_form({type,_L,binary,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_binary(),[]};
t_from_form({type,_L,binary,[Base,Unit]} = Type,
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    case {erl_eval:partial_eval(Base),erl_eval:partial_eval(Unit)} of
        {{integer,_,B},{integer,_,U}} when B >= 0, U >= 0 ->
            {t_bitstr(U, B),[]};
        _ ->
            throw({error,
                   io_lib:format("Unable to evaluate type ~w\n", [Type])})
    end;
t_from_form({type,_L,bitstring,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_bitstr(),[]};
t_from_form({type,_L,bool,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_boolean(),[]};
t_from_form({type,_L,boolean,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_boolean(),[]};
t_from_form({type,_L,byte,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_byte(),[]};
t_from_form({type,_L,char,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_char(),[]};
t_from_form({type,_L,dict,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_dict(),[]};
t_from_form({type,_L,digraph,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_digraph(),[]};
t_from_form({type,_L,float,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_float(),[]};
t_from_form({type,_L,function,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_fun(),[]};
t_from_form({type,_L,'fun',[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_fun(),[]};
t_from_form({type,_L,'fun',[{type,_,any},Range]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {T,R} = t_from_form(Range, TypeNames, InOpaque, RecDict, VarDict),
    {t_fun(T),R};
t_from_form({type,_L,'fun',[{type,_,product,Domain},Range]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {L,R1} =
        list_from_form(Domain, TypeNames, InOpaque, RecDict, VarDict),
    {T,R2} = t_from_form(Range, TypeNames, InOpaque, RecDict, VarDict),
    {t_fun(L, T),R1 ++ R2};
t_from_form({type,_L,gb_set,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_gb_set(),[]};
t_from_form({type,_L,gb_tree,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_gb_tree(),[]};
t_from_form({type,_L,identifier,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_identifier(),[]};
t_from_form({type,_L,integer,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_integer(),[]};
t_from_form({type,_L,iodata,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_iodata(),[]};
t_from_form({type,_L,iolist,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_iolist(),[]};
t_from_form({type,_L,list,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_list(),[]};
t_from_form({type,_L,list,[Type]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {T,R} = t_from_form(Type, TypeNames, InOpaque, RecDict, VarDict),
    {t_list(T),R};
t_from_form({type,_L,mfa,[]}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_mfa(),[]};
t_from_form({type,_L,module,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_module(),[]};
t_from_form({type,_L,nil,[]}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_nil(),[]};
t_from_form({type,_L,neg_integer,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_neg_integer(),[]};
t_from_form({type,_L,non_neg_integer,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_non_neg_integer(),[]};
t_from_form({type,_L,no_return,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_unit(),[]};
t_from_form({type,_L,node,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_node(),[]};
t_from_form({type,_L,none,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_none(),[]};
t_from_form({type,_L,nonempty_list,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_nonempty_list(),[]};
t_from_form({type,_L,nonempty_list,[Type]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {T,R} = t_from_form(Type, TypeNames, InOpaque, RecDict, VarDict),
    {t_nonempty_list(T),R};
t_from_form({type,_L,nonempty_improper_list,[Cont,Term]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {T1,R1} = t_from_form(Cont, TypeNames, InOpaque, RecDict, VarDict),
    {T2,R2} = t_from_form(Term, TypeNames, InOpaque, RecDict, VarDict),
    {t_cons(T1, T2),R1 ++ R2};
t_from_form({type,_L,nonempty_maybe_improper_list,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_cons(any, any),[]};
t_from_form({type,_L,nonempty_maybe_improper_list,[Cont,Term]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {T1,R1} = t_from_form(Cont, TypeNames, InOpaque, RecDict, VarDict),
    {T2,R2} = t_from_form(Term, TypeNames, InOpaque, RecDict, VarDict),
    {t_cons(T1, T2),R1 ++ R2};
t_from_form({type,_L,nonempty_string,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_nonempty_string(),[]};
t_from_form({type,_L,number,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_number(),[]};
t_from_form({type,_L,pid,[]}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_pid(),[]};
t_from_form({type,_L,port,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_port(),[]};
t_from_form({type,_L,pos_integer,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_pos_integer(),[]};
t_from_form({type,_L,maybe_improper_list,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_maybe_improper_list(),[]};
t_from_form({type,_L,maybe_improper_list,[Content,Termination]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {T1,R1} =
        t_from_form(Content, TypeNames, InOpaque, RecDict, VarDict),
    {T2,R2} =
        t_from_form(Termination, TypeNames, InOpaque, RecDict, VarDict),
    {t_maybe_improper_list(T1, T2),R1 ++ R2};
t_from_form({type,_L,product,Elements},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    {L,R} =
        list_from_form(Elements, TypeNames, InOpaque, RecDict, VarDict),
    {t_product(L),R};
t_from_form({type,_L,queue,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_queue(),[]};
t_from_form({type,_L,range,[From,To]} = Type,
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    case {erl_eval:partial_eval(From),erl_eval:partial_eval(To)} of
        {{integer,_,FromVal},{integer,_,ToVal}} ->
            {t_from_range(FromVal, ToVal),[]};
        _ ->
            throw({error,
                   io_lib:format("Unable to evaluate type ~w\n", [Type])})
    end;
t_from_form({type,_L,record,[Name|Fields]},
            TypeNames,
            InOpaque,
            RecDict,
            VarDict) ->
    record_from_form(Name,
                     Fields,
                     TypeNames,
                     InOpaque,
                     RecDict,
                     VarDict);
t_from_form({type,_L,reference,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_reference(),[]};
t_from_form({type,_L,set,[]}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_set(),[]};
t_from_form({type,_L,string,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_string(),[]};
t_from_form({type,_L,term,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_any(),[]};
t_from_form({type,_L,tid,[]}, _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {t_tid(),[]};
t_from_form({type,_L,timeout,[]},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_timeout(),[]};
t_from_form({type,_L,tuple,any},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    {t_tuple(),[]};
t_from_form({type,_L,tuple,Args}, TypeNames, InOpaque, RecDict, VarDict) ->
    {L,R} = list_from_form(Args, TypeNames, InOpaque, RecDict, VarDict),
    {t_tuple(L),R};
t_from_form({type,_L,union,Args}, TypeNames, InOpaque, RecDict, VarDict) ->
    {L,R} = list_from_form(Args, TypeNames, InOpaque, RecDict, VarDict),
    {t_sup(L),R};
t_from_form({type,_L,Name,Args}, TypeNames, InOpaque, RecDict, VarDict) ->
    ArgsLen = length(Args),
    case lookup_type(Name, ArgsLen, RecDict) of
        {type,{_Module,Type,ArgNames}} ->
            case can_unfold_more({type,Name}, TypeNames) of
                true ->
                    List =
                        lists:zipwith(fun(ArgName, ArgType) ->
                                             {Ttemp,_R} =
                                                 t_from_form(ArgType,
                                                             TypeNames,
                                                             InOpaque,
                                                             RecDict,
                                                             VarDict),
                                             {ArgName,Ttemp}
                                      end,
                                      ArgNames,
                                      Args),
                    TmpVarDict = dict:from_list(List),
                    {T,R} =
                        t_from_form(Type,
                                    [{type,Name}|TypeNames],
                                    InOpaque,
                                    RecDict,
                                    TmpVarDict),
                    case lists:member({type,Name}, R) of
                        true ->
                            {t_limit(T, 2),R};
                        false ->
                            {T,R}
                    end;
                false ->
                    {t_any(),[{type,Name}]}
            end;
        {opaque,{Module,Type,ArgNames}} ->
            {Rep,Rret} =
                case can_unfold_more({opaque,Name}, TypeNames) of
                    true ->
                        List =
                            lists:zipwith(fun(ArgName, ArgType) ->
                                                 {Ttemp,_R} =
                                                     t_from_form(ArgType,
                                                                 TypeNames,
                                                                 InOpaque,
                                                                 RecDict,
                                                                 VarDict),
                                                 {ArgName,Ttemp}
                                          end,
                                          ArgNames,
                                          Args),
                        TmpVarDict = dict:from_list(List),
                        {T,R} =
                            t_from_form(Type,
                                        [{opaque,Name}|TypeNames],
                                        true,
                                        RecDict,
                                        TmpVarDict),
                        case lists:member({opaque,Name}, R) of
                            true ->
                                {t_limit(T, 2),R};
                            false ->
                                {T,R}
                        end;
                    false ->
                        {t_any(),[{opaque,Name}]}
                end,
            Tret =
                case InOpaque of
                    true ->
                        Rep;
                    false ->
                        t_from_form({opaque,- 1,Name,{Module,Args,Rep}},
                                    RecDict,
                                    VarDict)
                end,
            {Tret,Rret};
        error ->
            Msg =
                io_lib:format("Unable to find type ~w/~w\n",
                              [Name,ArgsLen]),
            throw({error,Msg})
    end;
t_from_form({opaque,_L,Name,{Mod,Args,Rep}},
            _TypeNames,
            _InOpaque,
            _RecDict,
            _VarDict) ->
    case Args of
        [] ->
            {t_opaque(Mod, Name, Args, Rep),[]};
        _ ->
            throw({error,"Polymorphic opaque types not supported yet"})
    end.

record_from_form({atom,_,Name},
                 ModFields,
                 TypeNames,
                 InOpaque,
                 RecDict,
                 VarDict) ->
    case can_unfold_more({record,Name}, TypeNames) of
        true ->
            case lookup_record(Name, RecDict) of
                {ok,DeclFields} ->
                    TypeNames1 = [{record,Name}|TypeNames],
                    AreTyped =
                        [ 
                         is_erl_type(FieldType) ||
                             {_FieldName,FieldType} <- DeclFields
                        ],
                    {DeclFields1,R1} =
                        case
                            lists:all(fun(Elem) ->
                                             Elem
                                      end,
                                      AreTyped)
                        of
                            true ->
                                {DeclFields,[]};
                            false ->
                                fields_from_form(DeclFields,
                                                 TypeNames1,
                                                 InOpaque,
                                                 RecDict,
                                                 dict:new())
                        end,
                    {GetModRec,R2} =
                        get_mod_record(ModFields,
                                       DeclFields1,
                                       TypeNames1,
                                       InOpaque,
                                       RecDict,
                                       VarDict),
                    case GetModRec of
                        {error,FieldName} ->
                            throw({error,
                                   io_lib:format("Illegal declaration o"
                                                 "f #~w{~w}\n",
                                                 [Name,FieldName])});
                        {ok,NewFields} ->
                            {t_tuple([t_atom(Name)|
                                      [ 
                                       Type ||
                                           {_FieldName,Type} <-
                                               NewFields
                                      ]]),
                             R1 ++ R2}
                    end;
                error ->
                    throw({error,
                           io_lib:format("Unknown record #~w{}\n",
                                         [Name])})
            end;
        false ->
            {t_any(),[]}
    end.

get_mod_record([],
               DeclFields,
               _TypeNames,
               _InOpaque,
               _RecDict,
               _VarDict) ->
    {{ok,DeclFields},[]};
get_mod_record(ModFields,
               DeclFields,
               TypeNames,
               InOpaque,
               RecDict,
               VarDict) ->
    DeclFieldsDict = orddict:from_list(DeclFields),
    {ModFieldsDict,R} =
        build_field_dict(ModFields,
                         TypeNames,
                         InOpaque,
                         RecDict,
                         VarDict),
    case get_mod_record(DeclFieldsDict, ModFieldsDict, []) of
        {error,_FieldName} = Error ->
            {Error,R};
        {ok,FinalOrdDict} ->
            {{ok,
              [ 
               {FieldName,orddict:fetch(FieldName, FinalOrdDict)} ||
                   {FieldName,_} <- DeclFields
              ]},
             R}
    end.

build_field_dict(FieldTypes, TypeNames, InOpaque, RecDict, VarDict) ->
    build_field_dict(FieldTypes,
                     TypeNames,
                     InOpaque,
                     RecDict,
                     VarDict,
                     []).

build_field_dict([{type,_,field_type,[{atom,_,Name},Type]}|Left],
                 TypeNames,
                 InOpaque,
                 RecDict,
                 VarDict,
                 Acc) ->
    {T,R1} = t_from_form(Type, TypeNames, InOpaque, RecDict, VarDict),
    NewAcc = [{Name,T}|Acc],
    {D,R2} =
        build_field_dict(Left,
                         TypeNames,
                         InOpaque,
                         RecDict,
                         VarDict,
                         NewAcc),
    {D,R1 ++ R2};
build_field_dict([], _TypeNames, _InOpaque, _RecDict, _VarDict, Acc) ->
    {orddict:from_list(Acc),[]}.

get_mod_record([{FieldName,DeclType}|Left1],
               [{FieldName,ModType}|Left2],
               Acc) ->
    case
        t_is_var(ModType)
        orelse
        t_is_remote(ModType)
        orelse
        t_is_subtype(ModType, DeclType)
    of
        false ->
            {error,FieldName};
        true ->
            get_mod_record(Left1, Left2, [{FieldName,ModType}|Acc])
    end;
get_mod_record([{FieldName1,_DeclType} = DT|Left1],
               [{FieldName2,_ModType}|_] = List2,
               Acc)
    when FieldName1 < FieldName2 ->
    get_mod_record(Left1, List2, [DT|Acc]);
get_mod_record(DeclFields, [], Acc) ->
    {ok,orddict:from_list(Acc ++ DeclFields)};
get_mod_record(_, [{FieldName2,_ModType}|_], _Acc) ->
    {error,FieldName2}.

fields_from_form([], _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {[],[]};
fields_from_form([{Name,Type}|Tail],
                 TypeNames,
                 InOpaque,
                 RecDict,
                 VarDict) ->
    {T,R1} = t_from_form(Type, TypeNames, InOpaque, RecDict, VarDict),
    {F,R2} =
        fields_from_form(Tail, TypeNames, InOpaque, RecDict, VarDict),
    {[{Name,T}|F],R1 ++ R2}.

list_from_form([], _TypeNames, _InOpaque, _RecDict, _VarDict) ->
    {[],[]};
list_from_form([H|Tail], TypeNames, InOpaque, RecDict, VarDict) ->
    {T,R1} = t_from_form(H, TypeNames, InOpaque, RecDict, VarDict),
    {L,R2} = list_from_form(Tail, TypeNames, InOpaque, RecDict, VarDict),
    {[T|L],R1 ++ R2}.

-spec t_form_to_string(parse_form()) -> string().

t_form_to_string({var,_L,'_'}) ->
    "_";
t_form_to_string({var,_L,Name}) ->
    atom_to_list(Name);
t_form_to_string({atom,_L,Atom}) ->
    io_lib:write_string(atom_to_list(Atom), $');
t_form_to_string({integer,_L,Int}) ->
    integer_to_list(Int);
t_form_to_string({op,_L,_Op,_Arg} = Op) ->
    case erl_eval:partial_eval(Op) of
        {integer,_,_} = Int ->
            t_form_to_string(Int);
        _ ->
            io_lib:format("Badly formed type ~w", [Op])
    end;
t_form_to_string({op,_L,_Op,_Arg1,_Arg2} = Op) ->
    case erl_eval:partial_eval(Op) of
        {integer,_,_} = Int ->
            t_form_to_string(Int);
        _ ->
            io_lib:format("Badly formed type ~w", [Op])
    end;
t_form_to_string({ann_type,_L,[Var,Type]}) ->
    t_form_to_string(Var) ++ "::" ++ t_form_to_string(Type);
t_form_to_string({paren_type,_L,[Type]}) ->
    io_lib:format("(~s)", [t_form_to_string(Type)]);
t_form_to_string({remote_type,_L,[{atom,_,Mod},{atom,_,Name},Args]}) ->
    ArgString =
        "(" ++ string:join(t_form_to_string_list(Args), ",") ++ ")",
    io_lib:format("~w:~w", [Mod,Name]) ++ ArgString;
t_form_to_string({type,_L,arity,[]}) ->
    "arity()";
t_form_to_string({type,_L,binary,[]}) ->
    "binary()";
t_form_to_string({type,_L,binary,[Base,Unit]} = Type) ->
    case {erl_eval:partial_eval(Base),erl_eval:partial_eval(Unit)} of
        {{integer,_,B},{integer,_,U}} ->
            case {U,B} of
                {0,0} ->
                    "<<>>";
                {8,0} ->
                    "binary()";
                {1,0} ->
                    "bitstring()";
                {0,B} ->
                    lists:flatten(io_lib:format("<<_:~w>>", [B]));
                {U,0} ->
                    lists:flatten(io_lib:format("<<_:_*~w>>", [U]));
                {U,B} ->
                    lists:flatten(io_lib:format("<<_:~w,_:_*~w>>",
                                                [B,U]))
            end;
        _ ->
            io_lib:format("Badly formed bitstr type ~w", [Type])
    end;
t_form_to_string({type,_L,bitstring,[]}) ->
    "bitstring()";
t_form_to_string({type,_L,'fun',[]}) ->
    "fun()";
t_form_to_string({type,_L,'fun',[{type,_,any},Range]}) ->
    "fun(...) -> " ++ t_form_to_string(Range);
t_form_to_string({type,_L,'fun',[{type,_,product,Domain},Range]}) ->
    "fun(("
    ++
    string:join(t_form_to_string_list(Domain), ",")
    ++
    ") -> " ++ t_form_to_string(Range) ++ ")";
t_form_to_string({type,_L,iodata,[]}) ->
    "iodata()";
t_form_to_string({type,_L,iolist,[]}) ->
    "iolist()";
t_form_to_string({type,_L,list,[Type]}) ->
    "[" ++ t_form_to_string(Type) ++ "]";
t_form_to_string({type,_L,mfa,[]}) ->
    "mfa()";
t_form_to_string({type,_L,module,[]}) ->
    "module()";
t_form_to_string({type,_L,node,[]}) ->
    "node()";
t_form_to_string({type,_L,nonempty_list,[Type]}) ->
    "[" ++ t_form_to_string(Type) ++ ",...]";
t_form_to_string({type,_L,nonempty_string,[]}) ->
    "nonempty_string()";
t_form_to_string({type,_L,product,Elements}) ->
    "<" ++ string:join(t_form_to_string_list(Elements), ",") ++ ">";
t_form_to_string({type,_L,range,[From,To]} = Type) ->
    case {erl_eval:partial_eval(From),erl_eval:partial_eval(To)} of
        {{integer,_,FromVal},{integer,_,ToVal}} ->
            io_lib:format("~w..~w", [FromVal,ToVal]);
        _ ->
            io_lib:format("Badly formed type ~w", [Type])
    end;
t_form_to_string({type,_L,record,[{atom,_,Name}]}) ->
    io_lib:format("#~w{}", [Name]);
t_form_to_string({type,_L,record,[{atom,_,Name}|Fields]}) ->
    FieldString = string:join(t_form_to_string_list(Fields), ","),
    io_lib:format("#~w{~s}", [Name,FieldString]);
t_form_to_string({type,_L,field_type,[{atom,_,Name},Type]}) ->
    io_lib:format("~w::~s", [Name,t_form_to_string(Type)]);
t_form_to_string({type,_L,term,[]}) ->
    "term()";
t_form_to_string({type,_L,timeout,[]}) ->
    "timeout()";
t_form_to_string({type,_L,tuple,any}) ->
    "tuple()";
t_form_to_string({type,_L,tuple,Args}) ->
    "{" ++ string:join(t_form_to_string_list(Args), ",") ++ "}";
t_form_to_string({type,_L,union,Args}) ->
    string:join(t_form_to_string_list(Args), " | ");
t_form_to_string({type,_L,Name,[]} = T) ->
    try
        t_to_string(t_from_form(T))
    catch
        {error,_} ->
            atom_to_string(Name) ++ "()"
    end;
t_form_to_string({type,_L,Name,List}) ->
    io_lib:format("~w(~s)",
                  [Name,string:join(t_form_to_string_list(List), ",")]).

t_form_to_string_list(List) ->
    t_form_to_string_list(List, []).

t_form_to_string_list([H|T], Acc) ->
    t_form_to_string_list(T, [t_form_to_string(H)|Acc]);
t_form_to_string_list([], Acc) ->
    lists:reverse(Acc).

-spec atom_to_string(atom()) -> string().

atom_to_string(Atom) ->
    lists:flatten(io_lib:format("~w", [Atom])).

-spec any_none([erl_type()]) -> boolean().

any_none([none|_Left]) ->
    true;
any_none([_|Left]) ->
    any_none(Left);
any_none([]) ->
    false.

-spec any_none_or_unit([erl_type()]) -> boolean().

any_none_or_unit([none|_]) ->
    true;
any_none_or_unit([unit|_]) ->
    true;
any_none_or_unit([_|Left]) ->
    any_none_or_unit(Left);
any_none_or_unit([]) ->
    false.

-spec is_erl_type(any()) -> boolean().

is_erl_type(any) ->
    true;
is_erl_type(none) ->
    true;
is_erl_type(unit) ->
    true;
is_erl_type(#c{}) ->
    true;
is_erl_type(_) ->
    false.

-spec lookup_record(atom(), dict()) ->
                       error |
                       {ok, [{atom(), parse_form() | erl_type()}]}.

lookup_record(Tag, RecDict) when is_atom(Tag) ->
    case dict:find({record,Tag}, RecDict) of
        {ok,[{_Arity,Fields}]} ->
            {ok,Fields};
        {ok,List} when is_list(List) ->
            error;
        error ->
            error
    end.

-spec lookup_record(atom(), arity(), dict()) ->
                       error | {ok, [{atom(), erl_type()}]}.

lookup_record(Tag, Arity, RecDict) when is_atom(Tag) ->
    case dict:find({record,Tag}, RecDict) of
        {ok,[{Arity,Fields}]} ->
            {ok,Fields};
        {ok,OrdDict} ->
            orddict:find(Arity, OrdDict);
        error ->
            error
    end.

lookup_type(Name, Arity, RecDict) ->
    case dict:find({type,Name,Arity}, RecDict) of
        error ->
            case dict:find({opaque,Name,Arity}, RecDict) of
                error ->
                    error;
                {ok,Found} ->
                    {opaque,Found}
            end;
        {ok,Found} ->
            {type,Found}
    end.

-spec type_is_defined(type | opaque, atom(), arity(), dict()) ->
                         boolean().

type_is_defined(TypeOrOpaque, Name, Arity, RecDict) ->
    dict:is_key({TypeOrOpaque,Name,Arity}, RecDict).

can_unfold_more(TypeName, TypeNames) ->
    Fun =
        fun(E, Acc) ->
               case E of
                   TypeName ->
                       Acc + 1;
                   _ ->
                       Acc
               end
        end,
    lists:foldl(Fun, 0, TypeNames) < 2.

set_singleton(Element) ->
    ordsets:from_list([Element]).

set_is_singleton(Element, Set) ->
    set_singleton(Element) =:= Set.

set_is_element(Element, Set) ->
    ordsets:is_element(Element, Set).

set_union(any, _) ->
    any;
set_union(_, any) ->
    any;
set_union(S1, S2) ->
    case ordsets:union(S1, S2) of
        S when length(S) =< 13 ->
            S;
        _ ->
            any
    end.

set_union_no_limit(any, _) ->
    any;
set_union_no_limit(_, any) ->
    any;
set_union_no_limit(S1, S2) ->
    ordsets:union(S1, S2).

set_intersection(any, S) ->
    S;
set_intersection(S, any) ->
    S;
set_intersection(S1, S2) ->
    case ordsets:intersection(S1, S2) of
        [] ->
            none;
        S ->
            S
    end.

set_subtract(_, any) ->
    none;
set_subtract(any, _) ->
    any;
set_subtract(S1, S2) ->
    case ordsets:subtract(S1, S2) of
        [] ->
            none;
        S ->
            S
    end.

set_from_list(List) ->
    case length(List) of
        L when L =< 13 ->
            ordsets:from_list(List);
        L when L > 13 ->
            any
    end.

set_to_list(Set) ->
    ordsets:to_list(Set).

set_filter(Fun, Set) ->
    case ordsets:filter(Fun, Set) of
        [] ->
            none;
        NewSet ->
            NewSet
    end.

set_size(Set) ->
    ordsets:size(Set).

set_to_string(Set) ->
    L = [ 
         case is_atom(X) of
             true ->
                 io_lib:write_string(atom_to_list(X), $');
             false ->
                 io_lib:format("~w", [X])
         end ||
             X <- set_to_list(Set)
        ],
    string:join(L, " | ").

set_min([H|_]) ->
    H.

set_max(Set) ->
    hd(lists:reverse(Set)).

-spec gcd(integer(), integer()) -> integer().

gcd(A, B) when B > A ->
    gcd1(B, A);
gcd(A, B) ->
    gcd1(A, B).

-spec gcd1(integer(), integer()) -> integer().

gcd1(A, 0) ->
    A;
gcd1(A, B) ->
    case A rem B of
        0 ->
            B;
        X ->
            gcd1(B, X)
    end.

-spec bitstr_concat(erl_type(), erl_type()) -> erl_type().

bitstr_concat(none, _) ->
    none;
bitstr_concat(_, none) ->
    none;
bitstr_concat(#c{tag = binary,elements = [U1,B1]},
              #c{tag = binary,elements = [U2,B2]}) ->
    t_bitstr(gcd(U1, U2), B1 + B2).

-spec bitstr_match(erl_type(), erl_type()) -> erl_type().

bitstr_match(none, _) ->
    none;
bitstr_match(_, none) ->
    none;
bitstr_match(#c{tag = binary,elements = [0,B1]},
             #c{tag = binary,elements = [0,B2]})
    when B1 =< B2 ->
    t_bitstr(0, B2 - B1);
bitstr_match(#c{tag = binary,elements = [0,_B1]},
             #c{tag = binary,elements = [0,_B2]}) ->
    none;
bitstr_match(#c{tag = binary,elements = [0,B1]},
             #c{tag = binary,elements = [U2,B2]})
    when B1 =< B2 ->
    t_bitstr(U2, B2 - B1);
bitstr_match(#c{tag = binary,elements = [0,B1]},
             #c{tag = binary,elements = [U2,B2]}) ->
    t_bitstr(U2, handle_base(U2, B2 - B1));
bitstr_match(#c{tag = binary,elements = [_,B1]},
             #c{tag = binary,elements = [0,B2]})
    when B1 > B2 ->
    none;
bitstr_match(#c{tag = binary,elements = [U1,B1]},
             #c{tag = binary,elements = [U2,B2]}) ->
    GCD = gcd(U1, U2),
    t_bitstr(GCD, handle_base(GCD, B2 - B1)).

-spec handle_base(integer(), integer()) -> integer().

handle_base(Unit, Pos) when Pos >= 0 ->
    Pos rem Unit;
handle_base(Unit, Neg) ->
    (Unit + Neg rem Unit) rem Unit.



