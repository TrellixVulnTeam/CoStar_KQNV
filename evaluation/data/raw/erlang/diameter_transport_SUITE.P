-file("test/lib/diameter/test/diameter_transport_SUITE.erl", 1).

-module(diameter_transport_SUITE).

-export([suite/0,all/0,groups/0,init_per_suite/1,end_per_suite/1]).

-export([start/1,
         tcp_accept/1,
         tcp_connect/1,
         sctp_accept/1,
         sctp_connect/1,
         reconnect/1,
         reconnect/0,
         stop/1]).

-export([accept/1,connect/1,init/2]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/kernel-2.15.3/include/inet_sctp.hrl",
      1).

-record(sctp_initmsg,{num_ostreams,
                      max_instreams,
                      max_attempts,
                      max_init_timeo}).

-record(sctp_sndrcvinfo,{stream,
                         ssn,
                         flags,
                         ppid,
                         context,
                         timetolive,
                         tsn,
                         cumtsn,
                         assoc_id}).

-record(sctp_assoc_change,{state = cant_assoc,
                           error = 0,
                           outbound_streams = 0,
                           inbound_streams = 0,
                           assoc_id = 0}).

-record(sctp_paddr_change,{addr = [0,0,0,0],
                           state = addr_available,
                           error = 0,
                           assoc_id = 0}).

-record(sctp_remote_error,{error = 0,assoc_id = 0,data = []}).

-record(sctp_send_failed,{flags = false,
                          error = 0,
                          info = #sctp_sndrcvinfo{},
                          assoc_id = 0,
                          data = <<>>}).

-record(sctp_shutdown_event,{assoc_id = 0}).

-record(sctp_adaptation_event,{adaptation_ind = 0,assoc_id = 0}).

-record(sctp_pdapi_event,{indication = partial_delivery_aborted,
                          assoc_id = 0}).

-record(sctp_rtoinfo,{assoc_id,initial,max,min}).

-record(sctp_assocparams,{assoc_id,
                          asocmaxrxt,
                          number_peer_destinations,
                          peer_rwnd,
                          local_rwnd,
                          cookie_life}).

-record(sctp_prim,{assoc_id,addr}).

-record(sctp_setpeerprim,{assoc_id,addr}).

-record(sctp_setadaptation,{adaptation_ind}).

-record(sctp_paddrparams,{assoc_id,
                          address,
                          hbinterval,
                          pathmaxrxt,
                          pathmtu,
                          sackdelay,
                          flags}).

-record(sctp_event_subscribe,{data_io_event,
                              association_event,
                              address_event,
                              send_failure_event,
                              peer_error_event,
                              shutdown_event,
                              partial_delivery_event,
                              adaptation_layer_event,
                              authentication_event}).

-record(sctp_assoc_value,{assoc_id,assoc_value}).

-record(sctp_paddrinfo,{assoc_id,address,state,cwnd,srtt,rto,mtu}).

-record(sctp_status,{assoc_id,
                     state,
                     rwnd,
                     unackdata,
                     penddata,
                     instrms,
                     outstrms,
                     fragmentation_point,
                     primary}).

-file("test/lib/diameter/test/diameter_transport_SUITE.erl", 47).

-file("/Users/parrt/Downloads/fenollp-erlang-grammar-c1db83d09307/test/lib/diameter/test/../include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options =
                          [{answer_errors,report},
                           {request_errors,answer_3xxx}]}).

-file("test/lib/diameter/test/diameter_transport_SUITE.erl", 48).

suite() ->
    [{timetrap,{minutes,2}}].

all() ->
    [start,{group,all},{group,all,[parallel]},stop].

groups() ->
    [{all,[],tc()}].

tc() ->
    [tcp_accept,tcp_connect,sctp_accept,sctp_connect,reconnect].

init_per_suite(Config) ->
    [{sctp,have_sctp()}|Config].

end_per_suite(_Config) ->
    ok.

start(_Config) ->
    ok = diameter:start().

stop(_Config) ->
    ok = diameter:stop().

tcp_accept(_) ->
    accept(tcp).

sctp_accept(Config) ->
    if_sctp(fun accept/1, Config).

accept(Prot) ->
    T = {Prot,make_ref()},
    [] = diameter_util:run(diameter_util:scramble(acc(2 * 8, T, []))).

acc(0, _, Acc) ->
    Acc;
acc(N, T, Acc) ->
    acc(N - 1,
        T,
        [{diameter_transport_SUITE,
          [init,element(1 + N rem 2, {accept,gen_connect}),T]}|
         Acc]).

tcp_connect(_) ->
    connect(tcp).

sctp_connect(Config) ->
    if_sctp(fun connect/1, Config).

connect(Prot) ->
    T = {Prot,make_ref()},
    [] =
        diameter_util:run([ 
                           {diameter_transport_SUITE,[init,X,T]} ||
                               X <- [gen_accept,connect]
                          ]).

reconnect() ->
    [{timetrap,{minutes,4}}].

reconnect({listen,Ref}) ->
    SvcName = make_ref(),
    ok = start_service(SvcName),
    LRef = diameter_util:listen(SvcName, tcp, [{watchdog_timer,6000}]),
    [_] = diameter_reg:wait({diameter_tcp,listener,{LRef,'_'}}),
    true = diameter_reg:add_new({diameter_transport_SUITE,Ref,LRef}),
    TPid = abort(SvcName, LRef, Ref),
    exit(TPid, kill),
    abort(SvcName, LRef, Ref);
reconnect({connect,Ref}) ->
    SvcName = make_ref(),
    true = diameter:subscribe(SvcName),
    ok = start_service(SvcName),
    [{{_,_,LRef},Pid}] =
        diameter_reg:wait({diameter_transport_SUITE,Ref,'_'}),
    CRef =
        diameter_util:connect(SvcName,
                              tcp,
                              LRef,
                              [{reconnect_timer,2000},
                               {watchdog_timer,6000}]),
    abort(SvcName, Pid, Ref),
    receive
        #diameter_event{service = SvcName,info = {down,CRef,_,_}} ->
            now()
    end,
    receive
        #diameter_event{service = SvcName,info = {reconnect,CRef,_}} ->
            now()
    end,
    receive
        #diameter_event{service = SvcName,info = {up,CRef,_,_,_}} ->
            now()
    end,
    abort(SvcName, Pid, Ref),
    MRef = monitor(process, Pid),
    receive
        {'DOWN',MRef,process,_,_} ->
            now()
    end;
reconnect(_) ->
    Ref = make_ref(),
    [] =
        diameter_util:run([ 
                           {diameter_transport_SUITE,
                            [reconnect,{T,Ref}]} ||
                               T <- [listen,connect]
                          ]).

start_service(SvcName) ->
    OH = io_lib:format("~p-~p-~p", tuple_to_list(now())),
    Opts =
        [{application,
          [{dictionary,diameter_gen_base_rfc6733},
           {module,diameter_callback}]},
         {'Origin-Host',OH},
         {'Origin-Realm',OH ++ ".org"},
         {'Vendor-Id',0},
         {'Product-Name',"x"},
         {'Auth-Application-Id',[0]}],
    diameter:start_service(SvcName, Opts).

abort(SvcName, Pid, Ref) when is_pid(Pid) ->
    receive
        #diameter_event{service = SvcName,info = {reconnect,_,_}} = E ->
            error(E)
    after
        45000 -> ok
    end,
    Pid ! {abort,Ref};
abort(SvcName, LRef, Ref) when is_reference(LRef) ->
    receive
        {abort,Ref} ->
            now()
    end,
    [[{ref,LRef},{type,listen},{options,_},{accept,[_,_] = Ts}|_]] =
        diameter:service_info(SvcName, transport),
    [TPid] =
        [ 
         P ||
             [{watchdog,{_,_,okay}},{peer,{P,_}}|_] <- Ts
        ],
    TPid.

have_sctp() ->
    case gen_sctp:open() of
        {ok,Sock} ->
            gen_sctp:close(Sock),
            true;
        {error,E} when E == eprotonosupport; E == esocktnosupport ->
            false
    end.

if_sctp(F, Config) ->
    case proplists:get_value(sctp, Config) of
        true ->
            F(sctp);
        false ->
            {skip,no_sctp}
    end.

init(accept, {Prot,Ref}) ->
    TPid = start_accept(Prot, Ref),
    <<_:8,Len:24,_/binary>> =
        Bin =
            bin(Prot,
                receive
                    {diameter,{recv,P}} ->
                        P
                end),
    Len = size(Bin),
    TPid ! {diameter,{send,Bin}},
    MRef = monitor(process, TPid),
    receive
        {'DOWN',MRef,process,_,_} ->
            now()
    end;
init(gen_connect, {Prot,Ref}) ->
    [PortNr] = diameter_util:lport(Prot, Ref),
    {ok,Sock} = gen_connect(Prot, PortNr),
    Bin = make_msg(),
    ok = gen_send(Prot, Sock, Bin),
    Bin = gen_recv(Prot, Sock);
init(gen_accept, {Prot,Ref}) ->
    {ok,LSock} = gen_listen(Prot),
    {ok,PortNr} = inet:port(LSock),
    true =
        diameter_reg:add_new({diameter_transport_SUITE,
                              listen,
                              Ref,
                              PortNr}),
    {ok,Sock} = gen_accept(Prot, LSock),
    Bin = gen_recv(Prot, Sock),
    ok = gen_send(Prot, Sock, Bin);
init(connect, {Prot,Ref}) ->
    [{{diameter_transport_SUITE,listen,_,PortNr},_}] =
        diameter_reg:wait({diameter_transport_SUITE,listen,Ref,'_'}),
    TPid = start_connect(Prot, PortNr, Ref),
    Bin = make_msg(),
    TPid ! {diameter,{send,Bin}},
    Bin =
        bin(Prot,
            receive
                {diameter,{recv,P}} ->
                    P
            end),
    MRef = monitor(process, TPid),
    receive
        {'DOWN',MRef,process,_,_} ->
            now()
    end.

bin(sctp, #diameter_packet{bin = Bin}) ->
    Bin;
bin(tcp, Bin) ->
    Bin.

make_msg() ->
    N = 1024,
    Bin = rand_bytes(4 * N),
    Len = 4 * (N + 1),
    <<1:8,Len:24,Bin/binary>>.

rand_bytes(N) ->
    random:seed(now()),
    rand_bytes(N, <<>>).

rand_bytes(0, Bin) ->
    Bin;
rand_bytes(N, Bin) ->
    Oct = random:uniform(256) - 1,
    rand_bytes(N - 1, <<Oct,Bin/binary>>).

start_connect(Prot, PortNr, Ref) ->
    {ok,TPid,[{127,0,0,1}]} =
        start_connect(Prot,
                      {connect,Ref},
                      #diameter_service{capabilities =
                                            #diameter_caps{host_ip_address =
                                                               []}},
                      [{raddr,{127,0,0,1}},
                       {rport,PortNr},
                       {ip,{127,0,0,1}},
                       {port,0}]),
    receive
        {diameter,{TPid,connected,_}} ->
            now()
    end,
    TPid.

start_connect(sctp, T, Svc, Opts) ->
    diameter_sctp:start(T,
                        Svc,
                        [{sctp_initmsg,
                          #sctp_initmsg{num_ostreams = 5,
                                        max_instreams = 5}}|
                         Opts]);
start_connect(tcp, T, Svc, Opts) ->
    diameter_tcp:start(T, Svc, Opts).

start_accept(Prot, Ref) ->
    Pid = sync(accept, Ref),
    {Mod,Opts} = tmod(Prot),
    try
        {ok,TPid,[{127,0,0,1}]} =
            Mod:start({accept,Ref},
                      #diameter_service{capabilities =
                                            #diameter_caps{host_ip_address =
                                                               [{127,
                                                                 0,
                                                                 0,
                                                                 1}]}},
                      [{port,0}|Opts]),
        receive
            {diameter,{TPid,connected}} ->
                now()
        end,
        TPid
    after
        Pid ! Ref
    end.

sync(What, Ref) ->
    ok =
        diameter_sync:cast({diameter_transport_SUITE,What,Ref},
                           [fun lock/2,Ref,self()],
                           infinity,
                           infinity),
    receive
        {start,Ref,Pid} ->
            Pid
    end.

lock(Ref, Pid) ->
    Pid ! {start,Ref,self()},
    monitor(process, Pid),
    Ref =
        receive
            T ->
                T
        end.

tmod(sctp) ->
    {diameter_sctp,
     [{sctp_initmsg,#sctp_initmsg{num_ostreams = 5,max_instreams = 5}}]};
tmod(tcp) ->
    {diameter_tcp,[]}.

gen_connect(sctp = P, PortNr) ->
    {ok,Sock} =
        Ok =
            gen_sctp:open([{ip,{127,0,0,1}},
                           {port,0},
                           binary,
                           {active,true},
                           {sctp_initmsg,
                            #sctp_initmsg{num_ostreams = 5,
                                          max_instreams = 5}}]),
    ok = gen_sctp:connect_init(Sock, {127,0,0,1}, PortNr, []),
    Ok = gen_accept(P, Sock);
gen_connect(tcp, PortNr) ->
    gen_tcp:connect({127,0,0,1},
                    PortNr,
                    [binary,{active,true},{packet,0}]).

gen_listen(sctp) ->
    {ok,Sock} =
        gen_sctp:open([{ip,{127,0,0,1}},
                       {port,0},
                       binary,
                       {active,true},
                       {sctp_initmsg,
                        #sctp_initmsg{num_ostreams = 5,
                                      max_instreams = 5}}]),
    {gen_sctp:listen(Sock, true),Sock};
gen_listen(tcp) ->
    gen_tcp:listen(0,
                   [{ip,{127,0,0,1}},binary,{active,true},{packet,0}]).

gen_accept(sctp, Sock) ->
    Assoc =
        receive
            {sctp,
             Sock,
             _,
             _,
             {_,
              #sctp_assoc_change{state = comm_up,
                                 outbound_streams = O,
                                 inbound_streams = I,
                                 assoc_id = A}}} ->
                {O,I,A}
        end,
    putr(assoc, Assoc),
    {ok,Sock};
gen_accept(tcp, LSock) ->
    gen_tcp:accept(LSock).

gen_send(sctp, Sock, Bin) ->
    {OS,_IS,Id} = getr(assoc),
    {_,_,Us} = now(),
    gen_sctp:send(Sock, Id, Us rem OS, Bin);
gen_send(tcp, Sock, Bin) ->
    gen_tcp:send(Sock, Bin).

gen_recv(sctp, Sock) ->
    {_OS,_IS,Id} = getr(assoc),
    receive
        {sctp,Sock,_,_,{[#sctp_sndrcvinfo{assoc_id = Id}],Bin}} ->
            Bin
    end;
gen_recv(tcp, Sock) ->
    tcp_recv(Sock, <<>>).

tcp_recv(_, <<_:8,Len:24,_/binary>> = Bin) when Len =< size(Bin) ->
    Bin;
tcp_recv(Sock, B) ->
    receive
        {tcp,Sock,Bin} ->
            tcp_recv(Sock, <<B/binary,Bin/binary>>)
    end.

putr(Key, Val) ->
    put({diameter_transport_SUITE,Key}, Val).

getr(Key) ->
    get({diameter_transport_SUITE,Key}).



