-file("test/lib/kernel/src/gen_udp.erl", 1).

-module(gen_udp).

-export([open/1,open/2,close/1]).

-export([send/2,send/4,recv/2,recv/3,connect/3]).

-export([controlling_process/2]).

-export([fdopen/2]).

-file("test/lib/kernel/src/inet_int.hrl", 1).

-record(connect_opts,{ifaddr = any,port = 0,fd = - 1,opts = []}).

-record(listen_opts,{ifaddr = any,
                     port = 0,
                     backlog = 5,
                     fd = - 1,
                     opts = []}).

-record(udp_opts,{ifaddr = any,port = 0,fd = - 1,opts = [{active,true}]}).

-record(sctp_opts,{ifaddr,
                   port = 0,
                   fd = - 1,
                   type = seqpacket,
                   opts =
                       [{mode,binary},
                        {buffer,65536},
                        {sndbuf,65536},
                        {recbuf,1024},
                        {sctp_events,undefined}]}).

-file("test/lib/kernel/src/gen_udp.erl", 27).

-type option() :: {active, true | false | once}
                | {add_membership,
                   {inet:ip_address(), inet:ip_address()}}
                | {broadcast, boolean()}
                | {buffer, non_neg_integer()}
                | {deliver, port | term}
                | {dontroute, boolean()}
                | {drop_membership,
                   {inet:ip_address(), inet:ip_address()}}
                | {header, non_neg_integer()}
                | {high_msgq_watermark, pos_integer()}
                | {low_msgq_watermark, pos_integer()}
                | {mode, list | binary}
                | list
                | binary
                | {multicast_if, inet:ip_address()}
                | {multicast_loop, boolean()}
                | {multicast_ttl, non_neg_integer()}
                | {priority, non_neg_integer()}
                | {raw,
                   Protocol :: non_neg_integer(),
                   OptionNum :: non_neg_integer(),
                   ValueBin :: binary()}
                | {read_packets, non_neg_integer()}
                | {recbuf, non_neg_integer()}
                | {reuseaddr, boolean()}
                | {sndbuf, non_neg_integer()}
                | {tos, non_neg_integer()}
                | {ipv6_v6only, boolean()}.

-type option_name() :: active
                     | broadcast
                     | buffer
                     | deliver
                     | dontroute
                     | header
                     | high_msgq_watermark
                     | low_msgq_watermark
                     | mode
                     | multicast_if
                     | multicast_loop
                     | multicast_ttl
                     | priority
                     | {raw,
                        Protocol :: non_neg_integer(),
                        OptionNum :: non_neg_integer(),
                        ValueSpec :: (ValueSize :: non_neg_integer())
                                   | (ValueBin :: binary())}
                     | read_packets
                     | recbuf
                     | reuseaddr
                     | sndbuf
                     | tos
                     | ipv6_v6only.

-type socket() :: port().

-export_type([{option,0},{option_name,0}]).

-spec open(Port) -> {ok, Socket} | {error, Reason}
              when
                  is_subtype(Port, inet:port_number()),
                  is_subtype(Socket, socket()),
                  is_subtype(Reason, inet:posix()).

open(Port) ->
    open(Port, []).

-spec open(Port, Opts) -> {ok, Socket} | {error, Reason}
              when
                  is_subtype(Port, inet:port_number()),
                  is_subtype(Opts, [Option]),
                  is_subtype(Option,
                             {ip, inet:ip_address()} |
                             {fd, non_neg_integer()} |
                             {ifaddr, inet:ip_address()} |
                             inet:address_family() |
                             {port, inet:port_number()} |
                             option()),
                  is_subtype(Socket, socket()),
                  is_subtype(Reason, inet:posix()).

open(Port, Opts) ->
    Mod = mod(Opts, undefined),
    {ok,UP} = Mod:getserv(Port),
    Mod:open(UP, Opts).

-spec close(Socket) -> ok when is_subtype(Socket, socket()).

close(S) ->
    inet:udp_close(S).

-spec send(Socket, Address, Port, Packet) -> ok | {error, Reason}
              when
                  is_subtype(Socket, socket()),
                  is_subtype(Address,
                             inet:ip_address() | inet:hostname()),
                  is_subtype(Port, inet:port_number()),
                  is_subtype(Packet, iodata()),
                  is_subtype(Reason, not_owner | inet:posix()).

send(S, Address, Port, Packet) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            case Mod:getaddr(Address) of
                {ok,IP} ->
                    case Mod:getserv(Port) of
                        {ok,UP} ->
                            Mod:send(S, IP, UP, Packet);
                        {error,einval} ->
                            exit(badarg);
                        Error ->
                            Error
                    end;
                {error,einval} ->
                    exit(badarg);
                Error ->
                    Error
            end;
        Error ->
            Error
    end.

send(S, Packet) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:send(S, Packet);
        Error ->
            Error
    end.

-spec recv(Socket, Length) ->
              {ok, {Address, Port, Packet}} | {error, Reason}
              when
                  is_subtype(Socket, socket()),
                  is_subtype(Length, non_neg_integer()),
                  is_subtype(Address, inet:ip_address()),
                  is_subtype(Port, inet:port_number()),
                  is_subtype(Packet, string() | binary()),
                  is_subtype(Reason, not_owner | inet:posix()).

recv(S, Len) when is_port(S), is_integer(Len) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:recv(S, Len);
        Error ->
            Error
    end.

-spec recv(Socket, Length, Timeout) ->
              {ok, {Address, Port, Packet}} | {error, Reason}
              when
                  is_subtype(Socket, socket()),
                  is_subtype(Length, non_neg_integer()),
                  is_subtype(Timeout, timeout()),
                  is_subtype(Address, inet:ip_address()),
                  is_subtype(Port, inet:port_number()),
                  is_subtype(Packet, string() | binary()),
                  is_subtype(Reason, not_owner | inet:posix()).

recv(S, Len, Time) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            Mod:recv(S, Len, Time);
        Error ->
            Error
    end.

connect(S, Address, Port) when is_port(S) ->
    case inet_db:lookup_socket(S) of
        {ok,Mod} ->
            case Mod:getaddr(Address) of
                {ok,IP} ->
                    Mod:connect(S, IP, Port);
                Error ->
                    Error
            end;
        Error ->
            Error
    end.

-spec controlling_process(Socket, Pid) -> ok | {error, Reason}
                             when
                                 is_subtype(Socket, socket()),
                                 is_subtype(Pid, pid()),
                                 is_subtype(Reason,
                                            closed |
                                            not_owner |
                                            inet:posix()).

controlling_process(S, NewOwner) ->
    inet:udp_controlling_process(S, NewOwner).

fdopen(Fd, Opts) ->
    Mod = mod(Opts, undefined),
    Mod:fdopen(Fd, Opts).

mod(Address) ->
    case inet_db:udp_module() of
        inet_udp when tuple_size(Address) =:= 8 ->
            inet6_udp;
        Mod ->
            Mod
    end.

mod([{udp_module,Mod}|_], _Address) ->
    Mod;
mod([inet|_], _Address) ->
    inet_udp;
mod([inet6|_], _Address) ->
    inet6_udp;
mod([{ip,Address}|Opts], _) ->
    mod(Opts, Address);
mod([{ifaddr,Address}|Opts], _) ->
    mod(Opts, Address);
mod([_|Opts], Address) ->
    mod(Opts, Address);
mod([], Address) ->
    mod(Address).



