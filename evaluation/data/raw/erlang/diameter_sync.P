-file("test/lib/diameter/src/base/diameter_sync.erl", 1).

-module(diameter_sync).

-behaviour(gen_server).

-export([call/4,call/5,cast/4,cast/5,carp/1,carp/2]).

-export([start_link/0]).

-export([init/1,
         terminate/2,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         code_change/3]).

-export([state/0,uptime/0,flush/1,pending/0,pending/1,queues/0,pids/1]).

-file("test/lib/diameter/src/base/diameter_internal.hrl", 1).

-record(diameter_peer,{host_id,
                       statusT,
                       is_dynamic,
                       expiration,
                       tls_enabled}).

-record(diameter_realm,{name,
                        app_id,
                        local_action,
                        server_id,
                        is_dynamic,
                        expiration}).

-file("test/lib/diameter/src/base/diameter_sync.erl", 55).

-record(state,{time = now(),
               pending = 0 :: non_neg_integer(),
               monitor = new() :: ets:tid(),
               queue = new() :: ets:tid()}).

call(Name, Req, Max, Timeout) ->
    call(node(), Name, Req, Max, Timeout).

call(Node, Name, Req, Max, Timeout) ->
    gen_call({diameter_sync,Node}, {request,call,Name,Req,Max,Timeout}).

cast(Name, Req, Max, Timeout) ->
    cast(node(), Name, Req, Max, Timeout).

cast(Node, Name, Req, Max, Timeout) ->
    gen_call({diameter_sync,Node}, {request,cast,Name,Req,Max,Timeout}).

carp(Name) ->
    carp(node(), Name).

carp(Node, Name) ->
    gen_call({diameter_sync,Node}, {carp,Name}).

state() ->
    call(state).

uptime() ->
    call(uptime).

flush(Name) ->
    call({flush,Name}).

pending() ->
    call(pending).

pending(Name) ->
    call({pending,Name}).

queues() ->
    call(queues).

pids(Name) ->
    call({pids,Name}).

start_link() ->
    ServerName = {local,diameter_sync},
    Module = diameter_sync,
    Args = [],
    Options = [{spawn_opt,diameter_lib:spawn_opts(server, [])}],
    gen_server:start_link(ServerName, Module, Args, Options).

init(_) ->
    {ok,#state{}}.

handle_call({request,Type,Name,Req,Max,Timeout},
            From,
            #state{queue = QD} = State) ->
    T = find(Name, QD),
    nq(queued(T) =< Max, T, {Type,From}, Name, Req, Timeout, State);
handle_call(Request, From, State) ->
    {reply,call(Request, From, State),State}.

call({carp,Name}, _, #state{queue = QD}) ->
    pcar(find(Name, QD));
call(state, _, State) ->
    State;
call(uptime, _, #state{time = T}) ->
    diameter_lib:now_diff(T);
call({flush,Name}, _, #state{queue = QD}) ->
    cancel(find(Name, QD));
call(pending, _, #state{pending = N}) ->
    N;
call({pending,Name}, _, #state{queue = QD}) ->
    queued(find(Name, QD));
call(queues, _, #state{queue = QD}) ->
    fetch_keys(QD);
call({pids,Name}, _, #state{queue = QD}) ->
    plist(find(Name, QD));
call(Req, From, _State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_sync,handle_call,[Req,From]}),
    nok.

handle_cast(Msg, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_sync,
                                 element(2,
                                         element(2,
                                                 process_info(self(),
                                                              current_function))),
                                 [Msg]}),
    {noreply,State}.

handle_info(Request, State) ->
    {noreply,info(Request, State)}.

info({'DOWN',MRef,process,Pid,Info},
     #state{pending = N,monitor = MD,queue = QD} = State) ->
    {Name,From} = fetch(MRef, MD),
    reply(From, rc(Info)),
    State#state{pending = N - 1,
                monitor = erase(MRef, MD),
                queue = dq(fetch(Name, QD), Pid, Info, Name, QD)};
info(Info, State) ->
    diameter_lib:warning_report(unexpected,
                                {diameter_sync,handle_info,[Info]}),
    State.

reply({call,From}, T) ->
    gen_server:reply(From, T);
reply(cast, _) ->
    ok.

rc({value,T}) ->
    T;
rc(_) ->
    timeout.

code_change(_OldVsn, State, _Extra) ->
    {ok,State}.

terminate(_Reason, _State) ->
    ok.

queued({ok,{N,_}}) ->
    N;
queued(error) ->
    0.

nq(false, _, _, _Name, _Req, _Timeout, State) ->
    {reply,rejected,State};
nq(true,
   T,
   From,
   Name,
   Req,
   Timeout,
   #state{pending = N,monitor = MD,queue = QD} = State) ->
    Ref = make_ref(),
    Pid = init(Ref, Req, timeout(Timeout, T)),
    MRef = monitor(process, Pid),
    {noreply,
     State#state{pending = N + 1,
                 monitor = store(MRef, {Name,from(From)}, MD),
                 queue = store(Name, nq(T, {Pid,Ref}), QD)}}.

from({call,_} = T) ->
    T;
from({cast = T,From}) ->
    gen_server:reply(From, ok),
    T.

nq({ok,{N,Q}}, T) ->
    {N + 1,queue:in(T, Q)};
nq(error, T) ->
    go(T),
    {1,queue:from_list([T])}.

timeout(_, error) ->
    infinity;
timeout(Timeout, _) ->
    Timeout.

dq({N,Q}, Pid, _Info, Name, QD) ->
    {{value,T},TQ} = queue:out(Q),
    dq(N - 1, Pid, T, TQ, Name, QD).

dq(N, Pid, {Pid,_}, TQ, Name, QD) ->
    dq(N, TQ, Name, QD);
dq(N, Pid, T, TQ, Name, QD) ->
    store(Name, {N,req(Pid, queue:from_list([T]), TQ)}, QD).

dq(0, TQ, Name, QD) ->
    true = queue:is_empty(TQ),
    erase(Name, QD);
dq(N, TQ, Name, QD) ->
    go(queue:head(TQ)),
    store(Name, {N,TQ}, QD).

req(Pid, HQ, Q) ->
    {{value,T},TQ} = queue:out(Q),
    req(Pid, T, HQ, TQ).

req(Pid, {Pid,_}, HQ, TQ) ->
    queue:join(HQ, TQ);
req(Pid, T, HQ, TQ) ->
    req(Pid, queue:in(T, HQ), TQ).

go({Pid,Ref}) ->
    Pid ! {Ref,ok}.

init(Ref, Req, Timeout) ->
    spawn(fun() ->
                 exit(i(Ref, Req, Timeout))
          end).

i(Ref, Req, Timeout) ->
    Timer = send_timeout(Ref, Timeout),
    MRef = monitor(process, diameter_sync),
    receive
        {Ref,ok} ->
            cancel_timer(Timer),
            demonitor(MRef, [flush]),
            {value,eval(Req)};
        {Ref,timeout = T} ->
            T;
        {'DOWN',MRef,process,_Pid,_Info} = D ->
            D
    end.

send_timeout(_Ref, infinity = No) ->
    No;
send_timeout(Ref, Ms) ->
    Msg = {Ref,timeout},
    TRef = erlang:send_after(Ms, self(), Msg),
    {TRef,Msg}.

cancel_timer(infinity = No) ->
    No;
cancel_timer({TRef,Msg}) ->
    flush(Msg, erlang:cancel_timer(TRef)).

flush(Msg, false) ->
    ok =
        receive
            Msg ->
                ok
        after
            30000 -> error
        end;
flush(_, _) ->
    ok.

eval({M,F,A}) ->
    apply(M, F, A);
eval([Fun|Args]) ->
    apply(Fun, Args);
eval({Fun,A}) ->
    Fun(A);
eval(Fun) ->
    Fun().

pcar({ok,{_,Q}}) ->
    {Pid,_Ref} = queue:head(Q),
    {value,Pid};
pcar(error) ->
    false.

plist({ok,{_,Q}}) ->
    lists:map(fun({Pid,_Ref}) ->
                     Pid
              end,
              queue:to_list(Q));
plist(error) ->
    [].

cancel({ok,{N,Q}}) ->
    {_,TQ} = queue:split(1, Q),
    foreach(fun({Pid,Ref}) ->
                   Pid ! {Ref,timeout}
            end,
            N - 1,
            TQ),
    N - 1;
cancel(error) ->
    0.

foreach(_, 0, _) ->
    ok;
foreach(Fun, N, Q) ->
    Fun(queue:head(Q)),
    foreach(Fun, N - 1, queue:tail(Q)).

call(Request) ->
    try
        gen_server:call(diameter_sync, Request, 30000)
    catch
        exit:Reason ->
            {error,Reason}
    end.

erase(Key, Dict) ->
    ets:delete(Dict, Key),
    Dict.

fetch(Key, Dict) ->
    {ok,V} = find(Key, Dict),
    V.

fetch_keys(Dict) ->
    ets:foldl(fun({K,_}, Acc) ->
                     [K|Acc]
              end,
              [],
              Dict).

find(Key, Dict) ->
    case ets:lookup(Dict, Key) of
        [{Key,V}] ->
            {ok,V};
        [] ->
            error
    end.

new() ->
    ets:new(diameter_sync, [set]).

store(Key, Value, Dict) ->
    store({Key,Value}, Dict).

store({_,_} = T, Dict) ->
    ets:insert(Dict, T),
    Dict.

gen_call(Server, Req) ->
    gen_call(Server, Req, infinity).

gen_call(Server, Req, Timeout) ->
    try
        gen_server:call(Server, Req, Timeout)
    catch
        exit:_ ->
            timeout
    end.



