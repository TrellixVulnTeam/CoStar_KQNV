-file("test/lib/diameter/src/transport/diameter_sctp.erl", 1).

-module(diameter_sctp).

-behaviour(gen_server).

-export([start/3]).

-export([start_link/1]).

-export([init/1]).

-export([handle_call/3,
         handle_cast/2,
         handle_info/2,
         code_change/3,
         terminate/2]).

-export([info/1]).

-export([ports/0,ports/1]).

-export_type([{listen_option,0},{connect_option,0}]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/kernel-2.15.3/include/inet_sctp.hrl",
      1).

-record(sctp_initmsg,{num_ostreams,
                      max_instreams,
                      max_attempts,
                      max_init_timeo}).

-record(sctp_sndrcvinfo,{stream,
                         ssn,
                         flags,
                         ppid,
                         context,
                         timetolive,
                         tsn,
                         cumtsn,
                         assoc_id}).

-record(sctp_assoc_change,{state = cant_assoc,
                           error = 0,
                           outbound_streams = 0,
                           inbound_streams = 0,
                           assoc_id = 0}).

-record(sctp_paddr_change,{addr = [0,0,0,0],
                           state = addr_available,
                           error = 0,
                           assoc_id = 0}).

-record(sctp_remote_error,{error = 0,assoc_id = 0,data = []}).

-record(sctp_send_failed,{flags = false,
                          error = 0,
                          info = #sctp_sndrcvinfo{},
                          assoc_id = 0,
                          data = <<>>}).

-record(sctp_shutdown_event,{assoc_id = 0}).

-record(sctp_adaptation_event,{adaptation_ind = 0,assoc_id = 0}).

-record(sctp_pdapi_event,{indication = partial_delivery_aborted,
                          assoc_id = 0}).

-record(sctp_rtoinfo,{assoc_id,initial,max,min}).

-record(sctp_assocparams,{assoc_id,
                          asocmaxrxt,
                          number_peer_destinations,
                          peer_rwnd,
                          local_rwnd,
                          cookie_life}).

-record(sctp_prim,{assoc_id,addr}).

-record(sctp_setpeerprim,{assoc_id,addr}).

-record(sctp_setadaptation,{adaptation_ind}).

-record(sctp_paddrparams,{assoc_id,
                          address,
                          hbinterval,
                          pathmaxrxt,
                          pathmtu,
                          sackdelay,
                          flags}).

-record(sctp_event_subscribe,{data_io_event,
                              association_event,
                              address_event,
                              send_failure_event,
                              peer_error_event,
                              shutdown_event,
                              partial_delivery_event,
                              adaptation_layer_event,
                              authentication_event}).

-record(sctp_assoc_value,{assoc_id,assoc_value}).

-record(sctp_paddrinfo,{assoc_id,address,state,cwnd,srtt,rto,mtu}).

-record(sctp_status,{assoc_id,
                     state,
                     rwnd,
                     unackdata,
                     penddata,
                     instrms,
                     outstrms,
                     fragmentation_point,
                     primary}).

-file("test/lib/diameter/src/transport/diameter_sctp.erl", 49).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/diameter-1.3/include/diameter.hrl",
      1).

-record(diameter_event,{service,info}).

-record(diameter_packet,{header,avps,msg,bin,errors = [],transport_data}).

-record(diameter_header,{version,
                         length,
                         cmd_code,
                         application_id,
                         hop_by_hop_id,
                         end_to_end_id,
                         is_request,
                         is_proxiable,
                         is_error,
                         is_retransmitted}).

-record(diameter_avp,{code,
                      vendor_id,
                      is_mandatory = false,
                      need_encryption = false,
                      data,
                      name,
                      value,
                      type,
                      index}).

-record(diameter_caps,{origin_host,
                       origin_realm,
                       host_ip_address = [],
                       vendor_id,
                       product_name,
                       origin_state_id = [],
                       supported_vendor_id = [],
                       auth_application_id = [],
                       inband_security_id = [],
                       acct_application_id = [],
                       vendor_specific_application_id = [],
                       firmware_revision = [],
                       avp = []}).

-record(diameter_uri,{type,
                      fqdn,
                      port = 3868,
                      transport = sctp,
                      protocol = diameter}).

-record(diameter_callback,{peer_up,
                           peer_down,
                           pick_peer,
                           prepare_request,
                           prepare_retransmit,
                           handle_request,
                           handle_answer,
                           handle_error,
                           default,
                           extra = []}).

-record(diameter_service,{pid,capabilities,applications = []}).

-record(diameter_app,{alias,
                      dictionary,
                      module,
                      init_state,
                      id,
                      mutable = false,
                      options = [{answer_errors,report}]}).

-file("test/lib/diameter/src/transport/diameter_sctp.erl", 50).

-type connect_option() :: {raddr, inet:ip_address()}
                        | {rport, inet:port_number()}
                        | gen_sctp:open_option().

-type match() :: inet:ip_address() | string() | [match()].

-type listen_option() :: {accept, match()} | gen_sctp:open_option().

-type uint() :: non_neg_integer().

-record(transport,{parent :: undefined | pid(),
                   mode :: undefined
                         | {accept, pid()}
                         | accept
                         | {connect,
                            {[inet:ip_address()], uint(), list()}}
                         | connect,
                   socket :: undefined | gen_sctp:sctp_socket(),
                   assoc_id :: undefined | gen_sctp:assoc_id(),
                   peer :: undefined | {[inet:ip_address()], uint()},
                   streams :: undefined | {uint(), uint()},
                   os = 0 :: uint()}).

-record(listener,{ref :: undefined | reference(),
                  socket :: undefined | gen_sctp:sctp_socket(),
                  count = 0 :: uint(),
                  tmap = ets:new(diameter_sctp, []) :: ets:tid(),
                  pending = {0,ets:new(diameter_sctp, [ordered_set])},
                  tref :: undefined | reference(),
                  accept :: undefined | [match()]}).

-spec start({accept, Ref}, #diameter_service{}, [listen_option()]) ->
               {ok, pid(), [inet:ip_address()]}
               when is_subtype(Ref, diameter:transport_ref());
           ({connect, Ref}, #diameter_service{}, [connect_option()]) ->
               {ok, pid(), [inet:ip_address()]}
               when is_subtype(Ref, diameter:transport_ref()).

start(T, #diameter_service{capabilities = Caps}, Opts)
    when is_list(Opts) ->
    diameter_sctp_sup:start(),
    Addrs = Caps#diameter_caps.host_ip_address,
    s(T, Addrs, lists:map(fun ip/1, Opts)).

ip({ifaddr,A}) ->
    {ip,A};
ip(T) ->
    T.

s({accept,Ref} = A, Addrs, Opts) ->
    {LPid,LAs} = listener(Ref, {Opts,Addrs}),
    try gen_server:call(LPid, {A,self()}, infinity) of
        {ok,TPid} ->
            {ok,TPid,LAs}
    catch
        exit:Reason ->
            {error,Reason}
    end;
s({connect = C,Ref}, Addrs, Opts) ->
    diameter_sctp_sup:start_child({C,self(),Opts,Addrs,Ref}).

start_link(T) ->
    proc_lib:start_link(diameter_sctp,
                        init,
                        [T],
                        infinity,
                        diameter_lib:spawn_opts(server, [])).

info({gen_sctp,Sock}) ->
    lists:flatmap(fun(K) ->
                         info(K, Sock)
                  end,
                  [{socket,sockname},
                   {peer,peername},
                   {statistics,getstat}]).

info({K,F}, Sock) ->
    case inet:F(Sock) of
        {ok,V} ->
            [{K,V}];
        _ ->
            []
    end.

init(T) ->
    gen_server:enter_loop(diameter_sctp, [], i(T)).

i({listen,Ref,{Opts,Addrs}}) ->
    {[Matches],Rest} = proplists:split(Opts, [accept]),
    {LAs,Sock} = AS = open(Addrs, Rest, 3868),
    proc_lib:init_ack({ok,self(),LAs}),
    ok = gen_sctp:listen(Sock, true),
    true = diameter_reg:add_new({diameter_sctp,listener,{Ref,AS}}),
    start_timer(#listener{ref = Ref,
                          socket = Sock,
                          accept = accept(Matches)});
i({connect,Pid,Opts,Addrs,Ref}) ->
    {[As,Ps],Rest} = proplists:split(Opts, [raddr,rport]),
    RAs =
        [ 
         diameter_lib:ipaddr(A) ||
             {raddr,A} <- As
        ],
    [RP] =
        [ 
         P ||
             {rport,P} <- Ps
        ]
        ++
        [ 
         P ||
             P <- [3868],
             [] == Ps
        ],
    {LAs,Sock} = open(Addrs, Rest, 0),
    putr(ref, Ref),
    proc_lib:init_ack({ok,self(),LAs}),
    monitor(process, Pid),
    #transport{parent = Pid,
               mode = {connect,connect(Sock, RAs, RP, [])},
               socket = Sock};
i({accept,Pid,LPid,Sock,Ref}) when is_pid(Pid) ->
    putr(ref, Ref),
    proc_lib:init_ack({ok,self()}),
    monitor(process, Pid),
    monitor(process, LPid),
    #transport{parent = Pid,mode = {accept,LPid},socket = Sock};
i({accept,Ref,LPid,Sock,Id}) ->
    putr(ref, Ref),
    proc_lib:init_ack({ok,self()}),
    MRef = monitor(process, LPid),
    receive
        {Ref,Pid} ->
            #transport{parent = Pid,mode = {accept,LPid},socket = Sock};
        {'DOWN',MRef,process,_,_} = T ->
            close(Sock, Id),
            x(T)
    after
        5000 ->
            close(Sock, Id),
            x(timeout)
    end.

close(Sock, Id) ->
    gen_sctp:eof(Sock, #sctp_assoc_change{assoc_id = Id}).

listener(LRef, T) ->
    l(diameter_reg:match({diameter_sctp,listener,{LRef,'_'}}), LRef, T).

l([{{diameter_sctp,listener,{_,AS}},LPid}], _, _) ->
    {LAs,_Sock} = AS,
    {LPid,LAs};
l([], LRef, T) ->
    {ok,LPid,LAs} = diameter_sctp_sup:start_child({listen,LRef,T}),
    {LPid,LAs}.

open(Addrs, Opts, PortNr) ->
    {LAs,Os} = addrs(Addrs, Opts),
    {LAs,
     case gen_sctp:open(gen_opts(portnr(Os, PortNr))) of
         {ok,Sock} ->
             Sock;
         {error,Reason} ->
             x({open,Reason})
     end}.

addrs(Addrs, Opts) ->
    case proplists:split(Opts, [ip]) of
        {[[]],_} ->
            {Addrs,
             Opts
             ++
             [ 
              {ip,A} ||
                  A <- Addrs
             ]};
        {[As],Os} ->
            LAs =
                [ 
                 diameter_lib:ipaddr(A) ||
                     {ip,A} <- As
                ],
            {LAs,
             Os
             ++
             [ 
              {ip,A} ||
                  A <- LAs
             ]}
    end.

portnr(Opts, PortNr) ->
    case proplists:get_value(port, Opts) of
        undefined ->
            [{port,PortNr}|Opts];
        _ ->
            Opts
    end.

x(Reason) ->
    exit({shutdown,Reason}).

gen_opts(Opts) ->
    {L,_} = proplists:split(Opts, [binary,list,mode,active,sctp_events]),
    [[],[],[],[],[]] == L
    orelse
    error({{reserved_options,Opts},diameter_sctp,308}),
    [binary,{active,once}|Opts].

ports() ->
    Ts = diameter_reg:match({diameter_sctp,'_','_'}),
    [ 
     {type(T),N,Pid} ||
         {{diameter_sctp,T,{_,{_,S}}},Pid} <- Ts,
         {ok,N} <- [inet:port(S)]
    ].

ports(Ref) ->
    Ts = diameter_reg:match({diameter_sctp,'_',{Ref,'_'}}),
    [ 
     {type(T),N,Pid} ||
         {{diameter_sctp,T,{R,{_,S}}},Pid} <- Ts,
         R == Ref,
         {ok,N} <- [inet:port(S)]
    ].

type(listener) ->
    listen;
type(T) ->
    T.

handle_call({{accept,Ref},Pid}, _, #listener{ref = Ref,count = N} = S) ->
    {TPid,NewS} = accept(Ref, Pid, S),
    {reply,{ok,TPid},NewS#listener{count = N + 1}};
handle_call(T, From, {listener,_,_,_,_,_,_} = S) ->
    handle_call(T, From, upgrade(S));
handle_call(_, _, State) ->
    {reply,nok,State}.

handle_cast(_, State) ->
    {noreply,State}.

handle_info(T, #transport{} = S) ->
    {noreply,#transport{} = t(T, S)};
handle_info(T, #listener{} = S) ->
    {noreply,#listener{} = l(T, S)};
handle_info(T, {listener,_,_,_,_,_,_} = S) ->
    handle_info(T, upgrade(S)).

code_change(_, State, _) ->
    {ok,State}.

terminate(_, #transport{assoc_id = undefined}) ->
    ok;
terminate(_, #transport{socket = Sock,mode = accept,assoc_id = Id}) ->
    close(Sock, Id);
terminate(_, #transport{socket = Sock,mode = {accept,_},assoc_id = Id}) ->
    close(Sock, Id);
terminate(_, #transport{socket = Sock}) ->
    gen_sctp:close(Sock);
terminate(_, #listener{socket = Sock}) ->
    gen_sctp:close(Sock).

upgrade(S) ->
    #listener{} = erlang:append_element(S, []).

putr(Key, Val) ->
    put({diameter_sctp,Key}, Val).

getr(Key) ->
    get({diameter_sctp,Key}).

start_timer(#listener{count = 0} = S) ->
    S#listener{tref = erlang:start_timer(30000, self(), close)};
start_timer(S) ->
    S.

l({sctp,Sock,_RA,_RP,Data} = Msg, #listener{socket = Sock} = S) ->
    Id = assoc_id(Data),
    try find(Id, Data, S) of
        {TPid,NewS} ->
            TPid
            !
            {peeloff,peeloff(Sock, Id, TPid),Msg,S#listener.accept},
            NewS;
        false ->
            S
    after
        setopts(Sock)
    end;
l({send,AssocId,StreamId,Bin}, #listener{socket = Sock} = S) ->
    send(Sock, AssocId, StreamId, Bin),
    S;
l({'DOWN',MRef,process,TPid,_},
  #listener{pending = [TPid|Q],tmap = T,count = N} = S) ->
    ets:delete(T, MRef),
    ets:delete(T, TPid),
    start_timer(S#listener{count = N - 1,pending = Q});
l({'DOWN',_,process,_,_} = T, #listener{pending = [TPid|Q]} = S) ->
    #listener{pending = NQ} = NewS = l(T, S#listener{pending = Q}),
    NewS#listener{pending = [TPid|NQ]};
l({'DOWN',MRef,process,TPid,_},
  #listener{socket = Sock,tmap = T,count = N,pending = {P,Q}} = S) ->
    [{MRef,Id}] = ets:lookup(T, MRef),
    ets:delete(T, MRef),
    ets:delete(T, Id),
    Id == TPid
    orelse
    close(Sock, Id),
    case ets:lookup(Q, TPid) of
        [{TPid,_}] ->
            ets:delete(Q, TPid),
            S#listener{pending = {P - 1,Q}};
        [] ->
            start_timer(S#listener{count = N - 1})
    end;
l({timeout,TRef,close = T}, #listener{tref = TRef,count = 0}) ->
    x(T);
l({timeout,_,close}, #listener{} = S) ->
    S.

t(T, S) ->
    case transition(T, S) of
        ok ->
            S;
        #transport{} = NS ->
            NS;
        stop ->
            x(T)
    end.

transition({peeloff,Sock,{sctp,LSock,_RA,_RP,_Data} = Msg,Matches},
           #transport{mode = {accept,_},socket = LSock} = S) ->
    ok = accept_peer(Sock, Matches),
    transition(Msg, S#transport{socket = Sock});
transition({peeloff = T,_Sock,_Msg} = T, #transport{} = S) ->
    transition(erlang:append_element(T, []), S);
transition({sctp,_Sock,_RA,_RP,Data}, #transport{socket = Sock} = S) ->
    setopts(Sock),
    recv(Data, S);
transition({diameter,{send,Msg}}, S) ->
    send(Msg, S);
transition({diameter,{close,Pid}}, #transport{parent = Pid}) ->
    stop;
transition({diameter,{tls,_Ref,_Type,_Bool}}, _) ->
    stop;
transition({'DOWN',_,process,Pid,_}, #transport{parent = Pid}) ->
    stop;
transition({'DOWN',_,process,Pid,_}, #transport{mode = {accept,Pid}}) ->
    stop;
transition({'DOWN',_,process,_Pid,_}, #transport{mode = accept}) ->
    ok;
transition({resolve_port,Pid}, #transport{socket = Sock})
    when is_pid(Pid) ->
    Pid ! inet:port(Sock),
    ok.

ok({ok,T}) ->
    T;
ok(T) ->
    x(T).

accept_peer(_, []) ->
    ok;
accept_peer(Sock, Matches) ->
    {RAddrs,_} = ok(inet:peername(Sock)),
    diameter_peer:match(RAddrs, Matches)
    orelse
    x({accept,RAddrs,Matches}),
    ok.

accept(Opts) ->
    [ 
     [M] ||
         {accept,M} <- Opts
    ].

accept(Ref,
       Pid,
       #listener{socket = Sock,tmap = T,pending = {0,_} = Q} = S) ->
    Arg = {accept,Pid,self(),Sock,Ref},
    {ok,TPid} = diameter_sctp_sup:start_child(Arg),
    MRef = monitor(process, TPid),
    ets:insert(T, [{MRef,TPid},{TPid,MRef}]),
    {TPid,S#listener{pending = [TPid|Q]}};
accept(Ref, Pid, #listener{pending = [TPid|{0,_} = Q]} = S) ->
    false = is_process_alive(TPid),
    accept(Ref, Pid, S#listener{pending = Q});
accept(_, Pid, #listener{ref = Ref,pending = {N,Q}} = S) ->
    TPid = ets:first(Q),
    TPid ! {Ref,Pid},
    ets:delete(Q, TPid),
    {TPid,S#listener{pending = {N - 1,Q}}}.

send(#diameter_packet{bin = Bin,transport_data = {stream,SId}}, S) ->
    send(SId, Bin, S),
    S;
send(Bin, #transport{streams = {_,OS},os = N} = S) when is_binary(Bin) ->
    send(N, Bin, S),
    S#transport{os = (N + 1) rem OS}.

send(StreamId, Bin, #transport{socket = Sock,assoc_id = AId}) ->
    send(Sock, AId, StreamId, Bin).

send(Sock, AssocId, Stream, Bin) ->
    case gen_sctp:send(Sock, AssocId, Stream, Bin) of
        ok ->
            ok;
        {error,Reason} ->
            x({send,Reason})
    end.

recv({_,
      #sctp_assoc_change{state = comm_up,
                         outbound_streams = OS,
                         inbound_streams = IS,
                         assoc_id = Id}},
     #transport{assoc_id = undefined,mode = {T,_},socket = Sock} = S) ->
    Ref = getr(ref),
    publish(T, Ref, Id, Sock),
    up(S#transport{assoc_id = Id,streams = {IS,OS}});
recv({_,#sctp_assoc_change{} = E},
     #transport{assoc_id = undefined,
                socket = Sock,
                mode = {connect = C,{[RA|RAs],RP,Es}}} =
         S) ->
    S#transport{mode = {C,connect(Sock, RAs, RP, [{RA,E}|Es])}};
recv({_,#sctp_assoc_change{}}, _) ->
    stop;
recv({[#sctp_sndrcvinfo{stream = Id}],Bin}, #transport{parent = Pid})
    when is_binary(Bin) ->
    diameter_peer:recv(Pid,
                       #diameter_packet{transport_data = {stream,Id},
                                        bin = Bin}),
    ok;
recv({_,#sctp_shutdown_event{assoc_id = Id}}, #transport{assoc_id = Id}) ->
    stop;
recv({_,#sctp_paddr_change{}}, _) ->
    ok;
recv({_,#sctp_pdapi_event{}}, _) ->
    ok.

publish(T, Ref, Id, Sock) ->
    true = diameter_reg:add_new({diameter_sctp,T,{Ref,{Id,Sock}}}),
    putr(info, {gen_sctp,Sock}).

up(#transport{parent = Pid,mode = {connect = C,{[RA|_],RP,_}}} = S) ->
    diameter_peer:up(Pid, {RA,RP}),
    S#transport{mode = C};
up(#transport{parent = Pid,mode = {accept = A,_}} = S) ->
    diameter_peer:up(Pid),
    S#transport{mode = A}.

find(Id, Data, #listener{tmap = T} = S) ->
    f(ets:lookup(T, Id), Data, S).

f([],
  {_,#sctp_assoc_change{state = comm_up,assoc_id = Id}},
  #listener{tmap = T,pending = [TPid|{_,_} = Q]} = S) ->
    [{TPid,MRef}] = ets:lookup(T, TPid),
    ets:insert(T, [{MRef,Id},{Id,TPid}]),
    ets:delete(T, TPid),
    {TPid,S#listener{pending = Q}};
f([],
  {_,#sctp_assoc_change{state = comm_up,assoc_id = Id}},
  #listener{ref = Ref,socket = Sock,tmap = T,pending = {N,Q}} = S) ->
    Arg = {accept,Ref,self(),Sock,Id},
    {ok,TPid} = diameter_sctp_sup:start_child(Arg),
    MRef = monitor(process, TPid),
    ets:insert(T, [{MRef,Id},{Id,TPid}]),
    ets:insert(Q, {TPid,now()}),
    {TPid,S#listener{pending = {N + 1,Q}}};
f([{_,TPid}], _, S) ->
    {TPid,S};
f([], _, _) ->
    false.

assoc_id({[#sctp_sndrcvinfo{assoc_id = Id}],_}) ->
    Id;
assoc_id({_,Rec}) ->
    id(Rec).

id(#sctp_shutdown_event{assoc_id = Id}) ->
    Id;
id(#sctp_assoc_change{assoc_id = Id}) ->
    Id;
id(#sctp_sndrcvinfo{assoc_id = Id}) ->
    Id;
id(#sctp_paddr_change{assoc_id = Id}) ->
    Id;
id(#sctp_adaptation_event{assoc_id = Id}) ->
    Id.

peeloff(LSock, Id, TPid) ->
    {ok,Sock} = gen_sctp:peeloff(LSock, Id),
    ok = gen_sctp:controlling_process(Sock, TPid),
    Sock.

connect(_, [], _, Reasons) ->
    x({connect,lists:reverse(Reasons)});
connect(Sock, [Addr|AT] = As, Port, Reasons) ->
    case gen_sctp:connect_init(Sock, Addr, Port, []) of
        ok ->
            {As,Port,Reasons};
        {error,_} = E ->
            connect(Sock, AT, Port, [{Addr,E}|Reasons])
    end.

setopts(Sock) ->
    case inet:setopts(Sock, [{active,once}]) of
        ok ->
            ok;
        X ->
            x({setopts,Sock,X})
    end.



