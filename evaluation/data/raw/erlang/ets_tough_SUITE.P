-file("test/lib/stdlib/test/ets_tough_SUITE.erl", 1).

-module(ets_tough_SUITE).

-export([all/0,
         suite/0,
         groups/0,
         init_per_suite/1,
         end_per_suite/1,
         init_per_group/2,
         end_per_group/2,
         ex1/1]).

-export([init/1,terminate/2,handle_call/3,handle_info/2]).

-export([init_per_testcase/2,end_per_testcase/2]).

-compile([export_all]).

-file("/usr/local/Cellar/erlang/R15B03-1/lib/erlang/lib/test_server-3.5.3/include/test_server.hrl",
      1).

-file("test/lib/stdlib/test/ets_tough_SUITE.erl", 26).

suite() ->
    [{ct_hooks,[ts_install_cth]}].

all() ->
    [ex1].

groups() ->
    [].

init_per_suite(Config) ->
    Config.

end_per_suite(_Config) ->
    ok.

init_per_group(_GroupName, Config) ->
    Config.

end_per_group(_GroupName, Config) ->
    Config.

init_per_testcase(_Func, Config) ->
    Dog = test_server:timetrap(test_server:seconds(300)),
    [{watchdog,Dog}|Config].

end_per_testcase(_Func, Config) ->
    Dog = test_server:lookup_config(watchdog, Config),
    test_server:timetrap_cancel(Dog),
    ets:delete(ets_tough_SUITE_global_params).

ex1(Config) when is_list(Config) ->
    ets:new(ets_tough_SUITE_global_params, [named_table,public]),
    ets:insert(ets_tough_SUITE_global_params, {a,set}),
    ets:insert(ets_tough_SUITE_global_params, {b,set}),
    ex1_sub(Config),
    ets:insert(ets_tough_SUITE_global_params, {a,ordered_set}),
    ets:insert(ets_tough_SUITE_global_params, {b,set}),
    ex1_sub(Config),
    ets:insert(ets_tough_SUITE_global_params, {a,ordered_set}),
    ets:insert(ets_tough_SUITE_global_params, {b,ordered_set}),
    ex1_sub(Config).

ex1_sub(Config) ->
    {A,B} = prep(Config),
    N = case test_server:lookup_config(ets_tough_SUITE_iters, Config) of
            undefined ->
                5000;
            Other ->
                Other
        end,
    {NewA,NewB} = run({A,B}, N),
    _Gurkor = lists:keysearch(gurka, 1, ets:all()),
    catch stop(NewA),
    catch stop(NewB),
    ok.

prep(Config) ->
    random:seed(),
    put(dump_ticket, none),
    DumpDir =
        filename:join(test_server:lookup_config(priv_dir, Config),
                      "ets_tough"),
    file:make_dir(DumpDir),
    put(dump_dir, DumpDir),
    process_flag(trap_exit, true),
    {ok,A} = start(a),
    {ok,B} = start(b),
    {A,B}.

run({A,B}, N) ->
    run(A, B, 0, N).

run(A, B, N, N) ->
    {A,B};
run(A, B, N, M) ->
    eat_msgs(),
    Op = random_operation(),
    debug_disabled,
    case catch operate(Op, A, B) of
        {'EXIT',Reason} ->
            io:format("\nFAILURE on ~w: ~w, reason: ~w\n",
                      [N,Op,Reason]),
            exit(failed);
        {new_a,NewA} ->
            run(NewA, B, N + 1, M);
        _ ->
            run(A, B, N + 1, M)
    end.

eat_msgs() ->
    receive
        _Anything ->
            eat_msgs()
    after
        0 -> ok
    end.

operate(get, A, B) ->
    case random_key() of
        1 ->
            Class = random_class(),
            AnsA = lists:sort(dget_class(A, Class, all)),
            AnsB = lists:sort(dget_class(B, Class, all)),
            debug_disabled,
            AnsA = AnsB;
        _Other ->
            Class = random_class(),
            Key = random_key(),
            AnsA = dget(A, Class, Key),
            AnsB = dget(B, Class, Key),
            debug_disabled,
            AnsA = AnsB
    end;
operate(put, A, B) ->
    Class = random_class(),
    Key = random_key(),
    Value = random_value(),
    AnsA = dput(A, Class, Key, Value),
    AnsB = dput(B, Class, Key, Value),
    debug_disabled,
    AnsA = AnsB;
operate(erase, A, B) ->
    case random_key() of
        1 ->
            Class = random_class(),
            AnsA = derase_class(A, Class),
            AnsB = derase_class(B, Class),
            debug_disabled,
            AnsA = AnsB;
        _Other ->
            Class = random_class(),
            Key = random_key(),
            AnsA = derase(A, Class, Key),
            AnsB = derase(B, Class, Key),
            debug_disabled,
            AnsA = AnsB
    end;
operate(dirty_get, A, _B) ->
    Class = random_class(),
    Key = random_key(),
    AnsA = dget(A, Class, Key),
    AnsB = dirty_dget(b, Class, Key),
    debug_disabled,
    AnsA = AnsB;
operate(dump, A, _B) ->
    case get(dump_ticket) of
        {dump_more,Ticket} ->
            Units = random_key(),
            NewTicket = ddump_next(A, Units, Ticket),
            put(dump_ticket, NewTicket),
            _Result =
                case NewTicket of
                    done ->
                        done;
                    _ ->
                        dump_more
                end,
            debug_disabled;
        _ ->
            DumpDir = get(dump_dir),
            case random_key() of
                1 ->
                    debug_disabled,
                    NewTicket = ddump_first(A, DumpDir),
                    put(dump_ticket, NewTicket);
                2 ->
                    debug_disabled,
                    {dump_more,NewTicket} = ddump_first(A, DumpDir),
                    done = ddump_next(A, 1000000, NewTicket),
                    stop(A),
                    {ok,NewA} = start(a, DumpDir),
                    {new_a,NewA};
                _ ->
                    debug_disabled,
                    ok
            end
    end.

random_operation() ->
    Ops = {get,put,erase,dirty_get,dump},
    random_element(Ops).

random_class() ->
    Classes = {foo,bar,tomat,gurka},
    random_element(Classes).

random_key() ->
    random:uniform(8).

random_value() ->
    case random:uniform(5) of
        1 ->
            ok;
        2 ->
            {data,random_key()};
        3 ->
            {foo,bar,random_class()};
        4 ->
            random:uniform(1000);
        5 ->
            {recursive,random_value()}
    end.

random_element(T) ->
    I = random:uniform(tuple_size(T)),
    element(I, T).

show_table(N) ->
    FileName = ["etsdump.",integer_to_list(N)],
    case file:open(FileName, read) of
        {ok,Fd} ->
            show_entries(Fd);
        _ ->
            error
    end.

show_entries(Fd) ->
    case phys_read_len(Fd) of
        {ok,Len} ->
            case phys_read_entry(Fd, Len) of
                {ok,ok} ->
                    ok;
                {ok,{Key,Val}} ->
                    io:format("~w\n", [{Key,Val}]),
                    show_entries(Fd);
                _ ->
                    error
            end;
        _ ->
            error
    end.

start(DbName) ->
    case
        gen_server:start_link(ets_tough_SUITE, {DbName,no_dump_dir}, [])
    of
        {ok,Pid} when is_pid(Pid) ->
            {ok,Pid};
        Other ->
            Other
    end.

start(DbName, DumpDir) ->
    case
        gen_server:start_link(ets_tough_SUITE,
                              {DbName,{dump_dir,DumpDir}},
                              [])
    of
        {ok,Pid} when is_pid(Pid) ->
            {ok,Pid};
        Other ->
            Other
    end.

stop(ServerPid) ->
    gen_server:call(ServerPid, stop).

dget(ServerPid, Class, Key) ->
    gen_server:call(ServerPid, {handle_lookup,Class,Key}).

dirty_dget(DbName, Class, Key) ->
    Admin = admin_table_name(DbName),
    case catch ets:lookup(Admin, Class) of
        [{_Class,[Tab|_Tabs]}] ->
            case ets:lookup(Tab, Key) of
                [{_Key,Value}] ->
                    {value,Value};
                _ ->
                    undefined
            end;
        _ ->
            undefined
    end.

dput(ServerPid, Class, Key, Value) ->
    gen_server:call(ServerPid, {handle_insert,Class,Key,Value}).

derase(ServerPid, Class, Key) ->
    gen_server:call(ServerPid, {handle_delete,Class,Key}).

dget_class(ServerPid, Class, Condition) ->
    gen_server:call(ServerPid,
                    {handle_get_class,Class,Condition},
                    infinity).

derase_class(ServerPid, Class) ->
    gen_server:call(ServerPid, {handle_delete_class,Class}, infinity).

dmodify(ServerPid, Application) ->
    gen_server:call(ServerPid, {handle_dmodify,Application}, infinity).

ddump_first(ServerPid, DumpDir) ->
    gen_server:call(ServerPid, {handle_dump_first,DumpDir}, infinity).

ddump_next(ServerPid, Count, Ticket) ->
    gen_server:call(ServerPid, {handle_dump_next,Ticket,Count}, 150000).

init({DbName,DumpDir}) ->
    case DumpDir of
        no_dump_dir ->
            Admin = make_admin_table(DbName),
            ets:insert(Admin, {{'$list_of_classes'},[]}),
            init2(DbName, Admin);
        {dump_dir,Dir} ->
            case load_dump(DbName, Dir) of
                {ok,Admin} ->
                    ets:insert(Admin, {{'$dump_directory'},Dir}),
                    init2(DbName, Admin);
                _ ->
                    cant_load_dump
            end
    end.

init2(DbName, Admin) ->
    ets:insert(Admin, {{'$dumping_flag'},false}),
    ets:insert(Admin, {{'$db_name'},DbName}),
    {ok,Admin}.

terminate(_Reason, _Admin) ->
    ok.

handle_call({handle_lookup,Class,Key}, _From, Admin) ->
    Reply =
        case ets:lookup(Admin, Class) of
            [] ->
                undefined;
            [{_,TabList}] ->
                {_,Ans} = table_lookup(TabList, Key),
                Ans
        end,
    {reply,Reply,Admin};
handle_call({handle_insert,Class,Key,Value}, _From, Admin) ->
    Reply =
        case ets:lookup(Admin, Class) of
            [] ->
                Mtab = make_db_table(db_name(Admin), Class),
                ets:insert(Admin, {Class,[Mtab]}),
                [{_,Classes}] = ets:lookup(Admin, {'$list_of_classes'}),
                ets:insert(Admin,
                           {{'$list_of_classes'},[Class|Classes]}),
                ets:insert(Mtab, {Key,Value}),
                undefined;
            [{_,[Tab|Tabs]}] ->
                {_,Old} = table_lookup([Tab|Tabs], Key),
                ets:insert(Tab, {Key,Value}),
                Old
        end,
    {reply,Reply,Admin};
handle_call({handle_delete,Class,Key}, _From, Admin) ->
    Reply =
        case ets:lookup(Admin, Class) of
            [] ->
                undefined;
            [{_,[Tab]}] ->
                {_,Old} = table_lookup(Tab, Key),
                ets:delete(Tab, Key),
                Old;
            [{_,[Tab|Tabs]}] ->
                {_,Old} = table_lookup([Tab|Tabs], Key),
                ets:insert(Tab, {{{{'$erased'},Key}},erased}),
                ets:delete(Tab, Key),
                Old
        end,
    {reply,Reply,Admin};
handle_call({handle_get_class,Class,Cond}, _From, Admin) ->
    Reply =
        case ets:lookup(Admin, Class) of
            [] ->
                [];
            [{_,TabList}] ->
                table_lookup_batch(TabList, Class, Cond)
        end,
    {reply,Reply,Admin};
handle_call({handle_delete_class,Class}, _From, Admin) ->
    Reply =
        case ets:lookup(Admin, Class) of
            [] ->
                ok;
            [{_,[Tab|_Tabs]}] ->
                ets:delete(Tab),
                [{_,Classes}] = ets:lookup(Admin, {'$list_of_classes'}),
                NewClasses = lists:delete(Class, Classes),
                ets:insert(Admin, {{'$list_of_classes'},NewClasses}),
                ets:delete(Admin, Class),
                ok
        end,
    {reply,Reply,Admin};
handle_call({handle_dmodify,Application}, _From, Admin) ->
    [{_,Classes}] = ets:lookup(Admin, {'$list_of_classes'}),
    modify(Application, Classes, Admin),
    {reply,ok,Admin};
handle_call({handle_dump_first,DumpDir}, _From, Admin) ->
    case ets:lookup(Admin, {'$dumping_flag'}) of
        [{_,true}] ->
            {reply,already_dumping,Admin};
        _ ->
            phys_remove_ok(DumpDir),
            [{_,Classes}] = ets:lookup(Admin, {'$list_of_classes'}),
            Tables = dump_prepare_classes(Classes, Admin),
            ets:insert(Admin, {{'$dumping_flag'},true}),
            ets:insert(Admin, {{'$dump_directory'},DumpDir}),
            handle_dump_next({[{admin,Classes}|Tables]}, 0, Admin)
    end;
handle_call({handle_dump_next,Ticket,Count}, _From, Admin) ->
    handle_dump_next(Ticket, Count, Admin);
handle_call(stop, _From, Admin) ->
    ets:delete(Admin),
    {stop,normal,ok,[]}.

handle_info({'EXIT',_Pid,_Reason}, Admin) ->
    {stop,normal,Admin}.

handle_delete(Class, Key, Admin) ->
    handle_call({handle_delete,Class,Key}, from, Admin).

handle_insert(Class, Key, Value, Admin) ->
    handle_call({handle_insert,Class,Key,Value}, from, Admin).

handle_lookup(Class, Key, Admin) ->
    handle_call({handle_lookup,Class,Key}, from, Admin).

handle_dump_next({[]}, _Count, Admin) ->
    [{_Key,DumpDir}] = ets:lookup(Admin, {'$dump_directory'}),
    phys_ok_dump(DumpDir),
    ets:insert(Admin, {{'$dumping_flag'},false}),
    {reply,done,Admin};
handle_dump_next(Ticket, 0, Admin) ->
    {reply,{dump_more,Ticket},Admin};
handle_dump_next({[{admin,Classes}|Tables]}, Count, Admin) ->
    [{_Key,DumpDir}] = ets:lookup(Admin, {'$dump_directory'}),
    DumpData = phys_init_dump(admin, DumpDir, 0),
    phys_dump({{'$list_of_classes'},Classes}, DumpData),
    phys_finish_dump(DumpData),
    handle_dump_next({Tables}, Count - 1, Admin);
handle_dump_next({[{Class,Mtab}|Tables]}, Count, Admin) ->
    debug_disabled,
    [{_Key,DumpDir}] = ets:lookup(Admin, {'$dump_directory'}),
    DumpData = phys_init_dump(Class, DumpDir, length(Tables) + 1),
    First = ets:first(Mtab),
    handle_dump_next({Class,Tables,Mtab,First,DumpData}, Count, Admin);
handle_dump_next({Class,Tables,Stab,'$end_of_table',DumpData},
                 Count,
                 Admin) ->
    phys_finish_dump(DumpData),
    debug_disabled,
    case ets:lookup(Admin, Class) of
        [{Key,[Utab,Mtab]}] ->
            Ttab = make_db_table(db_name(Admin), Class),
            ets:insert(Admin, {Key,[Ttab,Utab,Mtab]}),
            First = ets:first(Utab),
            handle_dump_next({3,Class,Tables,Utab,First,Mtab},
                             Count,
                             Admin);
        _Other ->
            ets:delete(Stab),
            handle_dump_next({Tables}, Count, Admin)
    end;
handle_dump_next({Class,Tables,Tab,Key,DumpData}, Count, Admin) ->
    [KeyVal] = ets:lookup(Tab, Key),
    phys_dump(KeyVal, DumpData),
    NextKey = ets:next(Tab, Key),
    handle_dump_next({Class,Tables,Tab,NextKey,DumpData},
                     Count - 1,
                     Admin);
handle_dump_next({3,Class,Tables,Stab,'$end_of_table',Dtab},
                 Count,
                 Admin) ->
    case ets:lookup(Admin, Class) of
        [{Key,[Ttab,Utab,Mtab]}] ->
            case ets:info(Ttab, size) of
                0 ->
                    ets:insert(Admin, {Key,[Mtab]}),
                    ets:delete(Ttab),
                    ets:delete(Utab),
                    handle_dump_next({Tables}, Count, Admin);
                _Work ->
                    debug_disabled,
                    ets:delete(Utab),
                    Ntab = make_db_table(db_name(Admin), Class),
                    ets:insert(Admin, {Key,[Ntab,Ttab,Mtab]}),
                    First = ets:first(Ttab),
                    handle_dump_next({3,Class,Tables,Ttab,First,Mtab},
                                     Count,
                                     Admin)
            end;
        _Other ->
            ets:delete(Stab),
            ets:delete(Dtab),
            handle_dump_next({Tables}, Count, Admin)
    end;
handle_dump_next({3,Class,Tables,Stab,Key,Dtab}, Count, Admin) ->
    copy_dump_entry(Stab, Key, Dtab),
    NextKey = ets:next(Stab, Key),
    handle_dump_next({3,Class,Tables,Stab,NextKey,Dtab},
                     Count - 1,
                     Admin).

admin_table_name(DbName) ->
    list_to_atom(lists:append(atom_to_list(DbName), "#admin")).

make_admin_table(DbName) ->
    ets:new(admin_table_name(DbName),
            [named_table,protected,db_type(DbName)]).

make_db_table(DbName, Name) ->
    ets:new(Name, [protected,db_type(DbName)]).

db_name(Admin) ->
    ets:lookup_element(Admin, {'$db_name'}, 2).

db_type(DbName) ->
    case ets:lookup(ets_tough_SUITE_global_params, DbName) of
        [] ->
            set;
        [{DbName,X}] ->
            X
    end.

table_lookup([], _Key) ->
    {undef,undefined};
table_lookup([Table|Tables], Key) ->
    case table_lookup(Table, Key) of
        {_,undefined} ->
            case ets:lookup(Table, {{{'$erased'},Key}}) of
                [] ->
                    table_lookup(Tables, Key);
                _Definition ->
                    {erased,undefined}
            end;
        Answer ->
            Answer
    end;
table_lookup(Table, Key) ->
    case ets:lookup(Table, Key) of
        [] ->
            {undef,undefined};
        [{_Key,Value}] ->
            {def,{value,Value}}
    end.

table_lookup_batch([], _Class, _Cond) ->
    [];
table_lookup_batch([Table|Tables], Class, Cond) ->
    table_lookup_batch([],
                       Tables,
                       Table,
                       ets:first(Table),
                       Class,
                       Cond,
                       []).

table_lookup_batch(_Passed, [], _, '$end_of_table', _Class, _Cond, Ack) ->
    Ack;
table_lookup_batch(Passed,
                   [NewTable|Tables],
                   Table,
                   '$end_of_table',
                   Class,
                   Cond,
                   Ack) ->
    table_lookup_batch(lists:append(Passed, [Table]),
                       Tables,
                       NewTable,
                       ets:first(NewTable),
                       Class,
                       Cond,
                       Ack);
table_lookup_batch(Passed,
                   Tables,
                   Table,
                   {{{'$erased'},Key}},
                   Class,
                   Cond,
                   Ack) ->
    table_lookup_batch(Passed,
                       Tables,
                       Table,
                       ets:next(Table, {{{'$erased'},Key}}),
                       Class,
                       Cond,
                       Ack);
table_lookup_batch(Passed, Tables, Table, Key, Class, Cond, Ack) ->
    NewAck =
        case table_lookup(Passed, Key) of
            {undef,undefined} ->
                [{_Key,Value}] = ets:lookup(Table, Key),
                case Cond of
                    all ->
                        [Key|Ack];
                    {M,F,A} ->
                        case apply(M, F, [{{Class,Key},Value}|A]) of
                            {true,Key} ->
                                [Key|Ack];
                            false ->
                                Ack
                        end
                end;
            _Other ->
                Ack
        end,
    table_lookup_batch(Passed,
                       Tables,
                       Table,
                       ets:next(Table, Key),
                       Class,
                       Cond,
                       NewAck).

modify(_Application, [], _Admin) ->
    ok;
modify(Application, [Class|Classes], Admin) ->
    debug_disabled,
    [{_,Tables}] = ets:lookup(Admin, Class),
    modify_class(Application,
                 Class,
                 table_lookup_batch(Tables, Class, all),
                 Admin),
    modify(Application, Classes, Admin).

modify_class(_Application, _Class, [], _Admin) ->
    ok;
modify_class({Mod,Fun,ExtraArgs}, Class, [Key|Keys], Admin) ->
    {ok,{{value,Value},_Admin}} = handle_lookup(Class, Key, Admin),
    case apply(Mod, Fun, [{{Class,Key},Value}|ExtraArgs]) of
        {ok,{{NewClass,NewKey},NewValue}} ->
            handle_delete(Class, Key, Admin),
            handle_insert(NewClass, NewKey, NewValue, Admin);
        true ->
            ok;
        false ->
            handle_delete(Class, Key, Admin)
    end,
    modify_class({Mod,Fun,ExtraArgs}, Class, Keys, Admin).

dump_prepare_classes(Classes, Admin) ->
    debug_disabled,
    dump_prepare_classes(Classes, Admin, []).

dump_prepare_classes([], _Admin, Ack) ->
    Ack;
dump_prepare_classes([Class|Classes], Admin, Ack) ->
    [{_Class,[Mtab]}] = ets:lookup(Admin, Class),
    Ttab = make_db_table(db_name(Admin), Class),
    ets:insert(Admin, {Class,[Ttab,Mtab]}),
    dump_prepare_classes(Classes,
                         Admin,
                         lists:append(Ack, [{Class,Mtab}])).

copy_dump_entry(Stab, Key, Dtab) ->
    debug_disabled,
    case ets:lookup(Stab, Key) of
        [{{{{'$erased'},RealKey}},_}] ->
            case ets:lookup(Stab, RealKey) of
                [] ->
                    debug_disabled,
                    ets:delete(Dtab, RealKey);
                _Definition ->
                    ok
            end;
        [KeyVal] ->
            debug_disabled,
            ets:insert(Dtab, KeyVal)
    end.

load_dump(DbName, DumpDir) ->
    case phys_load_dump_ok(DumpDir) of
        ok ->
            Admin = make_admin_table(DbName),
            ets:insert(Admin, {{'$db_name'},DbName}),
            case phys_load_table(DumpDir, 0, Admin) of
                ok ->
                    load_dump2(DumpDir, Admin);
                Other ->
                    load_dump_failed(Admin, []),
                    {error,{load_dump1,Other}}
            end;
        Other ->
            {error,{load_dump2,Other}}
    end.

load_dump2(DumpDir, Admin) ->
    case ets:lookup(Admin, {'$list_of_classes'}) of
        [{_Key,Classes}] ->
            case load_dump_tables(DumpDir, Admin, Classes) of
                ok ->
                    {ok,Admin};
                Other ->
                    io:format("Dumping failed: ~p\n", [Other]),
                    load_dump_failed(Admin, Classes)
            end;
        Other ->
            io:format("Dumping failed2: ~p\n", [Other]),
            load_dump_failed(Admin, [])
    end.

load_dump_failed(Admin, []) ->
    ets:delete(Admin),
    {error,load_dump_failed};
load_dump_failed(Admin, [Class|Classes]) ->
    case ets:lookup(Admin, Class) of
        [{_Key,[Tab]}] ->
            ets:delete(Tab);
        _ ->
            ok
    end,
    load_dump_failed(Admin, Classes).

load_dump_tables(_DumpDir, _Admin, []) ->
    ok;
load_dump_tables(DumpDir, Admin, [Class|Classes]) ->
    Mtab = make_db_table(db_name(Admin), Class),
    ets:insert(Admin, {Class,[Mtab]}),
    Num = length(Classes) + 1,
    case phys_load_table(DumpDir, Num, Mtab) of
        ok ->
            load_dump_tables(DumpDir, Admin, Classes);
        Other ->
            {error,{load_dump_failed,Other}}
    end.

phys_init_dump(Class, DumpDir, Num) ->
    debug_disabled,
    FileName = [DumpDir,"/etsdump.",integer_to_list(Num)],
    {tag1,{ok,Fd}} = {tag1,file:open(FileName, write)},
    {Class,Fd}.

phys_finish_dump({_Class,Fd}) ->
    debug_disabled,
    phys_dump_term(Fd, ok),
    file:close(Fd),
    ok.

phys_dump({Key,Val}, {_Class,Fd}) ->
    debug_disabled,
    phys_dump_term(Fd, {Key,Val}),
    ok.

phys_dump_term(Fd, Term) ->
    Bin = binary_to_list(term_to_binary(Term)),
    {tag2,ok} = {tag2,io:put_chars(Fd, encode32(length(Bin)))},
    {tag3,ok} = {tag3,io:put_chars(Fd, Bin)}.

phys_ok_dump(DumpDir) ->
    debug_disabled,
    FileName = [DumpDir,"/ok"],
    {tag4,{ok,Fd}} = {tag4,file:open(FileName, write)},
    {tag5,ok} = {tag5,io:format(Fd, "ok.\n", [])},
    file:close(Fd),
    ok.

phys_remove_ok(DumpDir) ->
    debug_disabled,
    FileName = [DumpDir,"/ok"],
    file:delete(FileName),
    ok.

phys_load_dump_ok(DumpDir) ->
    FileName = [DumpDir,"/ok"],
    case file:consult(FileName) of
        {ok,[ok]} ->
            ok;
        Other ->
            {error,{consult_error,Other}}
    end.

phys_load_table(DumpDir, N, Tab) ->
    debug_disabled,
    FileName = [DumpDir,"/etsdump.",integer_to_list(N)],
    case file:open(FileName, read) of
        {ok,Fd} ->
            phys_load_entries(Fd, Tab);
        Other ->
            {error,{open_error,Other}}
    end.

phys_load_entries(Fd, Tab) ->
    case phys_read_len(Fd) of
        {ok,Len} ->
            case phys_read_entry(Fd, Len) of
                {ok,ok} ->
                    ok;
                {ok,{Key,Val}} ->
                    ets:insert(Tab, {Key,Val}),
                    phys_load_entries(Fd, Tab);
                Other ->
                    {error,{read_len,Other}}
            end;
        Other ->
            {error,{read_len2,Other}}
    end.

phys_read_len(Fd) ->
    case io:get_chars(Fd, '', 4) of
        [A,B,C,D] ->
            {ok,decode32(A, B, C, D)};
        Other ->
            {error,{decode,Other}}
    end.

phys_read_entry(Fd, Len) ->
    case io:get_chars(Fd, '', Len) of
        L when is_list(L), length(L) == Len ->
            {ok,binary_to_term(list_to_binary(L))};
        Other ->
            {error,{read_term,Other}}
    end.

encode32(N) ->
    [(N bsr 24) band 255,
     (N bsr 16) band 255,
     (N bsr 8) band 255,
     N band 255].

decode32(A, B, C, D) ->
    A bsl 24 bor (B bsl 16) bor (C bsl 8) bor D.



