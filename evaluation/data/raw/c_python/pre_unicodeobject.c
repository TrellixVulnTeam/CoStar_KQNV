# 1 "unicodeobject.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "unicodeobject.c"
# 42 "unicodeobject.c"
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 1






# 1 "/Users/parrt/tmp/Python-3.3.1/Include/patchlevel.h" 1
# 8 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/pyconfig.h" 1
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pymacconfig.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Developer/usr/llvm-gcc-4.2/lib/gcc/i686-apple-darwin11/4.2.1/include/limits.h" 1 3 4






# 1 "/Developer/usr/llvm-gcc-4.2/lib/gcc/i686-apple-darwin11/4.2.1/include/syslimits.h" 1 3 4
# 8 "/Developer/usr/llvm-gcc-4.2/lib/gcc/i686-apple-darwin11/4.2.1/include/limits.h" 2 3 4







# 1 "/usr/include/limits.h" 1 3 4
# 63 "/usr/include/limits.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 417 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 418 "/usr/include/sys/cdefs.h" 2 3 4
# 494 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_posix_availability.h" 1 3 4
# 495 "/usr/include/sys/cdefs.h" 2 3 4
# 64 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/machine/limits.h" 1 3 4





# 1 "/usr/include/i386/limits.h" 1 3 4
# 40 "/usr/include/i386/limits.h" 3 4
# 1 "/usr/include/i386/_limits.h" 1 3 4
# 41 "/usr/include/i386/limits.h" 2 3 4
# 7 "/usr/include/machine/limits.h" 2 3 4
# 65 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
# 66 "/usr/include/limits.h" 2 3 4
# 16 "/Developer/usr/llvm-gcc-4.2/lib/gcc/i686-apple-darwin11/4.2.1/include/limits.h" 2 3 4
# 12 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 25 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 65 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/Availability.h" 1 3 4
# 141 "/usr/include/Availability.h" 3 4
# 1 "/usr/include/AvailabilityInternal.h" 1 3 4
# 142 "/usr/include/Availability.h" 2 3 4
# 66 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/_types.h" 1 3 4
# 27 "/usr/include/_types.h" 3 4
# 1 "/usr/include/sys/_types.h" 1 3 4
# 33 "/usr/include/sys/_types.h" 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
# 32 "/usr/include/machine/_types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 37 "/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;





typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4
# 58 "/usr/include/sys/_types.h" 3 4
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[1168]; };
# 94 "/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
# 28 "/usr/include/_types.h" 2 3 4
# 39 "/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 68 "/usr/include/stdio.h" 2 3 4





typedef __darwin_va_list va_list;




typedef __darwin_size_t size_t;






typedef __darwin_off_t fpos_t;
# 96 "/usr/include/stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 130 "/usr/include/stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;


extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;

# 238 "/usr/include/stdio.h" 3 4

void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);

FILE *fopen(const char * , const char * ) __asm("_" "fopen" "$DARWIN_EXTSN");



int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));

# 296 "/usr/include/stdio.h" 3 4




char *ctermid(char *);



FILE *fdopen(int, const char *) __asm("_" "fdopen" "$DARWIN_EXTSN");



int fileno(FILE *);

# 318 "/usr/include/stdio.h" 3 4

int pclose(FILE *);

FILE *popen(const char *, const char *) __asm("_" "popen" "$DARWIN_EXTSN");




# 340 "/usr/include/stdio.h" 3 4

int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);








static __inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 377 "/usr/include/stdio.h" 3 4

void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


char *tempnam(const char *, const char *) __asm("_" "tempnam" );

# 414 "/usr/include/stdio.h" 3 4
typedef __darwin_off_t off_t;



int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);





int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));

# 442 "/usr/include/stdio.h" 3 4
typedef __darwin_ssize_t ssize_t;



int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((visibility("default")));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((visibility("default")));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((visibility("default")));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((visibility("default")));









extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char **, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));

# 499 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/secure/_stdio.h" 1 3 4
# 31 "/usr/include/secure/_stdio.h" 3 4
# 1 "/usr/include/secure/_common.h" 1 3 4
# 32 "/usr/include/secure/_stdio.h" 2 3 4
# 45 "/usr/include/secure/_stdio.h" 3 4
extern int __sprintf_chk (char * , int, size_t,
     const char * , ...)
  ;




extern int __snprintf_chk (char * , size_t, int, size_t,
      const char * , ...)
  ;





extern int __vsprintf_chk (char * , int, size_t,
      const char * , va_list)
  ;




extern int __vsnprintf_chk (char * , size_t, int, size_t,
       const char * , va_list)
  ;
# 500 "/usr/include/stdio.h" 2 3 4
# 26 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2




# 1 "/usr/include/string.h" 1 3 4
# 79 "/usr/include/string.h" 3 4

void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" );
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);

# 113 "/usr/include/string.h" 3 4

char *strtok_r(char *, const char *, char **);

# 125 "/usr/include/string.h" 3 4

int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);

# 139 "/usr/include/string.h" 3 4

char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((visibility("default")));
char *strndup(const char *, size_t) __attribute__((visibility("default")));
size_t strnlen(const char *, size_t) __attribute__((visibility("default")));
char *strsignal(int sig);

# 158 "/usr/include/string.h" 3 4

void *memmem(const void *, size_t, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern4(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern8(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern16(void *, const void *, size_t) __attribute__((visibility("default")));

char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);


void swab(const void * , void * , ssize_t);







# 1 "/usr/include/strings.h" 1 3 4
# 71 "/usr/include/strings.h" 3 4



int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);





int ffsl(long) __attribute__((visibility("default")));
int fls(int) __attribute__((visibility("default")));
int flsl(long) __attribute__((visibility("default")));


# 1 "/usr/include/string.h" 1 3 4
# 95 "/usr/include/strings.h" 2 3 4
# 181 "/usr/include/string.h" 2 3 4
# 190 "/usr/include/string.h" 3 4
# 1 "/usr/include/secure/_string.h" 1 3 4
# 58 "/usr/include/secure/_string.h" 3 4
static __inline void *
__inline_memcpy_chk (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}






static __inline void *
__inline_memmove_chk (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}






static __inline void *
__inline_memset_chk (void *__dest, int __val, size_t __len)
{
  return __builtin___memset_chk (__dest, __val, __len, __builtin_object_size (__dest, 0));
}






static __inline char *
__inline_strcpy_chk (char * __dest, const char * __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}







static __inline char *
__inline_stpcpy_chk (char *__dest, const char *__src)
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}






static __inline char *
__inline_stpncpy_chk (char * __dest, const char * __src,
        size_t __len)
{
  return __builtin___stpncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}







static __inline char *
__inline_strncpy_chk (char * __dest, const char * __src,
        size_t __len)
{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}






static __inline char *
__inline_strcat_chk (char * __dest, const char * __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}







static __inline char *
__inline_strncat_chk (char * __dest, const char * __src,
        size_t __len)
{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 191 "/usr/include/string.h" 2 3 4
# 31 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/usr/include/errno.h" 1 3 4
# 23 "/usr/include/errno.h" 3 4
# 1 "/usr/include/sys/errno.h" 1 3 4
# 74 "/usr/include/sys/errno.h" 3 4

extern int * __error(void);


# 24 "/usr/include/errno.h" 2 3 4
# 33 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 65 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/sys/wait.h" 1 3 4
# 79 "/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






typedef __darwin_pid_t pid_t;




typedef __darwin_id_t id_t;
# 116 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
# 73 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/usr/include/sys/signal.h" 2 3 4







# 1 "/usr/include/machine/signal.h" 1 3 4
# 32 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/i386/signal.h" 1 3 4
# 39 "/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 55 "/usr/include/i386/signal.h" 3 4
# 1 "/usr/include/i386/_structs.h" 1 3 4
# 56 "/usr/include/i386/signal.h" 2 3 4
# 33 "/usr/include/machine/signal.h" 2 3 4
# 82 "/usr/include/sys/signal.h" 2 3 4
# 148 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 57 "/usr/include/sys/_structs.h" 3 4
# 1 "/usr/include/machine/_structs.h" 1 3 4
# 29 "/usr/include/machine/_structs.h" 3 4
# 1 "/usr/include/i386/_structs.h" 1 3 4
# 38 "/usr/include/i386/_structs.h" 3 4
# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
# 43 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
# 402 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 454 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
# 751 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 39 "/usr/include/i386/_structs.h" 2 3 4
# 48 "/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 86 "/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 127 "/usr/include/i386/_structs.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/usr/include/machine/_structs.h" 2 3 4
# 58 "/usr/include/sys/_structs.h" 2 3 4
# 75 "/usr/include/sys/_structs.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
# 128 "/usr/include/sys/_structs.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};
# 218 "/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_sigaltstack stack_t;
# 227 "/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_ucontext ucontext_t;
# 149 "/usr/include/sys/signal.h" 2 3 4
# 157 "/usr/include/sys/signal.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;




typedef __darwin_sigset_t sigset_t;
# 172 "/usr/include/sys/signal.h" 3 4
typedef __darwin_uid_t uid_t;


union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 286 "/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 348 "/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 365 "/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 384 "/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 406 "/usr/include/sys/signal.h" 3 4

void (*signal(int, void (*)(int)))(int);

# 117 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 77 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 100 "/usr/include/sys/_structs.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 78 "/usr/include/sys/resource.h" 2 3 4
# 89 "/usr/include/sys/resource.h" 3 4
typedef __uint64_t rlim_t;
# 151 "/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 162 "/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 222 "/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 244 "/usr/include/sys/resource.h" 3 4

int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((visibility("default")));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((visibility("default")));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );

# 118 "/usr/include/sys/wait.h" 2 3 4
# 193 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
# 35 "/usr/include/machine/endian.h" 3 4
# 1 "/usr/include/i386/endian.h" 1 3 4
# 99 "/usr/include/i386/endian.h" 3 4
# 1 "/usr/include/sys/_endian.h" 1 3 4
# 124 "/usr/include/sys/_endian.h" 3 4
# 1 "/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static __inline__
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((_data << 8) | (_data >> 8));
}

static __inline__
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static __inline__
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 125 "/usr/include/sys/_endian.h" 2 3 4
# 100 "/usr/include/i386/endian.h" 2 3 4
# 36 "/usr/include/machine/endian.h" 2 3 4
# 194 "/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 254 "/usr/include/sys/wait.h" 3 4

pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);


# 66 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/alloca.h" 1 3 4
# 35 "/usr/include/alloca.h" 3 4

void *alloca(size_t);

# 68 "/usr/include/stdlib.h" 2 3 4
# 81 "/usr/include/stdlib.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;




typedef __darwin_rune_t rune_t;






typedef __darwin_wchar_t wchar_t;



typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 134 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 144 "/usr/include/stdlib.h" 3 4

void abort(void) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((visibility("default")));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **) ;

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system" );
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" );
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );






# 1 "/usr/include/machine/types.h" 1 3 4
# 35 "/usr/include/machine/types.h" 3 4
# 1 "/usr/include/i386/types.h" 1 3 4
# 70 "/usr/include/i386/types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 71 "/usr/include/i386/types.h" 2 3 4







typedef signed char int8_t;

typedef unsigned char u_int8_t;


typedef short int16_t;

typedef unsigned short u_int16_t;


typedef int int32_t;

typedef unsigned int u_int32_t;


typedef long long int64_t;

typedef unsigned long long u_int64_t;


typedef int64_t register_t;






typedef __darwin_intptr_t intptr_t;



typedef unsigned long uintptr_t;




typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 36 "/usr/include/machine/types.h" 2 3 4
# 256 "/usr/include/stdlib.h" 2 3 4


typedef __darwin_dev_t dev_t;




typedef __darwin_mode_t mode_t;



u_int32_t
  arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((visibility("default")));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((visibility("default")));

int atexit_b(void (^)(void)) __attribute__((visibility("default")));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((visibility("default")));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((deprecated,visibility("default")));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((visibility("default")));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((visibility("default")));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);







# 35 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/usr/include/unistd.h" 1 3 4
# 72 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 138 "/usr/include/sys/unistd.h" 3 4
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/usr/include/unistd.h" 2 3 4




typedef __darwin_gid_t gid_t;
# 114 "/usr/include/unistd.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 468 "/usr/include/unistd.h" 3 4

void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);

int getgroups(int, gid_t []) __asm("_" "getgroups" "$DARWIN_EXTSN");



char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int, const void *, size_t) __asm("_" "write" );

# 545 "/usr/include/unistd.h" 3 4

size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;

# 570 "/usr/include/unistd.h" 3 4





void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);






void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((__const__)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" );

ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" );





void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void);


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);

# 657 "/usr/include/unistd.h" 3 4

int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);








# 1 "/usr/include/sys/select.h" 1 3 4
# 78 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 88 "/usr/include/sys/_structs.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 183 "/usr/include/sys/_structs.h" 3 4

typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;



static __inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[_n/(sizeof(__int32_t) * 8)] & (1<<(_n % (sizeof(__int32_t) * 8))));
}
# 79 "/usr/include/sys/select.h" 2 3 4
# 87 "/usr/include/sys/select.h" 3 4
typedef __darwin_time_t time_t;




typedef __darwin_suseconds_t suseconds_t;
# 134 "/usr/include/sys/select.h" 3 4



int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )

  __asm("_" "pselect" "$DARWIN_EXTSN" )







  ;


# 1 "/usr/include/sys/_select.h" 1 3 4
# 39 "/usr/include/sys/_select.h" 3 4
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )

  __asm("_" "select" "$DARWIN_EXTSN" )







  ;
# 153 "/usr/include/sys/select.h" 2 3 4


# 673 "/usr/include/unistd.h" 2 3 4
# 686 "/usr/include/unistd.h" 3 4
typedef __darwin_uuid_t uuid_t;



void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
int gethostuuid(uuid_t, const struct timespec *) __attribute__((visibility("default")));
mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" );



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
# 772 "/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((visibility("default")));

extern int optreset;


# 37 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 48 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h"
# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4

void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));




# 49 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 1
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h"
# 1 "/usr/include/inttypes.h" 1 3 4
# 247 "/usr/include/inttypes.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 40 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long uint64_t;



typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
# 106 "/usr/include/stdint.h" 3 4
typedef long unsigned int uintmax_t;
# 248 "/usr/include/inttypes.h" 2 3 4
# 257 "/usr/include/inttypes.h" 3 4



  extern intmax_t imaxabs(intmax_t j);


  typedef struct {
        intmax_t quot;
        intmax_t rem;
  } imaxdiv_t;

  extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);


  extern intmax_t strtoimax(const char * nptr, char ** endptr, int base);
  extern uintmax_t strtoumax(const char * nptr, char ** endptr, int base);
# 282 "/usr/include/inttypes.h" 3 4
  extern intmax_t wcstoimax(const wchar_t * nptr, wchar_t ** endptr, int base);
  extern uintmax_t wcstoumax(const wchar_t * nptr, wchar_t ** endptr, int base);







# 10 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 2
# 170 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h"
typedef uintptr_t Py_uintptr_t;
typedef intptr_t Py_intptr_t;
# 194 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h"
typedef ssize_t Py_ssize_t;







typedef Py_ssize_t Py_hash_t;

typedef size_t Py_uhash_t;
# 340 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h"
# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
# 1 "/usr/include/architecture/i386/math.h" 1 3 4
# 49 "/usr/include/architecture/i386/math.h" 3 4
 typedef float float_t;
 typedef double double_t;
# 108 "/usr/include/architecture/i386/math.h" 3 4
extern int __math_errhandling ( void );
# 128 "/usr/include/architecture/i386/math.h" 3 4
extern int __fpclassifyf(float );
extern int __fpclassifyd(double );
extern int __fpclassify (long double);
# 163 "/usr/include/architecture/i386/math.h" 3 4
 static __inline__ int __inline_isfinitef (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinited (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinite (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isinff (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinfd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinf (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnanf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnand (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnan (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormalf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormald (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormal (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbit (long double) __attribute__ ((always_inline));

 static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
 static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
 static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
 static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
 static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
 static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
 static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
 static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
 static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
 static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
 static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
 static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); }
 static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= 1.17549435e-38F; }
 static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= 2.2250738585072014e-308; }
 static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= 3.36210314311209350626e-4932L; }
# 253 "/usr/include/architecture/i386/math.h" 3 4
extern double acos( double );
extern float acosf( float );

extern double asin( double );
extern float asinf( float );

extern double atan( double );
extern float atanf( float );

extern double atan2( double, double );
extern float atan2f( float, float );

extern double cos( double );
extern float cosf( float );

extern double sin( double );
extern float sinf( float );

extern double tan( double );
extern float tanf( float );

extern double acosh( double );
extern float acoshf( float );

extern double asinh( double );
extern float asinhf( float );

extern double atanh( double );
extern float atanhf( float );

extern double cosh( double );
extern float coshf( float );

extern double sinh( double );
extern float sinhf( float );

extern double tanh( double );
extern float tanhf( float );

extern double exp ( double );
extern float expf ( float );

extern double exp2 ( double );
extern float exp2f ( float );

extern double expm1 ( double );
extern float expm1f ( float );

extern double log ( double );
extern float logf ( float );

extern double log10 ( double );
extern float log10f ( float );

extern double log2 ( double );
extern float log2f ( float );

extern double log1p ( double );
extern float log1pf ( float );

extern double logb ( double );
extern float logbf ( float );

extern double modf ( double, double * );
extern float modff ( float, float * );

extern double ldexp ( double, int );
extern float ldexpf ( float, int );

extern double frexp ( double, int * );
extern float frexpf ( float, int * );

extern int ilogb ( double );
extern int ilogbf ( float );

extern double scalbn ( double, int );
extern float scalbnf ( float, int );

extern double scalbln ( double, long int );
extern float scalblnf ( float, long int );

extern double fabs( double );
extern float fabsf( float );

extern double cbrt( double );
extern float cbrtf( float );

extern double hypot ( double, double );
extern float hypotf ( float, float );

extern double pow ( double, double );
extern float powf ( float, float );

extern double sqrt( double );
extern float sqrtf( float );

extern double erf( double );
extern float erff( float );

extern double erfc( double );
extern float erfcf( float );






extern double lgamma( double );
extern float lgammaf( float );

extern double tgamma( double );
extern float tgammaf( float );

extern double ceil ( double );
extern float ceilf ( float );

extern double floor ( double );
extern float floorf ( float );

extern double nearbyint ( double );
extern float nearbyintf ( float );

extern double rint ( double );
extern float rintf ( float );

extern long int lrint ( double );
extern long int lrintf ( float );

extern double round ( double );
extern float roundf ( float );

extern long int lround ( double );
extern long int lroundf ( float );



    extern long long int llrint ( double );
    extern long long int llrintf ( float );
    extern long long int llround ( double );
    extern long long int llroundf ( float );


extern double trunc ( double );
extern float truncf ( float );

extern double fmod ( double, double );
extern float fmodf ( float, float );

extern double remainder ( double, double );
extern float remainderf ( float, float );

extern double remquo ( double, double, int * );
extern float remquof ( float, float, int * );

extern double copysign ( double, double );
extern float copysignf ( float, float );

extern double nan( const char * );
extern float nanf( const char * );

extern double nextafter ( double, double );
extern float nextafterf ( float, float );

extern double fdim ( double, double );
extern float fdimf ( float, float );

extern double fmax ( double, double );
extern float fmaxf ( float, float );

extern double fmin ( double, double );
extern float fminf ( float, float );

extern double fma ( double, double, double );
extern float fmaf ( float, float, float );

extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double exp2l(long double);
extern long double expm1l(long double);
extern long double logl(long double);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);
extern long double logbl(long double);
extern long double modfl(long double, long double *);
extern long double ldexpl(long double, int);
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double scalbnl(long double, int);
extern long double scalblnl(long double, long int);
extern long double fabsl(long double);
extern long double cbrtl(long double);
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double erfl(long double);
extern long double erfcl(long double);






extern long double lgammal(long double);

extern long double tgammal(long double);
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
extern long double rintl(long double);
extern long int lrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);



    extern long long int llrintl(long double);
    extern long long int llroundl(long double);


extern long double truncl(long double);
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);
# 507 "/usr/include/architecture/i386/math.h" 3 4
extern double __inf( void );
extern float __inff( void );
extern long double __infl( void );
extern float __nan( void );


extern double j0 ( double );

extern double j1 ( double );

extern double jn ( int, double );

extern double y0 ( double );

extern double y1 ( double );

extern double yn ( int, double );

extern double scalb ( double, double );
# 543 "/usr/include/architecture/i386/math.h" 3 4
extern int signgam;
# 558 "/usr/include/architecture/i386/math.h" 3 4
extern long int rinttol ( double );


extern long int roundtol ( double );
# 570 "/usr/include/architecture/i386/math.h" 3 4
struct exception {
 int type;
 char *name;
 double arg1;
 double arg2;
 double retval;
};
# 601 "/usr/include/architecture/i386/math.h" 3 4
extern int finite ( double );


extern double gamma ( double );




extern int matherr ( struct exception * );





extern double significand ( double );






extern double drem ( double, double );







# 1 "/usr/include/AvailabilityMacros.h" 1 3 4
# 631 "/usr/include/architecture/i386/math.h" 2 3 4

 extern float lgammaf_r ( float, int * ) ;
 extern double lgamma_r ( double, int * ) ;
 extern long double lgammal_r ( long double, int * ) ;
# 29 "/usr/include/math.h" 2 3 4
# 341 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 2






# 1 "/usr/include/sys/time.h" 1 3 4
# 78 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 79 "/usr/include/sys/time.h" 2 3 4
# 94 "/usr/include/sys/time.h" 3 4
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 144 "/usr/include/sys/time.h" 3 4
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 187 "/usr/include/sys/time.h" 3 4
struct clockinfo {
 int hz;
 int tick;
 int tickadj;
 int stathz;
 int profhz;
};




# 1 "/usr/include/time.h" 1 3 4
# 69 "/usr/include/time.h" 3 4
# 1 "/usr/include/_structs.h" 1 3 4
# 24 "/usr/include/_structs.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 25 "/usr/include/_structs.h" 2 3 4
# 70 "/usr/include/time.h" 2 3 4







typedef __darwin_clock_t clock_t;
# 90 "/usr/include/time.h" 3 4
struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 113 "/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;


char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" );


# 199 "/usr/include/sys/time.h" 2 3 4





int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *) __attribute__((visibility("default")));
int settimeofday(const struct timeval *, const struct timezone *);


int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * , void * );



int setitimer(int, const struct itimerval * ,
  struct itimerval * );
int utimes(const char *, const struct timeval *);


# 348 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 2
# 398 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h"
# 1 "/usr/include/sys/stat.h" 1 3 4
# 79 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/sys/_structs.h" 1 3 4
# 80 "/usr/include/sys/stat.h" 2 3 4







typedef __darwin_blkcnt_t blkcnt_t;




typedef __darwin_blksize_t blksize_t;
# 102 "/usr/include/sys/stat.h" 3 4
typedef __darwin_ino_t ino_t;





typedef __darwin_ino64_t ino64_t;
# 119 "/usr/include/sys/stat.h" 3 4
typedef __uint16_t nlink_t;
# 153 "/usr/include/sys/stat.h" 3 4
struct ostat {
 __uint16_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 __uint16_t st_uid;
 __uint16_t st_gid;
 __uint16_t st_rdev;
 __int32_t st_size;
 struct timespec st_atimespec;
 struct timespec st_mtimespec;
 struct timespec st_ctimespec;
 __int32_t st_blksize;
 __int32_t st_blocks;
 __uint32_t st_flags;
 __uint32_t st_gen;
};
# 225 "/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 264 "/usr/include/sys/stat.h" 3 4
struct stat64 { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 428 "/usr/include/sys/stat.h" 3 4


int chmod(const char *, mode_t) __asm("_" "chmod" );
int fchmod(int, mode_t) __asm("_" "fchmod" );
int fstat(int, struct stat *) __asm("_" "fstat" "$INODE64");
int lstat(const char *, struct stat *) __asm("_" "lstat" "$INODE64");
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int stat(const char *, struct stat *) __asm("_" "stat" "$INODE64");
int mknod(const char *, mode_t, dev_t);
mode_t umask(mode_t);



struct _filesec;
typedef struct _filesec *filesec_t;


int chflags(const char *, __uint32_t);
int chmodx_np(const char *, filesec_t);
int fchflags(int, __uint32_t);
int fchmodx_np(int, filesec_t);
int fstatx_np(int, struct stat *, filesec_t) __asm("_" "fstatx_np" "$INODE64");
int lchflags(const char *, __uint32_t) __attribute__((visibility("default")));
int lchmod(const char *, mode_t) __attribute__((visibility("default")));
int lstatx_np(const char *, struct stat *, filesec_t) __asm("_" "lstatx_np" "$INODE64");
int mkdirx_np(const char *, filesec_t);
int mkfifox_np(const char *, filesec_t);
int statx_np(const char *, struct stat *, filesec_t) __asm("_" "statx_np" "$INODE64");
int umaskx_np(filesec_t) __attribute__((deprecated,visibility("default")));



int fstatx64_np(int, struct stat64 *, filesec_t) __attribute__((deprecated,visibility("default")));
int lstatx64_np(const char *, struct stat64 *, filesec_t) __attribute__((deprecated,visibility("default")));
int statx64_np(const char *, struct stat64 *, filesec_t) __attribute__((deprecated,visibility("default")));
int fstat64(int, struct stat64 *) __attribute__((deprecated,visibility("default")));
int lstat64(const char *, struct stat64 *) __attribute__((deprecated,visibility("default")));
int stat64(const char *, struct stat64 *) __attribute__((deprecated,visibility("default")));




# 399 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 2
# 673 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h"
# 1 "/usr/include/termios.h" 1 3 4
# 27 "/usr/include/termios.h" 3 4
# 1 "/usr/include/sys/termios.h" 1 3 4
# 265 "/usr/include/sys/termios.h" 3 4
typedef unsigned long tcflag_t;
typedef unsigned char cc_t;
typedef unsigned long speed_t;

struct termios {
 tcflag_t c_iflag;
 tcflag_t c_oflag;
 tcflag_t c_cflag;
 tcflag_t c_lflag;
 cc_t c_cc[20];
 speed_t c_ispeed;
 speed_t c_ospeed;
};
# 332 "/usr/include/sys/termios.h" 3 4

speed_t cfgetispeed(const struct termios *);
speed_t cfgetospeed(const struct termios *);
int cfsetispeed(struct termios *, speed_t);
int cfsetospeed(struct termios *, speed_t);
int tcgetattr(int, struct termios *);
int tcsetattr(int, int, const struct termios *);
int tcdrain(int) __asm("_" "tcdrain" );
int tcflow(int, int);
int tcflush(int, int);
int tcsendbreak(int, int);


void cfmakeraw(struct termios *);
int cfsetspeed(struct termios *, speed_t);


# 358 "/usr/include/sys/termios.h" 3 4
# 1 "/usr/include/sys/ttycom.h" 1 3 4
# 72 "/usr/include/sys/ttycom.h" 3 4
# 1 "/usr/include/sys/ioccom.h" 1 3 4
# 73 "/usr/include/sys/ttycom.h" 2 3 4
# 83 "/usr/include/sys/ttycom.h" 3 4
struct winsize {
 unsigned short ws_row;
 unsigned short ws_col;
 unsigned short ws_xpixel;
 unsigned short ws_ypixel;
};
# 359 "/usr/include/sys/termios.h" 2 3 4
# 367 "/usr/include/sys/termios.h" 3 4
# 1 "/usr/include/sys/ttydefaults.h" 1 3 4
# 368 "/usr/include/sys/termios.h" 2 3 4
# 28 "/usr/include/termios.h" 2 3 4








pid_t tcgetsid(int);

# 674 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 2
extern int openpty(int *, int *, char *, struct termios *, struct winsize *);
extern pid_t forkpty(int *, char *, struct termios *, struct winsize *);
# 700 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 69 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/runetype.h" 1 3 4
# 70 "/usr/include/runetype.h" 3 4
typedef __darwin_wint_t wint_t;
# 81 "/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;




extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;

# 70 "/usr/include/ctype.h" 2 3 4
# 145 "/usr/include/ctype.h" 3 4

unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);


static __inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 164 "/usr/include/ctype.h" 3 4

int __maskrune(__darwin_ct_rune_t, unsigned long);



static __inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

static __inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 204 "/usr/include/ctype.h" 3 4

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);



static __inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






static __inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

static __inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

static __inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

static __inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


static __inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

static __inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

static __inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

static __inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

static __inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

static __inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

static __inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


static __inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

static __inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

static __inline int
tolower(int _c)
{
        return (__tolower(_c));
}

static __inline int
toupper(int _c)
{
        return (__toupper(_c));
}


static __inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

static __inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

static __inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

static __inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

static __inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

static __inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

static __inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 701 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 2
# 1 "/usr/include/wctype.h" 1 3 4
# 39 "/usr/include/wctype.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 53 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/_wctype.h" 1 3 4
# 52 "/usr/include/_wctype.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 71 "/usr/include/_wctype.h" 3 4
static __inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

static __inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

static __inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

static __inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

static __inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

static __inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

static __inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

static __inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

static __inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

static __inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

static __inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

static __inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

static __inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

static __inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 176 "/usr/include/_wctype.h" 3 4

wctype_t
 wctype(const char *);

# 54 "/usr/include/wctype.h" 2 3 4
# 62 "/usr/include/wctype.h" 3 4
static __inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


static __inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

static __inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

static __inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

static __inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

static __inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

static __inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

static __inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 130 "/usr/include/wctype.h" 3 4


wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);

# 702 "/Users/parrt/tmp/Python-3.3.1/Include/pyport.h" 2
# 51 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pymacro.h" 1
# 52 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pyatomic.h" 1







# 1 "/Users/parrt/tmp/Python-3.3.1/Include/dynamic_annotations.h" 1
# 375 "/Users/parrt/tmp/Python-3.3.1/Include/dynamic_annotations.h"
void AnnotateRWLockCreate(const char *file, int line,
                          const volatile void *lock);
void AnnotateRWLockDestroy(const char *file, int line,
                           const volatile void *lock);
void AnnotateRWLockAcquired(const char *file, int line,
                            const volatile void *lock, long is_w);
void AnnotateRWLockReleased(const char *file, int line,
                            const volatile void *lock, long is_w);
void AnnotateBarrierInit(const char *file, int line,
                         const volatile void *barrier, long count,
                         long reinitialization_allowed);
void AnnotateBarrierWaitBefore(const char *file, int line,
                               const volatile void *barrier);
void AnnotateBarrierWaitAfter(const char *file, int line,
                              const volatile void *barrier);
void AnnotateBarrierDestroy(const char *file, int line,
                            const volatile void *barrier);
void AnnotateCondVarWait(const char *file, int line,
                         const volatile void *cv,
                         const volatile void *lock);
void AnnotateCondVarSignal(const char *file, int line,
                           const volatile void *cv);
void AnnotateCondVarSignalAll(const char *file, int line,
                              const volatile void *cv);
void AnnotatePublishMemoryRange(const char *file, int line,
                                const volatile void *address,
                                long size);
void AnnotateUnpublishMemoryRange(const char *file, int line,
                                  const volatile void *address,
                                  long size);
void AnnotatePCQCreate(const char *file, int line,
                       const volatile void *pcq);
void AnnotatePCQDestroy(const char *file, int line,
                        const volatile void *pcq);
void AnnotatePCQPut(const char *file, int line,
                    const volatile void *pcq);
void AnnotatePCQGet(const char *file, int line,
                    const volatile void *pcq);
void AnnotateNewMemory(const char *file, int line,
                       const volatile void *address,
                       long size);
void AnnotateExpectRace(const char *file, int line,
                        const volatile void *address,
                        const char *description);
void AnnotateBenignRace(const char *file, int line,
                        const volatile void *address,
                        const char *description);
void AnnotateBenignRaceSized(const char *file, int line,
                        const volatile void *address,
                        long size,
                        const char *description);
void AnnotateMutexIsUsedAsCondVar(const char *file, int line,
                                  const volatile void *mu);
void AnnotateTraceMemory(const char *file, int line,
                         const volatile void *arg);
void AnnotateThreadName(const char *file, int line,
                        const char *name);
void AnnotateIgnoreReadsBegin(const char *file, int line);
void AnnotateIgnoreReadsEnd(const char *file, int line);
void AnnotateIgnoreWritesBegin(const char *file, int line);
void AnnotateIgnoreWritesEnd(const char *file, int line);
void AnnotateEnableRaceDetection(const char *file, int line, int enable);
void AnnotateNoOp(const char *file, int line,
                  const volatile void *arg);
void AnnotateFlushState(const char *file, int line);
# 456 "/Users/parrt/tmp/Python-3.3.1/Include/dynamic_annotations.h"
int RunningOnValgrind(void);
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/pyatomic.h" 2
# 23 "/Users/parrt/tmp/Python-3.3.1/Include/pyatomic.h"
typedef enum _Py_memory_order {
    _Py_memory_order_relaxed,
    _Py_memory_order_acquire,
    _Py_memory_order_release,
    _Py_memory_order_acq_rel,
    _Py_memory_order_seq_cst
} _Py_memory_order;

typedef struct _Py_atomic_address {
    void *_value;
} _Py_atomic_address;

typedef struct _Py_atomic_int {
    int _value;
} _Py_atomic_int;





static __inline__ void
_Py_atomic_signal_fence(_Py_memory_order order)
{
    if (order != _Py_memory_order_relaxed)
        __asm__ volatile("":::"memory");
}

static __inline__ void
_Py_atomic_thread_fence(_Py_memory_order order)
{
    if (order != _Py_memory_order_relaxed)
        __asm__ volatile("mfence":::"memory");
}


static __inline__ void
_Py_ANNOTATE_MEMORY_ORDER(const volatile void *address, _Py_memory_order order)
{
    (void)address;
    switch(order) {
    case _Py_memory_order_release:
    case _Py_memory_order_acq_rel:
    case _Py_memory_order_seq_cst:
        ;
        break;
    case _Py_memory_order_relaxed:
    case _Py_memory_order_acquire:
        break;
    }
    switch(order) {
    case _Py_memory_order_acquire:
    case _Py_memory_order_acq_rel:
    case _Py_memory_order_seq_cst:
        ;
        break;
    case _Py_memory_order_relaxed:
    case _Py_memory_order_release:
        break;
    }
}
# 54 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 64 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h"
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pymath.h" 1
# 65 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pytime.h" 1





# 1 "/Users/parrt/tmp/Python-3.3.1/Include/object.h" 1
# 105 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
typedef struct _object {
   
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;

typedef struct {
    PyObject ob_base;
    Py_ssize_t ob_size;
} PyVarObject;
# 140 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
typedef struct _Py_Identifier {
    struct _Py_Identifier *next;
    const char* string;
    PyObject *object;
} _Py_Identifier;
# 164 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
typedef PyObject * (*unaryfunc)(PyObject *);
typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
typedef int (*inquiry)(PyObject *);
typedef Py_ssize_t (*lenfunc)(PyObject *);
typedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);
typedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);
typedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);
typedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);



typedef struct bufferinfo {
    void *buf;
    PyObject *obj;
    Py_ssize_t len;
    Py_ssize_t itemsize;

    int readonly;
    int ndim;
    char *format;
    Py_ssize_t *shape;
    Py_ssize_t *strides;
    Py_ssize_t *suboffsets;
    void *internal;
} Py_buffer;

typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
# 230 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
typedef int (*objobjproc)(PyObject *, PyObject *);
typedef int (*visitproc)(PyObject *, void *);
typedef int (*traverseproc)(PyObject *, visitproc, void *);


typedef struct {




    binaryfunc nb_add;
    binaryfunc nb_subtract;
    binaryfunc nb_multiply;
    binaryfunc nb_remainder;
    binaryfunc nb_divmod;
    ternaryfunc nb_power;
    unaryfunc nb_negative;
    unaryfunc nb_positive;
    unaryfunc nb_absolute;
    inquiry nb_bool;
    unaryfunc nb_invert;
    binaryfunc nb_lshift;
    binaryfunc nb_rshift;
    binaryfunc nb_and;
    binaryfunc nb_xor;
    binaryfunc nb_or;
    unaryfunc nb_int;
    void *nb_reserved;
    unaryfunc nb_float;

    binaryfunc nb_inplace_add;
    binaryfunc nb_inplace_subtract;
    binaryfunc nb_inplace_multiply;
    binaryfunc nb_inplace_remainder;
    ternaryfunc nb_inplace_power;
    binaryfunc nb_inplace_lshift;
    binaryfunc nb_inplace_rshift;
    binaryfunc nb_inplace_and;
    binaryfunc nb_inplace_xor;
    binaryfunc nb_inplace_or;

    binaryfunc nb_floor_divide;
    binaryfunc nb_true_divide;
    binaryfunc nb_inplace_floor_divide;
    binaryfunc nb_inplace_true_divide;

    unaryfunc nb_index;
} PyNumberMethods;

typedef struct {
    lenfunc sq_length;
    binaryfunc sq_concat;
    ssizeargfunc sq_repeat;
    ssizeargfunc sq_item;
    void *was_sq_slice;
    ssizeobjargproc sq_ass_item;
    void *was_sq_ass_slice;
    objobjproc sq_contains;

    binaryfunc sq_inplace_concat;
    ssizeargfunc sq_inplace_repeat;
} PySequenceMethods;

typedef struct {
    lenfunc mp_length;
    binaryfunc mp_subscript;
    objobjargproc mp_ass_subscript;
} PyMappingMethods;


typedef struct {
     getbufferproc bf_getbuffer;
     releasebufferproc bf_releasebuffer;
} PyBufferProcs;


typedef void (*freefunc)(void *);
typedef void (*destructor)(PyObject *);





typedef int (*printfunc)(PyObject *, FILE *, int);

typedef PyObject *(*getattrfunc)(PyObject *, char *);
typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
typedef PyObject *(*reprfunc)(PyObject *);
typedef Py_hash_t (*hashfunc)(PyObject *);
typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
typedef PyObject *(*getiterfunc) (PyObject *);
typedef PyObject *(*iternextfunc) (PyObject *);
typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);




typedef struct _typeobject {
    PyVarObject ob_base;
    const char *tp_name;
    Py_ssize_t tp_basicsize, tp_itemsize;



    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    void *tp_reserved;
    reprfunc tp_repr;



    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;



    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;


    PyBufferProcs *tp_as_buffer;


    long tp_flags;

    const char *tp_doc;



    traverseproc tp_traverse;


    inquiry tp_clear;



    richcmpfunc tp_richcompare;


    Py_ssize_t tp_weaklistoffset;


    getiterfunc tp_iter;
    iternextfunc tp_iternext;


    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    Py_ssize_t tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free;
    inquiry tp_is_gc;
    PyObject *tp_bases;
    PyObject *tp_mro;
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
    destructor tp_del;


    unsigned int tp_version_tag;
# 419 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
} PyTypeObject;


typedef struct{
    int slot;
    void *pfunc;
} PyType_Slot;

typedef struct{
    const char* name;
    int basicsize;
    int itemsize;
    int flags;
    PyType_Slot *slots;
} PyType_Spec;

PyObject* PyType_FromSpec(PyType_Spec*);

PyObject* PyType_FromSpecWithBases(PyType_Spec*, PyObject*);




typedef struct _heaptypeobject {


    PyTypeObject ht_type;
    PyNumberMethods as_number;
    PyMappingMethods as_mapping;
    PySequenceMethods as_sequence;




    PyBufferProcs as_buffer;
    PyObject *ht_name, *ht_slots, *ht_qualname;
    struct _dictkeysobject *ht_cached_keys;

} PyHeapTypeObject;







int PyType_IsSubtype(PyTypeObject *, PyTypeObject *);



extern PyTypeObject PyType_Type;
extern PyTypeObject PyBaseObject_Type;
extern PyTypeObject PySuper_Type;

long PyType_GetFlags(PyTypeObject*);





int PyType_Ready(PyTypeObject *);
PyObject * PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
PyObject * PyType_GenericNew(PyTypeObject *,
                                               PyObject *, PyObject *);

PyObject * _PyType_Lookup(PyTypeObject *, PyObject *);
PyObject * _PyObject_LookupSpecial(PyObject *, _Py_Identifier *);
PyTypeObject * _PyType_CalculateMetaclass(PyTypeObject *, PyObject *);

unsigned int PyType_ClearCache(void);
void PyType_Modified(PyTypeObject *);


struct _Py_Identifier;

int PyObject_Print(PyObject *, FILE *, int);
void _Py_BreakPoint(void);
void _PyObject_Dump(PyObject *);

PyObject * PyObject_Repr(PyObject *);
PyObject * PyObject_Str(PyObject *);
PyObject * PyObject_ASCII(PyObject *);
PyObject * PyObject_Bytes(PyObject *);
PyObject * PyObject_RichCompare(PyObject *, PyObject *, int);
int PyObject_RichCompareBool(PyObject *, PyObject *, int);
PyObject * PyObject_GetAttrString(PyObject *, const char *);
int PyObject_SetAttrString(PyObject *, const char *, PyObject *);
int PyObject_HasAttrString(PyObject *, const char *);
PyObject * PyObject_GetAttr(PyObject *, PyObject *);
int PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
int PyObject_HasAttr(PyObject *, PyObject *);
int _PyObject_IsAbstract(PyObject *);
PyObject * _PyObject_GetAttrId(PyObject *, struct _Py_Identifier *);
int _PyObject_SetAttrId(PyObject *, struct _Py_Identifier *, PyObject *);
int _PyObject_HasAttrId(PyObject *, struct _Py_Identifier *);

PyObject ** _PyObject_GetDictPtr(PyObject *);

PyObject * PyObject_SelfIter(PyObject *);

PyObject * _PyObject_NextNotImplemented(PyObject *);

PyObject * PyObject_GenericGetAttr(PyObject *, PyObject *);
int PyObject_GenericSetAttr(PyObject *,
                                              PyObject *, PyObject *);
int PyObject_GenericSetDict(PyObject *, PyObject *, void *);
Py_hash_t PyObject_Hash(PyObject *);
Py_hash_t PyObject_HashNotImplemented(PyObject *);
int PyObject_IsTrue(PyObject *);
int PyObject_Not(PyObject *);
int PyCallable_Check(PyObject *);

void PyObject_ClearWeakRefs(PyObject *);



PyObject *
_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *);
int
_PyObject_GenericSetAttrWithDict(PyObject *, PyObject *,
                                 PyObject *, PyObject *);



PyObject *
_PyObject_GetBuiltin(const char *name);







PyObject * PyObject_Dir(PyObject *);



int Py_ReprEnter(PyObject *);
void Py_ReprLeave(PyObject *);



Py_hash_t _Py_HashDouble(double);
Py_hash_t _Py_HashPointer(void*);
Py_hash_t _Py_HashBytes(unsigned char*, Py_ssize_t);


typedef struct {
    Py_hash_t prefix;
    Py_hash_t suffix;
} _Py_HashSecret_t;
extern _Py_HashSecret_t _Py_HashSecret;
# 830 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
void Py_IncRef(PyObject *);
void Py_DecRef(PyObject *);







extern PyObject _Py_NoneStruct;
# 849 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
extern PyObject _Py_NotImplementedStruct;
# 867 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
extern int _Py_SwappedOp[];
# 966 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
void _PyTrash_deposit_object(PyObject*);
void _PyTrash_destroy_chain(void);
extern int _PyTrash_delete_nesting;
extern PyObject * _PyTrash_delete_later;


void _PyTrash_thread_deposit_object(PyObject*);
void _PyTrash_thread_destroy_chain(void);
# 993 "/Users/parrt/tmp/Python-3.3.1/Include/object.h"
void
_PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks,
                       size_t sizeof_block);
void
_PyObject_DebugTypeStats(FILE *out);
# 7 "/Users/parrt/tmp/Python-3.3.1/Include/pytime.h" 2
# 17 "/Users/parrt/tmp/Python-3.3.1/Include/pytime.h"
typedef struct timeval _PyTime_timeval;
# 26 "/Users/parrt/tmp/Python-3.3.1/Include/pytime.h"
typedef struct {
    const char *implementation;
    int monotonic;
    int adjustable;
    double resolution;
} _Py_clock_info_t;




void _PyTime_gettimeofday(_PyTime_timeval *tp);



void _PyTime_gettimeofday_info(
    _PyTime_timeval *tp,
    _Py_clock_info_t *info);
# 57 "/Users/parrt/tmp/Python-3.3.1/Include/pytime.h"
int _PyTime_ObjectToTime_t(
    PyObject *obj,
    time_t *sec);


PyObject * _PyLong_FromTime_t(
    time_t sec);


time_t _PyLong_AsTime_t(
    PyObject *obj);




int _PyTime_ObjectToTimeval(
    PyObject *obj,
    time_t *sec,
    long *usec);




int _PyTime_ObjectToTimespec(
    PyObject *obj,
    time_t *sec,
    long *nsec);



void _PyTime_Init(void);
# 66 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pymem.h" 1
# 52 "/Users/parrt/tmp/Python-3.3.1/Include/pymem.h"
void * PyMem_Malloc(size_t);
void * PyMem_Realloc(void *, size_t);
void PyMem_Free(void *);
# 67 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2


# 1 "/Users/parrt/tmp/Python-3.3.1/Include/objimpl.h" 1
# 97 "/Users/parrt/tmp/Python-3.3.1/Include/objimpl.h"
void * PyObject_Malloc(size_t);
void * PyObject_Realloc(void *, size_t);
void PyObject_Free(void *);





void _PyObject_DebugMallocStats(FILE *out);
# 149 "/Users/parrt/tmp/Python-3.3.1/Include/objimpl.h"
PyObject * PyObject_Init(PyObject *, PyTypeObject *);
PyVarObject * PyObject_InitVar(PyVarObject *,
                                                 PyTypeObject *, Py_ssize_t);
PyObject * _PyObject_New(PyTypeObject *);
PyVarObject * _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
# 231 "/Users/parrt/tmp/Python-3.3.1/Include/objimpl.h"
Py_ssize_t PyGC_Collect(void);
# 240 "/Users/parrt/tmp/Python-3.3.1/Include/objimpl.h"
PyVarObject * _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);





typedef union _gc_head {
    struct {
        union _gc_head *gc_next;
        union _gc_head *gc_prev;
        Py_ssize_t gc_refs;
    } gc;
    long double dummy;
} PyGC_Head;

extern PyGC_Head *_PyGC_generation0;
# 300 "/Users/parrt/tmp/Python-3.3.1/Include/objimpl.h"
PyObject * _PyObject_GC_Malloc(size_t);
PyObject * _PyObject_GC_New(PyTypeObject *);
PyVarObject * _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
void PyObject_GC_Track(void *);
void PyObject_GC_UnTrack(void *);
void PyObject_GC_Del(void *);
# 70 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/typeslots.h" 1
# 71 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pydebug.h" 1







extern int Py_DebugFlag;
extern int Py_VerboseFlag;
extern int Py_QuietFlag;
extern int Py_InteractiveFlag;
extern int Py_InspectFlag;
extern int Py_OptimizeFlag;
extern int Py_NoSiteFlag;
extern int Py_BytesWarningFlag;
extern int Py_UseClassExceptionsFlag;
extern int Py_FrozenFlag;
extern int Py_IgnoreEnvironmentFlag;
extern int Py_DontWriteBytecodeFlag;
extern int Py_NoUserSiteDirectory;
extern int Py_UnbufferedStdioFlag;
extern int Py_HashRandomizationFlag;
# 73 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/bytearrayobject.h" 1
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/bytearrayobject.h"
# 1 "/Developer/usr/llvm-gcc-4.2/lib/gcc/i686-apple-darwin11/4.2.1/include/stdarg.h" 1 3 4
# 43 "/Developer/usr/llvm-gcc-4.2/lib/gcc/i686-apple-darwin11/4.2.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/bytearrayobject.h" 2
# 23 "/Users/parrt/tmp/Python-3.3.1/Include/bytearrayobject.h"
typedef struct {
    PyVarObject ob_base;

    int ob_exports;
    Py_ssize_t ob_alloc;
    char *ob_bytes;
} PyByteArrayObject;



extern PyTypeObject PyByteArray_Type;
extern PyTypeObject PyByteArrayIter_Type;






PyObject * PyByteArray_FromObject(PyObject *);
PyObject * PyByteArray_Concat(PyObject *, PyObject *);
PyObject * PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
Py_ssize_t PyByteArray_Size(PyObject *);
char * PyByteArray_AsString(PyObject *);
int PyByteArray_Resize(PyObject *, Py_ssize_t);
# 55 "/Users/parrt/tmp/Python-3.3.1/Include/bytearrayobject.h"
extern char _PyByteArray_empty_string[];
# 75 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/bytesobject.h" 1
# 31 "/Users/parrt/tmp/Python-3.3.1/Include/bytesobject.h"
typedef struct {
    PyVarObject ob_base;
    Py_hash_t ob_shash;
    char ob_sval[1];






} PyBytesObject;


extern PyTypeObject PyBytes_Type;
extern PyTypeObject PyBytesIter_Type;





PyObject * PyBytes_FromStringAndSize(const char *, Py_ssize_t);
PyObject * PyBytes_FromString(const char *);
PyObject * PyBytes_FromObject(PyObject *);
PyObject * PyBytes_FromFormatV(const char*, va_list)
    __attribute__((format(printf, 1, 0)));
PyObject * PyBytes_FromFormat(const char*, ...)
    __attribute__((format(printf, 1, 2)));
Py_ssize_t PyBytes_Size(PyObject *);
char * PyBytes_AsString(PyObject *);
PyObject * PyBytes_Repr(PyObject *, int);
void PyBytes_Concat(PyObject **, PyObject *);
void PyBytes_ConcatAndDel(PyObject **, PyObject *);

int _PyBytes_Resize(PyObject **, Py_ssize_t);

PyObject * PyBytes_DecodeEscape(const char *, Py_ssize_t,
         const char *, Py_ssize_t,
         const char *);
# 80 "/Users/parrt/tmp/Python-3.3.1/Include/bytesobject.h"
PyObject * _PyBytes_Join(PyObject *sep, PyObject *x);







int PyBytes_AsStringAndSize(
    register PyObject *obj,
    register char **s,
    register Py_ssize_t *len


    );





Py_ssize_t _PyBytes_InsertThousandsGroupingLocale(char *buffer,
                                                   Py_ssize_t n_buffer,
                                                   char *digits,
                                                   Py_ssize_t n_digits,
                                                   Py_ssize_t min_width);




Py_ssize_t _PyBytes_InsertThousandsGrouping(char *buffer,
                                                   Py_ssize_t n_buffer,
                                                   char *digits,
                                                   Py_ssize_t n_digits,
                                                   Py_ssize_t min_width,
                                                   const char *grouping,
                                                   const char *thousands_sep);
# 76 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h" 1
# 93 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
typedef wchar_t Py_UNICODE;
# 115 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
# 1 "/usr/include/wchar.h" 1 3 4
# 85 "/usr/include/wchar.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 120 "/usr/include/wchar.h" 3 4

wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...) ;
int fwscanf(FILE * , const wchar_t * , ...) ;
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * ,
     ...) ;
int swscanf(const wchar_t * , const wchar_t * , ...) ;
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list) ;
int vwprintf(const wchar_t * , __darwin_va_list) ;
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...) ;
int wscanf(const wchar_t * , ...) ;
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);

# 194 "/usr/include/wchar.h" 3 4

int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list) ;
int vwscanf(const wchar_t * , __darwin_va_list) ;
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** ) ;

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);


# 219 "/usr/include/wchar.h" 3 4

size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((visibility("default")));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((visibility("default")));
wchar_t *wcsdup(const wchar_t *) __attribute__((visibility("default")));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((visibility("default")));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((visibility("default")));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((visibility("default")));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );









wchar_t *fgetwln(FILE * , size_t *) __attribute__((visibility("default")));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);

# 116 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h" 2





typedef unsigned int Py_UCS4;







typedef unsigned short Py_UCS2;




typedef unsigned char Py_UCS1;
# 217 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
typedef struct {
# 291 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
    PyObject ob_base;
    Py_ssize_t length;
    Py_hash_t hash;
    struct {
# 303 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
        unsigned int interned:2;
# 331 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
        unsigned int kind:3;




        unsigned int compact:1;



        unsigned int ascii:1;




        unsigned int ready:1;
    } state;
    wchar_t *wstr;
} PyASCIIObject;




typedef struct {
    PyASCIIObject _base;
    Py_ssize_t utf8_length;

    char *utf8;
    Py_ssize_t wstr_length;

} PyCompactUnicodeObject;




typedef struct {
    PyCompactUnicodeObject _base;
    union {
        void *any;
        Py_UCS1 *latin1;
        Py_UCS2 *ucs2;
        Py_UCS4 *ucs4;
    } data;
} PyUnicodeObject;


extern PyTypeObject PyUnicode_Type;
extern PyTypeObject PyUnicodeIter_Type;
# 448 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
enum PyUnicode_Kind {



    PyUnicode_WCHAR_KIND = 0,

    PyUnicode_1BYTE_KIND = 1,
    PyUnicode_2BYTE_KIND = 2,
    PyUnicode_4BYTE_KIND = 4
};
# 599 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_New(
    Py_ssize_t size,
    Py_UCS4 maxchar
    );
# 613 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
int _PyUnicode_Ready(
    PyObject *unicode
    );




PyObject* _PyUnicode_Copy(
    PyObject *unicode
    );
# 644 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
Py_ssize_t PyUnicode_CopyCharacters(
    PyObject *to,
    Py_ssize_t to_start,
    PyObject *from,
    Py_ssize_t from_start,
    Py_ssize_t how_many
    );




void _PyUnicode_FastCopyCharacters(
    PyObject *to,
    Py_ssize_t to_start,
    PyObject *from,
    Py_ssize_t from_start,
    Py_ssize_t how_many
    );
# 673 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
Py_ssize_t PyUnicode_Fill(
    PyObject *unicode,
    Py_ssize_t start,
    Py_ssize_t length,
    Py_UCS4 fill_char
    );



void _PyUnicode_FastFill(
    PyObject *unicode,
    Py_ssize_t start,
    Py_ssize_t length,
    Py_UCS4 fill_char
    );
# 701 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_FromUnicode(
    const Py_UNICODE *u,
    Py_ssize_t size
    );



PyObject* PyUnicode_FromStringAndSize(
    const char *u,
    Py_ssize_t size
    );



PyObject* PyUnicode_FromString(
    const char *u
    );




PyObject* PyUnicode_FromKindAndData(
    int kind,
    const void *buffer,
    Py_ssize_t size);



PyObject* _PyUnicode_FromASCII(
    const char *buffer,
    Py_ssize_t size);


PyObject* PyUnicode_Substring(
    PyObject *str,
    Py_ssize_t start,
    Py_ssize_t end);




Py_UCS4 _PyUnicode_FindMaxChar (
    PyObject *unicode,
    Py_ssize_t start,
    Py_ssize_t end);







Py_UCS4* PyUnicode_AsUCS4(
    PyObject *unicode,
    Py_UCS4* buffer,
    Py_ssize_t buflen,
    int copy_null);




Py_UCS4* PyUnicode_AsUCS4Copy(PyObject *unicode);







Py_UNICODE * PyUnicode_AsUnicode(
    PyObject *unicode
    );
# 781 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
Py_UNICODE * PyUnicode_AsUnicodeAndSize(
    PyObject *unicode,
    Py_ssize_t *size
    );




Py_ssize_t PyUnicode_GetLength(
    PyObject *unicode
);




Py_ssize_t PyUnicode_GetSize(
    PyObject *unicode
    );



Py_UCS4 PyUnicode_ReadChar(
    PyObject *unicode,
    Py_ssize_t index
    );






int PyUnicode_WriteChar(
    PyObject *unicode,
    Py_ssize_t index,
    Py_UCS4 character
    );



Py_UNICODE PyUnicode_GetMax(void);
# 839 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
int PyUnicode_Resize(
    PyObject **unicode,
    Py_ssize_t length
    );
# 861 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_FromEncodedObject(
    register PyObject *obj,
    const char *encoding,
    const char *errors
    );
# 880 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_FromObject(
    register PyObject *obj
    );

PyObject * PyUnicode_FromFormatV(
    const char *format,
    va_list vargs
    );
PyObject * PyUnicode_FromFormat(
    const char *format,
    ...
    );


typedef struct {
    PyObject *buffer;
    void *data;
    enum PyUnicode_Kind kind;
    Py_UCS4 maxchar;
    Py_ssize_t size;
    Py_ssize_t pos;


    Py_ssize_t min_length;
    unsigned char overallocate;


    unsigned char readonly;
} _PyUnicodeWriter ;






void
_PyUnicodeWriter_Init(_PyUnicodeWriter *writer, Py_ssize_t min_length);
# 932 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
int
_PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,
                                 Py_ssize_t length, Py_UCS4 maxchar);

int
_PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str);

PyObject *
_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer);

void
_PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer);





int _PyUnicode_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);


void PyUnicode_InternInPlace(PyObject **);
void PyUnicode_InternImmortal(PyObject **);
PyObject * PyUnicode_InternFromString(
    const char *u
    );

void _Py_ReleaseInternedUnicodeStrings(void);
# 979 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_FromWideChar(
    register const wchar_t *w,
    Py_ssize_t size
    );
# 996 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
Py_ssize_t PyUnicode_AsWideChar(
    PyObject *unicode,
    register wchar_t *w,
    Py_ssize_t size
    );
# 1010 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
wchar_t* PyUnicode_AsWideCharString(
    PyObject *unicode,
    Py_ssize_t *size
    );


void* _PyUnicode_AsKind(PyObject *s, unsigned int kind);
# 1030 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_FromOrdinal(int ordinal);
# 1041 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
int PyUnicode_ClearFreeList(void);
# 1084 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
char * PyUnicode_AsUTF8AndSize(
    PyObject *unicode,
    Py_ssize_t *size);
# 1111 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
char * PyUnicode_AsUTF8(PyObject *unicode);





const char* PyUnicode_GetDefaultEncoding(void);






PyObject* PyUnicode_Decode(
    const char *s,
    Py_ssize_t size,
    const char *encoding,
    const char *errors
    );




PyObject* PyUnicode_AsDecodedObject(
    PyObject *unicode,
    const char *encoding,
    const char *errors
    );




PyObject* PyUnicode_AsDecodedUnicode(
    PyObject *unicode,
    const char *encoding,
    const char *errors
    );





PyObject* PyUnicode_Encode(
    const Py_UNICODE *s,
    Py_ssize_t size,
    const char *encoding,
    const char *errors
    );





PyObject* PyUnicode_AsEncodedObject(
    PyObject *unicode,
    const char *encoding,
    const char *errors
    );




PyObject* PyUnicode_AsEncodedString(
    PyObject *unicode,
    const char *encoding,
    const char *errors
    );




PyObject* PyUnicode_AsEncodedUnicode(
    PyObject *unicode,
    const char *encoding,
    const char *errors
    );



PyObject* PyUnicode_BuildEncodingMap(
    PyObject* string
   );



PyObject* PyUnicode_DecodeUTF7(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicode_DecodeUTF7Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    Py_ssize_t *consumed
    );


PyObject* PyUnicode_EncodeUTF7(
    const Py_UNICODE *data,
    Py_ssize_t length,
    int base64SetO,
    int base64WhiteSpace,
    const char *errors
    );
PyObject* _PyUnicode_EncodeUTF7(
    PyObject *unicode,
    int base64SetO,
    int base64WhiteSpace,
    const char *errors
    );




PyObject* PyUnicode_DecodeUTF8(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicode_DecodeUTF8Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    Py_ssize_t *consumed
    );

PyObject* PyUnicode_AsUTF8String(
    PyObject *unicode
    );


PyObject* _PyUnicode_AsUTF8String(
    PyObject *unicode,
    const char *errors);

PyObject* PyUnicode_EncodeUTF8(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors
    );
# 1281 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeUTF32(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder


    );

PyObject* PyUnicode_DecodeUTF32Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder,


    Py_ssize_t *consumed
    );




PyObject* PyUnicode_AsUTF32String(
    PyObject *unicode
    );
# 1324 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_EncodeUTF32(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors,
    int byteorder
    );
PyObject* _PyUnicode_EncodeUTF32(
    PyObject *object,
    const char *errors,
    int byteorder
    );
# 1362 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeUTF16(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder


    );

PyObject* PyUnicode_DecodeUTF16Stateful(
    const char *string,
    Py_ssize_t length,
    const char *errors,
    int *byteorder,


    Py_ssize_t *consumed
    );




PyObject* PyUnicode_AsUTF16String(
    PyObject *unicode
    );
# 1409 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_EncodeUTF16(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors,
    int byteorder
    );
PyObject* _PyUnicode_EncodeUTF16(
    PyObject* unicode,
    const char *errors,
    int byteorder
    );




PyObject* PyUnicode_DecodeUnicodeEscape(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicode_AsUnicodeEscapeString(
    PyObject *unicode
    );


PyObject* PyUnicode_EncodeUnicodeEscape(
    const Py_UNICODE *data,
    Py_ssize_t length
    );




PyObject* PyUnicode_DecodeRawUnicodeEscape(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicode_AsRawUnicodeEscapeString(
    PyObject *unicode
    );


PyObject* PyUnicode_EncodeRawUnicodeEscape(
    const Py_UNICODE *data,
    Py_ssize_t length
    );







PyObject *_PyUnicode_DecodeUnicodeInternal(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );
# 1478 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeLatin1(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicode_AsLatin1String(
    PyObject *unicode
    );


PyObject* _PyUnicode_AsLatin1String(
    PyObject* unicode,
    const char* errors);

PyObject* PyUnicode_EncodeLatin1(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors
    );
# 1506 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeASCII(
    const char *string,
    Py_ssize_t length,
    const char *errors
    );

PyObject* PyUnicode_AsASCIIString(
    PyObject *unicode
    );


PyObject* _PyUnicode_AsASCIIString(
    PyObject* unicode,
    const char* errors);

PyObject* PyUnicode_EncodeASCII(
    const Py_UNICODE *data,
    Py_ssize_t length,
    const char *errors
    );
# 1550 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeCharmap(
    const char *string,
    Py_ssize_t length,
    PyObject *mapping,

    const char *errors
    );

PyObject* PyUnicode_AsCharmapString(
    PyObject *unicode,
    PyObject *mapping

    );


PyObject* PyUnicode_EncodeCharmap(
    const Py_UNICODE *data,
    Py_ssize_t length,
    PyObject *mapping,

    const char *errors
    );
PyObject* _PyUnicode_EncodeCharmap(
    PyObject *unicode,
    PyObject *mapping,

    const char *errors
    );
# 1594 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject * PyUnicode_TranslateCharmap(
    const Py_UNICODE *data,
    Py_ssize_t length,
    PyObject *table,
    const char *errors
    );
# 1672 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
int PyUnicode_EncodeDecimal(
    Py_UNICODE *s,
    Py_ssize_t length,
    char *output,
    const char *errors
    );
# 1687 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_TransformDecimalToASCII(
    Py_UNICODE *s,
    Py_ssize_t length
    );
# 1699 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* _PyUnicode_TransformDecimalAndSpaceToASCII(
    PyObject *unicode
    );
# 1714 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeLocaleAndSize(
    const char *str,
    Py_ssize_t len,
    const char *errors);




PyObject* PyUnicode_DecodeLocale(
    const char *str,
    const char *errors);






PyObject* PyUnicode_EncodeLocale(
    PyObject *unicode,
    const char *errors
    );






int PyUnicode_FSConverter(PyObject*, void*);




int PyUnicode_FSDecoder(PyObject*, void*);
# 1757 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeFSDefault(
    const char *s
    );
# 1768 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_DecodeFSDefaultAndSize(
    const char *s,
    Py_ssize_t size
    );
# 1780 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_EncodeFSDefault(
    PyObject *unicode
    );
# 1792 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_Concat(
    PyObject *left,
    PyObject *right
    );




void PyUnicode_Append(
    PyObject **pleft,
    PyObject *right
    );




void PyUnicode_AppendAndDel(
    PyObject **pleft,
    PyObject *right
    );
# 1824 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_Split(
    PyObject *s,
    PyObject *sep,
    Py_ssize_t maxsplit
    );






PyObject* PyUnicode_Splitlines(
    PyObject *s,
    int keepends
    );



PyObject* PyUnicode_Partition(
    PyObject *s,
    PyObject *sep
    );




PyObject* PyUnicode_RPartition(
    PyObject *s,
    PyObject *sep
    );
# 1868 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* PyUnicode_RSplit(
    PyObject *s,
    PyObject *sep,
    Py_ssize_t maxsplit
    );
# 1886 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject * PyUnicode_Translate(
    PyObject *str,
    PyObject *table,
    const char *errors
    );




PyObject* PyUnicode_Join(
    PyObject *separator,
    PyObject *seq
    );




Py_ssize_t PyUnicode_Tailmatch(
    PyObject *str,
    PyObject *substr,
    Py_ssize_t start,
    Py_ssize_t end,
    int direction
    );





Py_ssize_t PyUnicode_Find(
    PyObject *str,
    PyObject *substr,
    Py_ssize_t start,
    Py_ssize_t end,
    int direction
    );


Py_ssize_t PyUnicode_FindChar(
    PyObject *str,
    Py_UCS4 ch,
    Py_ssize_t start,
    Py_ssize_t end,
    int direction
    );



Py_ssize_t PyUnicode_Count(
    PyObject *str,
    PyObject *substr,
    Py_ssize_t start,
    Py_ssize_t end
    );




PyObject * PyUnicode_Replace(
    PyObject *str,
    PyObject *substr,
    PyObject *replstr,
    Py_ssize_t maxcount

    );




int PyUnicode_Compare(
    PyObject *left,
    PyObject *right
    );

int PyUnicode_CompareWithASCIIString(
    PyObject *left,
    const char *right
    );
# 1981 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject * PyUnicode_RichCompare(
    PyObject *left,
    PyObject *right,
    int op
    );




PyObject * PyUnicode_Format(
    PyObject *format,
    PyObject *args
    );







int PyUnicode_Contains(
    PyObject *container,
    PyObject *element
    );




int _PyUnicode_HasNULChars(PyObject *);




int PyUnicode_IsIdentifier(PyObject *s);



PyObject * _PyUnicode_XStrip(
    PyObject *self,
    int striptype,
    PyObject *sepobj
    );






Py_ssize_t _PyUnicode_InsertThousandsGrouping(
    PyObject *unicode,
    Py_ssize_t index,
    Py_ssize_t n_buffer,
    void *digits,
    Py_ssize_t n_digits,
    Py_ssize_t min_width,
    const char *grouping,
    PyObject *thousands_sep,
    Py_UCS4 *maxchar);






extern const unsigned char _Py_ascii_whitespace[];
# 2054 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
int _PyUnicode_IsLowercase(
    Py_UCS4 ch
    );

int _PyUnicode_IsUppercase(
    Py_UCS4 ch
    );

int _PyUnicode_IsTitlecase(
    Py_UCS4 ch
    );

int _PyUnicode_IsXidStart(
    Py_UCS4 ch
    );

int _PyUnicode_IsXidContinue(
    Py_UCS4 ch
    );

int _PyUnicode_IsWhitespace(
    const Py_UCS4 ch
    );

int _PyUnicode_IsLinebreak(
    const Py_UCS4 ch
    );

Py_UCS4 _PyUnicode_ToLowercase(
    Py_UCS4 ch
    );

Py_UCS4 _PyUnicode_ToUppercase(
    Py_UCS4 ch
    );

Py_UCS4 _PyUnicode_ToTitlecase(
    Py_UCS4 ch
    );

int _PyUnicode_ToLowerFull(
    Py_UCS4 ch,
    Py_UCS4 *res
    );

int _PyUnicode_ToTitleFull(
    Py_UCS4 ch,
    Py_UCS4 *res
    );

int _PyUnicode_ToUpperFull(
    Py_UCS4 ch,
    Py_UCS4 *res
    );

int _PyUnicode_ToFoldedFull(
    Py_UCS4 ch,
    Py_UCS4 *res
    );

int _PyUnicode_IsCaseIgnorable(
    Py_UCS4 ch
    );

int _PyUnicode_IsCased(
    Py_UCS4 ch
    );

int _PyUnicode_ToDecimalDigit(
    Py_UCS4 ch
    );

int _PyUnicode_ToDigit(
    Py_UCS4 ch
    );

double _PyUnicode_ToNumeric(
    Py_UCS4 ch
    );

int _PyUnicode_IsDecimalDigit(
    Py_UCS4 ch
    );

int _PyUnicode_IsDigit(
    Py_UCS4 ch
    );

int _PyUnicode_IsNumeric(
    Py_UCS4 ch
    );

int _PyUnicode_IsPrintable(
    Py_UCS4 ch
    );

int _PyUnicode_IsAlpha(
    Py_UCS4 ch
    );

size_t Py_UNICODE_strlen(
    const Py_UNICODE *u
    );

Py_UNICODE* Py_UNICODE_strcpy(
    Py_UNICODE *s1,
    const Py_UNICODE *s2);

Py_UNICODE* Py_UNICODE_strcat(
    Py_UNICODE *s1, const Py_UNICODE *s2);

Py_UNICODE* Py_UNICODE_strncpy(
    Py_UNICODE *s1,
    const Py_UNICODE *s2,
    size_t n);

int Py_UNICODE_strcmp(
    const Py_UNICODE *s1,
    const Py_UNICODE *s2
    );

int Py_UNICODE_strncmp(
    const Py_UNICODE *s1,
    const Py_UNICODE *s2,
    size_t n
    );

Py_UNICODE* Py_UNICODE_strchr(
    const Py_UNICODE *s,
    Py_UNICODE c
    );

Py_UNICODE* Py_UNICODE_strrchr(
    const Py_UNICODE *s,
    Py_UNICODE c
    );





Py_UNICODE* PyUnicode_AsUnicodeCopy(
    PyObject *unicode
    );
# 2207 "/Users/parrt/tmp/Python-3.3.1/Include/unicodeobject.h"
PyObject* _PyUnicode_FromId(_Py_Identifier*);

void _PyUnicode_ClearStaticStrings(void);
# 77 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/longobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/longobject.h"
typedef struct _longobject PyLongObject;

extern PyTypeObject PyLong_Type;





PyObject * PyLong_FromLong(long);
PyObject * PyLong_FromUnsignedLong(unsigned long);
PyObject * PyLong_FromSize_t(size_t);
PyObject * PyLong_FromSsize_t(Py_ssize_t);
PyObject * PyLong_FromDouble(double);
long PyLong_AsLong(PyObject *);
long PyLong_AsLongAndOverflow(PyObject *, int *);
Py_ssize_t PyLong_AsSsize_t(PyObject *);
size_t PyLong_AsSize_t(PyObject *);
unsigned long PyLong_AsUnsignedLong(PyObject *);
unsigned long PyLong_AsUnsignedLongMask(PyObject *);

int _PyLong_AsInt(PyObject *);

PyObject * PyLong_GetInfo(void);
# 57 "/Users/parrt/tmp/Python-3.3.1/Include/longobject.h"
extern unsigned char _PyLong_DigitValue[256];
# 67 "/Users/parrt/tmp/Python-3.3.1/Include/longobject.h"
double _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e);


double PyLong_AsDouble(PyObject *);
PyObject * PyLong_FromVoidPtr(void *);
void * PyLong_AsVoidPtr(PyObject *);


PyObject * PyLong_FromLongLong(long long);
PyObject * PyLong_FromUnsignedLongLong(unsigned long long);
long long PyLong_AsLongLong(PyObject *);
unsigned long long PyLong_AsUnsignedLongLong(PyObject *);
unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *);
long long PyLong_AsLongLongAndOverflow(PyObject *, int *);


PyObject * PyLong_FromString(char *, char **, int);

PyObject * PyLong_FromUnicode(Py_UNICODE*, Py_ssize_t, int);
PyObject * PyLong_FromUnicodeObject(PyObject *u, int base);







int _PyLong_Sign(PyObject *v);
# 104 "/Users/parrt/tmp/Python-3.3.1/Include/longobject.h"
size_t _PyLong_NumBits(PyObject *v);







PyObject * _PyLong_DivmodNear(PyObject *, PyObject *);
# 127 "/Users/parrt/tmp/Python-3.3.1/Include/longobject.h"
PyObject * _PyLong_FromByteArray(
    const unsigned char* bytes, size_t n,
    int little_endian, int is_signed);
# 150 "/Users/parrt/tmp/Python-3.3.1/Include/longobject.h"
int _PyLong_AsByteArray(PyLongObject* v,
    unsigned char* bytes, size_t n,
    int little_endian, int is_signed);




PyObject * _PyLong_Format(PyObject *obj, int base);

int _PyLong_FormatWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    int base,
    int alternate);



int _PyLong_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);





unsigned long PyOS_strtoul(char *, char **, int);
long PyOS_strtol(char *, char **, int);
# 78 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/longintrepr.h" 1
# 49 "/Users/parrt/tmp/Python-3.3.1/Include/longintrepr.h"
typedef uint32_t digit;
typedef int32_t sdigit;
typedef uint64_t twodigits;
typedef int64_t stwodigits;
# 89 "/Users/parrt/tmp/Python-3.3.1/Include/longintrepr.h"
struct _longobject {
 PyVarObject ob_base;
 digit ob_digit[1];
};

PyLongObject * _PyLong_New(Py_ssize_t);


PyObject * _PyLong_Copy(PyLongObject *src);
# 79 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/boolobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/boolobject.h"
extern PyTypeObject PyBool_Type;







extern struct _longobject _Py_FalseStruct, _Py_TrueStruct;
# 29 "/Users/parrt/tmp/Python-3.3.1/Include/boolobject.h"
PyObject * PyBool_FromLong(long);
# 80 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/floatobject.h" 1
# 15 "/Users/parrt/tmp/Python-3.3.1/Include/floatobject.h"
typedef struct {
    PyObject ob_base;
    double ob_fval;
} PyFloatObject;


extern PyTypeObject PyFloat_Type;
# 37 "/Users/parrt/tmp/Python-3.3.1/Include/floatobject.h"
double PyFloat_GetMax(void);
double PyFloat_GetMin(void);
PyObject * PyFloat_GetInfo(void);


PyObject * PyFloat_FromString(PyObject*);


PyObject * PyFloat_FromDouble(double);



double PyFloat_AsDouble(PyObject *);
# 87 "/Users/parrt/tmp/Python-3.3.1/Include/floatobject.h"
int _PyFloat_Pack4(double x, unsigned char *p, int le);
int _PyFloat_Pack8(double x, unsigned char *p, int le);




int _PyFloat_Repr(double x, char *p, size_t len);


int _PyFloat_Digits(char *buf, double v, int *signum);
void _PyFloat_DigitsInit(void);
# 107 "/Users/parrt/tmp/Python-3.3.1/Include/floatobject.h"
double _PyFloat_Unpack4(const unsigned char *p, int le);
double _PyFloat_Unpack8(const unsigned char *p, int le);


int PyFloat_ClearFreeList(void);

void _PyFloat_DebugMallocStats(FILE* out);



int _PyFloat_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);
# 81 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/complexobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/complexobject.h"
typedef struct {
    double real;
    double imag;
} Py_complex;
# 25 "/Users/parrt/tmp/Python-3.3.1/Include/complexobject.h"
Py_complex _Py_c_sum(Py_complex, Py_complex);
Py_complex _Py_c_diff(Py_complex, Py_complex);
Py_complex _Py_c_neg(Py_complex);
Py_complex _Py_c_prod(Py_complex, Py_complex);
Py_complex _Py_c_quot(Py_complex, Py_complex);
Py_complex _Py_c_pow(Py_complex, Py_complex);
double _Py_c_abs(Py_complex);
# 41 "/Users/parrt/tmp/Python-3.3.1/Include/complexobject.h"
typedef struct {
    PyObject ob_base;
    Py_complex cval;
} PyComplexObject;


extern PyTypeObject PyComplex_Type;





PyObject * PyComplex_FromCComplex(Py_complex);

PyObject * PyComplex_FromDoubles(double real, double imag);

double PyComplex_RealAsDouble(PyObject *op);
double PyComplex_ImagAsDouble(PyObject *op);

Py_complex PyComplex_AsCComplex(PyObject *op);





int _PyComplex_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);
# 82 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/rangeobject.h" 1
# 18 "/Users/parrt/tmp/Python-3.3.1/Include/rangeobject.h"
extern PyTypeObject PyRange_Type;
extern PyTypeObject PyRangeIter_Type;
extern PyTypeObject PyLongRangeIter_Type;
# 83 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/memoryobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/memoryobject.h"
extern PyTypeObject _PyManagedBuffer_Type;

extern PyTypeObject PyMemoryView_Type;
# 23 "/Users/parrt/tmp/Python-3.3.1/Include/memoryobject.h"
PyObject * PyMemoryView_FromObject(PyObject *base);
PyObject * PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
                                               int flags);

PyObject * PyMemoryView_FromBuffer(Py_buffer *info);

PyObject * PyMemoryView_GetContiguous(PyObject *base,
                                                  int buffertype,
                                                  char order);
# 40 "/Users/parrt/tmp/Python-3.3.1/Include/memoryobject.h"
typedef struct {
    PyObject ob_base;
    int flags;
    Py_ssize_t exports;
    Py_buffer master;
} _PyManagedBufferObject;
# 58 "/Users/parrt/tmp/Python-3.3.1/Include/memoryobject.h"
typedef struct {
    PyVarObject ob_base;
    _PyManagedBufferObject *mbuf;
    Py_hash_t hash;
    int flags;
    Py_ssize_t exports;
    Py_buffer view;
    char format[3];
    PyObject *weakreflist;
    Py_ssize_t ob_array[1];
} PyMemoryViewObject;
# 84 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/tupleobject.h" 1
# 25 "/Users/parrt/tmp/Python-3.3.1/Include/tupleobject.h"
typedef struct {
    PyVarObject ob_base;
    PyObject *ob_item[1];





} PyTupleObject;


extern PyTypeObject PyTuple_Type;
extern PyTypeObject PyTupleIter_Type;





PyObject * PyTuple_New(Py_ssize_t size);
Py_ssize_t PyTuple_Size(PyObject *);
PyObject * PyTuple_GetItem(PyObject *, Py_ssize_t);
int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);
PyObject * PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);

int _PyTuple_Resize(PyObject **, Py_ssize_t);

PyObject * PyTuple_Pack(Py_ssize_t, ...);

void _PyTuple_MaybeUntrack(PyObject *);
# 65 "/Users/parrt/tmp/Python-3.3.1/Include/tupleobject.h"
int PyTuple_ClearFreeList(void);

void _PyTuple_DebugMallocStats(FILE *out);
# 85 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/listobject.h" 1
# 23 "/Users/parrt/tmp/Python-3.3.1/Include/listobject.h"
typedef struct {
    PyVarObject ob_base;

    PyObject **ob_item;
# 39 "/Users/parrt/tmp/Python-3.3.1/Include/listobject.h"
    Py_ssize_t allocated;
} PyListObject;


extern PyTypeObject PyList_Type;
extern PyTypeObject PyListIter_Type;
extern PyTypeObject PyListRevIter_Type;
extern PyTypeObject PySortWrapper_Type;





PyObject * PyList_New(Py_ssize_t size);
Py_ssize_t PyList_Size(PyObject *);
PyObject * PyList_GetItem(PyObject *, Py_ssize_t);
int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);
int PyList_Insert(PyObject *, Py_ssize_t, PyObject *);
int PyList_Append(PyObject *, PyObject *);
PyObject * PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
int PyList_Sort(PyObject *);
int PyList_Reverse(PyObject *);
PyObject * PyList_AsTuple(PyObject *);

PyObject * _PyList_Extend(PyListObject *, PyObject *);

int PyList_ClearFreeList(void);
void _PyList_DebugMallocStats(FILE *out);
# 86 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/dictobject.h" 1
# 18 "/Users/parrt/tmp/Python-3.3.1/Include/dictobject.h"
typedef struct _dictkeysobject PyDictKeysObject;




typedef struct {
    PyObject ob_base;
    Py_ssize_t ma_used;
    PyDictKeysObject *ma_keys;
    PyObject **ma_values;
} PyDictObject;



extern PyTypeObject PyDict_Type;
extern PyTypeObject PyDictIterKey_Type;
extern PyTypeObject PyDictIterValue_Type;
extern PyTypeObject PyDictIterItem_Type;
extern PyTypeObject PyDictKeys_Type;
extern PyTypeObject PyDictItems_Type;
extern PyTypeObject PyDictValues_Type;
# 51 "/Users/parrt/tmp/Python-3.3.1/Include/dictobject.h"
PyObject * PyDict_New(void);
PyObject * PyDict_GetItem(PyObject *mp, PyObject *key);
PyObject * PyDict_GetItemWithError(PyObject *mp, PyObject *key);
PyObject * _PyDict_GetItemIdWithError(PyObject *dp,
                                                  struct _Py_Identifier *key);
int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
int PyDict_DelItem(PyObject *mp, PyObject *key);
void PyDict_Clear(PyObject *mp);
int PyDict_Next(
    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);

PyDictKeysObject *_PyDict_NewKeysForClass(void);
PyObject * PyObject_GenericGetDict(PyObject *, void *);
int _PyDict_Next(
    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash);

PyObject * PyDict_Keys(PyObject *mp);
PyObject * PyDict_Values(PyObject *mp);
PyObject * PyDict_Items(PyObject *mp);
Py_ssize_t PyDict_Size(PyObject *mp);
PyObject * PyDict_Copy(PyObject *mp);
int PyDict_Contains(PyObject *mp, PyObject *key);

int _PyDict_Contains(PyObject *mp, PyObject *key, Py_hash_t hash);
PyObject * _PyDict_NewPresized(Py_ssize_t minused);
void _PyDict_MaybeUntrack(PyObject *mp);
int _PyDict_HasOnlyStringKeys(PyObject *mp);
Py_ssize_t _PyDict_KeysSize(PyDictKeysObject *keys);


int PyDict_ClearFreeList(void);



int PyDict_Update(PyObject *mp, PyObject *other);






int PyDict_Merge(PyObject *mp,
                                   PyObject *other,
                                   int override);






int PyDict_MergeFromSeq2(PyObject *d,
                                           PyObject *seq2,
                                           int override);

PyObject * PyDict_GetItemString(PyObject *dp, const char *key);
PyObject * _PyDict_GetItemId(PyObject *dp, struct _Py_Identifier *key);
int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
int _PyDict_SetItemId(PyObject *dp, struct _Py_Identifier *key, PyObject *item);
int PyDict_DelItemString(PyObject *dp, const char *key);


int _PyObjectDict_SetItem(PyTypeObject *tp, PyObject **dictptr, PyObject *name, PyObject *value);
PyObject *_PyDict_LoadGlobal(PyDictObject *, PyDictObject *, PyObject *);
void _PyDict_DebugMallocStats(FILE *out);
# 87 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/enumobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/enumobject.h"
extern PyTypeObject PyEnum_Type;
extern PyTypeObject PyReversed_Type;
# 88 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/setobject.h" 1
# 24 "/Users/parrt/tmp/Python-3.3.1/Include/setobject.h"
typedef struct {

    Py_hash_t hash;
    PyObject *key;
} setentry;






typedef struct _setobject PySetObject;
struct _setobject {
    PyObject ob_base;

    Py_ssize_t fill;
    Py_ssize_t used;





    Py_ssize_t mask;





    setentry *table;
    setentry *(*lookup)(PySetObject *so, PyObject *key, Py_hash_t hash);
    setentry smalltable[8];

    Py_hash_t hash;
    PyObject *weakreflist;
};


extern PyTypeObject PySet_Type;
extern PyTypeObject PyFrozenSet_Type;
extern PyTypeObject PySetIter_Type;
# 86 "/Users/parrt/tmp/Python-3.3.1/Include/setobject.h"
PyObject * PySet_New(PyObject *);
PyObject * PyFrozenSet_New(PyObject *);
Py_ssize_t PySet_Size(PyObject *anyset);



int PySet_Clear(PyObject *set);
int PySet_Contains(PyObject *anyset, PyObject *key);
int PySet_Discard(PyObject *set, PyObject *key);
int PySet_Add(PyObject *set, PyObject *key);

int _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash);

PyObject * PySet_Pop(PyObject *set);

int _PySet_Update(PyObject *set, PyObject *iterable);

int PySet_ClearFreeList(void);
void _PySet_DebugMallocStats(FILE *out);
# 89 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/methodobject.h" 1
# 14 "/Users/parrt/tmp/Python-3.3.1/Include/methodobject.h"
extern PyTypeObject PyCFunction_Type;



typedef PyObject *(*PyCFunction)(PyObject *, PyObject *);
typedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *,
                                             PyObject *);
typedef PyObject *(*PyNoArgsFunction)(PyObject *);

PyCFunction PyCFunction_GetFunction(PyObject *);
PyObject * PyCFunction_GetSelf(PyObject *);
int PyCFunction_GetFlags(PyObject *);
# 38 "/Users/parrt/tmp/Python-3.3.1/Include/methodobject.h"
PyObject * PyCFunction_Call(PyObject *, PyObject *, PyObject *);

struct PyMethodDef {
    const char *ml_name;
    PyCFunction ml_meth;
    int ml_flags;

    const char *ml_doc;
};
typedef struct PyMethodDef PyMethodDef;


PyObject * PyCFunction_NewEx(PyMethodDef *, PyObject *,
                                         PyObject *);
# 75 "/Users/parrt/tmp/Python-3.3.1/Include/methodobject.h"
typedef struct {
    PyObject ob_base;
    PyMethodDef *m_ml;
    PyObject *m_self;
    PyObject *m_module;
} PyCFunctionObject;


int PyCFunction_ClearFreeList(void);


void _PyCFunction_DebugMallocStats(FILE *out);
void _PyMethod_DebugMallocStats(FILE *out);
# 90 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/moduleobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/moduleobject.h"
extern PyTypeObject PyModule_Type;




PyObject * PyModule_NewObject(
    PyObject *name
    );
PyObject * PyModule_New(
    const char *name
    );
PyObject * PyModule_GetDict(PyObject *);
PyObject * PyModule_GetNameObject(PyObject *);
const char * PyModule_GetName(PyObject *);
const char * PyModule_GetFilename(PyObject *);
PyObject * PyModule_GetFilenameObject(PyObject *);

void _PyModule_Clear(PyObject *);

struct PyModuleDef* PyModule_GetDef(PyObject*);
void* PyModule_GetState(PyObject*);

typedef struct PyModuleDef_Base {
  PyObject ob_base;
  PyObject* (*m_init)(void);
  Py_ssize_t m_index;
  PyObject* m_copy;
} PyModuleDef_Base;
# 46 "/Users/parrt/tmp/Python-3.3.1/Include/moduleobject.h"
typedef struct PyModuleDef{
  PyModuleDef_Base m_base;
  const char* m_name;
  const char* m_doc;
  Py_ssize_t m_size;
  PyMethodDef *m_methods;
  inquiry m_reload;
  traverseproc m_traverse;
  inquiry m_clear;
  freefunc m_free;
}PyModuleDef;
# 91 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/funcobject.h" 1
# 21 "/Users/parrt/tmp/Python-3.3.1/Include/funcobject.h"
typedef struct {
    PyObject ob_base;
    PyObject *func_code;
    PyObject *func_globals;
    PyObject *func_defaults;
    PyObject *func_kwdefaults;
    PyObject *func_closure;
    PyObject *func_doc;
    PyObject *func_name;
    PyObject *func_dict;
    PyObject *func_weakreflist;
    PyObject *func_module;
    PyObject *func_annotations;
    PyObject *func_qualname;






} PyFunctionObject;

extern PyTypeObject PyFunction_Type;



PyObject * PyFunction_New(PyObject *, PyObject *);
PyObject * PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);
PyObject * PyFunction_GetCode(PyObject *);
PyObject * PyFunction_GetGlobals(PyObject *);
PyObject * PyFunction_GetModule(PyObject *);
PyObject * PyFunction_GetDefaults(PyObject *);
int PyFunction_SetDefaults(PyObject *, PyObject *);
PyObject * PyFunction_GetKwDefaults(PyObject *);
int PyFunction_SetKwDefaults(PyObject *, PyObject *);
PyObject * PyFunction_GetClosure(PyObject *);
int PyFunction_SetClosure(PyObject *, PyObject *);
PyObject * PyFunction_GetAnnotations(PyObject *);
int PyFunction_SetAnnotations(PyObject *, PyObject *);
# 79 "/Users/parrt/tmp/Python-3.3.1/Include/funcobject.h"
extern PyTypeObject PyClassMethod_Type;
extern PyTypeObject PyStaticMethod_Type;

PyObject * PyClassMethod_New(PyObject *);
PyObject * PyStaticMethod_New(PyObject *);
# 92 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/classobject.h" 1
# 12 "/Users/parrt/tmp/Python-3.3.1/Include/classobject.h"
typedef struct {
    PyObject ob_base;
    PyObject *im_func;
    PyObject *im_self;
    PyObject *im_weakreflist;
} PyMethodObject;

extern PyTypeObject PyMethod_Type;



PyObject * PyMethod_New(PyObject *, PyObject *);

PyObject * PyMethod_Function(PyObject *);
PyObject * PyMethod_Self(PyObject *);
# 35 "/Users/parrt/tmp/Python-3.3.1/Include/classobject.h"
int PyMethod_ClearFreeList(void);

typedef struct {
 PyObject ob_base;
 PyObject *func;
} PyInstanceMethodObject;

extern PyTypeObject PyInstanceMethod_Type;



PyObject * PyInstanceMethod_New(PyObject *);
PyObject * PyInstanceMethod_Function(PyObject *);
# 93 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/fileobject.h" 1
# 11 "/Users/parrt/tmp/Python-3.3.1/Include/fileobject.h"
PyObject * PyFile_FromFd(int, char *, char *, int, char *, char *,
         char *, int);
PyObject * PyFile_GetLine(PyObject *, int);
int PyFile_WriteObject(PyObject *, PyObject *, int);
int PyFile_WriteString(const char *, PyObject *);
int PyObject_AsFileDescriptor(PyObject *);

char * Py_UniversalNewlineFgets(char *, int, FILE*, PyObject *);





extern const char * Py_FileSystemDefaultEncoding;
extern int Py_HasFileSystemDefaultEncoding;






PyObject * PyFile_NewStdPrinter(int);
extern PyTypeObject PyStdPrinter_Type;
# 94 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pycapsule.h" 1
# 21 "/Users/parrt/tmp/Python-3.3.1/Include/pycapsule.h"
extern PyTypeObject PyCapsule_Type;

typedef void (*PyCapsule_Destructor)(PyObject *);




PyObject * PyCapsule_New(
    void *pointer,
    const char *name,
    PyCapsule_Destructor destructor);

void * PyCapsule_GetPointer(PyObject *capsule, const char *name);

PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule);

const char * PyCapsule_GetName(PyObject *capsule);

void * PyCapsule_GetContext(PyObject *capsule);

int PyCapsule_IsValid(PyObject *capsule, const char *name);

int PyCapsule_SetPointer(PyObject *capsule, void *pointer);

int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor);

int PyCapsule_SetName(PyObject *capsule, const char *name);

int PyCapsule_SetContext(PyObject *capsule, void *context);

void * PyCapsule_Import(
    const char *name,
    int no_block);
# 95 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/traceback.h" 1







# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pystate.h" 1
# 13 "/Users/parrt/tmp/Python-3.3.1/Include/pystate.h"
struct _ts;
struct _is;




typedef struct _is {

    struct _is *next;
    struct _ts *tstate_head;

    PyObject *modules;
    PyObject *modules_by_index;
    PyObject *sysdict;
    PyObject *builtins;
    PyObject *importlib;

    PyObject *codec_search_path;
    PyObject *codec_search_cache;
    PyObject *codec_error_registry;
    int codecs_initialized;
    int fscodec_initialized;



    int dlopenflags;





} PyInterpreterState;





struct _frame;



typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);
# 69 "/Users/parrt/tmp/Python-3.3.1/Include/pystate.h"
typedef struct _ts {


    struct _ts *next;
    PyInterpreterState *interp;

    struct _frame *frame;
    int recursion_depth;
    char overflowed;

    char recursion_critical;




    int tracing;
    int use_tracing;

    Py_tracefunc c_profilefunc;
    Py_tracefunc c_tracefunc;
    PyObject *c_profileobj;
    PyObject *c_traceobj;

    PyObject *curexc_type;
    PyObject *curexc_value;
    PyObject *curexc_traceback;

    PyObject *exc_type;
    PyObject *exc_value;
    PyObject *exc_traceback;

    PyObject *dict;
# 110 "/Users/parrt/tmp/Python-3.3.1/Include/pystate.h"
    int tick_counter;

    int gilstate_counter;

    PyObject *async_exc;
    long thread_id;

    int trash_delete_nesting;
    PyObject *trash_delete_later;



} PyThreadState;



PyInterpreterState * PyInterpreterState_New(void);
void PyInterpreterState_Clear(PyInterpreterState *);
void PyInterpreterState_Delete(PyInterpreterState *);
int _PyState_AddModule(PyObject*, struct PyModuleDef*);


int PyState_AddModule(PyObject*, struct PyModuleDef*);
int PyState_RemoveModule(struct PyModuleDef*);

PyObject* PyState_FindModule(struct PyModuleDef*);

PyThreadState * PyThreadState_New(PyInterpreterState *);
PyThreadState * _PyThreadState_Prealloc(PyInterpreterState *);
void _PyThreadState_Init(PyThreadState *);
void PyThreadState_Clear(PyThreadState *);
void PyThreadState_Delete(PyThreadState *);

void PyThreadState_DeleteCurrent(void);
void _PyGILState_Reinit(void);


PyThreadState * PyThreadState_Get(void);
PyThreadState * PyThreadState_Swap(PyThreadState *);
PyObject * PyThreadState_GetDict(void);
int PyThreadState_SetAsyncExc(long, PyObject *);







extern _Py_atomic_address _PyThreadState_Current;
# 168 "/Users/parrt/tmp/Python-3.3.1/Include/pystate.h"
typedef
    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
        PyGILState_STATE;
# 195 "/Users/parrt/tmp/Python-3.3.1/Include/pystate.h"
PyGILState_STATE PyGILState_Ensure(void);
# 205 "/Users/parrt/tmp/Python-3.3.1/Include/pystate.h"
void PyGILState_Release(PyGILState_STATE);







PyThreadState * PyGILState_GetThisThreadState(void);







PyObject * _PyThread_CurrentFrames(void);





PyInterpreterState * PyInterpreterState_Head(void);
PyInterpreterState * PyInterpreterState_Next(PyInterpreterState *);
PyThreadState * PyInterpreterState_ThreadHead(PyInterpreterState *);
PyThreadState * PyThreadState_Next(PyThreadState *);

typedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);




extern PyThreadFrameGetter _PyThreadState_GetFrame;
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/traceback.h" 2

struct _frame;



typedef struct _traceback {
    PyObject ob_base;
    struct _traceback *tb_next;
    struct _frame *tb_frame;
    int tb_lasti;
    int tb_lineno;
} PyTracebackObject;


int PyTraceBack_Here(struct _frame *);
int PyTraceBack_Print(PyObject *, PyObject *);

int _Py_DisplaySourceLine(PyObject *, PyObject *, int, int);



extern PyTypeObject PyTraceBack_Type;
# 50 "/Users/parrt/tmp/Python-3.3.1/Include/traceback.h"
extern void _Py_DumpTraceback(
    int fd,
    PyThreadState *tstate);
# 64 "/Users/parrt/tmp/Python-3.3.1/Include/traceback.h"
extern const char* _Py_DumpTracebackThreads(
    int fd, PyInterpreterState *interp,
    PyThreadState *current_thread);
# 96 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/sliceobject.h" 1
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/sliceobject.h"
extern PyObject _Py_EllipsisObject;
# 22 "/Users/parrt/tmp/Python-3.3.1/Include/sliceobject.h"
typedef struct {
    PyObject ob_base;
    PyObject *start, *stop, *step;
} PySliceObject;


extern PyTypeObject PySlice_Type;
extern PyTypeObject PyEllipsis_Type;



PyObject * PySlice_New(PyObject* start, PyObject* stop,
                                  PyObject* step);

PyObject * _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);

int PySlice_GetIndices(PyObject *r, Py_ssize_t length,
                                  Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step);
int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length,
        Py_ssize_t *start, Py_ssize_t *stop,
        Py_ssize_t *step, Py_ssize_t *slicelength);
# 97 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/cellobject.h" 1
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/cellobject.h"
typedef struct {
 PyObject ob_base;
 PyObject *ob_ref;
} PyCellObject;

extern PyTypeObject PyCell_Type;



PyObject * PyCell_New(PyObject *);
PyObject * PyCell_Get(PyObject *);
int PyCell_Set(PyObject *, PyObject *);
# 98 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/iterobject.h" 1







extern PyTypeObject PySeqIter_Type;
extern PyTypeObject PyCallIter_Type;
extern PyTypeObject PyCmpWrapper_Type;



PyObject * PySeqIter_New(PyObject *);




PyObject * PyCallIter_New(PyObject *, PyObject *);
# 99 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/genobject.h" 1
# 11 "/Users/parrt/tmp/Python-3.3.1/Include/genobject.h"
struct _frame;

typedef struct {
    PyObject ob_base;



    struct _frame *gi_frame;


    char gi_running;


    PyObject *gi_code;


    PyObject *gi_weakreflist;
} PyGenObject;

extern PyTypeObject PyGen_Type;




PyObject * PyGen_New(struct _frame *);
int PyGen_NeedsFinalizing(PyGenObject *);
int _PyGen_FetchStopIterationValue(PyObject **);
PyObject *_PyGen_Send(PyGenObject *, PyObject *);
# 100 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/descrobject.h" 1







typedef PyObject *(*getter)(PyObject *, void *);
typedef int (*setter)(PyObject *, PyObject *, void *);

typedef struct PyGetSetDef {
    char *name;
    getter get;
    setter set;
    char *doc;
    void *closure;
} PyGetSetDef;


typedef PyObject *(*wrapperfunc)(PyObject *self, PyObject *args,
                                 void *wrapped);

typedef PyObject *(*wrapperfunc_kwds)(PyObject *self, PyObject *args,
                                      void *wrapped, PyObject *kwds);

struct wrapperbase {
    char *name;
    int offset;
    void *function;
    wrapperfunc wrapper;
    char *doc;
    int flags;
    PyObject *name_strobj;
};






typedef struct {
    PyObject ob_base;
    PyTypeObject *d_type;
    PyObject *d_name;
    PyObject *d_qualname;
} PyDescrObject;






typedef struct {
    PyDescrObject d_common;
    PyMethodDef *d_method;
} PyMethodDescrObject;

typedef struct {
    PyDescrObject d_common;
    struct PyMemberDef *d_member;
} PyMemberDescrObject;

typedef struct {
    PyDescrObject d_common;
    PyGetSetDef *d_getset;
} PyGetSetDescrObject;

typedef struct {
    PyDescrObject d_common;
    struct wrapperbase *d_base;
    void *d_wrapped;
} PyWrapperDescrObject;


extern PyTypeObject PyClassMethodDescr_Type;
extern PyTypeObject PyGetSetDescr_Type;
extern PyTypeObject PyMemberDescr_Type;
extern PyTypeObject PyMethodDescr_Type;
extern PyTypeObject PyWrapperDescr_Type;
extern PyTypeObject PyDictProxy_Type;
extern PyTypeObject _PyMethodWrapper_Type;

PyObject * PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
PyObject * PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
struct PyMemberDef;
PyObject * PyDescr_NewMember(PyTypeObject *,
                                               struct PyMemberDef *);
PyObject * PyDescr_NewGetSet(PyTypeObject *,
                                               struct PyGetSetDef *);

PyObject * PyDescr_NewWrapper(PyTypeObject *,
                                                struct wrapperbase *, void *);



PyObject * PyDictProxy_New(PyObject *);
PyObject * PyWrapper_New(PyObject *, PyObject *);


extern PyTypeObject PyProperty_Type;
# 101 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/warnings.h" 1







PyObject* _PyWarnings_Init(void);


int PyErr_WarnEx(
    PyObject *category,
    const char *message,
    Py_ssize_t stack_level);
int PyErr_WarnFormat(
    PyObject *category,
    Py_ssize_t stack_level,
    const char *format,
    ...);
int PyErr_WarnExplicit(
    PyObject *category,
    const char *message,
    const char *filename,
    int lineno,
    const char *module,
    PyObject *registry);
# 102 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/weakrefobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/weakrefobject.h"
typedef struct _PyWeakReference PyWeakReference;





struct _PyWeakReference {
    PyObject ob_base;





    PyObject *wr_object;


    PyObject *wr_callback;




    Py_hash_t hash;






    PyWeakReference *wr_prev;
    PyWeakReference *wr_next;
};


extern PyTypeObject _PyWeakref_RefType;
extern PyTypeObject _PyWeakref_ProxyType;
extern PyTypeObject _PyWeakref_CallableProxyType;
# 61 "/Users/parrt/tmp/Python-3.3.1/Include/weakrefobject.h"
PyObject * PyWeakref_NewRef(PyObject *ob,
                                              PyObject *callback);
PyObject * PyWeakref_NewProxy(PyObject *ob,
                                                PyObject *callback);
PyObject * PyWeakref_GetObject(PyObject *ref);


Py_ssize_t _PyWeakref_GetWeakrefCount(PyWeakReference *head);

void _PyWeakref_ClearRef(PyWeakReference *self);
# 103 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/structseq.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/structseq.h"
typedef struct PyStructSequence_Field {
    char *name;
    char *doc;
} PyStructSequence_Field;

typedef struct PyStructSequence_Desc {
    char *name;
    char *doc;
    struct PyStructSequence_Field *fields;
    int n_in_sequence;
} PyStructSequence_Desc;

extern char* PyStructSequence_UnnamedField;


void PyStructSequence_InitType(PyTypeObject *type,
                                           PyStructSequence_Desc *desc);

PyTypeObject* PyStructSequence_NewType(PyStructSequence_Desc *desc);

PyObject * PyStructSequence_New(PyTypeObject* type);


typedef PyTupleObject PyStructSequence;







void PyStructSequence_SetItem(PyObject*, Py_ssize_t, PyObject*);
PyObject* PyStructSequence_GetItem(PyObject*, Py_ssize_t);
# 104 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/namespaceobject.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/namespaceobject.h"
extern PyTypeObject _PyNamespace_Type;

PyObject * _PyNamespace_New(PyObject *kwds);
# 105 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h" 1
# 26 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h"
int PyCodec_Register(
       PyObject *search_function
       );
# 49 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h"
PyObject * _PyCodec_Lookup(
       const char *encoding
       );
# 61 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h"
int PyCodec_KnownEncoding(
       const char *encoding
       );
# 75 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h"
PyObject * PyCodec_Encode(
       PyObject *object,
       const char *encoding,
       const char *errors
       );
# 91 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h"
PyObject * PyCodec_Decode(
       PyObject *object,
       const char *encoding,
       const char *errors
       );
# 107 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h"
PyObject * PyCodec_Encoder(
       const char *encoding
       );



PyObject * PyCodec_Decoder(
       const char *encoding
       );



PyObject * PyCodec_IncrementalEncoder(
       const char *encoding,
       const char *errors
       );



PyObject * PyCodec_IncrementalDecoder(
       const char *encoding,
       const char *errors
       );



PyObject * PyCodec_StreamReader(
       const char *encoding,
       PyObject *stream,
       const char *errors
       );



PyObject * PyCodec_StreamWriter(
       const char *encoding,
       PyObject *stream,
       const char *errors
       );
# 155 "/Users/parrt/tmp/Python-3.3.1/Include/codecs.h"
int PyCodec_RegisterError(const char *name, PyObject *error);




PyObject * PyCodec_LookupError(const char *name);


PyObject * PyCodec_StrictErrors(PyObject *exc);


PyObject * PyCodec_IgnoreErrors(PyObject *exc);


PyObject * PyCodec_ReplaceErrors(PyObject *exc);


PyObject * PyCodec_XMLCharRefReplaceErrors(PyObject *exc);


PyObject * PyCodec_BackslashReplaceErrors(PyObject *exc);

extern const char * Py_hexdigits;
# 107 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pyerrors.h" 1
# 16 "/Users/parrt/tmp/Python-3.3.1/Include/pyerrors.h"
typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
} PyBaseExceptionObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *msg;
    PyObject *filename;
    PyObject *lineno;
    PyObject *offset;
    PyObject *text;
    PyObject *print_file_and_line;
} PySyntaxErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *msg;
    PyObject *name;
    PyObject *path;
} PyImportErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *encoding;
    PyObject *object;
    Py_ssize_t start;
    Py_ssize_t end;
    PyObject *reason;
} PyUnicodeErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *code;
} PySystemExitObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *myerrno;
    PyObject *strerror;
    PyObject *filename;



    Py_ssize_t written;
} PyOSErrorObject;

typedef struct {
    PyObject ob_base; PyObject *dict; PyObject *args; PyObject *traceback; PyObject *context; PyObject *cause; char suppress_context;
    PyObject *value;
} PyStopIterationObject;


typedef PyOSErrorObject PyEnvironmentErrorObject;







void PyErr_SetNone(PyObject *);
void PyErr_SetObject(PyObject *, PyObject *);
void PyErr_SetString(
    PyObject *exception,
    const char *string
    );
PyObject * PyErr_Occurred(void);
void PyErr_Clear(void);
void PyErr_Fetch(PyObject **, PyObject **, PyObject **);
void PyErr_Restore(PyObject *, PyObject *, PyObject *);
void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **);
void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *);
# 98 "/Users/parrt/tmp/Python-3.3.1/Include/pyerrors.h"
void Py_FatalError(const char *message) ;
# 107 "/Users/parrt/tmp/Python-3.3.1/Include/pyerrors.h"
int PyErr_GivenExceptionMatches(PyObject *, PyObject *);
int PyErr_ExceptionMatches(PyObject *);
void PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);


int PyException_SetTraceback(PyObject *, PyObject *);
PyObject * PyException_GetTraceback(PyObject *);


PyObject * PyException_GetCause(PyObject *);
void PyException_SetCause(PyObject *, PyObject *);


PyObject * PyException_GetContext(PyObject *);
void PyException_SetContext(PyObject *, PyObject *);
# 141 "/Users/parrt/tmp/Python-3.3.1/Include/pyerrors.h"
extern PyObject * PyExc_BaseException;
extern PyObject * PyExc_Exception;
extern PyObject * PyExc_StopIteration;
extern PyObject * PyExc_GeneratorExit;
extern PyObject * PyExc_ArithmeticError;
extern PyObject * PyExc_LookupError;

extern PyObject * PyExc_AssertionError;
extern PyObject * PyExc_AttributeError;
extern PyObject * PyExc_BufferError;
extern PyObject * PyExc_EOFError;
extern PyObject * PyExc_FloatingPointError;
extern PyObject * PyExc_OSError;
extern PyObject * PyExc_ImportError;
extern PyObject * PyExc_IndexError;
extern PyObject * PyExc_KeyError;
extern PyObject * PyExc_KeyboardInterrupt;
extern PyObject * PyExc_MemoryError;
extern PyObject * PyExc_NameError;
extern PyObject * PyExc_OverflowError;
extern PyObject * PyExc_RuntimeError;
extern PyObject * PyExc_NotImplementedError;
extern PyObject * PyExc_SyntaxError;
extern PyObject * PyExc_IndentationError;
extern PyObject * PyExc_TabError;
extern PyObject * PyExc_ReferenceError;
extern PyObject * PyExc_SystemError;
extern PyObject * PyExc_SystemExit;
extern PyObject * PyExc_TypeError;
extern PyObject * PyExc_UnboundLocalError;
extern PyObject * PyExc_UnicodeError;
extern PyObject * PyExc_UnicodeEncodeError;
extern PyObject * PyExc_UnicodeDecodeError;
extern PyObject * PyExc_UnicodeTranslateError;
extern PyObject * PyExc_ValueError;
extern PyObject * PyExc_ZeroDivisionError;

extern PyObject * PyExc_BlockingIOError;
extern PyObject * PyExc_BrokenPipeError;
extern PyObject * PyExc_ChildProcessError;
extern PyObject * PyExc_ConnectionError;
extern PyObject * PyExc_ConnectionAbortedError;
extern PyObject * PyExc_ConnectionRefusedError;
extern PyObject * PyExc_ConnectionResetError;
extern PyObject * PyExc_FileExistsError;
extern PyObject * PyExc_FileNotFoundError;
extern PyObject * PyExc_InterruptedError;
extern PyObject * PyExc_IsADirectoryError;
extern PyObject * PyExc_NotADirectoryError;
extern PyObject * PyExc_PermissionError;
extern PyObject * PyExc_ProcessLookupError;
extern PyObject * PyExc_TimeoutError;



extern PyObject * PyExc_EnvironmentError;
extern PyObject * PyExc_IOError;







extern PyObject * PyExc_RecursionErrorInst;


extern PyObject * PyExc_Warning;
extern PyObject * PyExc_UserWarning;
extern PyObject * PyExc_DeprecationWarning;
extern PyObject * PyExc_PendingDeprecationWarning;
extern PyObject * PyExc_SyntaxWarning;
extern PyObject * PyExc_RuntimeWarning;
extern PyObject * PyExc_FutureWarning;
extern PyObject * PyExc_ImportWarning;
extern PyObject * PyExc_UnicodeWarning;
extern PyObject * PyExc_BytesWarning;
extern PyObject * PyExc_ResourceWarning;




int PyErr_BadArgument(void);
PyObject * PyErr_NoMemory(void);
PyObject * PyErr_SetFromErrno(PyObject *);
PyObject * PyErr_SetFromErrnoWithFilenameObject(
    PyObject *, PyObject *);
PyObject * PyErr_SetFromErrnoWithFilename(
    PyObject *exc,
    const char *filename
    );





PyObject * PyErr_Format(
    PyObject *exception,
    const char *format,
    ...
    );
# 268 "/Users/parrt/tmp/Python-3.3.1/Include/pyerrors.h"
PyObject * PyErr_SetExcWithArgsKwargs(PyObject *, PyObject *,
    PyObject *);
PyObject * PyErr_SetImportError(PyObject *, PyObject *,
    PyObject *);


void PyErr_BadInternalCall(void);
void _PyErr_BadInternalCall(const char *filename, int lineno);





PyObject * PyErr_NewException(
    const char *name, PyObject *base, PyObject *dict);
PyObject * PyErr_NewExceptionWithDoc(
    const char *name, const char *doc, PyObject *base, PyObject *dict);
void PyErr_WriteUnraisable(PyObject *);


int PyErr_CheckSignals(void);
void PyErr_SetInterrupt(void);



int PySignal_SetWakeupFd(int fd);



void PyErr_SyntaxLocation(
    const char *filename,
    int lineno);
void PyErr_SyntaxLocationEx(
    const char *filename,
    int lineno,
    int col_offset);
PyObject * PyErr_ProgramText(
    const char *filename,
    int lineno);





PyObject * PyUnicodeDecodeError_Create(
    const char *encoding,
    const char *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason
    );



PyObject * PyUnicodeEncodeError_Create(
    const char *encoding,
    const Py_UNICODE *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason
    );




PyObject * PyUnicodeTranslateError_Create(
    const Py_UNICODE *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason
    );
PyObject * _PyUnicodeTranslateError_Create(
    PyObject *object,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason
    );



PyObject * PyUnicodeEncodeError_GetEncoding(PyObject *);
PyObject * PyUnicodeDecodeError_GetEncoding(PyObject *);


PyObject * PyUnicodeEncodeError_GetObject(PyObject *);
PyObject * PyUnicodeDecodeError_GetObject(PyObject *);
PyObject * PyUnicodeTranslateError_GetObject(PyObject *);



int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *);
int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *);
int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *);



int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t);
int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t);
int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t);



int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *);
int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *);
int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *);



int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t);
int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t);
int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);


PyObject * PyUnicodeEncodeError_GetReason(PyObject *);
PyObject * PyUnicodeDecodeError_GetReason(PyObject *);
PyObject * PyUnicodeTranslateError_GetReason(PyObject *);



int PyUnicodeEncodeError_SetReason(
    PyObject *exc,
    const char *reason
    );
int PyUnicodeDecodeError_SetReason(
    PyObject *exc,
    const char *reason
    );
int PyUnicodeTranslateError_SetReason(
    PyObject *exc,
    const char *reason
    );
# 418 "/Users/parrt/tmp/Python-3.3.1/Include/pyerrors.h"
int PyOS_snprintf(char *str, size_t size, const char *format, ...)
                        __attribute__((format(printf, 3, 4)));
int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
                        __attribute__((format(printf, 3, 0)));
# 108 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2



# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pyarena.h" 1
# 12 "/Users/parrt/tmp/Python-3.3.1/Include/pyarena.h"
  typedef struct _arena PyArena;
# 36 "/Users/parrt/tmp/Python-3.3.1/Include/pyarena.h"
  PyArena * PyArena_New(void);
  void PyArena_Free(PyArena *);
# 51 "/Users/parrt/tmp/Python-3.3.1/Include/pyarena.h"
  void * PyArena_Malloc(PyArena *, size_t size);





  int PyArena_AddPyObject(PyArena *, PyObject *);
# 112 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/modsupport.h" 1
# 28 "/Users/parrt/tmp/Python-3.3.1/Include/modsupport.h"
int _PyArg_Parse_SizeT(PyObject *, const char *, ...);
int _PyArg_ParseTuple_SizeT(PyObject *, const char *, ...) ;
int _PyArg_ParseTupleAndKeywords_SizeT(PyObject *, PyObject *,
                                                  const char *, char **, ...);
int PyArg_ValidateKeywordArguments(PyObject *);
int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);
PyObject * _Py_BuildValue_SizeT(const char *, ...);
PyObject * _Py_BuildValue_SizeT(const char *, ...);


int _PyArg_NoKeywords(const char *funcname, PyObject *kw);

int _PyArg_VaParse_SizeT(PyObject *, const char *, va_list);
int _PyArg_VaParseTupleAndKeywords_SizeT(PyObject *, PyObject *,
                                                  const char *, char **, va_list);

PyObject * _Py_VaBuildValue_SizeT(const char *, va_list);

int PyModule_AddObject(PyObject *, const char *, PyObject *);
int PyModule_AddIntConstant(PyObject *, const char *, long);
int PyModule_AddStringConstant(PyObject *, const char *, const char *);
# 113 "/Users/parrt/tmp/Python-3.3.1/Include/modsupport.h"
PyObject * PyModule_Create2(struct PyModuleDef*,
                                     int apiver);
# 125 "/Users/parrt/tmp/Python-3.3.1/Include/modsupport.h"
extern char * _Py_PackageContext;
# 113 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pythonrun.h" 1
# 20 "/Users/parrt/tmp/Python-3.3.1/Include/pythonrun.h"
typedef struct {
    int cf_flags;
} PyCompilerFlags;


void Py_SetProgramName(wchar_t *);
wchar_t * Py_GetProgramName(void);

void Py_SetPythonHome(wchar_t *);
wchar_t * Py_GetPythonHome(void);

void Py_Initialize(void);
void Py_InitializeEx(int);

void _Py_InitializeEx_Private(int, int);

void Py_Finalize(void);
int Py_IsInitialized(void);
PyThreadState * Py_NewInterpreter(void);
void Py_EndInterpreter(PyThreadState *);


int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
int PyRun_AnyFileExFlags(
    FILE *fp,
    const char *filename,
    int closeit,
    PyCompilerFlags *flags);
int PyRun_SimpleFileExFlags(
    FILE *fp,
    const char *filename,
    int closeit,
    PyCompilerFlags *flags);
int PyRun_InteractiveOneFlags(
    FILE *fp,
    const char *filename,
    PyCompilerFlags *flags);
int PyRun_InteractiveLoopFlags(
    FILE *fp,
    const char *filename,
    PyCompilerFlags *flags);

struct _mod * PyParser_ASTFromString(
    const char *s,
    const char *filename,
    int start,
    PyCompilerFlags *flags,
    PyArena *arena);
struct _mod * PyParser_ASTFromFile(
    FILE *fp,
    const char *filename,
    const char* enc,
    int start,
    char *ps1,
    char *ps2,
    PyCompilerFlags *flags,
    int *errcode,
    PyArena *arena);
# 87 "/Users/parrt/tmp/Python-3.3.1/Include/pythonrun.h"
struct _node * PyParser_SimpleParseStringFlags(const char *, int,
                                                           int);
struct _node * PyParser_SimpleParseStringFlagsFilename(const char *,
                                                                   const char *,
                                                                   int, int);
struct _node * PyParser_SimpleParseFileFlags(FILE *, const char *,
                                                         int, int);


PyObject * PyRun_StringFlags(const char *, int, PyObject *,
                                         PyObject *, PyCompilerFlags *);

PyObject * PyRun_FileExFlags(
    FILE *fp,
    const char *filename,
    int start,
    PyObject *globals,
    PyObject *locals,
    int closeit,
    PyCompilerFlags *flags);







PyObject * Py_CompileStringExFlags(
    const char *str,
    const char *filename,
    int start,
    PyCompilerFlags *flags,
    int optimize);

struct symtable * Py_SymtableString(
    const char *str,
    const char *filename,
    int start);

void PyErr_Print(void);
void PyErr_PrintEx(int);
void PyErr_Display(PyObject *, PyObject *, PyObject *);





void _Py_PyAtExit(void (*func)(void));

int Py_AtExit(void (*func)(void));

void Py_Exit(int);



void _Py_RestoreSignals(void);

int Py_FdIsInteractive(FILE *, const char *);



int Py_Main(int argc, wchar_t **argv);
# 172 "/Users/parrt/tmp/Python-3.3.1/Include/pythonrun.h"
wchar_t * Py_GetProgramFullPath(void);
wchar_t * Py_GetPrefix(void);
wchar_t * Py_GetExecPrefix(void);
wchar_t * Py_GetPath(void);
void Py_SetPath(const wchar_t *);





const char * Py_GetVersion(void);
const char * Py_GetPlatform(void);
const char * Py_GetCopyright(void);
const char * Py_GetCompiler(void);
const char * Py_GetBuildInfo(void);

const char * _Py_hgidentifier(void);
const char * _Py_hgversion(void);




PyObject * _PyBuiltin_Init(void);
PyObject * _PySys_Init(void);
void _PyImport_Init(void);
void _PyExc_Init(PyObject * bltinmod);
void _PyImportHooks_Init(void);
int _PyFrame_Init(void);
void _PyFloat_Init(void);
int PyByteArray_Init(void);
void _PyRandom_Init(void);




void _PyExc_Fini(void);
void _PyImport_Fini(void);
void PyMethod_Fini(void);
void PyFrame_Fini(void);
void PyCFunction_Fini(void);
void PyDict_Fini(void);
void PyTuple_Fini(void);
void PyList_Fini(void);
void PySet_Fini(void);
void PyBytes_Fini(void);
void PyByteArray_Fini(void);
void PyFloat_Fini(void);
void PyOS_FiniInterrupts(void);
void _PyGC_Fini(void);
void PySlice_Fini(void);

extern PyThreadState * _Py_Finalizing;




char * PyOS_Readline(FILE *, FILE *, char *);

extern int (*PyOS_InputHook)(void);
extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, char *);

extern PyThreadState* _PyOS_ReadlineTState;
# 252 "/Users/parrt/tmp/Python-3.3.1/Include/pythonrun.h"
typedef void (*PyOS_sighandler_t)(int);
PyOS_sighandler_t PyOS_getsig(int);
PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t);


int _PyOS_URandom (void *buffer, Py_ssize_t size);
# 114 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/ceval.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/ceval.h"
PyObject * PyEval_CallObjectWithKeywords(
    PyObject *, PyObject *, PyObject *);





PyObject * PyEval_CallFunction(PyObject *obj,
                                           const char *format, ...);
PyObject * PyEval_CallMethod(PyObject *obj,
                                         const char *methodname,
                                         const char *format, ...);


void PyEval_SetProfile(Py_tracefunc, PyObject *);
void PyEval_SetTrace(Py_tracefunc, PyObject *);


struct _frame;

PyObject * PyEval_GetBuiltins(void);
PyObject * PyEval_GetGlobals(void);
PyObject * PyEval_GetLocals(void);
struct _frame * PyEval_GetFrame(void);





int PyEval_MergeCompilerFlags(PyCompilerFlags *cf);


int Py_AddPendingCall(int (*func)(void *), void *arg);
int Py_MakePendingCalls(void);
# 70 "/Users/parrt/tmp/Python-3.3.1/Include/ceval.h"
void Py_SetRecursionLimit(int);
int Py_GetRecursionLimit(void);
# 80 "/Users/parrt/tmp/Python-3.3.1/Include/ceval.h"
int _Py_CheckRecursiveCall(char *where);
extern int _Py_CheckRecursionLimit;
# 108 "/Users/parrt/tmp/Python-3.3.1/Include/ceval.h"
const char * PyEval_GetFuncName(PyObject *);
const char * PyEval_GetFuncDesc(PyObject *);

PyObject * PyEval_GetCallStats(PyObject *);
PyObject * PyEval_EvalFrame(struct _frame *);
PyObject * PyEval_EvalFrameEx(struct _frame *f, int exc);
# 160 "/Users/parrt/tmp/Python-3.3.1/Include/ceval.h"
PyThreadState * PyEval_SaveThread(void);
void PyEval_RestoreThread(PyThreadState *);



int PyEval_ThreadsInitialized(void);
void PyEval_InitThreads(void);
void _PyEval_FiniThreads(void);
void PyEval_AcquireLock(void);
void PyEval_ReleaseLock(void);
void PyEval_AcquireThread(PyThreadState *tstate);
void PyEval_ReleaseThread(PyThreadState *tstate);
void PyEval_ReInitThreads(void);


void _PyEval_SetSwitchInterval(unsigned long microseconds);
unsigned long _PyEval_GetSwitchInterval(void);
# 197 "/Users/parrt/tmp/Python-3.3.1/Include/ceval.h"
int _PyEval_SliceIndex(PyObject *, Py_ssize_t *);
void _PyEval_SignalAsyncExc(void);
# 115 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/sysmodule.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/sysmodule.h"
PyObject * PySys_GetObject(const char *);
int PySys_SetObject(const char *, PyObject *);
void PySys_SetArgv(int, wchar_t **);
void PySys_SetArgvEx(int, wchar_t **, int);
void PySys_SetPath(const wchar_t *);

void PySys_WriteStdout(const char *format, ...)
                 __attribute__((format(printf, 1, 2)));
void PySys_WriteStderr(const char *format, ...)
                 __attribute__((format(printf, 1, 2)));
void PySys_FormatStdout(const char *format, ...);
void PySys_FormatStderr(const char *format, ...);

void PySys_ResetWarnOptions(void);
void PySys_AddWarnOption(const wchar_t *);
void PySys_AddWarnOptionUnicode(PyObject *);
int PySys_HasWarnOptions(void);

void PySys_AddXOption(const wchar_t *);
PyObject * PySys_GetXOptions(void);
# 116 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/intrcheck.h" 1







int PyOS_InterruptOccurred(void);
void PyOS_InitInterrupts(void);
void PyOS_AfterFork(void);
int _PyOS_IsMainThread(void);
# 117 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/import.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/import.h"
void _PyImportZip_Init(void);

PyObject* PyInit_imp(void);
long PyImport_GetMagicNumber(void);
const char * PyImport_GetMagicTag(void);
PyObject * PyImport_ExecCodeModule(
    char *name,
    PyObject *co
    );
PyObject * PyImport_ExecCodeModuleEx(
    char *name,
    PyObject *co,
    char *pathname
    );
PyObject * PyImport_ExecCodeModuleWithPathnames(
    char *name,
    PyObject *co,
    char *pathname,
    char *cpathname
    );
PyObject * PyImport_ExecCodeModuleObject(
    PyObject *name,
    PyObject *co,
    PyObject *pathname,
    PyObject *cpathname
    );
PyObject * PyImport_GetModuleDict(void);
PyObject * PyImport_AddModuleObject(
    PyObject *name
    );
PyObject * PyImport_AddModule(
    const char *name
    );
PyObject * PyImport_ImportModule(
    const char *name
    );
PyObject * PyImport_ImportModuleNoBlock(
    const char *name
    );
PyObject * PyImport_ImportModuleLevel(
    const char *name,
    PyObject *globals,
    PyObject *locals,
    PyObject *fromlist,
    int level
    );
PyObject * PyImport_ImportModuleLevelObject(
    PyObject *name,
    PyObject *globals,
    PyObject *locals,
    PyObject *fromlist,
    int level
    );




PyObject * PyImport_GetImporter(PyObject *path);
PyObject * PyImport_Import(PyObject *name);
PyObject * PyImport_ReloadModule(PyObject *m);
void PyImport_Cleanup(void);
int PyImport_ImportFrozenModuleObject(
    PyObject *name
    );
int PyImport_ImportFrozenModule(
    char *name
    );



void _PyImport_AcquireLock(void);
int _PyImport_ReleaseLock(void);





void _PyImport_ReInitLock(void);

PyObject *_PyImport_FindBuiltin(
    const char *name
    );
PyObject *_PyImport_FindExtensionObject(PyObject *, PyObject *);
int _PyImport_FixupBuiltin(
    PyObject *mod,
    char *name
    );
int _PyImport_FixupExtensionObject(PyObject*, PyObject *, PyObject *);

struct _inittab {
    char *name;
    PyObject* (*initfunc)(void);
};
extern struct _inittab * PyImport_Inittab;
int PyImport_ExtendInittab(struct _inittab *newtab);


extern PyTypeObject PyNullImporter_Type;

int PyImport_AppendInittab(
    const char *name,
    PyObject* (*initfunc)(void)
    );


struct _frozen {
    char *name;
    unsigned char *code;
    int size;
};




extern struct _frozen * PyImport_FrozenModules;
# 118 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h" 1
# 266 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyObject_Call(PyObject *callable_object,
                                          PyObject *args, PyObject *kw);







     PyObject * PyObject_CallObject(PyObject *callable_object,
                                                PyObject *args);
# 286 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * _PyObject_CallFunction_SizeT(PyObject *callable_object,
                                                  char *format, ...);
# 299 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * _PyObject_CallMethod_SizeT(PyObject *o, char *method,
                                                char *format, ...);
# 311 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * _PyObject_CallMethodId_SizeT(PyObject *o, _Py_Identifier *method,
                                                  char *format, ...);






     PyObject * _PyObject_CallFunction_SizeT(PyObject *callable,
                                                         char *format, ...);
     PyObject * _PyObject_CallMethod_SizeT(PyObject *o,
                                                       char *name,
                                                       char *format, ...);
     PyObject * _PyObject_CallMethodId_SizeT(PyObject *o,
                                                       _Py_Identifier *name,
                                                       char *format, ...);

     PyObject * PyObject_CallFunctionObjArgs(PyObject *callable,
                                                         ...);
# 340 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyObject_CallMethodObjArgs(PyObject *o,
                                                       PyObject *method, ...);
     PyObject * _PyObject_CallMethodObjIdArgs(PyObject *o,
                                               struct _Py_Identifier *method,
                                               ...);
# 384 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyObject_Type(PyObject *o);







     Py_ssize_t PyObject_Size(PyObject *o);
# 403 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     Py_ssize_t PyObject_Length(PyObject *o);



     Py_ssize_t _PyObject_LengthHint(PyObject *o, Py_ssize_t);
# 416 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyObject_GetItem(PyObject *o, PyObject *key);







     int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);







     int PyObject_DelItemString(PyObject *o, char *key);







     int PyObject_DelItem(PyObject *o, PyObject *key);
# 453 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyObject_AsCharBuffer(PyObject *obj,
                                           const char **buffer,
                                           Py_ssize_t *buffer_len);
# 468 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyObject_CheckReadBuffer(PyObject *obj);







     int PyObject_AsReadBuffer(PyObject *obj,
                                           const void **buffer,
                                           Py_ssize_t *buffer_len);
# 491 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyObject_AsWriteBuffer(PyObject *obj,
                                            void **buffer,
                                            Py_ssize_t *buffer_len);
# 515 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyObject_GetBuffer(PyObject *obj, Py_buffer *view,
                                        int flags);
# 525 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     void * PyBuffer_GetPointer(Py_buffer *view, Py_ssize_t *indices);





     int PyBuffer_SizeFromFormat(const char *);







     int PyBuffer_ToContiguous(void *buf, Py_buffer *view,
                                           Py_ssize_t len, char order);

     int PyBuffer_FromContiguous(Py_buffer *view, void *buf,
                                             Py_ssize_t len, char order);
# 562 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyObject_CopyData(PyObject *dest, PyObject *src);




     int PyBuffer_IsContiguous(const Py_buffer *view, char fort);


     void PyBuffer_FillContiguousStrides(int ndims,
                                                    Py_ssize_t *shape,
                                                    Py_ssize_t *strides,
                                                    int itemsize,
                                                    char fort);







     int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf,
                                       Py_ssize_t len, int readonly,
                                       int flags);







     void PyBuffer_Release(Py_buffer *view);





     PyObject * PyObject_Format(PyObject* obj,
                                            PyObject *format_spec);







     PyObject * PyObject_GetIter(PyObject *);
# 616 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyIter_Next(PyObject *);







     int PyNumber_Check(PyObject *o);
# 633 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyNumber_Add(PyObject *o1, PyObject *o2);






     PyObject * PyNumber_Subtract(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_Multiply(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_FloorDivide(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_TrueDivide(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_Remainder(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_Divmod(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_Power(PyObject *o1, PyObject *o2,
                                           PyObject *o3);







     PyObject * PyNumber_Negative(PyObject *o);






     PyObject * PyNumber_Positive(PyObject *o);






     PyObject * PyNumber_Absolute(PyObject *o);






     PyObject * PyNumber_Invert(PyObject *o);







     PyObject * PyNumber_Lshift(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_Rshift(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_And(PyObject *o1, PyObject *o2);
# 751 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyNumber_Xor(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_Or(PyObject *o1, PyObject *o2);
# 771 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyNumber_Index(PyObject *o);






     Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc);
# 788 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyNumber_Long(PyObject *o);







     PyObject * PyNumber_Float(PyObject *o);
# 806 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlaceFloorDivide(PyObject *o1,
                                                        PyObject *o2);
# 840 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyNumber_InPlaceTrueDivide(PyObject *o1,
                                                       PyObject *o2);
# 850 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
                                                  PyObject *o3);







     PyObject * PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);







     PyObject * PyNumber_ToBase(PyObject *n, int base);
# 918 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PySequence_Check(PyObject *o);
# 927 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     Py_ssize_t PySequence_Size(PyObject *o);







     Py_ssize_t PySequence_Length(PyObject *o);



     PyObject * PySequence_Concat(PyObject *o1, PyObject *o2);







     PyObject * PySequence_Repeat(PyObject *o, Py_ssize_t count);







     PyObject * PySequence_GetItem(PyObject *o, Py_ssize_t i);






     PyObject * PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);







     int PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v);







     int PySequence_DelItem(PyObject *o, Py_ssize_t i);







     int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2,
                                         PyObject *v);







     int PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);







     PyObject * PySequence_Tuple(PyObject *o);







     PyObject * PySequence_List(PyObject *o);





     PyObject * PySequence_Fast(PyObject *o, const char* m);
# 1053 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     Py_ssize_t PySequence_Count(PyObject *o, PyObject *value);
# 1062 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PySequence_Contains(PyObject *seq, PyObject *ob);
# 1072 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     Py_ssize_t _PySequence_IterSearch(PyObject *seq,
                                        PyObject *obj, int operation);
# 1088 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PySequence_In(PyObject *o, PyObject *value);
# 1099 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     Py_ssize_t PySequence_Index(PyObject *o, PyObject *value);
# 1109 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
# 1118 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
# 1129 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyMapping_Check(PyObject *o);
# 1138 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     Py_ssize_t PyMapping_Size(PyObject *o);
# 1148 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     Py_ssize_t PyMapping_Length(PyObject *o);
# 1172 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyMapping_HasKeyString(PyObject *o, char *key);
# 1182 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     int PyMapping_HasKey(PyObject *o, PyObject *key);
# 1193 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyMapping_Keys(PyObject *o);






     PyObject * PyMapping_Values(PyObject *o);






     PyObject * PyMapping_Items(PyObject *o);
# 1216 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
     PyObject * PyMapping_GetItemString(PyObject *o, char *key);







     int PyMapping_SetItemString(PyObject *o, char *key,
                                            PyObject *value);
# 1234 "/Users/parrt/tmp/Python-3.3.1/Include/abstract.h"
int PyObject_IsInstance(PyObject *object, PyObject *typeorclass);


int PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);




int _PyObject_RealIsInstance(PyObject *inst, PyObject *cls);

int _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls);

char *const * _PySequence_BytesToCharpArray(PyObject* self);

void _Py_FreeCharPArray(char *const array[]);



void _Py_add_one_to_index_F(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);
void _Py_add_one_to_index_C(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);
# 120 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/bltinmodule.h" 1






extern PyTypeObject PyFilter_Type;
extern PyTypeObject PyMap_Type;
extern PyTypeObject PyZip_Type;
# 121 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/compile.h" 1




# 1 "/Users/parrt/tmp/Python-3.3.1/Include/code.h" 1
# 11 "/Users/parrt/tmp/Python-3.3.1/Include/code.h"
typedef struct {
    PyObject ob_base;
    int co_argcount;
    int co_kwonlyargcount;
    int co_nlocals;
    int co_stacksize;
    int co_flags;
    PyObject *co_code;
    PyObject *co_consts;
    PyObject *co_names;
    PyObject *co_varnames;
    PyObject *co_freevars;
    PyObject *co_cellvars;

    unsigned char *co_cell2arg;
    PyObject *co_filename;
    PyObject *co_name;
    int co_firstlineno;
    PyObject *co_lnotab;

    void *co_zombieframe;
    PyObject *co_weakreflist;
} PyCodeObject;
# 73 "/Users/parrt/tmp/Python-3.3.1/Include/code.h"
extern PyTypeObject PyCode_Type;





PyCodeObject * PyCode_New(
 int, int, int, int, int, PyObject *, PyObject *,
 PyObject *, PyObject *, PyObject *, PyObject *,
 PyObject *, PyObject *, int, PyObject *);



PyCodeObject *
PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno);




int PyCode_Addr2Line(PyCodeObject *, int);


typedef struct _addr_pair {
        int ap_lower;
        int ap_upper;
} PyAddrPair;





int _PyCode_CheckLineNumber(PyCodeObject* co,
                                        int lasti, PyAddrPair *bounds);


PyObject* PyCode_Optimize(PyObject *code, PyObject* consts,
                                      PyObject *names, PyObject *lineno_obj);
# 6 "/Users/parrt/tmp/Python-3.3.1/Include/compile.h" 2






struct _node;
PyCodeObject * PyNode_Compile(struct _node *, const char *);



typedef struct {
    int ff_features;
    int ff_lineno;
} PyFutureFeatures;
# 31 "/Users/parrt/tmp/Python-3.3.1/Include/compile.h"
struct _mod;

PyCodeObject * PyAST_CompileEx(
    struct _mod *mod,
    const char *filename,
    PyCompilerFlags *flags,
    int optimize,
    PyArena *arena);
PyFutureFeatures * PyFuture_FromAST(struct _mod *, const char *);


PyObject* _Py_Mangle(PyObject *p, PyObject *name);
# 123 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/eval.h" 1
# 10 "/Users/parrt/tmp/Python-3.3.1/Include/eval.h"
PyObject * PyEval_EvalCode(PyObject *, PyObject *, PyObject *);

PyObject * PyEval_EvalCodeEx(PyObject *co,
     PyObject *globals,
     PyObject *locals,
     PyObject **args, int argc,
     PyObject **kwds, int kwdc,
     PyObject **defs, int defc,
     PyObject *kwdefs, PyObject *closure);


PyObject * _PyEval_CallTracing(PyObject *func, PyObject *args);
# 124 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2

# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pyctype.h" 1
# 13 "/Users/parrt/tmp/Python-3.3.1/Include/pyctype.h"
extern const unsigned int _Py_ctype_table[256];
# 26 "/Users/parrt/tmp/Python-3.3.1/Include/pyctype.h"
extern const unsigned char _Py_ctype_tolower[256];
extern const unsigned char _Py_ctype_toupper[256];
# 126 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pystrtod.h" 1
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/pystrtod.h"
double PyOS_string_to_double(const char *str,
                                         char **endptr,
                                         PyObject *overflow_exception);



char * PyOS_double_to_string(double val,
                                         char format_code,
                                         int precision,
                                         int flags,
                                         int *type);


double _Py_parse_inf_or_nan(const char *p, char **endptr);
# 127 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pystrcmp.h" 1







int PyOS_mystrnicmp(const char *, const char *, Py_ssize_t);
int PyOS_mystricmp(const char *, const char *);
# 128 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/dtoa.h" 1






double _Py_dg_strtod(const char *str, char **ptr);
char * _Py_dg_dtoa(double d, int mode, int ndigits,
                        int *decpt, int *sign, char **rve);
void _Py_dg_freedtoa(char *s);
double _Py_dg_stdnan(int sign);
double _Py_dg_infinity(int sign);
# 129 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/fileutils.h" 1







PyObject * _Py_device_encoding(int);

wchar_t * _Py_char2wchar(
    const char *arg,
    size_t *size);

char* _Py_wchar2char(
    const wchar_t *text,
    size_t *error_pos);


int _Py_wstat(
    const wchar_t* path,
    struct stat *buf);



int _Py_stat(
    PyObject *path,
    struct stat *statbuf);


FILE * _Py_wfopen(
    const wchar_t *path,
    const wchar_t *mode);

FILE* _Py_fopen(
    PyObject *path,
    const char *mode);


int _Py_wreadlink(
    const wchar_t *path,
    wchar_t *buf,
    size_t bufsiz);



wchar_t* _Py_wrealpath(
    const wchar_t *path,
    wchar_t *resolved_path,
    size_t resolved_path_size);


wchar_t* _Py_wgetcwd(
    wchar_t *buf,
    size_t size);
# 130 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/pyfpe.h" 1
# 131 "/Users/parrt/tmp/Python-3.3.1/Include/Python.h" 2
# 43 "unicodeobject.c" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/ucnhash.h" 1
# 13 "/Users/parrt/tmp/Python-3.3.1/Include/ucnhash.h"
typedef struct {


    int size;





    int (*getname)(PyObject *self, Py_UCS4 code, char* buffer, int buflen,
                   int with_alias_and_seq);



    int (*getcode)(PyObject *self, const char* name, int namelen, Py_UCS4* code,
                   int with_named_seq);

} _PyUnicode_Name_CAPI;
# 44 "unicodeobject.c" 2
# 1 "/Users/parrt/tmp/Python-3.3.1/Include/bytes_methods.h" 1
# 9 "/Users/parrt/tmp/Python-3.3.1/Include/bytes_methods.h"
extern PyObject* _Py_bytes_isspace(const char *cptr, Py_ssize_t len);
extern PyObject* _Py_bytes_isalpha(const char *cptr, Py_ssize_t len);
extern PyObject* _Py_bytes_isalnum(const char *cptr, Py_ssize_t len);
extern PyObject* _Py_bytes_isdigit(const char *cptr, Py_ssize_t len);
extern PyObject* _Py_bytes_islower(const char *cptr, Py_ssize_t len);
extern PyObject* _Py_bytes_isupper(const char *cptr, Py_ssize_t len);
extern PyObject* _Py_bytes_istitle(const char *cptr, Py_ssize_t len);


extern void _Py_bytes_lower(char *result, const char *cptr, Py_ssize_t len);
extern void _Py_bytes_upper(char *result, const char *cptr, Py_ssize_t len);
extern void _Py_bytes_title(char *result, char *s, Py_ssize_t len);
extern void _Py_bytes_capitalize(char *result, char *s, Py_ssize_t len);
extern void _Py_bytes_swapcase(char *result, char *s, Py_ssize_t len);


extern PyObject* _Py_bytes_maketrans(PyObject *args);


extern const char _Py_isspace__doc__[];
extern const char _Py_isalpha__doc__[];
extern const char _Py_isalnum__doc__[];
extern const char _Py_isdigit__doc__[];
extern const char _Py_islower__doc__[];
extern const char _Py_isupper__doc__[];
extern const char _Py_istitle__doc__[];
extern const char _Py_lower__doc__[];
extern const char _Py_upper__doc__[];
extern const char _Py_title__doc__[];
extern const char _Py_capitalize__doc__[];
extern const char _Py_swapcase__doc__[];
extern const char _Py_maketrans__doc__[];
# 45 "unicodeobject.c" 2
# 183 "unicodeobject.c"
static PyObject *interned = ((void *)0);


static PyObject *unicode_empty = ((void *)0);
# 208 "unicodeobject.c"
static _Py_Identifier *static_strings = ((void *)0);



static PyObject *unicode_latin1[256] = {((void *)0)};


const unsigned char _Py_ascii_whitespace[] = {
    0, 0, 0, 0, 0, 0, 0, 0,





    0, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,




    0, 0, 0, 0, 1, 1, 1, 1,

    1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
};


static PyUnicodeObject *_PyUnicode_New(Py_ssize_t length);
static PyObject* get_latin1_char(unsigned char ch);
static int unicode_modifiable(PyObject *unicode);


static PyObject *
_PyUnicode_FromUCS1(const Py_UCS1 *s, Py_ssize_t size);
static PyObject *
_PyUnicode_FromUCS2(const Py_UCS2 *s, Py_ssize_t size);
static PyObject *
_PyUnicode_FromUCS4(const Py_UCS4 *s, Py_ssize_t size);

static PyObject *
unicode_encode_call_errorhandler(const char *errors,
       PyObject **errorHandler,const char *encoding, const char *reason,
       PyObject *unicode, PyObject **exceptionObject,
       Py_ssize_t startpos, Py_ssize_t endpos, Py_ssize_t *newpos);

static void
raise_encode_exception(PyObject **exceptionObject,
                       const char *encoding,
                       PyObject *unicode,
                       Py_ssize_t startpos, Py_ssize_t endpos,
                       const char *reason);


static unsigned char ascii_linebreak[] = {
    0, 0, 0, 0, 0, 0, 0, 0,




    0, 0, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,



    0, 0, 0, 0, 1, 1, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
};



Py_UNICODE
PyUnicode_GetMax(void)
{

    return 0x10FFFF;





}
# 429 "unicodeobject.c"
static PyObject*
unicode_result_wchar(PyObject *unicode)
{

    Py_ssize_t len;

    (__builtin_expect(!((((PyObject*)(unicode))->ob_refcnt) == 1), 0) ? __assert_rtn(__func__, "unicodeobject.c", 435, "Py_REFCNT(unicode) == 1") : (void)0);

    len = (((PyCompactUnicodeObject*)(unicode))->wstr_length);
    if (len == 0) {
        do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 440, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    }

    if (len == 1) {
        wchar_t ch = (((PyASCIIObject*)(unicode))->wstr)[0];
        if ((Py_UCS4)ch < 256) {
            PyObject *latin1_char = get_latin1_char((unsigned char)ch);
            do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
            return latin1_char;
        }
    }

    if (_PyUnicode_Ready(unicode) < 0) {
        do { if ((unicode) == ((void *)0)) ; else do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0); } while (0);
        return ((void *)0);
    }





    return unicode;
}

static PyObject*
unicode_result_ready(PyObject *unicode)
{
    Py_ssize_t length;

    length = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 469, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 469, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
    if (length == 0) {
        if (unicode != unicode_empty) {
            do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
            do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 473, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
        }
        return unicode_empty;
    }

    if (length == 1) {
        Py_UCS4 ch = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_IS_READY(unicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(0)] : (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 479, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(0)] ) ));
        if (ch < 256) {
            PyObject *latin1_char = unicode_latin1[ch];
            if (latin1_char != ((void *)0)) {
                if (unicode != latin1_char) {
                    ( ((PyObject*)(latin1_char))->ob_refcnt++);
                    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
                }
                return latin1_char;
            }
            else {
                (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 490, "_PyUnicode_CheckConsistency(unicode, 1)") : (void)0);
                ( ((PyObject*)(unicode))->ob_refcnt++);
                unicode_latin1[ch] = unicode;
                return unicode;
            }
        }
    }

    (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 498, "_PyUnicode_CheckConsistency(unicode, 1)") : (void)0);
    return unicode;
}

static PyObject*
unicode_result(PyObject *unicode)
{
    (__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 505, "_PyUnicode_CHECK(unicode)") : (void)0);
    if ((((PyASCIIObject*)unicode)->state.ready))
        return unicode_result_ready(unicode);
    else
        return unicode_result_wchar(unicode);
}

static PyObject*
unicode_result_unchanged(PyObject *unicode)
{
    if (((((PyObject*)(unicode))->ob_type) == &PyUnicode_Type)) {
        if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 516, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
            return ((void *)0);
        ( ((PyObject*)(unicode))->ob_refcnt++);
        return unicode;
    }
    else

        return _PyUnicode_Copy(unicode);
}
# 550 "unicodeobject.c"
static unsigned long bloom_linebreak = ~(unsigned long)0;
# 559 "unicodeobject.c"
static inline unsigned long
make_bloom_mask(int kind, void* ptr, Py_ssize_t len)
{


    unsigned long mask;
    Py_ssize_t i;

    mask = 0;
    for (i = 0; i < len; i++)
        ((mask |= (1UL << ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(ptr))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(ptr))[(i)] : ((const Py_UCS4 *)(ptr))[(i)] ) ))) & (64 - 1)))));

    return mask;
}







# 1 "stringlib/asciilib.h" 1
# 581 "unicodeobject.c" 2
# 1 "stringlib/fastsearch.h" 1
# 36 "stringlib/fastsearch.h"
static inline Py_ssize_t
asciilib_fastsearch_memchr_1char(const Py_UCS1* s, Py_ssize_t n,
                                   Py_UCS1 ch, unsigned char needle,
                                   Py_ssize_t maxcount, int mode)
{
    if (mode == 1) {
        const Py_UCS1 *ptr = s;
        const Py_UCS1 *e = s + n;
        while (ptr < e) {
            void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(Py_UCS1));
            if (candidate == ((void *)0))
                return -1;
            ptr = (const Py_UCS1 *) ((void *)((Py_uintptr_t)(candidate) & ~(Py_uintptr_t)((sizeof(Py_UCS1)) - 1)));
            if (sizeof(Py_UCS1) == 1 || *ptr == ch)
                return (ptr - s);

            ptr++;
        }
        return -1;
    }
# 75 "stringlib/fastsearch.h"
    else {
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "stringlib/fastsearch.h", 76, "0") : (void)0);
        return 0;
    }


}

static inline Py_ssize_t
asciilib_fastsearch(const Py_UCS1* s, Py_ssize_t n,
           const Py_UCS1* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode)
{
    unsigned long mask;
    Py_ssize_t skip, count = 0;
    Py_ssize_t i, j, mlast, w;

    w = n - m;

    if (w < 0 || (mode == 0 && maxcount == 0))
        return -1;


    if (m <= 1) {
        if (m <= 0)
            return -1;

        if (n > 10 && (mode == 1



                    )) {


            unsigned char needle;
            needle = p[0] & 0xff;






                return asciilib_fastsearch_memchr_1char
                       (s, n, p[0], needle, maxcount, mode);
        }
        if (mode == 0) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0]) {
                    count++;
                    if (count == maxcount)
                        return maxcount;
                }
            return count;
        } else if (mode == 1) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0])
                    return i;
        } else {
            for (i = n - 1; i > -1; i--)
                if (s[i] == p[0])
                    return i;
        }
        return -1;
    }

    mlast = m - 1;
    skip = mlast - 1;
    mask = 0;

    if (mode != 2) {




        for (i = 0; i < mlast; i++) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[mlast])
                skip = mlast - i - 1;
        }

        ((mask |= (1UL << ((p[mlast]) & (64 -1)))));

        for (i = 0; i <= w; i++) {

            if (s[i+m-1] == p[m-1]) {

                for (j = 0; j < mlast; j++)
                    if (s[i+j] != p[j])
                        break;
                if (j == mlast) {

                    if (mode != 0)
                        return i;
                    count++;
                    if (count == maxcount)
                        return maxcount;
                    i = i + mlast;
                    continue;
                }

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
                else
                    i = i + skip;
            } else {

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
            }
        }
    } else {




        ((mask |= (1UL << ((p[0]) & (64 -1)))));

        for (i = mlast; i > 0; i--) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[0])
                skip = i - 1;
        }

        for (i = w; i >= 0; i--) {
            if (s[i] == p[0]) {

                for (j = mlast; j > 0; j--)
                    if (s[i+j] != p[j])
                        break;
                if (j == 0)

                    return i;

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
                else
                    i = i - skip;
            } else {

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
            }
        }
    }

    if (mode != 0)
        return -1;
    return count;
}
# 582 "unicodeobject.c" 2
# 1 "stringlib/partition.h" 1






static inline PyObject*
asciilib_partition(PyObject* str_obj,
                    const Py_UCS1* str, Py_ssize_t str_len,
                    PyObject* sep_obj,
                    const Py_UCS1* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = asciilib_fastsearch(str, str_len, sep, sep_len, -1, 1);

    if (pos < 0) {





        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) str_obj);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) unicode_empty);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromASCII((char*)(str),(pos)));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromASCII((char*)(str + pos),(str_len - pos)));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}

static inline PyObject*
asciilib_rpartition(PyObject* str_obj,
                     const Py_UCS1* str, Py_ssize_t str_len,
                     PyObject* sep_obj,
                     const Py_UCS1* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = asciilib_fastsearch(str, str_len, sep, sep_len, -1, 2);

    if (pos < 0) {





        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) str_obj);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromASCII((char*)(str),(pos)));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromASCII((char*)(str + pos),(str_len - pos)));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}
# 583 "unicodeobject.c" 2
# 1 "stringlib/split.h" 1
# 53 "stringlib/split.h"
static inline PyObject *
asciilib_split_whitespace(PyObject* str_obj,
                           const Py_UCS1* str, Py_ssize_t str_len,
                           Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i == str_len) break;
        j = i; i++;
        while (i < str_len && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;

        if (j == 0 && i == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromASCII((char*)((str) + (j)),((i) - (j))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i < str_len) {


        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i != str_len)
            { sub = _PyUnicode_FromASCII((char*)((str) + (i)),((str_len) - (i))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
asciilib_split_char(PyObject* str_obj,
                     const Py_UCS1* str, Py_ssize_t str_len,
                     const Py_UCS1 ch,
                     Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while ((j < str_len) && (maxcount-- > 0)) {
        for(; j < str_len; j++) {

            if (str[j] == ch) {
                { sub = _PyUnicode_FromASCII((char*)((str) + (i)),((j) - (i))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                i = j = j + 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (i <= str_len) {
        { sub = _PyUnicode_FromASCII((char*)((str) + (i)),((str_len) - (i))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
asciilib_split(PyObject* str_obj,
                const Py_UCS1* str, Py_ssize_t str_len,
                const Py_UCS1* sep, Py_ssize_t sep_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t i, j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return asciilib_split_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        pos = asciilib_fastsearch(str+i, str_len-i, sep, sep_len, -1, 1);
        if (pos < 0)
            break;
        j = i + pos;
        { sub = _PyUnicode_FromASCII((char*)((str) + (i)),((j) - (i))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        i = j + sep_len;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromASCII((char*)((str) + (i)),((str_len) - (i))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
asciilib_rsplit_whitespace(PyObject* str_obj,
                            const Py_UCS1* str, Py_ssize_t str_len,
                            Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while (maxcount-- > 0) {
        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i < 0) break;
        j = i; i--;
        while (i >= 0 && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;

        if (j == str_len - 1 && i < 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromASCII((char*)((str) + (i + 1)),((j + 1) - (i + 1))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i >= 0) {


        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i >= 0)
            { sub = _PyUnicode_FromASCII((char*)((str) + (0)),((i + 1) - (0))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
asciilib_rsplit_char(PyObject* str_obj,
                      const Py_UCS1* str, Py_ssize_t str_len,
                      const Py_UCS1 ch,
                      Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while ((i >= 0) && (maxcount-- > 0)) {
        for(; i >= 0; i--) {
            if (str[i] == ch) {
                { sub = _PyUnicode_FromASCII((char*)((str) + (i + 1)),((j + 1) - (i + 1))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                j = i = i - 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (j >= -1) {
        { sub = _PyUnicode_FromASCII((char*)((str) + (0)),((j + 1) - (0))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
asciilib_rsplit(PyObject* str_obj,
                 const Py_UCS1* str, Py_ssize_t str_len,
                 const Py_UCS1* sep, Py_ssize_t sep_len,
                 Py_ssize_t maxcount)
{
    Py_ssize_t j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return asciilib_rsplit_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    j = str_len;
    while (maxcount-- > 0) {
        pos = asciilib_fastsearch(str, j, sep, sep_len, -1, 2);
        if (pos < 0)
            break;
        { sub = _PyUnicode_FromASCII((char*)((str) + (pos + sep_len)),((j) - (pos + sep_len))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        j = pos;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromASCII((char*)((str) + (0)),((j) - (0))); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
asciilib_splitlines(PyObject* str_obj,
                     const Py_UCS1* str, Py_ssize_t str_len,
                     int keepends)
{
# 348 "stringlib/split.h"
    register Py_ssize_t i;
    register Py_ssize_t j;
    PyObject *list = PyList_New(0);
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    for (i = j = 0; i < str_len; ) {
        Py_ssize_t eol;


        while (i < str_len && !((str[i]) < 128U ? ascii_linebreak[(str[i])] : (((bloom_linebreak & (1UL << (((str[i])) & (64 - 1))))) && _PyUnicode_IsLinebreak(str[i]))))
            i++;


        eol = i;
        if (i < str_len) {
            if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')
                i += 2;
            else
                i++;
            if (keepends)
                eol = i;
        }

        if (j == 0 && eol == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            if (PyList_Append(list, str_obj))
                goto onError;
            break;
        }

        sub = _PyUnicode_FromASCII((char*)((str) + (j)),((eol) - (j))); if (sub == ((void *)0)) goto onError; if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);;
        j = i;
    }
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}
# 584 "unicodeobject.c" 2
# 1 "stringlib/count.h" 1






static inline Py_ssize_t
asciilib_count(const Py_UCS1* str, Py_ssize_t str_len,
                const Py_UCS1* sub, Py_ssize_t sub_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t count;

    if (str_len < 0)
        return 0;
    if (sub_len == 0)
        return (str_len < maxcount) ? str_len + 1 : maxcount;

    count = asciilib_fastsearch(str, str_len, sub, sub_len, maxcount, 0);

    if (count < 0)
        return 0;

    return count;
}
# 585 "unicodeobject.c" 2
# 1 "stringlib/find.h" 1






static inline Py_ssize_t
asciilib_find(const Py_UCS1* str, Py_ssize_t str_len,
               const Py_UCS1* sub, Py_ssize_t sub_len,
               Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return offset;

    pos = asciilib_fastsearch(str, str_len, sub, sub_len, -1, 1);

    if (pos >= 0)
        pos += offset;

    return pos;
}

static inline Py_ssize_t
asciilib_rfind(const Py_UCS1* str, Py_ssize_t str_len,
                const Py_UCS1* sub, Py_ssize_t sub_len,
                Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return str_len + offset;

    pos = asciilib_fastsearch(str, str_len, sub, sub_len, -1, 2);

    if (pos >= 0)
        pos += offset;

    return pos;
}
# 62 "stringlib/find.h"
static inline Py_ssize_t
asciilib_find_slice(const Py_UCS1* str, Py_ssize_t str_len,
                     const Py_UCS1* sub, Py_ssize_t sub_len,
                     Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return asciilib_find(str + start, end - start, sub, sub_len, start);
}

static inline Py_ssize_t
asciilib_rfind_slice(const Py_UCS1* str, Py_ssize_t str_len,
                      const Py_UCS1* sub, Py_ssize_t sub_len,
                      Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return asciilib_rfind(str + start, end - start, sub, sub_len, start);
}
# 104 "stringlib/find.h"
static inline int
asciilib_parse_args_finds(const char * function_name, PyObject *args,
                           PyObject **subobj,
                           Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_subobj;
    Py_ssize_t tmp_start = 0;
    Py_ssize_t tmp_end = ((Py_ssize_t)(((size_t)-1)>>1));
    PyObject *obj_start=(&_Py_NoneStruct), *obj_end=(&_Py_NoneStruct);
    char format[50] = "O|OO:";
    size_t len = strlen(format);

    ((__builtin_object_size (format + len, 0) != (size_t) -1) ? __builtin___strncpy_chk (format + len, function_name, 50 - len - 1, __builtin_object_size (format + len, 2 > 1)) : __inline_strncpy_chk (format + len, function_name, 50 - len - 1));
    format[50 - 1] = '\0';

    if (!_PyArg_ParseTuple_SizeT(args, format, &tmp_subobj, &obj_start, &obj_end))
        return 0;




    if (obj_start != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_start, &tmp_start))
            return 0;
    if (obj_end != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_end, &tmp_end))
            return 0;

    *start = tmp_start;
    *end = tmp_end;
    *subobj = tmp_subobj;
    return 1;
}
# 152 "stringlib/find.h"
static inline int
asciilib_parse_args_finds_unicode(const char * function_name, PyObject *args,
                                   PyObject **substring,
                                   Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_substring;

    if(asciilib_parse_args_finds(function_name, args, &tmp_substring,
                                  start, end)) {
        tmp_substring = PyUnicode_FromObject(tmp_substring);
        if (!tmp_substring)
            return 0;
        *substring = tmp_substring;
        return 1;
    }
    return 0;
}
# 586 "unicodeobject.c" 2
# 1 "stringlib/find_max_char.h" 1
# 17 "stringlib/find_max_char.h"
static inline Py_UCS4
asciilib_find_max_char(const Py_UCS1 *begin, const Py_UCS1 *end)
{
    const unsigned char *p = (const unsigned char *) begin;
    const unsigned char *aligned_end =
            (const unsigned char *) ((void *)((Py_uintptr_t)(end) & ~(Py_uintptr_t)((8) - 1)));

    while (p < end) {
        if ((!((Py_uintptr_t)(p) & (Py_uintptr_t)((8) - 1)))) {

            register const unsigned char *_p = p;
            while (_p < aligned_end) {
                unsigned long value = *(unsigned long *) _p;
                if (value & 0x8080808080808080UL)
                    return 255;
                _p += 8;
            }
            p = _p;
            if (p == end)
                break;
        }
        if (*p++ & 0x80)
            return 255;
    }
    return 127;
}
# 587 "unicodeobject.c" 2
# 1 "stringlib/localeutil.h" 1


# 1 "/usr/include/locale.h" 1 3 4
# 40 "/usr/include/locale.h" 3 4
# 1 "/usr/include/_locale.h" 1 3 4
# 43 "/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};






struct lconv *localeconv(void);

# 41 "/usr/include/locale.h" 2 3 4
# 52 "/usr/include/locale.h" 3 4

char *setlocale(int, const char *);

# 4 "stringlib/localeutil.h" 2





typedef struct {
    const char *grouping;
    char previous;
    Py_ssize_t i;
} asciilib_GroupGenerator;

static void
asciilib_GroupGenerator_init(asciilib_GroupGenerator *self, const char *grouping)
{
    self->grouping = grouping;
    self->i = 0;
    self->previous = 0;
}


static Py_ssize_t
asciilib_GroupGenerator_next(asciilib_GroupGenerator *self)
{




    switch (self->grouping[self->i]) {
    case 0:
        return self->previous;
    case 127:

        return 0;
    default: {
        char ch = self->grouping[self->i];
        self->previous = ch;
        self->i++;
        return (Py_ssize_t)ch;
    }
    }
}



static void
asciilib_fill(Py_UCS1 **digits_end, Py_UCS1 **buffer_end,
     Py_ssize_t n_chars, Py_ssize_t n_zeros, Py_UCS1* thousands_sep,
     Py_ssize_t thousands_sep_len)
{
    Py_ssize_t i;

    if (thousands_sep) {
        *buffer_end -= thousands_sep_len;


        ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 1, __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 1));

    }

    *buffer_end -= n_chars;
    *digits_end -= n_chars;
    ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS1), __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS1)));

    *buffer_end -= n_zeros;
    for (i = 0; i < n_zeros; i++)
        (*buffer_end)[i] = '0';
}
# 102 "stringlib/localeutil.h"
static Py_ssize_t
asciilib_InsertThousandsGrouping(
    Py_UCS1 *buffer,
    Py_ssize_t n_buffer,
    Py_UCS1 *digits,
    Py_ssize_t n_digits,
    Py_ssize_t min_width,
    const char *grouping,
    Py_UCS1 *thousands_sep,
    Py_ssize_t thousands_sep_len)
{
    Py_ssize_t count = 0;
    Py_ssize_t n_zeros;
    int loop_broken = 0;
    int use_separator = 0;


    Py_UCS1 *buffer_end = ((void *)0);
    Py_UCS1 *digits_end = ((void *)0);
    Py_ssize_t l;
    Py_ssize_t n_chars;
    Py_ssize_t remaining = n_digits;



    asciilib_GroupGenerator groupgen;
    asciilib_GroupGenerator_init(&groupgen, grouping);

    if (buffer) {
        buffer_end = buffer + n_buffer;
        digits_end = digits + n_digits;
    }

    while ((l = asciilib_GroupGenerator_next(&groupgen)) > 0) {
        l = (((l) > (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1)))) ? (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1))) : (l));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));




        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

        if (buffer) {

            asciilib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }


        use_separator = 1;

        remaining -= n_chars;
        min_width -= l;

        if (remaining <= 0 && min_width <= 0) {
            loop_broken = 1;
            break;
        }
        min_width -= thousands_sep_len;
    }
    if (!loop_broken) {


        l = ((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));


        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;
        if (buffer) {

            asciilib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }
    }
    return count;
}
# 588 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 589 "unicodeobject.c" 2

# 1 "stringlib/ucs1lib.h" 1
# 591 "unicodeobject.c" 2
# 1 "stringlib/fastsearch.h" 1
# 36 "stringlib/fastsearch.h"
static inline Py_ssize_t
ucs1lib_fastsearch_memchr_1char(const Py_UCS1* s, Py_ssize_t n,
                                   Py_UCS1 ch, unsigned char needle,
                                   Py_ssize_t maxcount, int mode)
{
    if (mode == 1) {
        const Py_UCS1 *ptr = s;
        const Py_UCS1 *e = s + n;
        while (ptr < e) {
            void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(Py_UCS1));
            if (candidate == ((void *)0))
                return -1;
            ptr = (const Py_UCS1 *) ((void *)((Py_uintptr_t)(candidate) & ~(Py_uintptr_t)((sizeof(Py_UCS1)) - 1)));
            if (sizeof(Py_UCS1) == 1 || *ptr == ch)
                return (ptr - s);

            ptr++;
        }
        return -1;
    }
# 75 "stringlib/fastsearch.h"
    else {
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "stringlib/fastsearch.h", 76, "0") : (void)0);
        return 0;
    }


}

static inline Py_ssize_t
ucs1lib_fastsearch(const Py_UCS1* s, Py_ssize_t n,
           const Py_UCS1* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode)
{
    unsigned long mask;
    Py_ssize_t skip, count = 0;
    Py_ssize_t i, j, mlast, w;

    w = n - m;

    if (w < 0 || (mode == 0 && maxcount == 0))
        return -1;


    if (m <= 1) {
        if (m <= 0)
            return -1;

        if (n > 10 && (mode == 1



                    )) {


            unsigned char needle;
            needle = p[0] & 0xff;






                return ucs1lib_fastsearch_memchr_1char
                       (s, n, p[0], needle, maxcount, mode);
        }
        if (mode == 0) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0]) {
                    count++;
                    if (count == maxcount)
                        return maxcount;
                }
            return count;
        } else if (mode == 1) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0])
                    return i;
        } else {
            for (i = n - 1; i > -1; i--)
                if (s[i] == p[0])
                    return i;
        }
        return -1;
    }

    mlast = m - 1;
    skip = mlast - 1;
    mask = 0;

    if (mode != 2) {




        for (i = 0; i < mlast; i++) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[mlast])
                skip = mlast - i - 1;
        }

        ((mask |= (1UL << ((p[mlast]) & (64 -1)))));

        for (i = 0; i <= w; i++) {

            if (s[i+m-1] == p[m-1]) {

                for (j = 0; j < mlast; j++)
                    if (s[i+j] != p[j])
                        break;
                if (j == mlast) {

                    if (mode != 0)
                        return i;
                    count++;
                    if (count == maxcount)
                        return maxcount;
                    i = i + mlast;
                    continue;
                }

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
                else
                    i = i + skip;
            } else {

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
            }
        }
    } else {




        ((mask |= (1UL << ((p[0]) & (64 -1)))));

        for (i = mlast; i > 0; i--) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[0])
                skip = i - 1;
        }

        for (i = w; i >= 0; i--) {
            if (s[i] == p[0]) {

                for (j = mlast; j > 0; j--)
                    if (s[i+j] != p[j])
                        break;
                if (j == 0)

                    return i;

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
                else
                    i = i - skip;
            } else {

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
            }
        }
    }

    if (mode != 0)
        return -1;
    return count;
}
# 592 "unicodeobject.c" 2
# 1 "stringlib/partition.h" 1






static inline PyObject*
ucs1lib_partition(PyObject* str_obj,
                    const Py_UCS1* str, Py_ssize_t str_len,
                    PyObject* sep_obj,
                    const Py_UCS1* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = ucs1lib_fastsearch(str, str_len, sep, sep_len, -1, 1);

    if (pos < 0) {





        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) str_obj);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) unicode_empty);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromUCS1(str, pos));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromUCS1(str + pos, str_len - pos));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}

static inline PyObject*
ucs1lib_rpartition(PyObject* str_obj,
                     const Py_UCS1* str, Py_ssize_t str_len,
                     PyObject* sep_obj,
                     const Py_UCS1* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = ucs1lib_fastsearch(str, str_len, sep, sep_len, -1, 2);

    if (pos < 0) {





        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) str_obj);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromUCS1(str, pos));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromUCS1(str + pos, str_len - pos));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}
# 593 "unicodeobject.c" 2
# 1 "stringlib/split.h" 1
# 53 "stringlib/split.h"
static inline PyObject *
ucs1lib_split_whitespace(PyObject* str_obj,
                           const Py_UCS1* str, Py_ssize_t str_len,
                           Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i == str_len) break;
        j = i; i++;
        while (i < str_len && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;

        if (j == 0 && i == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromUCS1((str) + (j), (i) - (j)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i < str_len) {


        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i != str_len)
            { sub = _PyUnicode_FromUCS1((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs1lib_split_char(PyObject* str_obj,
                     const Py_UCS1* str, Py_ssize_t str_len,
                     const Py_UCS1 ch,
                     Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while ((j < str_len) && (maxcount-- > 0)) {
        for(; j < str_len; j++) {

            if (str[j] == ch) {
                { sub = _PyUnicode_FromUCS1((str) + (i), (j) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                i = j = j + 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (i <= str_len) {
        { sub = _PyUnicode_FromUCS1((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs1lib_split(PyObject* str_obj,
                const Py_UCS1* str, Py_ssize_t str_len,
                const Py_UCS1* sep, Py_ssize_t sep_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t i, j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return ucs1lib_split_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        pos = ucs1lib_fastsearch(str+i, str_len-i, sep, sep_len, -1, 1);
        if (pos < 0)
            break;
        j = i + pos;
        { sub = _PyUnicode_FromUCS1((str) + (i), (j) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        i = j + sep_len;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromUCS1((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs1lib_rsplit_whitespace(PyObject* str_obj,
                            const Py_UCS1* str, Py_ssize_t str_len,
                            Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while (maxcount-- > 0) {
        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i < 0) break;
        j = i; i--;
        while (i >= 0 && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;

        if (j == str_len - 1 && i < 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromUCS1((str) + (i + 1), (j + 1) - (i + 1)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i >= 0) {


        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i >= 0)
            { sub = _PyUnicode_FromUCS1((str) + (0), (i + 1) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs1lib_rsplit_char(PyObject* str_obj,
                      const Py_UCS1* str, Py_ssize_t str_len,
                      const Py_UCS1 ch,
                      Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while ((i >= 0) && (maxcount-- > 0)) {
        for(; i >= 0; i--) {
            if (str[i] == ch) {
                { sub = _PyUnicode_FromUCS1((str) + (i + 1), (j + 1) - (i + 1)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                j = i = i - 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (j >= -1) {
        { sub = _PyUnicode_FromUCS1((str) + (0), (j + 1) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs1lib_rsplit(PyObject* str_obj,
                 const Py_UCS1* str, Py_ssize_t str_len,
                 const Py_UCS1* sep, Py_ssize_t sep_len,
                 Py_ssize_t maxcount)
{
    Py_ssize_t j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return ucs1lib_rsplit_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    j = str_len;
    while (maxcount-- > 0) {
        pos = ucs1lib_fastsearch(str, j, sep, sep_len, -1, 2);
        if (pos < 0)
            break;
        { sub = _PyUnicode_FromUCS1((str) + (pos + sep_len), (j) - (pos + sep_len)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        j = pos;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromUCS1((str) + (0), (j) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs1lib_splitlines(PyObject* str_obj,
                     const Py_UCS1* str, Py_ssize_t str_len,
                     int keepends)
{
# 348 "stringlib/split.h"
    register Py_ssize_t i;
    register Py_ssize_t j;
    PyObject *list = PyList_New(0);
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    for (i = j = 0; i < str_len; ) {
        Py_ssize_t eol;


        while (i < str_len && !((str[i]) < 128U ? ascii_linebreak[(str[i])] : (((bloom_linebreak & (1UL << (((str[i])) & (64 - 1))))) && _PyUnicode_IsLinebreak(str[i]))))
            i++;


        eol = i;
        if (i < str_len) {
            if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')
                i += 2;
            else
                i++;
            if (keepends)
                eol = i;
        }

        if (j == 0 && eol == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            if (PyList_Append(list, str_obj))
                goto onError;
            break;
        }

        sub = _PyUnicode_FromUCS1((str) + (j), (eol) - (j)); if (sub == ((void *)0)) goto onError; if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);;
        j = i;
    }
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}
# 594 "unicodeobject.c" 2
# 1 "stringlib/count.h" 1






static inline Py_ssize_t
ucs1lib_count(const Py_UCS1* str, Py_ssize_t str_len,
                const Py_UCS1* sub, Py_ssize_t sub_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t count;

    if (str_len < 0)
        return 0;
    if (sub_len == 0)
        return (str_len < maxcount) ? str_len + 1 : maxcount;

    count = ucs1lib_fastsearch(str, str_len, sub, sub_len, maxcount, 0);

    if (count < 0)
        return 0;

    return count;
}
# 595 "unicodeobject.c" 2
# 1 "stringlib/find.h" 1






static inline Py_ssize_t
ucs1lib_find(const Py_UCS1* str, Py_ssize_t str_len,
               const Py_UCS1* sub, Py_ssize_t sub_len,
               Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return offset;

    pos = ucs1lib_fastsearch(str, str_len, sub, sub_len, -1, 1);

    if (pos >= 0)
        pos += offset;

    return pos;
}

static inline Py_ssize_t
ucs1lib_rfind(const Py_UCS1* str, Py_ssize_t str_len,
                const Py_UCS1* sub, Py_ssize_t sub_len,
                Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return str_len + offset;

    pos = ucs1lib_fastsearch(str, str_len, sub, sub_len, -1, 2);

    if (pos >= 0)
        pos += offset;

    return pos;
}
# 62 "stringlib/find.h"
static inline Py_ssize_t
ucs1lib_find_slice(const Py_UCS1* str, Py_ssize_t str_len,
                     const Py_UCS1* sub, Py_ssize_t sub_len,
                     Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return ucs1lib_find(str + start, end - start, sub, sub_len, start);
}

static inline Py_ssize_t
ucs1lib_rfind_slice(const Py_UCS1* str, Py_ssize_t str_len,
                      const Py_UCS1* sub, Py_ssize_t sub_len,
                      Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return ucs1lib_rfind(str + start, end - start, sub, sub_len, start);
}
# 104 "stringlib/find.h"
static inline int
ucs1lib_parse_args_finds(const char * function_name, PyObject *args,
                           PyObject **subobj,
                           Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_subobj;
    Py_ssize_t tmp_start = 0;
    Py_ssize_t tmp_end = ((Py_ssize_t)(((size_t)-1)>>1));
    PyObject *obj_start=(&_Py_NoneStruct), *obj_end=(&_Py_NoneStruct);
    char format[50] = "O|OO:";
    size_t len = strlen(format);

    ((__builtin_object_size (format + len, 0) != (size_t) -1) ? __builtin___strncpy_chk (format + len, function_name, 50 - len - 1, __builtin_object_size (format + len, 2 > 1)) : __inline_strncpy_chk (format + len, function_name, 50 - len - 1));
    format[50 - 1] = '\0';

    if (!_PyArg_ParseTuple_SizeT(args, format, &tmp_subobj, &obj_start, &obj_end))
        return 0;




    if (obj_start != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_start, &tmp_start))
            return 0;
    if (obj_end != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_end, &tmp_end))
            return 0;

    *start = tmp_start;
    *end = tmp_end;
    *subobj = tmp_subobj;
    return 1;
}
# 152 "stringlib/find.h"
static inline int
ucs1lib_parse_args_finds_unicode(const char * function_name, PyObject *args,
                                   PyObject **substring,
                                   Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_substring;

    if(ucs1lib_parse_args_finds(function_name, args, &tmp_substring,
                                  start, end)) {
        tmp_substring = PyUnicode_FromObject(tmp_substring);
        if (!tmp_substring)
            return 0;
        *substring = tmp_substring;
        return 1;
    }
    return 0;
}
# 596 "unicodeobject.c" 2
# 1 "stringlib/find_max_char.h" 1
# 17 "stringlib/find_max_char.h"
static inline Py_UCS4
ucs1lib_find_max_char(const Py_UCS1 *begin, const Py_UCS1 *end)
{
    const unsigned char *p = (const unsigned char *) begin;
    const unsigned char *aligned_end =
            (const unsigned char *) ((void *)((Py_uintptr_t)(end) & ~(Py_uintptr_t)((8) - 1)));

    while (p < end) {
        if ((!((Py_uintptr_t)(p) & (Py_uintptr_t)((8) - 1)))) {

            register const unsigned char *_p = p;
            while (_p < aligned_end) {
                unsigned long value = *(unsigned long *) _p;
                if (value & 0x8080808080808080UL)
                    return 255;
                _p += 8;
            }
            p = _p;
            if (p == end)
                break;
        }
        if (*p++ & 0x80)
            return 255;
    }
    return 127;
}
# 597 "unicodeobject.c" 2
# 1 "stringlib/localeutil.h" 1
# 9 "stringlib/localeutil.h"
typedef struct {
    const char *grouping;
    char previous;
    Py_ssize_t i;
} ucs1lib_GroupGenerator;

static void
ucs1lib_GroupGenerator_init(ucs1lib_GroupGenerator *self, const char *grouping)
{
    self->grouping = grouping;
    self->i = 0;
    self->previous = 0;
}


static Py_ssize_t
ucs1lib_GroupGenerator_next(ucs1lib_GroupGenerator *self)
{




    switch (self->grouping[self->i]) {
    case 0:
        return self->previous;
    case 127:

        return 0;
    default: {
        char ch = self->grouping[self->i];
        self->previous = ch;
        self->i++;
        return (Py_ssize_t)ch;
    }
    }
}



static void
ucs1lib_fill(Py_UCS1 **digits_end, Py_UCS1 **buffer_end,
     Py_ssize_t n_chars, Py_ssize_t n_zeros, Py_UCS1* thousands_sep,
     Py_ssize_t thousands_sep_len)
{
    Py_ssize_t i;

    if (thousands_sep) {
        *buffer_end -= thousands_sep_len;


        ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 1, __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 1));

    }

    *buffer_end -= n_chars;
    *digits_end -= n_chars;
    ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS1), __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS1)));

    *buffer_end -= n_zeros;
    for (i = 0; i < n_zeros; i++)
        (*buffer_end)[i] = '0';
}
# 102 "stringlib/localeutil.h"
static Py_ssize_t
ucs1lib_InsertThousandsGrouping(
    Py_UCS1 *buffer,
    Py_ssize_t n_buffer,
    Py_UCS1 *digits,
    Py_ssize_t n_digits,
    Py_ssize_t min_width,
    const char *grouping,
    Py_UCS1 *thousands_sep,
    Py_ssize_t thousands_sep_len)
{
    Py_ssize_t count = 0;
    Py_ssize_t n_zeros;
    int loop_broken = 0;
    int use_separator = 0;


    Py_UCS1 *buffer_end = ((void *)0);
    Py_UCS1 *digits_end = ((void *)0);
    Py_ssize_t l;
    Py_ssize_t n_chars;
    Py_ssize_t remaining = n_digits;



    ucs1lib_GroupGenerator groupgen;
    ucs1lib_GroupGenerator_init(&groupgen, grouping);

    if (buffer) {
        buffer_end = buffer + n_buffer;
        digits_end = digits + n_digits;
    }

    while ((l = ucs1lib_GroupGenerator_next(&groupgen)) > 0) {
        l = (((l) > (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1)))) ? (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1))) : (l));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));




        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

        if (buffer) {

            ucs1lib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }


        use_separator = 1;

        remaining -= n_chars;
        min_width -= l;

        if (remaining <= 0 && min_width <= 0) {
            loop_broken = 1;
            break;
        }
        min_width -= thousands_sep_len;
    }
    if (!loop_broken) {


        l = ((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));


        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;
        if (buffer) {

            ucs1lib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }
    }
    return count;
}
# 598 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 599 "unicodeobject.c" 2

# 1 "stringlib/ucs2lib.h" 1
# 601 "unicodeobject.c" 2
# 1 "stringlib/fastsearch.h" 1
# 36 "stringlib/fastsearch.h"
static inline Py_ssize_t
ucs2lib_fastsearch_memchr_1char(const Py_UCS2* s, Py_ssize_t n,
                                   Py_UCS2 ch, unsigned char needle,
                                   Py_ssize_t maxcount, int mode)
{
    if (mode == 1) {
        const Py_UCS2 *ptr = s;
        const Py_UCS2 *e = s + n;
        while (ptr < e) {
            void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(Py_UCS2));
            if (candidate == ((void *)0))
                return -1;
            ptr = (const Py_UCS2 *) ((void *)((Py_uintptr_t)(candidate) & ~(Py_uintptr_t)((sizeof(Py_UCS2)) - 1)));
            if (sizeof(Py_UCS2) == 1 || *ptr == ch)
                return (ptr - s);

            ptr++;
        }
        return -1;
    }
# 75 "stringlib/fastsearch.h"
    else {
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "stringlib/fastsearch.h", 76, "0") : (void)0);
        return 0;
    }


}

static inline Py_ssize_t
ucs2lib_fastsearch(const Py_UCS2* s, Py_ssize_t n,
           const Py_UCS2* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode)
{
    unsigned long mask;
    Py_ssize_t skip, count = 0;
    Py_ssize_t i, j, mlast, w;

    w = n - m;

    if (w < 0 || (mode == 0 && maxcount == 0))
        return -1;


    if (m <= 1) {
        if (m <= 0)
            return -1;

        if (n > 10 && (mode == 1



                    )) {


            unsigned char needle;
            needle = p[0] & 0xff;




            if (needle != 0)

                return ucs2lib_fastsearch_memchr_1char
                       (s, n, p[0], needle, maxcount, mode);
        }
        if (mode == 0) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0]) {
                    count++;
                    if (count == maxcount)
                        return maxcount;
                }
            return count;
        } else if (mode == 1) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0])
                    return i;
        } else {
            for (i = n - 1; i > -1; i--)
                if (s[i] == p[0])
                    return i;
        }
        return -1;
    }

    mlast = m - 1;
    skip = mlast - 1;
    mask = 0;

    if (mode != 2) {




        for (i = 0; i < mlast; i++) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[mlast])
                skip = mlast - i - 1;
        }

        ((mask |= (1UL << ((p[mlast]) & (64 -1)))));

        for (i = 0; i <= w; i++) {

            if (s[i+m-1] == p[m-1]) {

                for (j = 0; j < mlast; j++)
                    if (s[i+j] != p[j])
                        break;
                if (j == mlast) {

                    if (mode != 0)
                        return i;
                    count++;
                    if (count == maxcount)
                        return maxcount;
                    i = i + mlast;
                    continue;
                }

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
                else
                    i = i + skip;
            } else {

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
            }
        }
    } else {




        ((mask |= (1UL << ((p[0]) & (64 -1)))));

        for (i = mlast; i > 0; i--) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[0])
                skip = i - 1;
        }

        for (i = w; i >= 0; i--) {
            if (s[i] == p[0]) {

                for (j = mlast; j > 0; j--)
                    if (s[i+j] != p[j])
                        break;
                if (j == 0)

                    return i;

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
                else
                    i = i - skip;
            } else {

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
            }
        }
    }

    if (mode != 0)
        return -1;
    return count;
}
# 602 "unicodeobject.c" 2
# 1 "stringlib/partition.h" 1






static inline PyObject*
ucs2lib_partition(PyObject* str_obj,
                    const Py_UCS2* str, Py_ssize_t str_len,
                    PyObject* sep_obj,
                    const Py_UCS2* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = ucs2lib_fastsearch(str, str_len, sep, sep_len, -1, 1);

    if (pos < 0) {





        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) str_obj);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) unicode_empty);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromUCS2(str, pos));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromUCS2(str + pos, str_len - pos));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}

static inline PyObject*
ucs2lib_rpartition(PyObject* str_obj,
                     const Py_UCS2* str, Py_ssize_t str_len,
                     PyObject* sep_obj,
                     const Py_UCS2* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = ucs2lib_fastsearch(str, str_len, sep, sep_len, -1, 2);

    if (pos < 0) {





        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) str_obj);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromUCS2(str, pos));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromUCS2(str + pos, str_len - pos));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}
# 603 "unicodeobject.c" 2
# 1 "stringlib/split.h" 1
# 53 "stringlib/split.h"
static inline PyObject *
ucs2lib_split_whitespace(PyObject* str_obj,
                           const Py_UCS2* str, Py_ssize_t str_len,
                           Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i == str_len) break;
        j = i; i++;
        while (i < str_len && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;

        if (j == 0 && i == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromUCS2((str) + (j), (i) - (j)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i < str_len) {


        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i != str_len)
            { sub = _PyUnicode_FromUCS2((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs2lib_split_char(PyObject* str_obj,
                     const Py_UCS2* str, Py_ssize_t str_len,
                     const Py_UCS2 ch,
                     Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while ((j < str_len) && (maxcount-- > 0)) {
        for(; j < str_len; j++) {

            if (str[j] == ch) {
                { sub = _PyUnicode_FromUCS2((str) + (i), (j) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                i = j = j + 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (i <= str_len) {
        { sub = _PyUnicode_FromUCS2((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs2lib_split(PyObject* str_obj,
                const Py_UCS2* str, Py_ssize_t str_len,
                const Py_UCS2* sep, Py_ssize_t sep_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t i, j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return ucs2lib_split_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        pos = ucs2lib_fastsearch(str+i, str_len-i, sep, sep_len, -1, 1);
        if (pos < 0)
            break;
        j = i + pos;
        { sub = _PyUnicode_FromUCS2((str) + (i), (j) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        i = j + sep_len;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromUCS2((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs2lib_rsplit_whitespace(PyObject* str_obj,
                            const Py_UCS2* str, Py_ssize_t str_len,
                            Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while (maxcount-- > 0) {
        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i < 0) break;
        j = i; i--;
        while (i >= 0 && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;

        if (j == str_len - 1 && i < 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromUCS2((str) + (i + 1), (j + 1) - (i + 1)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i >= 0) {


        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i >= 0)
            { sub = _PyUnicode_FromUCS2((str) + (0), (i + 1) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs2lib_rsplit_char(PyObject* str_obj,
                      const Py_UCS2* str, Py_ssize_t str_len,
                      const Py_UCS2 ch,
                      Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while ((i >= 0) && (maxcount-- > 0)) {
        for(; i >= 0; i--) {
            if (str[i] == ch) {
                { sub = _PyUnicode_FromUCS2((str) + (i + 1), (j + 1) - (i + 1)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                j = i = i - 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (j >= -1) {
        { sub = _PyUnicode_FromUCS2((str) + (0), (j + 1) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs2lib_rsplit(PyObject* str_obj,
                 const Py_UCS2* str, Py_ssize_t str_len,
                 const Py_UCS2* sep, Py_ssize_t sep_len,
                 Py_ssize_t maxcount)
{
    Py_ssize_t j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return ucs2lib_rsplit_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    j = str_len;
    while (maxcount-- > 0) {
        pos = ucs2lib_fastsearch(str, j, sep, sep_len, -1, 2);
        if (pos < 0)
            break;
        { sub = _PyUnicode_FromUCS2((str) + (pos + sep_len), (j) - (pos + sep_len)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        j = pos;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromUCS2((str) + (0), (j) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs2lib_splitlines(PyObject* str_obj,
                     const Py_UCS2* str, Py_ssize_t str_len,
                     int keepends)
{
# 348 "stringlib/split.h"
    register Py_ssize_t i;
    register Py_ssize_t j;
    PyObject *list = PyList_New(0);
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    for (i = j = 0; i < str_len; ) {
        Py_ssize_t eol;


        while (i < str_len && !((str[i]) < 128U ? ascii_linebreak[(str[i])] : (((bloom_linebreak & (1UL << (((str[i])) & (64 - 1))))) && _PyUnicode_IsLinebreak(str[i]))))
            i++;


        eol = i;
        if (i < str_len) {
            if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')
                i += 2;
            else
                i++;
            if (keepends)
                eol = i;
        }

        if (j == 0 && eol == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            if (PyList_Append(list, str_obj))
                goto onError;
            break;
        }

        sub = _PyUnicode_FromUCS2((str) + (j), (eol) - (j)); if (sub == ((void *)0)) goto onError; if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);;
        j = i;
    }
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}
# 604 "unicodeobject.c" 2
# 1 "stringlib/count.h" 1






static inline Py_ssize_t
ucs2lib_count(const Py_UCS2* str, Py_ssize_t str_len,
                const Py_UCS2* sub, Py_ssize_t sub_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t count;

    if (str_len < 0)
        return 0;
    if (sub_len == 0)
        return (str_len < maxcount) ? str_len + 1 : maxcount;

    count = ucs2lib_fastsearch(str, str_len, sub, sub_len, maxcount, 0);

    if (count < 0)
        return 0;

    return count;
}
# 605 "unicodeobject.c" 2
# 1 "stringlib/find.h" 1






static inline Py_ssize_t
ucs2lib_find(const Py_UCS2* str, Py_ssize_t str_len,
               const Py_UCS2* sub, Py_ssize_t sub_len,
               Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return offset;

    pos = ucs2lib_fastsearch(str, str_len, sub, sub_len, -1, 1);

    if (pos >= 0)
        pos += offset;

    return pos;
}

static inline Py_ssize_t
ucs2lib_rfind(const Py_UCS2* str, Py_ssize_t str_len,
                const Py_UCS2* sub, Py_ssize_t sub_len,
                Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return str_len + offset;

    pos = ucs2lib_fastsearch(str, str_len, sub, sub_len, -1, 2);

    if (pos >= 0)
        pos += offset;

    return pos;
}
# 62 "stringlib/find.h"
static inline Py_ssize_t
ucs2lib_find_slice(const Py_UCS2* str, Py_ssize_t str_len,
                     const Py_UCS2* sub, Py_ssize_t sub_len,
                     Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return ucs2lib_find(str + start, end - start, sub, sub_len, start);
}

static inline Py_ssize_t
ucs2lib_rfind_slice(const Py_UCS2* str, Py_ssize_t str_len,
                      const Py_UCS2* sub, Py_ssize_t sub_len,
                      Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return ucs2lib_rfind(str + start, end - start, sub, sub_len, start);
}
# 104 "stringlib/find.h"
static inline int
ucs2lib_parse_args_finds(const char * function_name, PyObject *args,
                           PyObject **subobj,
                           Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_subobj;
    Py_ssize_t tmp_start = 0;
    Py_ssize_t tmp_end = ((Py_ssize_t)(((size_t)-1)>>1));
    PyObject *obj_start=(&_Py_NoneStruct), *obj_end=(&_Py_NoneStruct);
    char format[50] = "O|OO:";
    size_t len = strlen(format);

    ((__builtin_object_size (format + len, 0) != (size_t) -1) ? __builtin___strncpy_chk (format + len, function_name, 50 - len - 1, __builtin_object_size (format + len, 2 > 1)) : __inline_strncpy_chk (format + len, function_name, 50 - len - 1));
    format[50 - 1] = '\0';

    if (!_PyArg_ParseTuple_SizeT(args, format, &tmp_subobj, &obj_start, &obj_end))
        return 0;




    if (obj_start != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_start, &tmp_start))
            return 0;
    if (obj_end != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_end, &tmp_end))
            return 0;

    *start = tmp_start;
    *end = tmp_end;
    *subobj = tmp_subobj;
    return 1;
}
# 152 "stringlib/find.h"
static inline int
ucs2lib_parse_args_finds_unicode(const char * function_name, PyObject *args,
                                   PyObject **substring,
                                   Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_substring;

    if(ucs2lib_parse_args_finds(function_name, args, &tmp_substring,
                                  start, end)) {
        tmp_substring = PyUnicode_FromObject(tmp_substring);
        if (!tmp_substring)
            return 0;
        *substring = tmp_substring;
        return 1;
    }
    return 0;
}
# 606 "unicodeobject.c" 2
# 1 "stringlib/find_max_char.h" 1
# 57 "stringlib/find_max_char.h"
static inline Py_UCS4
ucs2lib_find_max_char(const Py_UCS2 *begin, const Py_UCS2 *end)
{

    const Py_UCS4 mask_limit = 0xFFFFFF00;
    const Py_UCS4 max_char_limit = 0xffff;






    register Py_UCS4 mask;
    Py_ssize_t n = end - begin;
    const Py_UCS2 *p = begin;
    const Py_UCS2 *unrolled_end = begin + ((size_t)(n) & ~(size_t)((4) - 1));
    Py_UCS4 max_char;

    max_char = 0x7f;
    mask = 0xFFFFFF80;
    while (p < unrolled_end) {
        Py_UCS2 bits = p[0] | p[1] | p[2] | p[3];
        if (bits & mask) {
            if (mask == mask_limit) {

                return max_char_limit;
            }
            if (mask == 0xFFFFFF80) {
                max_char = 0xff;
                mask = 0xFFFFFF00;
            }
            else {

                (__builtin_expect(!(mask == 0xFFFFFF00), 0) ? __assert_rtn(__func__, "stringlib/find_max_char.h", 90, "mask == MASK_UCS1") : (void)0);
                max_char = 0xffff;
                mask = 0xFFFF0000;
            }

            continue;
        }
        p += 4;
    }
    while (p < end) {
        if (p[0] & mask) {
            if (mask == mask_limit) {

                return max_char_limit;
            }
            if (mask == 0xFFFFFF80) {
                max_char = 0xff;
                mask = 0xFFFFFF00;
            }
            else {

                (__builtin_expect(!(mask == 0xFFFFFF00), 0) ? __assert_rtn(__func__, "stringlib/find_max_char.h", 111, "mask == MASK_UCS1") : (void)0);
                max_char = 0xffff;
                mask = 0xFFFF0000;
            }

            continue;
        }
        p++;
    }
    return max_char;
}
# 607 "unicodeobject.c" 2
# 1 "stringlib/localeutil.h" 1
# 9 "stringlib/localeutil.h"
typedef struct {
    const char *grouping;
    char previous;
    Py_ssize_t i;
} ucs2lib_GroupGenerator;

static void
ucs2lib_GroupGenerator_init(ucs2lib_GroupGenerator *self, const char *grouping)
{
    self->grouping = grouping;
    self->i = 0;
    self->previous = 0;
}


static Py_ssize_t
ucs2lib_GroupGenerator_next(ucs2lib_GroupGenerator *self)
{




    switch (self->grouping[self->i]) {
    case 0:
        return self->previous;
    case 127:

        return 0;
    default: {
        char ch = self->grouping[self->i];
        self->previous = ch;
        self->i++;
        return (Py_ssize_t)ch;
    }
    }
}



static void
ucs2lib_fill(Py_UCS2 **digits_end, Py_UCS2 **buffer_end,
     Py_ssize_t n_chars, Py_ssize_t n_zeros, Py_UCS2* thousands_sep,
     Py_ssize_t thousands_sep_len)
{
    Py_ssize_t i;

    if (thousands_sep) {
        *buffer_end -= thousands_sep_len;


        ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 2, __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 2));

    }

    *buffer_end -= n_chars;
    *digits_end -= n_chars;
    ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS2), __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS2)));

    *buffer_end -= n_zeros;
    for (i = 0; i < n_zeros; i++)
        (*buffer_end)[i] = '0';
}
# 102 "stringlib/localeutil.h"
static Py_ssize_t
ucs2lib_InsertThousandsGrouping(
    Py_UCS2 *buffer,
    Py_ssize_t n_buffer,
    Py_UCS2 *digits,
    Py_ssize_t n_digits,
    Py_ssize_t min_width,
    const char *grouping,
    Py_UCS2 *thousands_sep,
    Py_ssize_t thousands_sep_len)
{
    Py_ssize_t count = 0;
    Py_ssize_t n_zeros;
    int loop_broken = 0;
    int use_separator = 0;


    Py_UCS2 *buffer_end = ((void *)0);
    Py_UCS2 *digits_end = ((void *)0);
    Py_ssize_t l;
    Py_ssize_t n_chars;
    Py_ssize_t remaining = n_digits;



    ucs2lib_GroupGenerator groupgen;
    ucs2lib_GroupGenerator_init(&groupgen, grouping);

    if (buffer) {
        buffer_end = buffer + n_buffer;
        digits_end = digits + n_digits;
    }

    while ((l = ucs2lib_GroupGenerator_next(&groupgen)) > 0) {
        l = (((l) > (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1)))) ? (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1))) : (l));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));




        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

        if (buffer) {

            ucs2lib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }


        use_separator = 1;

        remaining -= n_chars;
        min_width -= l;

        if (remaining <= 0 && min_width <= 0) {
            loop_broken = 1;
            break;
        }
        min_width -= thousands_sep_len;
    }
    if (!loop_broken) {


        l = ((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));


        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;
        if (buffer) {

            ucs2lib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }
    }
    return count;
}
# 608 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 609 "unicodeobject.c" 2

# 1 "stringlib/ucs4lib.h" 1
# 611 "unicodeobject.c" 2
# 1 "stringlib/fastsearch.h" 1
# 36 "stringlib/fastsearch.h"
static inline Py_ssize_t
ucs4lib_fastsearch_memchr_1char(const Py_UCS4* s, Py_ssize_t n,
                                   Py_UCS4 ch, unsigned char needle,
                                   Py_ssize_t maxcount, int mode)
{
    if (mode == 1) {
        const Py_UCS4 *ptr = s;
        const Py_UCS4 *e = s + n;
        while (ptr < e) {
            void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(Py_UCS4));
            if (candidate == ((void *)0))
                return -1;
            ptr = (const Py_UCS4 *) ((void *)((Py_uintptr_t)(candidate) & ~(Py_uintptr_t)((sizeof(Py_UCS4)) - 1)));
            if (sizeof(Py_UCS4) == 1 || *ptr == ch)
                return (ptr - s);

            ptr++;
        }
        return -1;
    }
# 75 "stringlib/fastsearch.h"
    else {
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "stringlib/fastsearch.h", 76, "0") : (void)0);
        return 0;
    }


}

static inline Py_ssize_t
ucs4lib_fastsearch(const Py_UCS4* s, Py_ssize_t n,
           const Py_UCS4* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode)
{
    unsigned long mask;
    Py_ssize_t skip, count = 0;
    Py_ssize_t i, j, mlast, w;

    w = n - m;

    if (w < 0 || (mode == 0 && maxcount == 0))
        return -1;


    if (m <= 1) {
        if (m <= 0)
            return -1;

        if (n > 10 && (mode == 1



                    )) {


            unsigned char needle;
            needle = p[0] & 0xff;




            if (needle != 0)

                return ucs4lib_fastsearch_memchr_1char
                       (s, n, p[0], needle, maxcount, mode);
        }
        if (mode == 0) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0]) {
                    count++;
                    if (count == maxcount)
                        return maxcount;
                }
            return count;
        } else if (mode == 1) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0])
                    return i;
        } else {
            for (i = n - 1; i > -1; i--)
                if (s[i] == p[0])
                    return i;
        }
        return -1;
    }

    mlast = m - 1;
    skip = mlast - 1;
    mask = 0;

    if (mode != 2) {




        for (i = 0; i < mlast; i++) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[mlast])
                skip = mlast - i - 1;
        }

        ((mask |= (1UL << ((p[mlast]) & (64 -1)))));

        for (i = 0; i <= w; i++) {

            if (s[i+m-1] == p[m-1]) {

                for (j = 0; j < mlast; j++)
                    if (s[i+j] != p[j])
                        break;
                if (j == mlast) {

                    if (mode != 0)
                        return i;
                    count++;
                    if (count == maxcount)
                        return maxcount;
                    i = i + mlast;
                    continue;
                }

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
                else
                    i = i + skip;
            } else {

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
            }
        }
    } else {




        ((mask |= (1UL << ((p[0]) & (64 -1)))));

        for (i = mlast; i > 0; i--) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[0])
                skip = i - 1;
        }

        for (i = w; i >= 0; i--) {
            if (s[i] == p[0]) {

                for (j = mlast; j > 0; j--)
                    if (s[i+j] != p[j])
                        break;
                if (j == 0)

                    return i;

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
                else
                    i = i - skip;
            } else {

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
            }
        }
    }

    if (mode != 0)
        return -1;
    return count;
}
# 612 "unicodeobject.c" 2
# 1 "stringlib/partition.h" 1






static inline PyObject*
ucs4lib_partition(PyObject* str_obj,
                    const Py_UCS4* str, Py_ssize_t str_len,
                    PyObject* sep_obj,
                    const Py_UCS4* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = ucs4lib_fastsearch(str, str_len, sep, sep_len, -1, 1);

    if (pos < 0) {





        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) str_obj);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) unicode_empty);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromUCS4(str, pos));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromUCS4(str + pos, str_len - pos));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}

static inline PyObject*
ucs4lib_rpartition(PyObject* str_obj,
                     const Py_UCS4* str, Py_ssize_t str_len,
                     PyObject* sep_obj,
                     const Py_UCS4* sep, Py_ssize_t sep_len)
{
    PyObject* out;
    Py_ssize_t pos;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }

    out = PyTuple_New(3);
    if (!out)
        return ((void *)0);

    pos = ucs4lib_fastsearch(str, str_len, sep, sep_len, -1, 2);

    if (pos < 0) {





        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[0] = (PyObject*) unicode_empty);
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[1] = (PyObject*) unicode_empty);
        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyTupleObject *)(out))->ob_item[2] = (PyObject*) str_obj);

        return out;
    }

    (((PyTupleObject *)(out))->ob_item[0] = _PyUnicode_FromUCS4(str, pos));
    ( ((PyObject*)(sep_obj))->ob_refcnt++);
    (((PyTupleObject *)(out))->ob_item[1] = sep_obj);
    pos += sep_len;
    (((PyTupleObject *)(out))->ob_item[2] = _PyUnicode_FromUCS4(str + pos, str_len - pos));

    if (PyErr_Occurred()) {
        do { if ( --((PyObject*)(out))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(out)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(out)))); } while (0);
        return ((void *)0);
    }

    return out;
}
# 613 "unicodeobject.c" 2
# 1 "stringlib/split.h" 1
# 53 "stringlib/split.h"
static inline PyObject *
ucs4lib_split_whitespace(PyObject* str_obj,
                           const Py_UCS4* str, Py_ssize_t str_len,
                           Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i == str_len) break;
        j = i; i++;
        while (i < str_len && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;

        if (j == 0 && i == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromUCS4((str) + (j), (i) - (j)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i < str_len) {


        while (i < str_len && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i++;
        if (i != str_len)
            { sub = _PyUnicode_FromUCS4((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs4lib_split_char(PyObject* str_obj,
                     const Py_UCS4* str, Py_ssize_t str_len,
                     const Py_UCS4 ch,
                     Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while ((j < str_len) && (maxcount-- > 0)) {
        for(; j < str_len; j++) {

            if (str[j] == ch) {
                { sub = _PyUnicode_FromUCS4((str) + (i), (j) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                i = j = j + 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (i <= str_len) {
        { sub = _PyUnicode_FromUCS4((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs4lib_split(PyObject* str_obj,
                const Py_UCS4* str, Py_ssize_t str_len,
                const Py_UCS4* sep, Py_ssize_t sep_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t i, j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return ucs4lib_split_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    i = j = 0;
    while (maxcount-- > 0) {
        pos = ucs4lib_fastsearch(str+i, str_len-i, sep, sep_len, -1, 1);
        if (pos < 0)
            break;
        j = i + pos;
        { sub = _PyUnicode_FromUCS4((str) + (i), (j) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        i = j + sep_len;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromUCS4((str) + (i), (str_len) - (i)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs4lib_rsplit_whitespace(PyObject* str_obj,
                            const Py_UCS4* str, Py_ssize_t str_len,
                            Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while (maxcount-- > 0) {
        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i < 0) break;
        j = i; i--;
        while (i >= 0 && !((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;

        if (j == str_len - 1 && i < 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            ( ((PyObject*)(str_obj))->ob_refcnt++);
            (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
            count++;
            break;
        }

        { sub = _PyUnicode_FromUCS4((str) + (i + 1), (j + 1) - (i + 1)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }

    if (i >= 0) {


        while (i >= 0 && ((str[i]) < 128U ? _Py_ascii_whitespace[(str[i])] : _PyUnicode_IsWhitespace(str[i])))
            i--;
        if (i >= 0)
            { sub = _PyUnicode_FromUCS4((str) + (0), (i + 1) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs4lib_rsplit_char(PyObject* str_obj,
                      const Py_UCS4* str, Py_ssize_t str_len,
                      const Py_UCS4 ch,
                      Py_ssize_t maxcount)
{
    Py_ssize_t i, j, count=0;
    PyObject *list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    i = j = str_len - 1;
    while ((i >= 0) && (maxcount-- > 0)) {
        for(; i >= 0; i--) {
            if (str[i] == ch) {
                { sub = _PyUnicode_FromUCS4((str) + (i + 1), (j + 1) - (i + 1)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
                j = i = i - 1;
                break;
            }
        }
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    if (j >= -1) {
        { sub = _PyUnicode_FromUCS4((str) + (0), (j + 1) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs4lib_rsplit(PyObject* str_obj,
                 const Py_UCS4* str, Py_ssize_t str_len,
                 const Py_UCS4* sep, Py_ssize_t sep_len,
                 Py_ssize_t maxcount)
{
    Py_ssize_t j, pos, count=0;
    PyObject *list, *sub;

    if (sep_len == 0) {
        PyErr_SetString(PyExc_ValueError, "empty separator");
        return ((void *)0);
    }
    else if (sep_len == 1)
        return ucs4lib_rsplit_char(str_obj, str, str_len, sep[0], maxcount);

    list = PyList_New((maxcount >= 12 ? 12 : maxcount+1));
    if (list == ((void *)0))
        return ((void *)0);

    j = str_len;
    while (maxcount-- > 0) {
        pos = ucs4lib_fastsearch(str, j, sep, sep_len, -1, 2);
        if (pos < 0)
            break;
        { sub = _PyUnicode_FromUCS4((str) + (pos + sep_len), (j) - (pos + sep_len)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
        j = pos;
    }

    if (count == 0 && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

        ( ((PyObject*)(str_obj))->ob_refcnt++);
        (((PyListObject *)(list))->ob_item[0] = ((PyObject *)str_obj));
        count++;
    } else

    {
        { sub = _PyUnicode_FromUCS4((str) + (0), (j) - (0)); if (sub == ((void *)0)) goto onError; if (count < 12) { (((PyListObject *)(list))->ob_item[count] = (sub)); } else { if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); } count++; };
    }
    (((PyVarObject*)(list))->ob_size) = count;
    if (PyList_Reverse(list) < 0)
        goto onError;
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}

static inline PyObject *
ucs4lib_splitlines(PyObject* str_obj,
                     const Py_UCS4* str, Py_ssize_t str_len,
                     int keepends)
{
# 348 "stringlib/split.h"
    register Py_ssize_t i;
    register Py_ssize_t j;
    PyObject *list = PyList_New(0);
    PyObject *sub;

    if (list == ((void *)0))
        return ((void *)0);

    for (i = j = 0; i < str_len; ) {
        Py_ssize_t eol;


        while (i < str_len && !((str[i]) < 128U ? ascii_linebreak[(str[i])] : (((bloom_linebreak & (1UL << (((str[i])) & (64 - 1))))) && _PyUnicode_IsLinebreak(str[i]))))
            i++;


        eol = i;
        if (i < str_len) {
            if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')
                i += 2;
            else
                i++;
            if (keepends)
                eol = i;
        }

        if (j == 0 && eol == str_len && ((((PyObject*)(str_obj))->ob_type) == &PyUnicode_Type)) {

            if (PyList_Append(list, str_obj))
                goto onError;
            break;
        }

        sub = _PyUnicode_FromUCS4((str) + (j), (eol) - (j)); if (sub == ((void *)0)) goto onError; if (PyList_Append(list, sub)) { do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0); goto onError; } else do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);;
        j = i;
    }
    return list;

  onError:
    do { if ( --((PyObject*)(list))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(list)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(list)))); } while (0);
    return ((void *)0);
}
# 614 "unicodeobject.c" 2
# 1 "stringlib/count.h" 1






static inline Py_ssize_t
ucs4lib_count(const Py_UCS4* str, Py_ssize_t str_len,
                const Py_UCS4* sub, Py_ssize_t sub_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t count;

    if (str_len < 0)
        return 0;
    if (sub_len == 0)
        return (str_len < maxcount) ? str_len + 1 : maxcount;

    count = ucs4lib_fastsearch(str, str_len, sub, sub_len, maxcount, 0);

    if (count < 0)
        return 0;

    return count;
}
# 615 "unicodeobject.c" 2
# 1 "stringlib/find.h" 1






static inline Py_ssize_t
ucs4lib_find(const Py_UCS4* str, Py_ssize_t str_len,
               const Py_UCS4* sub, Py_ssize_t sub_len,
               Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return offset;

    pos = ucs4lib_fastsearch(str, str_len, sub, sub_len, -1, 1);

    if (pos >= 0)
        pos += offset;

    return pos;
}

static inline Py_ssize_t
ucs4lib_rfind(const Py_UCS4* str, Py_ssize_t str_len,
                const Py_UCS4* sub, Py_ssize_t sub_len,
                Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return str_len + offset;

    pos = ucs4lib_fastsearch(str, str_len, sub, sub_len, -1, 2);

    if (pos >= 0)
        pos += offset;

    return pos;
}
# 62 "stringlib/find.h"
static inline Py_ssize_t
ucs4lib_find_slice(const Py_UCS4* str, Py_ssize_t str_len,
                     const Py_UCS4* sub, Py_ssize_t sub_len,
                     Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return ucs4lib_find(str + start, end - start, sub, sub_len, start);
}

static inline Py_ssize_t
ucs4lib_rfind_slice(const Py_UCS4* str, Py_ssize_t str_len,
                      const Py_UCS4* sub, Py_ssize_t sub_len,
                      Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return ucs4lib_rfind(str + start, end - start, sub, sub_len, start);
}
# 104 "stringlib/find.h"
static inline int
ucs4lib_parse_args_finds(const char * function_name, PyObject *args,
                           PyObject **subobj,
                           Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_subobj;
    Py_ssize_t tmp_start = 0;
    Py_ssize_t tmp_end = ((Py_ssize_t)(((size_t)-1)>>1));
    PyObject *obj_start=(&_Py_NoneStruct), *obj_end=(&_Py_NoneStruct);
    char format[50] = "O|OO:";
    size_t len = strlen(format);

    ((__builtin_object_size (format + len, 0) != (size_t) -1) ? __builtin___strncpy_chk (format + len, function_name, 50 - len - 1, __builtin_object_size (format + len, 2 > 1)) : __inline_strncpy_chk (format + len, function_name, 50 - len - 1));
    format[50 - 1] = '\0';

    if (!_PyArg_ParseTuple_SizeT(args, format, &tmp_subobj, &obj_start, &obj_end))
        return 0;




    if (obj_start != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_start, &tmp_start))
            return 0;
    if (obj_end != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_end, &tmp_end))
            return 0;

    *start = tmp_start;
    *end = tmp_end;
    *subobj = tmp_subobj;
    return 1;
}
# 152 "stringlib/find.h"
static inline int
ucs4lib_parse_args_finds_unicode(const char * function_name, PyObject *args,
                                   PyObject **substring,
                                   Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_substring;

    if(ucs4lib_parse_args_finds(function_name, args, &tmp_substring,
                                  start, end)) {
        tmp_substring = PyUnicode_FromObject(tmp_substring);
        if (!tmp_substring)
            return 0;
        *substring = tmp_substring;
        return 1;
    }
    return 0;
}
# 616 "unicodeobject.c" 2
# 1 "stringlib/find_max_char.h" 1
# 57 "stringlib/find_max_char.h"
static inline Py_UCS4
ucs4lib_find_max_char(const Py_UCS4 *begin, const Py_UCS4 *end)
{




    const Py_UCS4 mask_limit = 0xFFFF0000;
    const Py_UCS4 max_char_limit = 0x10ffff;



    register Py_UCS4 mask;
    Py_ssize_t n = end - begin;
    const Py_UCS4 *p = begin;
    const Py_UCS4 *unrolled_end = begin + ((size_t)(n) & ~(size_t)((4) - 1));
    Py_UCS4 max_char;

    max_char = 0x7f;
    mask = 0xFFFFFF80;
    while (p < unrolled_end) {
        Py_UCS4 bits = p[0] | p[1] | p[2] | p[3];
        if (bits & mask) {
            if (mask == mask_limit) {

                return max_char_limit;
            }
            if (mask == 0xFFFFFF80) {
                max_char = 0xff;
                mask = 0xFFFFFF00;
            }
            else {

                (__builtin_expect(!(mask == 0xFFFFFF00), 0) ? __assert_rtn(__func__, "stringlib/find_max_char.h", 90, "mask == MASK_UCS1") : (void)0);
                max_char = 0xffff;
                mask = 0xFFFF0000;
            }

            continue;
        }
        p += 4;
    }
    while (p < end) {
        if (p[0] & mask) {
            if (mask == mask_limit) {

                return max_char_limit;
            }
            if (mask == 0xFFFFFF80) {
                max_char = 0xff;
                mask = 0xFFFFFF00;
            }
            else {

                (__builtin_expect(!(mask == 0xFFFFFF00), 0) ? __assert_rtn(__func__, "stringlib/find_max_char.h", 111, "mask == MASK_UCS1") : (void)0);
                max_char = 0xffff;
                mask = 0xFFFF0000;
            }

            continue;
        }
        p++;
    }
    return max_char;
}
# 617 "unicodeobject.c" 2
# 1 "stringlib/localeutil.h" 1
# 9 "stringlib/localeutil.h"
typedef struct {
    const char *grouping;
    char previous;
    Py_ssize_t i;
} ucs4lib_GroupGenerator;

static void
ucs4lib_GroupGenerator_init(ucs4lib_GroupGenerator *self, const char *grouping)
{
    self->grouping = grouping;
    self->i = 0;
    self->previous = 0;
}


static Py_ssize_t
ucs4lib_GroupGenerator_next(ucs4lib_GroupGenerator *self)
{




    switch (self->grouping[self->i]) {
    case 0:
        return self->previous;
    case 127:

        return 0;
    default: {
        char ch = self->grouping[self->i];
        self->previous = ch;
        self->i++;
        return (Py_ssize_t)ch;
    }
    }
}



static void
ucs4lib_fill(Py_UCS4 **digits_end, Py_UCS4 **buffer_end,
     Py_ssize_t n_chars, Py_ssize_t n_zeros, Py_UCS4* thousands_sep,
     Py_ssize_t thousands_sep_len)
{
    Py_ssize_t i;

    if (thousands_sep) {
        *buffer_end -= thousands_sep_len;


        ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 4, __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, thousands_sep, thousands_sep_len * 4));

    }

    *buffer_end -= n_chars;
    *digits_end -= n_chars;
    ((__builtin_object_size (*buffer_end, 0) != (size_t) -1) ? __builtin___memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS4), __builtin_object_size (*buffer_end, 0)) : __inline_memcpy_chk (*buffer_end, *digits_end, n_chars * sizeof(Py_UCS4)));

    *buffer_end -= n_zeros;
    for (i = 0; i < n_zeros; i++)
        (*buffer_end)[i] = '0';
}
# 102 "stringlib/localeutil.h"
static Py_ssize_t
ucs4lib_InsertThousandsGrouping(
    Py_UCS4 *buffer,
    Py_ssize_t n_buffer,
    Py_UCS4 *digits,
    Py_ssize_t n_digits,
    Py_ssize_t min_width,
    const char *grouping,
    Py_UCS4 *thousands_sep,
    Py_ssize_t thousands_sep_len)
{
    Py_ssize_t count = 0;
    Py_ssize_t n_zeros;
    int loop_broken = 0;
    int use_separator = 0;


    Py_UCS4 *buffer_end = ((void *)0);
    Py_UCS4 *digits_end = ((void *)0);
    Py_ssize_t l;
    Py_ssize_t n_chars;
    Py_ssize_t remaining = n_digits;



    ucs4lib_GroupGenerator groupgen;
    ucs4lib_GroupGenerator_init(&groupgen, grouping);

    if (buffer) {
        buffer_end = buffer + n_buffer;
        digits_end = digits + n_digits;
    }

    while ((l = ucs4lib_GroupGenerator_next(&groupgen)) > 0) {
        l = (((l) > (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1)))) ? (((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1))) : (l));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));




        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

        if (buffer) {

            ucs4lib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }


        use_separator = 1;

        remaining -= n_chars;
        min_width -= l;

        if (remaining <= 0 && min_width <= 0) {
            loop_broken = 1;
            break;
        }
        min_width -= thousands_sep_len;
    }
    if (!loop_broken) {


        l = ((((((remaining) > (min_width)) ? (remaining) : (min_width))) > (1)) ? ((((remaining) > (min_width)) ? (remaining) : (min_width))) : (1));
        n_zeros = (((0) > (l - remaining)) ? (0) : (l - remaining));
        n_chars = (((0) > ((((remaining) > (l)) ? (l) : (remaining)))) ? (0) : ((((remaining) > (l)) ? (l) : (remaining))));


        count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;
        if (buffer) {

            ucs4lib_fill(&digits_end, &buffer_end, n_chars, n_zeros,
                 use_separator ? thousands_sep : ((void *)0), thousands_sep_len);
        }
    }
    return count;
}
# 618 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 619 "unicodeobject.c" 2

# 1 "stringlib/unicodedefs.h" 1
# 621 "unicodeobject.c" 2
# 1 "stringlib/fastsearch.h" 1
# 36 "stringlib/fastsearch.h"
static inline Py_ssize_t
stringlib_fastsearch_memchr_1char(const Py_UNICODE* s, Py_ssize_t n,
                                   Py_UNICODE ch, unsigned char needle,
                                   Py_ssize_t maxcount, int mode)
{
    if (mode == 1) {
        const Py_UNICODE *ptr = s;
        const Py_UNICODE *e = s + n;
        while (ptr < e) {
            void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(Py_UNICODE));
            if (candidate == ((void *)0))
                return -1;
            ptr = (const Py_UNICODE *) ((void *)((Py_uintptr_t)(candidate) & ~(Py_uintptr_t)((sizeof(Py_UNICODE)) - 1)));
            if (sizeof(Py_UNICODE) == 1 || *ptr == ch)
                return (ptr - s);

            ptr++;
        }
        return -1;
    }
# 75 "stringlib/fastsearch.h"
    else {
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "stringlib/fastsearch.h", 76, "0") : (void)0);
        return 0;
    }


}

static inline Py_ssize_t
fastsearch(const Py_UNICODE* s, Py_ssize_t n,
           const Py_UNICODE* p, Py_ssize_t m,
           Py_ssize_t maxcount, int mode)
{
    unsigned long mask;
    Py_ssize_t skip, count = 0;
    Py_ssize_t i, j, mlast, w;

    w = n - m;

    if (w < 0 || (mode == 0 && maxcount == 0))
        return -1;


    if (m <= 1) {
        if (m <= 0)
            return -1;

        if (n > 10 && (mode == 1



                    )) {


            unsigned char needle;
            needle = p[0] & 0xff;




            if (needle != 0)

                return stringlib_fastsearch_memchr_1char
                       (s, n, p[0], needle, maxcount, mode);
        }
        if (mode == 0) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0]) {
                    count++;
                    if (count == maxcount)
                        return maxcount;
                }
            return count;
        } else if (mode == 1) {
            for (i = 0; i < n; i++)
                if (s[i] == p[0])
                    return i;
        } else {
            for (i = n - 1; i > -1; i--)
                if (s[i] == p[0])
                    return i;
        }
        return -1;
    }

    mlast = m - 1;
    skip = mlast - 1;
    mask = 0;

    if (mode != 2) {




        for (i = 0; i < mlast; i++) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[mlast])
                skip = mlast - i - 1;
        }

        ((mask |= (1UL << ((p[mlast]) & (64 -1)))));

        for (i = 0; i <= w; i++) {

            if (s[i+m-1] == p[m-1]) {

                for (j = 0; j < mlast; j++)
                    if (s[i+j] != p[j])
                        break;
                if (j == mlast) {

                    if (mode != 0)
                        return i;
                    count++;
                    if (count == maxcount)
                        return maxcount;
                    i = i + mlast;
                    continue;
                }

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
                else
                    i = i + skip;
            } else {

                if (!((mask & (1UL << ((s[i+m]) & (64 -1))))))
                    i = i + m;
            }
        }
    } else {




        ((mask |= (1UL << ((p[0]) & (64 -1)))));

        for (i = mlast; i > 0; i--) {
            ((mask |= (1UL << ((p[i]) & (64 -1)))));
            if (p[i] == p[0])
                skip = i - 1;
        }

        for (i = w; i >= 0; i--) {
            if (s[i] == p[0]) {

                for (j = mlast; j > 0; j--)
                    if (s[i+j] != p[j])
                        break;
                if (j == 0)

                    return i;

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
                else
                    i = i - skip;
            } else {

                if (i > 0 && !((mask & (1UL << ((s[i-1]) & (64 -1))))))
                    i = i - m;
            }
        }
    }

    if (mode != 0)
        return -1;
    return count;
}
# 622 "unicodeobject.c" 2
# 1 "stringlib/count.h" 1






static inline Py_ssize_t
stringlib_count(const Py_UNICODE* str, Py_ssize_t str_len,
                const Py_UNICODE* sub, Py_ssize_t sub_len,
                Py_ssize_t maxcount)
{
    Py_ssize_t count;

    if (str_len < 0)
        return 0;
    if (sub_len == 0)
        return (str_len < maxcount) ? str_len + 1 : maxcount;

    count = fastsearch(str, str_len, sub, sub_len, maxcount, 0);

    if (count < 0)
        return 0;

    return count;
}
# 623 "unicodeobject.c" 2
# 1 "stringlib/find.h" 1






static inline Py_ssize_t
stringlib_find(const Py_UNICODE* str, Py_ssize_t str_len,
               const Py_UNICODE* sub, Py_ssize_t sub_len,
               Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return offset;

    pos = fastsearch(str, str_len, sub, sub_len, -1, 1);

    if (pos >= 0)
        pos += offset;

    return pos;
}

static inline Py_ssize_t
stringlib_rfind(const Py_UNICODE* str, Py_ssize_t str_len,
                const Py_UNICODE* sub, Py_ssize_t sub_len,
                Py_ssize_t offset)
{
    Py_ssize_t pos;

    if (str_len < 0)
        return -1;
    if (sub_len == 0)
        return str_len + offset;

    pos = fastsearch(str, str_len, sub, sub_len, -1, 2);

    if (pos >= 0)
        pos += offset;

    return pos;
}
# 62 "stringlib/find.h"
static inline Py_ssize_t
stringlib_find_slice(const Py_UNICODE* str, Py_ssize_t str_len,
                     const Py_UNICODE* sub, Py_ssize_t sub_len,
                     Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return stringlib_find(str + start, end - start, sub, sub_len, start);
}

static inline Py_ssize_t
stringlib_rfind_slice(const Py_UNICODE* str, Py_ssize_t str_len,
                      const Py_UNICODE* sub, Py_ssize_t sub_len,
                      Py_ssize_t start, Py_ssize_t end)
{
    if (end > str_len) end = str_len; else if (end < 0) { end += str_len; if (end < 0) end = 0; } if (start < 0) { start += str_len; if (start < 0) start = 0; };
    return stringlib_rfind(str + start, end - start, sub, sub_len, start);
}



static inline int
stringlib_contains_obj(PyObject* str, PyObject* sub)
{
    return stringlib_find(
        ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/find.h", 86, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject *)(str))->wstr) ? (((PyASCIIObject *)(str))->wstr) : PyUnicode_AsUnicode((PyObject *)(str))), ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/find.h", 86, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject *)(str))->wstr) ? ((((PyASCIIObject*)str)->state.ascii && (((PyASCIIObject*)(str))->state.compact)) ? ((PyASCIIObject*)str)->length : ((PyCompactUnicodeObject*)str)->wstr_length) : ((void)PyUnicode_AsUnicode((PyObject *)(str)), (__builtin_expect(!(((PyASCIIObject *)(str))->wstr), 0) ? __assert_rtn(__func__, "stringlib/find.h", 86, "((PyASCIIObject *)(str))->wstr") : (void)0), ((((PyASCIIObject*)str)->state.ascii && (((PyASCIIObject*)(str))->state.compact)) ? ((PyASCIIObject*)str)->length : ((PyCompactUnicodeObject*)str)->wstr_length))),
        ((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/find.h", 87, "PyUnicode_Check(sub)") : (void)0), (((PyASCIIObject *)(sub))->wstr) ? (((PyASCIIObject *)(sub))->wstr) : PyUnicode_AsUnicode((PyObject *)(sub))), ((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/find.h", 87, "PyUnicode_Check(sub)") : (void)0), (((PyASCIIObject *)(sub))->wstr) ? ((((PyASCIIObject*)sub)->state.ascii && (((PyASCIIObject*)(sub))->state.compact)) ? ((PyASCIIObject*)sub)->length : ((PyCompactUnicodeObject*)sub)->wstr_length) : ((void)PyUnicode_AsUnicode((PyObject *)(sub)), (__builtin_expect(!(((PyASCIIObject *)(sub))->wstr), 0) ? __assert_rtn(__func__, "stringlib/find.h", 87, "((PyASCIIObject *)(sub))->wstr") : (void)0), ((((PyASCIIObject*)sub)->state.ascii && (((PyASCIIObject*)(sub))->state.compact)) ? ((PyASCIIObject*)sub)->length : ((PyCompactUnicodeObject*)sub)->wstr_length))), 0
        ) != -1;
}
# 104 "stringlib/find.h"
static inline int
stringlib_parse_args_finds(const char * function_name, PyObject *args,
                           PyObject **subobj,
                           Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_subobj;
    Py_ssize_t tmp_start = 0;
    Py_ssize_t tmp_end = ((Py_ssize_t)(((size_t)-1)>>1));
    PyObject *obj_start=(&_Py_NoneStruct), *obj_end=(&_Py_NoneStruct);
    char format[50] = "O|OO:";
    size_t len = strlen(format);

    ((__builtin_object_size (format + len, 0) != (size_t) -1) ? __builtin___strncpy_chk (format + len, function_name, 50 - len - 1, __builtin_object_size (format + len, 2 > 1)) : __inline_strncpy_chk (format + len, function_name, 50 - len - 1));
    format[50 - 1] = '\0';

    if (!_PyArg_ParseTuple_SizeT(args, format, &tmp_subobj, &obj_start, &obj_end))
        return 0;




    if (obj_start != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_start, &tmp_start))
            return 0;
    if (obj_end != (&_Py_NoneStruct))
        if (!_PyEval_SliceIndex(obj_end, &tmp_end))
            return 0;

    *start = tmp_start;
    *end = tmp_end;
    *subobj = tmp_subobj;
    return 1;
}
# 152 "stringlib/find.h"
static inline int
stringlib_parse_args_finds_unicode(const char * function_name, PyObject *args,
                                   PyObject **substring,
                                   Py_ssize_t *start, Py_ssize_t *end)
{
    PyObject *tmp_substring;

    if(stringlib_parse_args_finds(function_name, args, &tmp_substring,
                                  start, end)) {
        tmp_substring = PyUnicode_FromObject(tmp_substring);
        if (!tmp_substring)
            return 0;
        *substring = tmp_substring;
        return 1;
    }
    return 0;
}
# 624 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 625 "unicodeobject.c" 2



static PyObject *
fixup(PyObject *self, Py_UCS4 (*fixfct)(PyObject *s));

static inline Py_ssize_t findchar(void *s, int kind,
                                     Py_ssize_t size, Py_UCS4 ch,
                                     int direction)
{
    int mode = (direction == 1) ? 1 : 2;

    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        {
            Py_UCS1 ch1 = (Py_UCS1) ch;
            if (ch1 == ch)
                return ucs1lib_fastsearch((Py_UCS1 *) s, size, &ch1, 1, 0, mode);
            else
                return -1;
        }
    case PyUnicode_2BYTE_KIND:
        {
            Py_UCS2 ch2 = (Py_UCS2) ch;
            if (ch2 == ch)
                return ucs2lib_fastsearch((Py_UCS2 *) s, size, &ch2, 1, 0, mode);
            else
                return -1;
        }
    case PyUnicode_4BYTE_KIND:
        return ucs4lib_fastsearch((Py_UCS4 *) s, size, &ch, 1, 0, mode);
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 657, "0") : (void)0);
        return -1;
    }
}

static PyObject*
resize_compact(PyObject *unicode, Py_ssize_t length)
{
    Py_ssize_t char_size;
    Py_ssize_t struct_size;
    Py_ssize_t new_size;
    int share_wstr;
    PyObject *new_unicode;
    (__builtin_expect(!(unicode_modifiable(unicode)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 670, "unicode_modifiable(unicode)") : (void)0);
    (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 671, "PyUnicode_IS_READY(unicode)") : (void)0);
    (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.compact)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 672, "PyUnicode_IS_COMPACT(unicode)") : (void)0);

    char_size = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 674, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 674, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 675, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 675, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
        struct_size = sizeof(PyASCIIObject);
    else
        struct_size = sizeof(PyCompactUnicodeObject);
    share_wstr = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 679, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)(unicode))->wstr) == ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 679, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 679, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 679, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 679, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))));

    if (length > ((((Py_ssize_t)(((size_t)-1)>>1)) - struct_size) / char_size - 1)) {
        PyErr_NoMemory();
        return ((void *)0);
    }
    new_size = (struct_size + (length + 1) * char_size);

    ;
    ;

    new_unicode = (PyObject *)PyObject_Realloc((char *)unicode, new_size);
    if (new_unicode == ((void *)0)) {
        ( (((PyObject*)(unicode))->ob_refcnt) = 1);
        PyErr_NoMemory();
        return ((void *)0);
    }
    unicode = new_unicode;
    ( (((PyObject*)(unicode))->ob_refcnt) = 1);

    (((PyASCIIObject *)(unicode))->length) = length;
    if (share_wstr) {
        (((PyASCIIObject*)(unicode))->wstr) = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 701, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 701, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 701, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 701, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
        if (!((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 702, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 702, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
            (((PyCompactUnicodeObject*)(unicode))->wstr_length) = length;
    }
    else if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 705, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)(unicode))->wstr) && (!(((PyASCIIObject*)unicode)->state.ready) || (((PyASCIIObject*)(unicode))->wstr) != ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 705, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 705, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 705, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 705, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))))))) {
        PyObject_Free((((PyASCIIObject*)(unicode))->wstr));
        (((PyASCIIObject*)(unicode))->wstr) = ((void *)0);
    }
    do { switch ((((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind))) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))))[(length)] = (Py_UCS1)(0); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))))[(length)] = (Py_UCS2)(0); break; } default: { (__builtin_expect(!((((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 710, \"PyUnicode_Check(unicode)\") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 710, \"PyUnicode_IS_READY(unicode)\") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 710, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))))[(length)] = (Py_UCS4)(0); } } } while (0);

    (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 711, "_PyUnicode_CheckConsistency(unicode, 0)") : (void)0);
    return unicode;
}

static int
resize_inplace(PyObject *unicode, Py_ssize_t length)
{
    wchar_t *wstr;
    Py_ssize_t new_size;
    (__builtin_expect(!(!(((PyASCIIObject*)(unicode))->state.compact)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 720, "!PyUnicode_IS_COMPACT(unicode)") : (void)0);
    (__builtin_expect(!((((PyObject*)(unicode))->ob_refcnt) == 1), 0) ? __assert_rtn(__func__, "unicodeobject.c", 721, "Py_REFCNT(unicode) == 1") : (void)0);

    if ((((PyASCIIObject*)unicode)->state.ready)) {
        Py_ssize_t char_size;
        int share_wstr, share_utf8;
        void *data;

        data = (((PyUnicodeObject*)(unicode))->data.any);
        char_size = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 729, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 729, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
        share_wstr = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 730, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)(unicode))->wstr) == ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 730, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 730, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 730, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 730, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))));
        share_utf8 = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 731, "_PyUnicode_CHECK(unicode)") : (void)0), (__builtin_expect(!(!(((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact))), 0) ? __assert_rtn(__func__, "unicodeobject.c", 731, "!PyUnicode_IS_COMPACT_ASCII(unicode)") : (void)0), ((((PyCompactUnicodeObject*)(unicode))->utf8) == ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 731, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 731, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 731, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 731, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))));

        if (length > (((Py_ssize_t)(((size_t)-1)>>1)) / char_size - 1)) {
            PyErr_NoMemory();
            return -1;
        }
        new_size = (length + 1) * char_size;

        if (!share_utf8 && ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 739, "_PyUnicode_CHECK(unicode)") : (void)0), (!(((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) && (((PyCompactUnicodeObject*)(unicode))->utf8) && (((PyCompactUnicodeObject*)(unicode))->utf8) != ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 739, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 739, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 739, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 739, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))))))
        {
            PyObject_Free((((PyCompactUnicodeObject*)(unicode))->utf8));
            (((PyCompactUnicodeObject*)(unicode))->utf8) = ((void *)0);
            (((PyCompactUnicodeObject*)(unicode))->utf8_length) = 0;
        }

        data = (PyObject *)PyObject_Realloc(data, new_size);
        if (data == ((void *)0)) {
            PyErr_NoMemory();
            return -1;
        }
        (((PyUnicodeObject*)(unicode))->data.any) = data;
        if (share_wstr) {
            (((PyASCIIObject*)(unicode))->wstr) = data;
            (((PyCompactUnicodeObject*)(unicode))->wstr_length) = length;
        }
        if (share_utf8) {
            (((PyCompactUnicodeObject*)(unicode))->utf8) = data;
            (((PyCompactUnicodeObject*)(unicode))->utf8_length) = length;
        }
        (((PyASCIIObject *)(unicode))->length) = length;
        do { switch ((((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 761, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 761, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind))) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(length)] = (Py_UCS1)(0); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(length)] = (Py_UCS2)(0); break; } default: { (__builtin_expect(!((((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 761, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 761, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 761, "(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 761, \"PyUnicode_Check(unicode)\") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 761, \"PyUnicode_IS_READY(unicode)\") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(length)] = (Py_UCS4)(0); } } } while (0);
        if (share_wstr || (((PyASCIIObject*)(unicode))->wstr) == ((void *)0)) {
            (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 763, "_PyUnicode_CheckConsistency(unicode, 0)") : (void)0);
            return 0;
        }
    }
    (__builtin_expect(!((((PyASCIIObject*)(unicode))->wstr) != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 767, "_PyUnicode_WSTR(unicode) != NULL") : (void)0);


    if (length > ((Py_ssize_t)(((size_t)-1)>>1)) / sizeof(wchar_t) - 1) {
        PyErr_NoMemory();
        return -1;
    }
    new_size = sizeof(wchar_t) * (length + 1);
    wstr = (((PyASCIIObject*)(unicode))->wstr);
    wstr = PyObject_Realloc(wstr, new_size);
    if (!wstr) {
        PyErr_NoMemory();
        return -1;
    }
    (((PyASCIIObject*)(unicode))->wstr) = wstr;
    (((PyASCIIObject*)(unicode))->wstr)[length] = 0;
    (((PyCompactUnicodeObject*)(unicode))->wstr_length) = length;
    (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 784, "_PyUnicode_CheckConsistency(unicode, 0)") : (void)0);
    return 0;
}

static PyObject*
resize_copy(PyObject *unicode, Py_ssize_t length)
{
    Py_ssize_t copy_length;
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 792, "_PyUnicode_CHECK(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) != PyUnicode_WCHAR_KIND) {
        PyObject *copy;

        if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 795, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
            return ((void *)0);

        copy = PyUnicode_New(length, ((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 798, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 798, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 798, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 798, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 798, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 798, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 798, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))));
        if (copy == ((void *)0))
            return ((void *)0);

        copy_length = (((length) > (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 802, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 802, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length))) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 802, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 802, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)) : (length));
        _PyUnicode_FastCopyCharacters(copy, 0, unicode, 0, copy_length);
        return copy;
    }
    else {
        PyObject *w;

        w = (PyObject*)_PyUnicode_New(length);
        if (w == ((void *)0))
            return ((void *)0);
        copy_length = (((PyCompactUnicodeObject*)(unicode))->wstr_length);
        copy_length = (((copy_length) > (length)) ? (length) : (copy_length));
        ((__builtin_object_size (((((PyASCIIObject*)(w))->wstr)), 0) != (size_t) -1) ? __builtin___memcpy_chk (((((PyASCIIObject*)(w))->wstr)), ((((PyASCIIObject*)(unicode))->wstr)), (copy_length)*sizeof(Py_UNICODE), __builtin_object_size (((((PyASCIIObject*)(w))->wstr)), 0)) : __inline_memcpy_chk (((((PyASCIIObject*)(w))->wstr)), ((((PyASCIIObject*)(unicode))->wstr)), (copy_length)*sizeof(Py_UNICODE)));

        return w;
    }
}
# 829 "unicodeobject.c"
static PyUnicodeObject *
_PyUnicode_New(Py_ssize_t length)
{
    register PyUnicodeObject *unicode;
    size_t new_size;


    if (length == 0 && unicode_empty != ((void *)0)) {
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        return (PyUnicodeObject*)unicode_empty;
    }


    if (length > ((((Py_ssize_t)(((size_t)-1)>>1)) / sizeof(Py_UNICODE)) - 1)) {
        return (PyUnicodeObject *)PyErr_NoMemory();
    }
    if (length < 0) {
        PyErr_SetString(PyExc_SystemError,
                        "Negative size passed to _PyUnicode_New");
        return ((void *)0);
    }

    unicode = ( (PyUnicodeObject *) _PyObject_New(&PyUnicode_Type) );
    if (unicode == ((void *)0))
        return ((void *)0);
    new_size = sizeof(Py_UNICODE) * ((size_t)length + 1);
    (((PyASCIIObject*)(unicode))->wstr) = (Py_UNICODE*) PyObject_Malloc(new_size);
    if (!(((PyASCIIObject*)(unicode))->wstr)) {
        do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
        PyErr_NoMemory();
        return ((void *)0);
    }
# 869 "unicodeobject.c"
    (((PyASCIIObject*)(unicode))->wstr)[0] = 0;
    (((PyASCIIObject*)(unicode))->wstr)[length] = 0;
    (((PyCompactUnicodeObject*)(unicode))->wstr_length) = length;
    (((PyASCIIObject *)(unicode))->hash) = -1;
    (((PyASCIIObject *)(unicode))->state).interned = 0;
    (((PyASCIIObject *)(unicode))->state).kind = 0;
    (((PyASCIIObject *)(unicode))->state).compact = 0;
    (((PyASCIIObject *)(unicode))->state).ready = 0;
    (((PyASCIIObject *)(unicode))->state).ascii = 0;
    (((PyUnicodeObject*)(unicode))->data.any) = ((void *)0);
    (((PyASCIIObject *)(unicode))->length) = 0;
    (((PyCompactUnicodeObject*)(unicode))->utf8) = ((void *)0);
    (((PyCompactUnicodeObject*)(unicode))->utf8_length) = 0;
    (__builtin_expect(!(_PyUnicode_CheckConsistency((PyObject *)unicode, 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 882, "_PyUnicode_CheckConsistency((PyObject *)unicode, 0)") : (void)0);
    return unicode;
}

static const char*
unicode_kind_name(PyObject *unicode)
{


    if (!(((PyASCIIObject*)(unicode))->state.compact))
    {
        if (!(((PyASCIIObject*)unicode)->state.ready))
            return "wstr";
        switch (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 895, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 895, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind))
        {
        case PyUnicode_1BYTE_KIND:
            if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 898, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 898, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
                return "legacy ascii";
            else
                return "legacy latin1";
        case PyUnicode_2BYTE_KIND:
            return "legacy UCS2";
        case PyUnicode_4BYTE_KIND:
            return "legacy UCS4";
        default:
            return "<legacy invalid kind>";
        }
    }
    (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 910, "PyUnicode_IS_READY(unicode)") : (void)0);
    switch (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 911, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 911, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 913, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 913, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
            return "ascii";
        else
            return "latin1";
    case PyUnicode_2BYTE_KIND:
        return "UCS2";
    case PyUnicode_4BYTE_KIND:
        return "UCS4";
    default:
        return "<invalid compact kind>";
    }
}
# 978 "unicodeobject.c"
PyObject *
PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
{
    PyObject *obj;
    PyCompactUnicodeObject *unicode;
    void *data;
    enum PyUnicode_Kind kind;
    int is_sharing, is_ascii;
    Py_ssize_t char_size;
    Py_ssize_t struct_size;


    if (size == 0 && unicode_empty != ((void *)0)) {
        ( ((PyObject*)(unicode_empty))->ob_refcnt++);
        return unicode_empty;
    }

    is_ascii = 0;
    is_sharing = 0;
    struct_size = sizeof(PyCompactUnicodeObject);
    if (maxchar < 128) {
        kind = PyUnicode_1BYTE_KIND;
        char_size = 1;
        is_ascii = 1;
        struct_size = sizeof(PyASCIIObject);
    }
    else if (maxchar < 256) {
        kind = PyUnicode_1BYTE_KIND;
        char_size = 1;
    }
    else if (maxchar < 65536) {
        kind = PyUnicode_2BYTE_KIND;
        char_size = 2;
        if (sizeof(wchar_t) == 2)
            is_sharing = 1;
    }
    else {
        if (maxchar > 0x10ffff) {
            PyErr_SetString(PyExc_SystemError,
                            "invalid maximum character passed to PyUnicode_New");
            return ((void *)0);
        }
        kind = PyUnicode_4BYTE_KIND;
        char_size = 4;
        if (sizeof(wchar_t) == 4)
            is_sharing = 1;
    }


    if (size < 0) {
        PyErr_SetString(PyExc_SystemError,
                        "Negative size passed to PyUnicode_New");
        return ((void *)0);
    }
    if (size > ((((Py_ssize_t)(((size_t)-1)>>1)) - struct_size) / char_size - 1))
        return PyErr_NoMemory();





    obj = (PyObject *) PyObject_Malloc(struct_size + (size + 1) * char_size);
    if (obj == ((void *)0))
        return PyErr_NoMemory();
    obj = ( (((PyObject*)(obj))->ob_type) = (&PyUnicode_Type), ( (((PyObject*)((PyObject *)(obj)))->ob_refcnt) = 1), (obj) );
    if (obj == ((void *)0))
        return ((void *)0);

    unicode = (PyCompactUnicodeObject *)obj;
    if (is_ascii)
        data = ((PyASCIIObject*)obj) + 1;
    else
        data = unicode + 1;
    (((PyASCIIObject *)(unicode))->length) = size;
    (((PyASCIIObject *)(unicode))->hash) = -1;
    (((PyASCIIObject *)(unicode))->state).interned = 0;
    (((PyASCIIObject *)(unicode))->state).kind = kind;
    (((PyASCIIObject *)(unicode))->state).compact = 1;
    (((PyASCIIObject *)(unicode))->state).ready = 1;
    (((PyASCIIObject *)(unicode))->state).ascii = is_ascii;
    if (is_ascii) {
        ((char*)data)[size] = 0;
        (((PyASCIIObject*)(unicode))->wstr) = ((void *)0);
    }
    else if (kind == PyUnicode_1BYTE_KIND) {
        ((char*)data)[size] = 0;
        (((PyASCIIObject*)(unicode))->wstr) = ((void *)0);
        (((PyCompactUnicodeObject*)(unicode))->wstr_length) = 0;
        unicode->utf8 = ((void *)0);
        unicode->utf8_length = 0;
    }
    else {
        unicode->utf8 = ((void *)0);
        unicode->utf8_length = 0;
        if (kind == PyUnicode_2BYTE_KIND)
            ((Py_UCS2*)data)[size] = 0;
        else
            ((Py_UCS4*)data)[size] = 0;
        if (is_sharing) {
            (((PyCompactUnicodeObject*)(unicode))->wstr_length) = size;
            (((PyASCIIObject*)(unicode))->wstr) = (wchar_t *)data;
        }
        else {
            (((PyCompactUnicodeObject*)(unicode))->wstr_length) = 0;
            (((PyASCIIObject*)(unicode))->wstr) = ((void *)0);
        }
    }







    (__builtin_expect(!(_PyUnicode_CheckConsistency((PyObject*)unicode, 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1092, "_PyUnicode_CheckConsistency((PyObject*)unicode, 0)") : (void)0);
    return obj;
}
# 1136 "unicodeobject.c"
static int
unicode_check_modifiable(PyObject *unicode)
{
    if (!unicode_modifiable(unicode)) {
        PyErr_SetString(PyExc_SystemError,
                        "Cannot modify a string currently used");
        return -1;
    }
    return 0;
}

static int
_copy_characters(PyObject *to, Py_ssize_t to_start,
                 PyObject *from, Py_ssize_t from_start,
                 Py_ssize_t how_many, int check_maxchar)
{
    unsigned int from_kind, to_kind;
    void *from_data, *to_data;

    (__builtin_expect(!(0 <= how_many), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1155, "0 <= how_many") : (void)0);
    (__builtin_expect(!(0 <= from_start), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1156, "0 <= from_start") : (void)0);
    (__builtin_expect(!(0 <= to_start), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1157, "0 <= to_start") : (void)0);
    (__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1158, "PyUnicode_Check(from)") : (void)0);
    (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1159, "PyUnicode_IS_READY(from)") : (void)0);
    (__builtin_expect(!(from_start + how_many <= ((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1160, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1160, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject *)(from))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1160, "from_start + how_many <= PyUnicode_GET_LENGTH(from)") : (void)0);

    (__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1162, "PyUnicode_Check(to)") : (void)0);
    (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1163, "PyUnicode_IS_READY(to)") : (void)0);
    (__builtin_expect(!(to_start + how_many <= ((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1164, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1164, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1164, "to_start + how_many <= PyUnicode_GET_LENGTH(to)") : (void)0);

    if (how_many == 0)
        return 0;

    from_kind = ((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1169, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1169, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject *)(from))->state.kind);
    from_data = ((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1170, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1170, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1170, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1170, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))));
    to_kind = ((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1171, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1171, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->state.kind);
    to_data = ((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1172, "PyUnicode_Check(to)") : (void)0), (((PyASCIIObject*)(to))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1172, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1172, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? ((void*)((PyASCIIObject*)(to) + 1)) : ((void*)((PyCompactUnicodeObject*)(to) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(to))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1172, "((PyUnicodeObject*)(to))->data.any") : (void)0), ((((PyUnicodeObject *)(to))->data.any))));
# 1188 "unicodeobject.c"
    if (from_kind == to_kind) {
        if (check_maxchar
            && !((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1190, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1190, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1190, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1190, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii))
        {


            Py_UCS4 max_char;
            max_char = ucs1lib_find_max_char(from_data,
                                             (Py_UCS1*)from_data + how_many);
            if (max_char >= 128)
                return -1;
        }
        ((__builtin_object_size ((char*)to_data + to_kind * to_start, 0) != (size_t) -1) ? __builtin___memcpy_chk ((char*)to_data + to_kind * to_start, (char*)from_data + from_kind * from_start, to_kind * how_many, __builtin_object_size ((char*)to_data + to_kind * to_start, 0)) : __inline_memcpy_chk ((char*)to_data + to_kind * to_start, (char*)from_data + from_kind * from_start, to_kind * how_many));


    }
    else if (from_kind == PyUnicode_1BYTE_KIND
             && to_kind == PyUnicode_2BYTE_KIND)
    {
        do { Py_UCS2 *_to = (Py_UCS2 *) ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_Check(to)") : (void)0), (((PyASCIIObject*)(to))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? ((void*)((PyASCIIObject*)(to) + 1)) : ((void*)((PyCompactUnicodeObject*)(to) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(to))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "((PyUnicodeObject*)(to))->data.any") : (void)0), ((((PyUnicodeObject *)(to))->data.any))))) + to_start; const Py_UCS1 *_iter = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start); const Py_UCS1 *_end = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1212, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start + how_many); Py_ssize_t n = (_end) - (_iter); const Py_UCS1 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS2) _iter[0]; _to[1] = (Py_UCS2) _iter[1]; _to[2] = (Py_UCS2) _iter[2]; _to[3] = (Py_UCS2) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS2) *_iter++; } while (0);





    }
    else if (from_kind == PyUnicode_1BYTE_KIND
             && to_kind == PyUnicode_4BYTE_KIND)
    {
        do { Py_UCS4 *_to = (Py_UCS4 *) ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_Check(to)") : (void)0), (((PyASCIIObject*)(to))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? ((void*)((PyASCIIObject*)(to) + 1)) : ((void*)((PyCompactUnicodeObject*)(to) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(to))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "((PyUnicodeObject*)(to))->data.any") : (void)0), ((((PyUnicodeObject *)(to))->data.any))))) + to_start; const Py_UCS1 *_iter = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start); const Py_UCS1 *_end = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1222, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start + how_many); Py_ssize_t n = (_end) - (_iter); const Py_UCS1 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS4) _iter[0]; _to[1] = (Py_UCS4) _iter[1]; _to[2] = (Py_UCS4) _iter[2]; _to[3] = (Py_UCS4) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS4) *_iter++; } while (0);





    }
    else if (from_kind == PyUnicode_2BYTE_KIND
             && to_kind == PyUnicode_4BYTE_KIND)
    {
        do { Py_UCS4 *_to = (Py_UCS4 *) ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_Check(to)") : (void)0), (((PyASCIIObject*)(to))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? ((void*)((PyASCIIObject*)(to) + 1)) : ((void*)((PyCompactUnicodeObject*)(to) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(to))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "((PyUnicodeObject*)(to))->data.any") : (void)0), ((((PyUnicodeObject *)(to))->data.any))))) + to_start; const Py_UCS2 *_iter = (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start); const Py_UCS2 *_end = (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1232, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start + how_many); Py_ssize_t n = (_end) - (_iter); const Py_UCS2 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS4) _iter[0]; _to[1] = (Py_UCS4) _iter[1]; _to[2] = (Py_UCS4) _iter[2]; _to[3] = (Py_UCS4) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS4) *_iter++; } while (0);





    }
    else {
        (__builtin_expect(!(((__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(from)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject *)(from))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject *)(from))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))) > ((__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(to)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))))), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1235, "PyUnicode_MAX_CHAR_VALUE(from) > PyUnicode_MAX_CHAR_VALUE(to)") : (void)0);

        if (!check_maxchar) {
            if (from_kind == PyUnicode_2BYTE_KIND
                && to_kind == PyUnicode_1BYTE_KIND)
            {
                do { Py_UCS1 *_to = (Py_UCS1 *) ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_Check(to)") : (void)0), (((PyASCIIObject*)(to))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? ((void*)((PyASCIIObject*)(to) + 1)) : ((void*)((PyCompactUnicodeObject*)(to) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(to))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "((PyUnicodeObject*)(to))->data.any") : (void)0), ((((PyUnicodeObject *)(to))->data.any))))) + to_start; const Py_UCS2 *_iter = (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start); const Py_UCS2 *_end = (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1246, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start + how_many); Py_ssize_t n = (_end) - (_iter); const Py_UCS2 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS1) _iter[0]; _to[1] = (Py_UCS1) _iter[1]; _to[2] = (Py_UCS1) _iter[2]; _to[3] = (Py_UCS1) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS1) *_iter++; } while (0);





            }
            else if (from_kind == PyUnicode_4BYTE_KIND
                     && to_kind == PyUnicode_1BYTE_KIND)
            {
                do { Py_UCS1 *_to = (Py_UCS1 *) ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_Check(to)") : (void)0), (((PyASCIIObject*)(to))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? ((void*)((PyASCIIObject*)(to) + 1)) : ((void*)((PyCompactUnicodeObject*)(to) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(to))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "((PyUnicodeObject*)(to))->data.any") : (void)0), ((((PyUnicodeObject *)(to))->data.any))))) + to_start; const Py_UCS4 *_iter = (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start); const Py_UCS4 *_end = (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1256, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start + how_many); Py_ssize_t n = (_end) - (_iter); const Py_UCS4 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS1) _iter[0]; _to[1] = (Py_UCS1) _iter[1]; _to[2] = (Py_UCS1) _iter[2]; _to[3] = (Py_UCS1) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS1) *_iter++; } while (0);





            }
            else if (from_kind == PyUnicode_4BYTE_KIND
                     && to_kind == PyUnicode_2BYTE_KIND)
            {
                do { Py_UCS2 *_to = (Py_UCS2 *) ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_Check(to)") : (void)0), (((PyASCIIObject*)(to))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? ((void*)((PyASCIIObject*)(to) + 1)) : ((void*)((PyCompactUnicodeObject*)(to) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(to))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "((PyUnicodeObject*)(to))->data.any") : (void)0), ((((PyUnicodeObject *)(to))->data.any))))) + to_start; const Py_UCS4 *_iter = (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start); const Py_UCS4 *_end = (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_Check(from)") : (void)0), (((PyASCIIObject*)(from))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject*)from)->state.ascii) ? ((void*)((PyASCIIObject*)(from) + 1)) : ((void*)((PyCompactUnicodeObject*)(from) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(from))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1266, "((PyUnicodeObject*)(from))->data.any") : (void)0), ((((PyUnicodeObject *)(from))->data.any))))) + from_start + how_many); Py_ssize_t n = (_end) - (_iter); const Py_UCS4 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS2) _iter[0]; _to[1] = (Py_UCS2) _iter[1]; _to[2] = (Py_UCS2) _iter[2]; _to[3] = (Py_UCS2) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS2) *_iter++; } while (0);





            }
            else {
                (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1269, "0") : (void)0);
                return -1;
            }
        }
        else {
            const Py_UCS4 to_maxchar = ((__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1274, "PyUnicode_IS_READY(to)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1274, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1274, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject*)to)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1274, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1274, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1274, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1274, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
            Py_UCS4 ch;
            Py_ssize_t i;

            for (i=0; i < how_many; i++) {
                ch = ((Py_UCS4) ((from_kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(from_data))[(from_start + i)] : ((from_kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(from_data))[(from_start + i)] : ((const Py_UCS4 *)(from_data))[(from_start + i)] ) ));
                if (ch > to_maxchar)
                    return -1;
                do { switch ((to_kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(to_data))[(to_start + i)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(to_data))[(to_start + i)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((to_kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1282, "(to_kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(to_data))[(to_start + i)] = (Py_UCS4)(ch); } } } while (0);
            }
        }
    }
    return 0;
}

void
_PyUnicode_FastCopyCharacters(
    PyObject *to, Py_ssize_t to_start,
    PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
{
    (void)_copy_characters(to, to_start, from, from_start, how_many, 0);
}

Py_ssize_t
PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start,
                         PyObject *from, Py_ssize_t from_start,
                         Py_ssize_t how_many)
{
    int err;

    if (!((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0) || !((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 1305);
        return -1;
    }

    if (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1309, "_PyUnicode_CHECK(from)") : (void)0), ((((PyASCIIObject*)from)->state.ready) ? 0 : _PyUnicode_Ready(from))) == -1)
        return -1;
    if (((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1311, "_PyUnicode_CHECK(to)") : (void)0), ((((PyASCIIObject*)to)->state.ready) ? 0 : _PyUnicode_Ready(to))) == -1)
        return -1;

    if (from_start < 0) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return -1;
    }
    if (to_start < 0) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return -1;
    }
    how_many = (((((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1322, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1322, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject *)(from))->length)) > (how_many)) ? (how_many) : (((__builtin_expect(!(((((((PyObject*)(from))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1322, "PyUnicode_Check(from)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)from)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1322, "PyUnicode_IS_READY(from)") : (void)0), ((PyASCIIObject *)(from))->length)));
    if (to_start + how_many > ((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1323, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1323, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->length)) {
        PyErr_Format(PyExc_SystemError,
                     "Cannot write %zi characters at %zi "
                     "in a string of %zi characters",
                     how_many, to_start, ((__builtin_expect(!(((((((PyObject*)(to))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1327, "PyUnicode_Check(to)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)to)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1327, "PyUnicode_IS_READY(to)") : (void)0), ((PyASCIIObject *)(to))->length));
        return -1;
    }

    if (how_many == 0)
        return 0;

    if (unicode_check_modifiable(to))
        return -1;

    err = _copy_characters(to, to_start, from, from_start, how_many, 1);
    if (err) {
        PyErr_Format(PyExc_SystemError,
                     "Cannot copy %s characters "
                     "into a string of %s characters",
                     unicode_kind_name(from),
                     unicode_kind_name(to));
        return -1;
    }
    return how_many;
}






static int
find_maxchar_surrogates(const wchar_t *begin, const wchar_t *end,
                        Py_UCS4 *maxchar, Py_ssize_t *num_surrogates)
{
    const wchar_t *iter;
    Py_UCS4 ch;

    (__builtin_expect(!(num_surrogates != ((void *)0) && maxchar != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1361, "num_surrogates != NULL && maxchar != NULL") : (void)0);
    *num_surrogates = 0;
    *maxchar = 0;

    for (iter = begin; iter < end; ) {
# 1377 "unicodeobject.c"
        {
            ch = *iter;
            iter++;
        }
        if (ch > *maxchar) {
            *maxchar = ch;
            if (*maxchar > 0x10ffff) {
                PyErr_Format(PyExc_ValueError,
                             "character U+%x is not in range [U+0000; U+10ffff]",
                             ch);
                return -1;
            }
        }
    }
    return 0;
}

int
_PyUnicode_Ready(PyObject *unicode)
{
    wchar_t *end;
    Py_UCS4 maxchar = 0;
    Py_ssize_t num_surrogates;
# 1408 "unicodeobject.c"
    (__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1408, "_PyUnicode_CHECK(unicode)") : (void)0);
    (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1409, "_PyUnicode_CHECK(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_WCHAR_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1409, "_PyUnicode_KIND(unicode) == PyUnicode_WCHAR_KIND") : (void)0);
    (__builtin_expect(!((((PyASCIIObject*)(unicode))->wstr) != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1410, "_PyUnicode_WSTR(unicode) != NULL") : (void)0);
    (__builtin_expect(!((((PyUnicodeObject*)(unicode))->data.any) == ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1411, "_PyUnicode_DATA_ANY(unicode) == NULL") : (void)0);
    (__builtin_expect(!((((PyCompactUnicodeObject*)(unicode))->utf8) == ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1412, "_PyUnicode_UTF8(unicode) == NULL") : (void)0);

    (__builtin_expect(!((((PyASCIIObject *)(unicode))->state).interned == 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1414, "_PyUnicode_STATE(unicode).interned == SSTATE_NOT_INTERNED") : (void)0);

    end = (((PyASCIIObject*)(unicode))->wstr) + (((PyCompactUnicodeObject*)(unicode))->wstr_length);
    if (find_maxchar_surrogates((((PyASCIIObject*)(unicode))->wstr), end,
                                &maxchar, &num_surrogates) == -1)
        return -1;

    if (maxchar < 256) {
        (((PyUnicodeObject*)(unicode))->data.any) = PyObject_Malloc((((PyCompactUnicodeObject*)(unicode))->wstr_length) + 1);
        if (!(((PyUnicodeObject*)(unicode))->data.any)) {
            PyErr_NoMemory();
            return -1;
        }
        do { unsigned char *_to = (unsigned char *) ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1429, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1429, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1429, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1429, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))); const wchar_t *_iter = ((((PyASCIIObject*)(unicode))->wstr)); const wchar_t *_end = (end); Py_ssize_t n = (_end) - (_iter); const wchar_t *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (unsigned char) _iter[0]; _to[1] = (unsigned char) _iter[1]; _to[2] = (unsigned char) _iter[2]; _to[3] = (unsigned char) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (unsigned char) *_iter++; } while (0);


        ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1430, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1430, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1430, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1430, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))))[(((PyCompactUnicodeObject*)(unicode))->wstr_length)] = '\0';
        (((PyASCIIObject *)(unicode))->length) = (((PyCompactUnicodeObject*)(unicode))->wstr_length);
        (((PyASCIIObject *)(unicode))->state).kind = PyUnicode_1BYTE_KIND;
        if (maxchar < 128) {
            (((PyASCIIObject *)(unicode))->state).ascii = 1;
            (((PyCompactUnicodeObject*)(unicode))->utf8) = (((PyUnicodeObject*)(unicode))->data.any);
            (((PyCompactUnicodeObject*)(unicode))->utf8_length) = (((PyCompactUnicodeObject*)(unicode))->wstr_length);
        }
        else {
            (((PyASCIIObject *)(unicode))->state).ascii = 0;
            (((PyCompactUnicodeObject*)(unicode))->utf8) = ((void *)0);
            (((PyCompactUnicodeObject*)(unicode))->utf8_length) = 0;
        }
        PyObject_Free((((PyASCIIObject*)(unicode))->wstr));
        (((PyASCIIObject*)(unicode))->wstr) = ((void *)0);
        (((PyCompactUnicodeObject*)(unicode))->wstr_length) = 0;
    }


    else if (maxchar < 65536) {
        (__builtin_expect(!(num_surrogates == 0 && "FindMaxCharAndNumSurrogatePairs() messed up"), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1451, "num_surrogates == 0 && \"FindMaxCharAndNumSurrogatePairs() messed up\"") : (void)0);
# 1463 "unicodeobject.c"
        (((PyUnicodeObject*)(unicode))->data.any) = PyObject_Malloc(
            2 * ((((PyCompactUnicodeObject*)(unicode))->wstr_length) + 1));
        if (!(((PyUnicodeObject*)(unicode))->data.any)) {
            PyErr_NoMemory();
            return -1;
        }
        do { Py_UCS2 *_to = (Py_UCS2 *) ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1471, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1471, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1471, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1471, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))); const wchar_t *_iter = ((((PyASCIIObject*)(unicode))->wstr)); const wchar_t *_end = (end); Py_ssize_t n = (_end) - (_iter); const wchar_t *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS2) _iter[0]; _to[1] = (Py_UCS2) _iter[1]; _to[2] = (Py_UCS2) _iter[2]; _to[3] = (Py_UCS2) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS2) *_iter++; } while (0);


        ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1472, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1472, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1472, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1472, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))))[(((PyCompactUnicodeObject*)(unicode))->wstr_length)] = '\0';
        (((PyASCIIObject *)(unicode))->length) = (((PyCompactUnicodeObject*)(unicode))->wstr_length);
        (((PyASCIIObject *)(unicode))->state).kind = PyUnicode_2BYTE_KIND;
        (((PyCompactUnicodeObject*)(unicode))->utf8) = ((void *)0);
        (((PyCompactUnicodeObject*)(unicode))->utf8_length) = 0;
        PyObject_Free((((PyASCIIObject*)(unicode))->wstr));
        (((PyASCIIObject*)(unicode))->wstr) = ((void *)0);
        (((PyCompactUnicodeObject*)(unicode))->wstr_length) = 0;

    }

    else {
# 1504 "unicodeobject.c"
        (__builtin_expect(!(num_surrogates == 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1504, "num_surrogates == 0") : (void)0);

        (((PyUnicodeObject*)(unicode))->data.any) = (((PyASCIIObject*)(unicode))->wstr);
        (((PyASCIIObject *)(unicode))->length) = (((PyCompactUnicodeObject*)(unicode))->wstr_length);
        (((PyCompactUnicodeObject*)(unicode))->utf8) = ((void *)0);
        (((PyCompactUnicodeObject*)(unicode))->utf8_length) = 0;
        (((PyASCIIObject *)(unicode))->state).kind = PyUnicode_4BYTE_KIND;

        ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1512, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1512, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1512, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1512, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))))[(((PyASCIIObject *)(unicode))->length)] = '\0';
    }
    (((PyASCIIObject *)(unicode))->state).ready = 1;
    (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1515, "_PyUnicode_CheckConsistency(unicode, 1)") : (void)0);
    return 0;
}

static void
unicode_dealloc(register PyObject *unicode)
{
    switch ((((PyASCIIObject *)(unicode))->state.interned)) {
    case 0:
        break;

    case 1:

        (((PyObject*)(unicode))->ob_refcnt) = 3;
        if (PyDict_DelItem(interned, unicode) != 0)
            Py_FatalError(
                "deletion of interned string failed");
        break;

    case 2:
        Py_FatalError("Immortal interned string died.");

    default:
        Py_FatalError("Inconsistent interned string state.");
    }

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1541, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)(unicode))->wstr) && (!(((PyASCIIObject*)unicode)->state.ready) || (((PyASCIIObject*)(unicode))->wstr) != ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1541, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1541, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1541, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1541, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))))))
        PyObject_Free((((PyASCIIObject*)(unicode))->wstr));
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1543, "_PyUnicode_CHECK(unicode)") : (void)0), (!(((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) && (((PyCompactUnicodeObject*)(unicode))->utf8) && (((PyCompactUnicodeObject*)(unicode))->utf8) != ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1543, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1543, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1543, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1543, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))))))
        PyObject_Free((((PyCompactUnicodeObject*)(unicode))->utf8));
    if (!(((PyASCIIObject*)(unicode))->state.compact) && (((PyUnicodeObject*)(unicode))->data.any))
        PyObject_Free((((PyUnicodeObject*)(unicode))->data.any));

    (((PyObject*)(unicode))->ob_type)->tp_free(unicode);
}
# 1568 "unicodeobject.c"
static int
unicode_modifiable(PyObject *unicode)
{
    (__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1571, "_PyUnicode_CHECK(unicode)") : (void)0);
    if ((((PyObject*)(unicode))->ob_refcnt) != 1)
        return 0;
    if ((((PyASCIIObject *)(unicode))->hash) != -1)
        return 0;
    if ((((PyASCIIObject *)(unicode))->state.interned))
        return 0;
    if (!((((PyObject*)(unicode))->ob_type) == &PyUnicode_Type))
        return 0;




    return 1;
}

static int
unicode_resize(PyObject **p_unicode, Py_ssize_t length)
{
    PyObject *unicode;
    Py_ssize_t old_length;

    (__builtin_expect(!(p_unicode != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1593, "p_unicode != NULL") : (void)0);
    unicode = *p_unicode;

    (__builtin_expect(!(unicode != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1596, "unicode != NULL") : (void)0);
    (__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1597, "PyUnicode_Check(unicode)") : (void)0);
    (__builtin_expect(!(0 <= length), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1598, "0 <= length") : (void)0);

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1600, "_PyUnicode_CHECK(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_WCHAR_KIND)
        old_length = ((((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((PyASCIIObject*)unicode)->length : ((PyCompactUnicodeObject*)unicode)->wstr_length);
    else
        old_length = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1603, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1603, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
    if (old_length == length)
        return 0;

    if (length == 0) {
        do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1608, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0);
        if (!unicode_empty)
            return -1;
        do { if ( --((PyObject*)(*p_unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*p_unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*p_unicode)))); } while (0);
        *p_unicode = unicode_empty;
        return 0;
    }

    if (!unicode_modifiable(unicode)) {
        PyObject *copy = resize_copy(unicode, length);
        if (copy == ((void *)0))
            return -1;
        do { if ( --((PyObject*)(*p_unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*p_unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*p_unicode)))); } while (0);
        *p_unicode = copy;
        return 0;
    }

    if ((((PyASCIIObject*)(unicode))->state.compact)) {
        PyObject *new_unicode = resize_compact(unicode, length);
        if (new_unicode == ((void *)0))
            return -1;
        *p_unicode = new_unicode;
        return 0;
    }
    return resize_inplace(unicode, length);
}

int
PyUnicode_Resize(PyObject **p_unicode, Py_ssize_t length)
{
    PyObject *unicode;
    if (p_unicode == ((void *)0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 1640);
        return -1;
    }
    unicode = *p_unicode;
    if (unicode == ((void *)0) || !((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0) || length < 0)
    {
        _PyErr_BadInternalCall("unicodeobject.c", 1646);
        return -1;
    }
    return unicode_resize(p_unicode, length);
}

static int
unicode_widen(PyObject **p_unicode, Py_ssize_t length,
              unsigned int maxchar)
{
    PyObject *result;
    (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1657, "PyUnicode_IS_READY(*p_unicode)") : (void)0);
    (__builtin_expect(!(length <= ((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1658, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1658, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject *)(*p_unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1658, "length <= PyUnicode_GET_LENGTH(*p_unicode)") : (void)0);
    if (maxchar <= ((__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1659, "PyUnicode_IS_READY(*p_unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1659, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1659, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject*)*p_unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1659, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1659, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject *)(*p_unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1659, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1659, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject *)(*p_unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))))
        return 0;
    result = PyUnicode_New(((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1661, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1661, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject *)(*p_unicode))->length),
                           maxchar);
    if (result == ((void *)0))
        return -1;
    _PyUnicode_FastCopyCharacters(result, 0, *p_unicode, 0, length);
    do { if ( --((PyObject*)(*p_unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*p_unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*p_unicode)))); } while (0);
    *p_unicode = result;
    return 0;
}

static int
unicode_putchar(PyObject **p_unicode, Py_ssize_t *pos,
                Py_UCS4 ch)
{
    (__builtin_expect(!(ch <= 0x10ffff), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1675, "ch <= MAX_UNICODE") : (void)0);
    if (unicode_widen(p_unicode, *pos, ch) < 0)
        return -1;
    do { switch ((((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject *)(*p_unicode))->state.kind))) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (((PyASCIIObject*)(*p_unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject*)*p_unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(*p_unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(*p_unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(*p_unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "((PyUnicodeObject*)(*p_unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(*p_unicode))->data.any))))))[((*pos)++)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (((PyASCIIObject*)(*p_unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject*)*p_unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(*p_unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(*p_unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(*p_unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "((PyUnicodeObject*)(*p_unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(*p_unicode))->data.any))))))[((*pos)++)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject *)(*p_unicode))->state.kind)) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "(((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 1680, \"PyUnicode_Check(*p_unicode)\") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 1680, \"PyUnicode_IS_READY(*p_unicode)\") : (void)0), ((PyASCIIObject *)(*p_unicode))->state.kind)) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (((PyASCIIObject*)(*p_unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(*p_unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_Check(*p_unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*p_unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "PyUnicode_IS_READY(*p_unicode)") : (void)0), ((PyASCIIObject*)*p_unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(*p_unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(*p_unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(*p_unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1680, "((PyUnicodeObject*)(*p_unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(*p_unicode))->data.any))))))[((*pos)++)] = (Py_UCS4)(ch); } } } while (0);


    return 0;
}






static void
unicode_write_cstr(PyObject *unicode, Py_ssize_t index,
                   const char *str, Py_ssize_t len)
{
    enum PyUnicode_Kind kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1693, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1693, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    void *data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1694, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1694, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1694, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1694, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
    const char *end = str + len;

    switch (kind) {
    case PyUnicode_1BYTE_KIND: {
        (__builtin_expect(!(index + len <= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1699, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1699, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1699, "index + len <= PyUnicode_GET_LENGTH(unicode)") : (void)0);
        ((__builtin_object_size ((char *) data + index, 0) != (size_t) -1) ? __builtin___memcpy_chk ((char *) data + index, str, len, __builtin_object_size ((char *) data + index, 0)) : __inline_memcpy_chk ((char *) data + index, str, len));
        break;
    }
    case PyUnicode_2BYTE_KIND: {
        Py_UCS2 *start = (Py_UCS2 *)data + index;
        Py_UCS2 *ucs2 = start;
        (__builtin_expect(!(index <= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1706, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1706, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1706, "index <= PyUnicode_GET_LENGTH(unicode)") : (void)0);

        for (; str < end; ++ucs2, ++str)
            *ucs2 = (Py_UCS2)*str;

        (__builtin_expect(!((ucs2 - start) <= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1711, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1711, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1711, "(ucs2 - start) <= PyUnicode_GET_LENGTH(unicode)") : (void)0);
        break;
    }
    default: {
        Py_UCS4 *start = (Py_UCS4 *)data + index;
        Py_UCS4 *ucs4 = start;
        (__builtin_expect(!(kind == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1717, "kind == PyUnicode_4BYTE_KIND") : (void)0);
        (__builtin_expect(!(index <= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1718, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1718, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1718, "index <= PyUnicode_GET_LENGTH(unicode)") : (void)0);

        for (; str < end; ++ucs4, ++str)
            *ucs4 = (Py_UCS4)*str;

        (__builtin_expect(!((ucs4 - start) <= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1723, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1723, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1723, "(ucs4 - start) <= PyUnicode_GET_LENGTH(unicode)") : (void)0);
    }
    }
}


static PyObject*
get_latin1_char(unsigned char ch)
{
    PyObject *unicode = unicode_latin1[ch];
    if (!unicode) {
        unicode = PyUnicode_New(1, ch);
        if (!unicode)
            return ((void *)0);
        ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1737, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1737, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1737, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1737, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))))[0] = ch;
        (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1738, "_PyUnicode_CheckConsistency(unicode, 1)") : (void)0);
        unicode_latin1[ch] = unicode;
    }
    ( ((PyObject*)(unicode))->ob_refcnt++);
    return unicode;
}

PyObject *
PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)
{
    PyObject *unicode;
    Py_UCS4 maxchar = 0;
    Py_ssize_t num_surrogates;

    if (u == ((void *)0))
        return (PyObject*)_PyUnicode_New(size);





    if (size == 0)
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1760, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);



    if (size == 1 && (Py_UCS4)*u < 256)
        return get_latin1_char((unsigned char)*u);



    if (find_maxchar_surrogates(u, u + size,
                                &maxchar, &num_surrogates) == -1)
        return ((void *)0);

    unicode = PyUnicode_New(size - num_surrogates, maxchar);
    if (!unicode)
        return ((void *)0);

    switch (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1777, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1777, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) {
    case PyUnicode_1BYTE_KIND:
        do { unsigned char *_to = (unsigned char *) ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1780, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1780, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1780, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1780, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))); const Py_UNICODE *_iter = (u); const Py_UNICODE *_end = (u + size); Py_ssize_t n = (_end) - (_iter); const Py_UNICODE *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (unsigned char) _iter[0]; _to[1] = (unsigned char) _iter[1]; _to[2] = (unsigned char) _iter[2]; _to[3] = (unsigned char) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (unsigned char) *_iter++; } while (0);

        break;
    case PyUnicode_2BYTE_KIND:



        do { Py_UCS2 *_to = (Py_UCS2 *) ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1787, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1787, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1787, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1787, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))); const Py_UNICODE *_iter = (u); const Py_UNICODE *_end = (u + size); Py_ssize_t n = (_end) - (_iter); const Py_UNICODE *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS2) _iter[0]; _to[1] = (Py_UCS2) _iter[1]; _to[2] = (Py_UCS2) _iter[2]; _to[3] = (Py_UCS2) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS2) *_iter++; } while (0);


        break;
    case PyUnicode_4BYTE_KIND:





        (__builtin_expect(!(num_surrogates == 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1796, "num_surrogates == 0") : (void)0);
        ((__builtin_object_size (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), 0) != (size_t) -1) ? __builtin___memcpy_chk (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), u, size * 4, __builtin_object_size (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), 0)) : __inline_memcpy_chk (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1797, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), u, size * 4));

        break;
    default:
        (__builtin_expect(!(0 && "Impossible state"), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1801, "0 && \"Impossible state\"") : (void)0);
    }

    return unicode_result(unicode);
}

PyObject *
PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
{
    if (size < 0) {
        PyErr_SetString(PyExc_SystemError,
                        "Negative size passed to PyUnicode_FromStringAndSize");
        return ((void *)0);
    }
    if (u != ((void *)0))
        return PyUnicode_DecodeUTF8Stateful(u, size, ((void *)0), ((void *)0));
    else
        return (PyObject *)_PyUnicode_New(size);
}

PyObject *
PyUnicode_FromString(const char *u)
{
    size_t size = strlen(u);
    if (size > ((Py_ssize_t)(((size_t)-1)>>1))) {
        PyErr_SetString(PyExc_OverflowError, "input too long");
        return ((void *)0);
    }
    return PyUnicode_DecodeUTF8Stateful(u, (Py_ssize_t)size, ((void *)0), ((void *)0));
}

PyObject *
_PyUnicode_FromId(_Py_Identifier *id)
{
    if (!id->object) {
        id->object = PyUnicode_DecodeUTF8Stateful(id->string,
                                                  strlen(id->string),
                                                  ((void *)0), ((void *)0));
        if (!id->object)
            return ((void *)0);
        PyUnicode_InternInPlace(&id->object);
        (__builtin_expect(!(!id->next), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1842, "!id->next") : (void)0);
        id->next = static_strings;
        static_strings = id;
    }
    return id->object;
}

void
_PyUnicode_ClearStaticStrings()
{
    _Py_Identifier *tmp, *s = static_strings;
    while (s) {
        do { if ( --((PyObject*)(s->object))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(s->object)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(s->object)))); } while (0);
        s->object = ((void *)0);
        tmp = s->next;
        s->next = ((void *)0);
        s = tmp;
    }
    static_strings = ((void *)0);
}



PyObject*
_PyUnicode_FromASCII(const char *buffer, Py_ssize_t size)
{
    const unsigned char *s = (const unsigned char *)buffer;
    PyObject *unicode;
    if (size == 1) {



        return get_latin1_char(s[0]);
    }
    unicode = PyUnicode_New(size, 127);
    if (!unicode)
        return ((void *)0);
    ((__builtin_object_size (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), 0) != (size_t) -1) ? __builtin___memcpy_chk (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), s, size, __builtin_object_size (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), 0)) : __inline_memcpy_chk (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1879, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), s, size));
    (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1880, "_PyUnicode_CheckConsistency(unicode, 1)") : (void)0);
    return unicode;
}

static Py_UCS4
kind_maxchar_limit(unsigned int kind)
{
    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        return 0x80;
    case PyUnicode_2BYTE_KIND:
        return 0x100;
    case PyUnicode_4BYTE_KIND:
        return 0x10000;
    default:
        (__builtin_expect(!(0 && "invalid kind"), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1895, "0 && \"invalid kind\"") : (void)0);
        return 0x10ffff;
    }
}

static inline Py_UCS4
align_maxchar(Py_UCS4 maxchar)
{
    if (maxchar <= 127)
        return 127;
    else if (maxchar <= 255)
        return 255;
    else if (maxchar <= 65535)
        return 65535;
    else
        return 0x10ffff;
}

static PyObject*
_PyUnicode_FromUCS1(const Py_UCS1* u, Py_ssize_t size)
{
    PyObject *res;
    unsigned char max_char;

    if (size == 0)
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1920, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    (__builtin_expect(!(size > 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1921, "size > 0") : (void)0);
    if (size == 1)
        return get_latin1_char(u[0]);

    max_char = ucs1lib_find_max_char(u, u + size);
    res = PyUnicode_New(size, max_char);
    if (!res)
        return ((void *)0);
    ((__builtin_object_size (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), 0) != (size_t) -1) ? __builtin___memcpy_chk (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), u, size, __builtin_object_size (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), 0)) : __inline_memcpy_chk (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1929, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), u, size));
    (__builtin_expect(!(_PyUnicode_CheckConsistency(res, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1930, "_PyUnicode_CheckConsistency(res, 1)") : (void)0);
    return res;
}

static PyObject*
_PyUnicode_FromUCS2(const Py_UCS2 *u, Py_ssize_t size)
{
    PyObject *res;
    Py_UCS2 max_char;

    if (size == 0)
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1941, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    (__builtin_expect(!(size > 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1942, "size > 0") : (void)0);
    if (size == 1) {
        Py_UCS4 ch = u[0];
        if (ch < 256)
            return get_latin1_char((unsigned char)ch);

        res = PyUnicode_New(1, ch);
        if (res == ((void *)0))
            return ((void *)0);
        do { switch ((((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->state.kind))) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))))[(0)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))))[(0)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->state.kind)) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 1951, \"PyUnicode_Check(res)\") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 1951, \"PyUnicode_IS_READY(res)\") : (void)0), ((PyASCIIObject *)(res))->state.kind)) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1951, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))))[(0)] = (Py_UCS4)(ch); } } } while (0);
        (__builtin_expect(!(_PyUnicode_CheckConsistency(res, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1952, "_PyUnicode_CheckConsistency(res, 1)") : (void)0);
        return res;
    }

    max_char = ucs2lib_find_max_char(u, u + size);
    res = PyUnicode_New(size, max_char);
    if (!res)
        return ((void *)0);
    if (max_char >= 256)
        ((__builtin_object_size (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), 0) != (size_t) -1) ? __builtin___memcpy_chk (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), u, sizeof(Py_UCS2)*size, __builtin_object_size (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), 0)) : __inline_memcpy_chk (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1961, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), u, sizeof(Py_UCS2)*size));
    else {
        do { Py_UCS1 *_to = (Py_UCS1 *) ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1964, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1964, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1964, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1964, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))); const Py_UCS2 *_iter = (u); const Py_UCS2 *_end = (u + size); Py_ssize_t n = (_end) - (_iter); const Py_UCS2 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS1) _iter[0]; _to[1] = (Py_UCS1) _iter[1]; _to[2] = (Py_UCS1) _iter[2]; _to[3] = (Py_UCS1) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS1) *_iter++; } while (0);

    }
    (__builtin_expect(!(_PyUnicode_CheckConsistency(res, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1966, "_PyUnicode_CheckConsistency(res, 1)") : (void)0);
    return res;
}

static PyObject*
_PyUnicode_FromUCS4(const Py_UCS4 *u, Py_ssize_t size)
{
    PyObject *res;
    Py_UCS4 max_char;

    if (size == 0)
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1977, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    (__builtin_expect(!(size > 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1978, "size > 0") : (void)0);
    if (size == 1) {
        Py_UCS4 ch = u[0];
        if (ch < 256)
            return get_latin1_char((unsigned char)ch);

        res = PyUnicode_New(1, ch);
        if (res == ((void *)0))
            return ((void *)0);
        do { switch ((((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->state.kind))) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))))[(0)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))))[(0)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->state.kind)) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 1987, \"PyUnicode_Check(res)\") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 1987, \"PyUnicode_IS_READY(res)\") : (void)0), ((PyASCIIObject *)(res))->state.kind)) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1987, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))))[(0)] = (Py_UCS4)(ch); } } } while (0);
        (__builtin_expect(!(_PyUnicode_CheckConsistency(res, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1988, "_PyUnicode_CheckConsistency(res, 1)") : (void)0);
        return res;
    }

    max_char = ucs4lib_find_max_char(u, u + size);
    res = PyUnicode_New(size, max_char);
    if (!res)
        return ((void *)0);
    if (max_char < 256)
        do { Py_UCS1 *_to = (Py_UCS1 *) ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1998, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1998, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1998, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 1998, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))); const Py_UCS4 *_iter = (u); const Py_UCS4 *_end = (u + size); Py_ssize_t n = (_end) - (_iter); const Py_UCS4 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS1) _iter[0]; _to[1] = (Py_UCS1) _iter[1]; _to[2] = (Py_UCS1) _iter[2]; _to[3] = (Py_UCS1) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS1) *_iter++; } while (0);

    else if (max_char < 0x10000)
        do { Py_UCS2 *_to = (Py_UCS2 *) ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2001, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2001, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2001, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2001, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))); const Py_UCS4 *_iter = (u); const Py_UCS4 *_end = (u + size); Py_ssize_t n = (_end) - (_iter); const Py_UCS4 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS2) _iter[0]; _to[1] = (Py_UCS2) _iter[1]; _to[2] = (Py_UCS2) _iter[2]; _to[3] = (Py_UCS2) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS2) *_iter++; } while (0);

    else
        ((__builtin_object_size (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), 0) != (size_t) -1) ? __builtin___memcpy_chk (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), u, sizeof(Py_UCS4)*size, __builtin_object_size (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), 0)) : __inline_memcpy_chk (((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2003, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))), u, sizeof(Py_UCS4)*size));
    (__builtin_expect(!(_PyUnicode_CheckConsistency(res, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2004, "_PyUnicode_CheckConsistency(res, 1)") : (void)0);
    return res;
}

PyObject*
PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
{
    if (size < 0) {
        PyErr_SetString(PyExc_ValueError, "size must be positive");
        return ((void *)0);
    }
    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        return _PyUnicode_FromUCS1(buffer, size);
    case PyUnicode_2BYTE_KIND:
        return _PyUnicode_FromUCS2(buffer, size);
    case PyUnicode_4BYTE_KIND:
        return _PyUnicode_FromUCS4(buffer, size);
    default:
        PyErr_SetString(PyExc_SystemError, "invalid kind");
        return ((void *)0);
    }
}

Py_UCS4
_PyUnicode_FindMaxChar(PyObject *unicode, Py_ssize_t start, Py_ssize_t end)
{
    enum PyUnicode_Kind kind;
    void *startptr, *endptr;

    (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2034, "PyUnicode_IS_READY(unicode)") : (void)0);
    (__builtin_expect(!(0 <= start), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2035, "0 <= start") : (void)0);
    (__builtin_expect(!(end <= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2036, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2036, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2036, "end <= PyUnicode_GET_LENGTH(unicode)") : (void)0);
    (__builtin_expect(!(start <= end), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2037, "start <= end") : (void)0);

    if (start == 0 && end == ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2039, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2039, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length))
        return ((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2040, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2040, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2040, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2040, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2040, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2040, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2040, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));

    if (start == end)
        return 127;

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2045, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2045, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
        return 127;

    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2048, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2048, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    startptr = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2049, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2049, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2049, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2049, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
    endptr = (char *)startptr + end * kind;
    startptr = (char *)startptr + start * kind;
    switch(kind) {
    case PyUnicode_1BYTE_KIND:
        return ucs1lib_find_max_char(startptr, endptr);
    case PyUnicode_2BYTE_KIND:
        return ucs2lib_find_max_char(startptr, endptr);
    case PyUnicode_4BYTE_KIND:
        return ucs4lib_find_max_char(startptr, endptr);
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2060, "0") : (void)0);
        return 0;
    }
}




static void
unicode_adjust_maxchar(PyObject **p_unicode)
{
    PyObject *unicode, *copy;
    Py_UCS4 max_char;
    Py_ssize_t len;
    unsigned int kind;

    (__builtin_expect(!(p_unicode != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2076, "p_unicode != NULL") : (void)0);
    unicode = *p_unicode;
    (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2078, "PyUnicode_IS_READY(unicode)") : (void)0);
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2079, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2079, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
        return;

    len = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2082, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2082, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2083, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2083, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    if (kind == PyUnicode_1BYTE_KIND) {
        const Py_UCS1 *u = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2085, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2085, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2085, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2085, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))));
        max_char = ucs1lib_find_max_char(u, u + len);
        if (max_char >= 128)
            return;
    }
    else if (kind == PyUnicode_2BYTE_KIND) {
        const Py_UCS2 *u = ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2091, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2091, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2091, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2091, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))));
        max_char = ucs2lib_find_max_char(u, u + len);
        if (max_char >= 256)
            return;
    }
    else {
        const Py_UCS4 *u = ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2097, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2097, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2097, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2097, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))));
        (__builtin_expect(!(kind == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2098, "kind == PyUnicode_4BYTE_KIND") : (void)0);
        max_char = ucs4lib_find_max_char(u, u + len);
        if (max_char >= 0x10000)
            return;
    }
    copy = PyUnicode_New(len, max_char);
    if (copy != ((void *)0))
        _PyUnicode_FastCopyCharacters(copy, 0, unicode, 0, len);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    *p_unicode = copy;
}

PyObject*
_PyUnicode_Copy(PyObject *unicode)
{
    Py_ssize_t length;
    PyObject *copy;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 2117);
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2120, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);

    length = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2123, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2123, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
    copy = PyUnicode_New(length, ((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2124, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2124, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2124, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2124, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2124, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2124, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2124, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))));
    if (!copy)
        return ((void *)0);
    (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2127, "PyUnicode_Check(copy)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)copy)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2127, "PyUnicode_IS_READY(copy)") : (void)0), ((PyASCIIObject *)(copy))->state.kind) == ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2127, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2127, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2127, "PyUnicode_KIND(copy) == PyUnicode_KIND(unicode)") : (void)0);

    ((__builtin_object_size (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (((PyASCIIObject*)(copy))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)copy)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(copy)") : (void)0), ((PyASCIIObject*)copy)->state.ascii) ? ((void*)((PyASCIIObject*)(copy) + 1)) : ((void*)((PyCompactUnicodeObject*)(copy) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(copy))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "((PyUnicodeObject*)(copy))->data.any") : (void)0), ((((PyUnicodeObject *)(copy))->data.any)))), 0) != (size_t) -1) ? __builtin___memcpy_chk (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (((PyASCIIObject*)(copy))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)copy)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(copy)") : (void)0), ((PyASCIIObject*)copy)->state.ascii) ? ((void*)((PyASCIIObject*)(copy) + 1)) : ((void*)((PyCompactUnicodeObject*)(copy) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(copy))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "((PyUnicodeObject*)(copy))->data.any") : (void)0), ((((PyUnicodeObject *)(copy))->data.any)))), ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))), length * ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind), __builtin_object_size (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (((PyASCIIObject*)(copy))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)copy)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(copy)") : (void)0), ((PyASCIIObject*)copy)->state.ascii) ? ((void*)((PyASCIIObject*)(copy) + 1)) : ((void*)((PyCompactUnicodeObject*)(copy) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(copy))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "((PyUnicodeObject*)(copy))->data.any") : (void)0), ((((PyUnicodeObject *)(copy))->data.any)))), 0)) : __inline_memcpy_chk (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (((PyASCIIObject*)(copy))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(copy))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(copy)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)copy)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(copy)") : (void)0), ((PyASCIIObject*)copy)->state.ascii) ? ((void*)((PyASCIIObject*)(copy) + 1)) : ((void*)((PyCompactUnicodeObject*)(copy) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(copy))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "((PyUnicodeObject*)(copy))->data.any") : (void)0), ((((PyUnicodeObject *)(copy))->data.any)))), ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))), length * ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2130, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)));

    (__builtin_expect(!(_PyUnicode_CheckConsistency(copy, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2131, "_PyUnicode_CheckConsistency(copy, 1)") : (void)0);
    return copy;
}





void*
_PyUnicode_AsKind(PyObject *s, unsigned int kind)
{
    Py_ssize_t len;
    void *result;
    unsigned int skind;

    if (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2146, "_PyUnicode_CHECK(s)") : (void)0), ((((PyASCIIObject*)s)->state.ready) ? 0 : _PyUnicode_Ready(s))) == -1)
        return ((void *)0);

    len = ((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2149, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2149, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject *)(s))->length);
    skind = ((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2150, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2150, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject *)(s))->state.kind);
    if (skind >= kind) {
        PyErr_SetString(PyExc_SystemError, "invalid widening attempt");
        return ((void *)0);
    }
    switch (kind) {
    case PyUnicode_2BYTE_KIND:
        result = PyMem_Malloc(len * sizeof(Py_UCS2));
        if (!result)
            return PyErr_NoMemory();
        (__builtin_expect(!(skind == PyUnicode_1BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2160, "skind == PyUnicode_1BYTE_KIND") : (void)0);
        do { Py_UCS2 *_to = (Py_UCS2 *) result; const Py_UCS1 *_iter = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "PyUnicode_Check(s)") : (void)0), (((PyASCIIObject*)(s))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject*)s)->state.ascii) ? ((void*)((PyASCIIObject*)(s) + 1)) : ((void*)((PyCompactUnicodeObject*)(s) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "((PyUnicodeObject*)(s))->data.any") : (void)0), ((((PyUnicodeObject *)(s))->data.any)))))); const Py_UCS1 *_end = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "PyUnicode_Check(s)") : (void)0), (((PyASCIIObject*)(s))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject*)s)->state.ascii) ? ((void*)((PyASCIIObject*)(s) + 1)) : ((void*)((PyCompactUnicodeObject*)(s) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2165, "((PyUnicodeObject*)(s))->data.any") : (void)0), ((((PyUnicodeObject *)(s))->data.any))))) + len); Py_ssize_t n = (_end) - (_iter); const Py_UCS1 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS2) _iter[0]; _to[1] = (Py_UCS2) _iter[1]; _to[2] = (Py_UCS2) _iter[2]; _to[3] = (Py_UCS2) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS2) *_iter++; } while (0);




        return result;
    case PyUnicode_4BYTE_KIND:
        result = PyMem_Malloc(len * sizeof(Py_UCS4));
        if (!result)
            return PyErr_NoMemory();
        if (skind == PyUnicode_2BYTE_KIND) {
            do { Py_UCS4 *_to = (Py_UCS4 *) result; const Py_UCS2 *_iter = (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "PyUnicode_Check(s)") : (void)0), (((PyASCIIObject*)(s))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject*)s)->state.ascii) ? ((void*)((PyASCIIObject*)(s) + 1)) : ((void*)((PyCompactUnicodeObject*)(s) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "((PyUnicodeObject*)(s))->data.any") : (void)0), ((((PyUnicodeObject *)(s))->data.any)))))); const Py_UCS2 *_end = (((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "PyUnicode_Check(s)") : (void)0), (((PyASCIIObject*)(s))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject*)s)->state.ascii) ? ((void*)((PyASCIIObject*)(s) + 1)) : ((void*)((PyCompactUnicodeObject*)(s) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2176, "((PyUnicodeObject*)(s))->data.any") : (void)0), ((((PyUnicodeObject *)(s))->data.any))))) + len); Py_ssize_t n = (_end) - (_iter); const Py_UCS2 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS4) _iter[0]; _to[1] = (Py_UCS4) _iter[1]; _to[2] = (Py_UCS4) _iter[2]; _to[3] = (Py_UCS4) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS4) *_iter++; } while (0);




        }
        else {
            (__builtin_expect(!(skind == PyUnicode_1BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2179, "skind == PyUnicode_1BYTE_KIND") : (void)0);
            do { Py_UCS4 *_to = (Py_UCS4 *) result; const Py_UCS1 *_iter = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "PyUnicode_Check(s)") : (void)0), (((PyASCIIObject*)(s))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject*)s)->state.ascii) ? ((void*)((PyASCIIObject*)(s) + 1)) : ((void*)((PyCompactUnicodeObject*)(s) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "((PyUnicodeObject*)(s))->data.any") : (void)0), ((((PyUnicodeObject *)(s))->data.any)))))); const Py_UCS1 *_end = (((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "PyUnicode_Check(s)") : (void)0), (((PyASCIIObject*)(s))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject*)s)->state.ascii) ? ((void*)((PyASCIIObject*)(s) + 1)) : ((void*)((PyCompactUnicodeObject*)(s) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2184, "((PyUnicodeObject*)(s))->data.any") : (void)0), ((((PyUnicodeObject *)(s))->data.any))))) + len); Py_ssize_t n = (_end) - (_iter); const Py_UCS1 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS4) _iter[0]; _to[1] = (Py_UCS4) _iter[1]; _to[2] = (Py_UCS4) _iter[2]; _to[3] = (Py_UCS4) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS4) *_iter++; } while (0);




        }
        return result;
    default:
        break;
    }
    PyErr_SetString(PyExc_SystemError, "invalid kind");
    return ((void *)0);
}

static Py_UCS4*
as_ucs4(PyObject *string, Py_UCS4 *target, Py_ssize_t targetsize,
        int copy_null)
{
    int kind;
    void *data;
    Py_ssize_t len, targetlen;
    if (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2201, "_PyUnicode_CHECK(string)") : (void)0), ((((PyASCIIObject*)string)->state.ready) ? 0 : _PyUnicode_Ready(string))) == -1)
        return ((void *)0);
    kind = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2203, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2203, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2204, "PyUnicode_Check(string)") : (void)0), (((PyASCIIObject*)(string))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2204, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2204, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii) ? ((void*)((PyASCIIObject*)(string) + 1)) : ((void*)((PyCompactUnicodeObject*)(string) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(string))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2204, "((PyUnicodeObject*)(string))->data.any") : (void)0), ((((PyUnicodeObject *)(string))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2205, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2205, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length);
    targetlen = len;
    if (copy_null)
        targetlen++;
    if (!target) {
        if (((Py_ssize_t)(((size_t)-1)>>1)) / sizeof(Py_UCS4) < targetlen) {
            PyErr_NoMemory();
            return ((void *)0);
        }
        target = PyMem_Malloc(targetlen * sizeof(Py_UCS4));
        if (!target) {
            PyErr_NoMemory();
            return ((void *)0);
        }
    }
    else {
        if (targetsize < targetlen) {
            PyErr_Format(PyExc_SystemError,
                         "string is longer than the buffer");
            if (copy_null && 0 < targetsize)
                target[0] = 0;
            return ((void *)0);
        }
    }
    if (kind == PyUnicode_1BYTE_KIND) {
        Py_UCS1 *start = (Py_UCS1 *) data;
        do { Py_UCS4 *_to = (Py_UCS4 *) target; const Py_UCS1 *_iter = (start); const Py_UCS1 *_end = (start + len); Py_ssize_t n = (_end) - (_iter); const Py_UCS1 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS4) _iter[0]; _to[1] = (Py_UCS4) _iter[1]; _to[2] = (Py_UCS4) _iter[2]; _to[3] = (Py_UCS4) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS4) *_iter++; } while (0);
    }
    else if (kind == PyUnicode_2BYTE_KIND) {
        Py_UCS2 *start = (Py_UCS2 *) data;
        do { Py_UCS4 *_to = (Py_UCS4 *) target; const Py_UCS2 *_iter = (start); const Py_UCS2 *_end = (start + len); Py_ssize_t n = (_end) - (_iter); const Py_UCS2 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS4) _iter[0]; _to[1] = (Py_UCS4) _iter[1]; _to[2] = (Py_UCS4) _iter[2]; _to[3] = (Py_UCS4) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS4) *_iter++; } while (0);
    }
    else {
        (__builtin_expect(!(kind == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2238, "kind == PyUnicode_4BYTE_KIND") : (void)0);
        ((__builtin_object_size (target, 0) != (size_t) -1) ? __builtin___memcpy_chk (target, data, len * sizeof(Py_UCS4), __builtin_object_size (target, 0)) : __inline_memcpy_chk (target, data, len * sizeof(Py_UCS4)));
    }
    if (copy_null)
        target[len] = 0;
    return target;
}

Py_UCS4*
PyUnicode_AsUCS4(PyObject *string, Py_UCS4 *target, Py_ssize_t targetsize,
                 int copy_null)
{
    if (target == ((void *)0) || targetsize < 0) {
        _PyErr_BadInternalCall("unicodeobject.c", 2251);
        return ((void *)0);
    }
    return as_ucs4(string, target, targetsize, copy_null);
}

Py_UCS4*
PyUnicode_AsUCS4Copy(PyObject *string)
{
    return as_ucs4(string, ((void *)0), 0, 1);
}



PyObject *
PyUnicode_FromWideChar(register const wchar_t *w, Py_ssize_t size)
{
    if (w == ((void *)0)) {
        if (size == 0)
            do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2270, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
        _PyErr_BadInternalCall("unicodeobject.c", 2271);
        return ((void *)0);
    }

    if (size == -1) {
        size = wcslen(w);
    }

    return PyUnicode_FromUnicode(w, size);
}



static void
makefmt(char *fmt, int longflag, int longlongflag, int size_tflag,
        int zeropad, int width, int precision, char c)
{
    *fmt++ = '%';
    if (width) {
        if (zeropad)
            *fmt++ = '0';
        fmt += __builtin___sprintf_chk (fmt, 0, __builtin_object_size (fmt, 2 > 1), "%d", width);
    }
    if (precision)
        fmt += __builtin___sprintf_chk (fmt, 0, __builtin_object_size (fmt, 2 > 1), ".%d", precision);
    if (longflag)
        *fmt++ = 'l';
    else if (longlongflag) {



        char *f = "ll";
        while (*f)
            *fmt++ = *f++;





    }
    else if (size_tflag) {
        char *f = "l";
        while (*f)
            *fmt++ = *f++;
    }
    *fmt++ = c;
    *fmt = '\0';
}



static const char*
parse_format_flags(const char *f,
                   int *p_width, int *p_precision,
                   int *p_longflag, int *p_longlongflag, int *p_size_tflag)
{
    int width, precision, longflag, longlongflag, size_tflag;


    f++;
    width = 0;
    while ((_Py_ctype_table[((unsigned char)(((unsigned)*f) & 0xff))] & 0x04))
        width = (width*10) + *f++ - '0';
    precision = 0;
    if (*f == '.') {
        f++;
        while ((_Py_ctype_table[((unsigned char)(((unsigned)*f) & 0xff))] & 0x04))
            precision = (precision*10) + *f++ - '0';
        if (*f == '%') {

            f--;
        }
    }
    if (*f == '\0') {

        f--;
    }
    if (p_width != ((void *)0))
        *p_width = width;
    if (p_precision != ((void *)0))
        *p_precision = precision;


    longflag = 0;
    longlongflag = 0;
    size_tflag = 0;

    if (*f == 'l') {
        if (f[1] == 'd' || f[1] == 'u' || f[1] == 'i') {
            longflag = 1;
            ++f;
        }

        else if (f[1] == 'l' &&
                 (f[2] == 'd' || f[2] == 'u' || f[2] == 'i')) {
            longlongflag = 1;
            f += 2;
        }

    }

    else if (*f == 'z' && (f[1] == 'd' || f[1] == 'u' || f[1] == 'i')) {
        size_tflag = 1;
        ++f;
    }
    if (p_longflag != ((void *)0))
        *p_longflag = longflag;
    if (p_longlongflag != ((void *)0))
        *p_longlongflag = longlongflag;
    if (p_size_tflag != ((void *)0))
        *p_size_tflag = size_tflag;
    return f;
}
# 2393 "unicodeobject.c"
PyObject *
PyUnicode_FromFormatV(const char *format, va_list vargs)
{
    va_list count;
    Py_ssize_t callcount = 0;
    PyObject **callresults = ((void *)0);
    PyObject **callresult = ((void *)0);
    Py_ssize_t n = 0;
    int width = 0;
    int precision = 0;
    int zeropad;
    const char* f;
    PyObject *string;

    char fmt[61];
    Py_UCS4 maxchar = 127;
    Py_UCS4 argmaxchar;
    Py_ssize_t numbersize = 0;
    char *numberresults = ((void *)0);
    char *numberresult = ((void *)0);
    Py_ssize_t i;
    int kind;
    void *data;

    ((__builtin_object_size ((count), 0) != (size_t) -1) ? __builtin___memcpy_chk ((count), (vargs), sizeof(va_list), __builtin_object_size ((count), 0)) : __inline_memcpy_chk ((count), (vargs), sizeof(va_list)));







    for (f = format; *f; f++) {
        if (*f == '%') {
            int longlongflag;

            f = parse_format_flags(f, &width, ((void *)0), ((void *)0), &longlongflag, ((void *)0));
            if (*f == 's' || *f=='S' || *f=='R' || *f=='A' || *f=='V')
                ++callcount;

            else if (*f == 'd' || *f=='u' || *f=='i' || *f=='x' || *f=='p') {

                if (longlongflag) {
                    if (width < (2 + (8*53-1) / 22))
                        width = (2 + (8*53-1) / 22);
                }
                else





                    if (width < 21)
                        width = 21;



                numbersize += (width + 1);
            }
        }
        else if ((unsigned char)*f > 127) {
            PyErr_Format(PyExc_ValueError,
                "PyUnicode_FromFormatV() expects an ASCII-encoded format "
                "string, got a non-ASCII byte: 0x%02x",
                (unsigned char)*f);
            return ((void *)0);
        }
    }


    if (callcount) {
        callresults = PyObject_Malloc(sizeof(PyObject *) * callcount);
        if (!callresults) {
            PyErr_NoMemory();
            return ((void *)0);
        }
        callresult = callresults;
    }

    if (numbersize) {
        numberresults = PyObject_Malloc(numbersize);
        if (!numberresults) {
            PyErr_NoMemory();
            goto fail;
        }
        numberresult = numberresults;
    }


    for (f = format; *f; f++) {
        if (*f == '%') {
            const char* p;
            int longflag;
            int longlongflag;
            int size_tflag;
            int numprinted;

            p = f;
            zeropad = (f[1] == '0');
            f = parse_format_flags(f, &width, &precision,
                                   &longflag, &longlongflag, &size_tflag);
            switch (*f) {
            case 'c':
            {
                Py_UCS4 ordinal = __builtin_va_arg(count,int);
                maxchar = ((maxchar) | (ordinal));
                n++;
                break;
            }
            case '%':
                n++;
                break;
            case 'i':
            case 'd':
                makefmt(fmt, longflag, longlongflag, size_tflag, zeropad,
                        width, precision, *f);
                if (longflag)
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,long));


                else if (longlongflag)
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,long long));


                else if (size_tflag)
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,Py_ssize_t));

                else
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,int));

                n += numprinted;

                numberresult += (numprinted + 1);
                (__builtin_expect(!(*(numberresult - 1) == '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2526, "*(numberresult - 1) == '\\0'") : (void)0);
                (__builtin_expect(!(*(numberresult - 2) != '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2527, "*(numberresult - 2) != '\\0'") : (void)0);
                (__builtin_expect(!(numprinted >= 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2528, "numprinted >= 0") : (void)0);
                (__builtin_expect(!(numberresult <= numberresults + numbersize), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2529, "numberresult <= numberresults + numbersize") : (void)0);
                break;
            case 'u':
                makefmt(fmt, longflag, longlongflag, size_tflag, zeropad,
                        width, precision, 'u');
                if (longflag)
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,unsigned long));


                else if (longlongflag)
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,unsigned long long));


                else if (size_tflag)
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,size_t));

                else
                    numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,unsigned int));

                n += numprinted;
                numberresult += (numprinted + 1);
                (__builtin_expect(!(*(numberresult - 1) == '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2550, "*(numberresult - 1) == '\\0'") : (void)0);
                (__builtin_expect(!(*(numberresult - 2) != '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2551, "*(numberresult - 2) != '\\0'") : (void)0);
                (__builtin_expect(!(numprinted >= 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2552, "numprinted >= 0") : (void)0);
                (__builtin_expect(!(numberresult <= numberresults + numbersize), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2553, "numberresult <= numberresults + numbersize") : (void)0);
                break;
            case 'x':
                makefmt(fmt, 0, 0, 0, zeropad, width, precision, 'x');
                numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), fmt, __builtin_va_arg(count,int));
                n += numprinted;
                numberresult += (numprinted + 1);
                (__builtin_expect(!(*(numberresult - 1) == '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2560, "*(numberresult - 1) == '\\0'") : (void)0);
                (__builtin_expect(!(*(numberresult - 2) != '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2561, "*(numberresult - 2) != '\\0'") : (void)0);
                (__builtin_expect(!(numprinted >= 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2562, "numprinted >= 0") : (void)0);
                (__builtin_expect(!(numberresult <= numberresults + numbersize), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2563, "numberresult <= numberresults + numbersize") : (void)0);
                break;
            case 'p':
                numprinted = __builtin___sprintf_chk (numberresult, 0, __builtin_object_size (numberresult, 2 > 1), "%p", __builtin_va_arg(count,void*));

                if (numberresult[1] == 'X')
                    numberresult[1] = 'x';
                else if (numberresult[1] != 'x') {
                    ((__builtin_object_size (numberresult + 2, 0) != (size_t) -1) ? __builtin___memmove_chk (numberresult + 2, numberresult, strlen(numberresult) + 1, __builtin_object_size (numberresult + 2, 0)) : __inline_memmove_chk (numberresult + 2, numberresult, strlen(numberresult) + 1));

                    numberresult[0] = '0';
                    numberresult[1] = 'x';
                    numprinted += 2;
                }
                n += numprinted;
                numberresult += (numprinted + 1);
                (__builtin_expect(!(*(numberresult - 1) == '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2579, "*(numberresult - 1) == '\\0'") : (void)0);
                (__builtin_expect(!(*(numberresult - 2) != '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2580, "*(numberresult - 2) != '\\0'") : (void)0);
                (__builtin_expect(!(numprinted >= 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2581, "numprinted >= 0") : (void)0);
                (__builtin_expect(!(numberresult <= numberresults + numbersize), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2582, "numberresult <= numberresults + numbersize") : (void)0);
                break;
            case 's':
            {

                const char *s = __builtin_va_arg(count,const char*);
                PyObject *str = PyUnicode_DecodeUTF8Stateful(s, strlen(s), "replace", ((void *)0));
                if (!str)
                    goto fail;


                argmaxchar = ((__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2593, "PyUnicode_IS_READY(str)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2593, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2593, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2593, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2593, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2593, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2593, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                maxchar = ((maxchar) | (argmaxchar));
                n += ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2595, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2595, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);

                *callresult++ = str;
                break;
            }
            case 'U':
            {
                PyObject *obj = __builtin_va_arg(count,PyObject *);
                (__builtin_expect(!(obj && ((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2603, "obj && _PyUnicode_CHECK(obj)") : (void)0);
                if (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2604, "_PyUnicode_CHECK(obj)") : (void)0), ((((PyASCIIObject*)obj)->state.ready) ? 0 : _PyUnicode_Ready(obj))) == -1)
                    goto fail;
                argmaxchar = ((__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2606, "PyUnicode_IS_READY(obj)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2606, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2606, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject*)obj)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2606, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2606, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2606, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2606, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                maxchar = ((maxchar) | (argmaxchar));
                n += ((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2608, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2608, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->length);
                break;
            }
            case 'V':
            {
                PyObject *obj = __builtin_va_arg(count,PyObject *);
                const char *str = __builtin_va_arg(count,const char *);
                PyObject *str_obj;
                (__builtin_expect(!(obj || str), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2616, "obj || str") : (void)0);
                (__builtin_expect(!(!obj || ((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2617, "!obj || _PyUnicode_CHECK(obj)") : (void)0);
                if (obj) {
                    if (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2619, "_PyUnicode_CHECK(obj)") : (void)0), ((((PyASCIIObject*)obj)->state.ready) ? 0 : _PyUnicode_Ready(obj))) == -1)
                        goto fail;
                    argmaxchar = ((__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2621, "PyUnicode_IS_READY(obj)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2621, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2621, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject*)obj)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2621, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2621, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2621, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2621, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                    maxchar = ((maxchar) | (argmaxchar));
                    n += ((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2623, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2623, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->length);
                    *callresult++ = ((void *)0);
                }
                else {
                    str_obj = PyUnicode_DecodeUTF8Stateful(str, strlen(str), "replace", ((void *)0));
                    if (!str_obj)
                        goto fail;
                    if (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2630, "_PyUnicode_CHECK(str_obj)") : (void)0), ((((PyASCIIObject*)str_obj)->state.ready) ? 0 : _PyUnicode_Ready(str_obj))) == -1) {
                        do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
                        goto fail;
                    }
                    argmaxchar = ((__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2634, "PyUnicode_IS_READY(str_obj)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2634, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2634, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject*)str_obj)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2634, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2634, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2634, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2634, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                    maxchar = ((maxchar) | (argmaxchar));
                    n += ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2636, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2636, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->length);
                    *callresult++ = str_obj;
                }
                break;
            }
            case 'S':
            {
                PyObject *obj = __builtin_va_arg(count,PyObject *);
                PyObject *str;
                (__builtin_expect(!(obj), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2645, "obj") : (void)0);
                str = PyObject_Str(obj);
                if (!str)
                    goto fail;
                if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2649, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1) {
                    do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
                    goto fail;
                }
                argmaxchar = ((__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2653, "PyUnicode_IS_READY(str)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2653, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2653, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2653, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2653, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2653, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2653, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                maxchar = ((maxchar) | (argmaxchar));
                n += ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2655, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2655, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);

                *callresult++ = str;
                break;
            }
            case 'R':
            {
                PyObject *obj = __builtin_va_arg(count,PyObject *);
                PyObject *repr;
                (__builtin_expect(!(obj), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2664, "obj") : (void)0);
                repr = PyObject_Repr(obj);
                if (!repr)
                    goto fail;
                if (((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2668, "_PyUnicode_CHECK(repr)") : (void)0), ((((PyASCIIObject*)repr)->state.ready) ? 0 : _PyUnicode_Ready(repr))) == -1) {
                    do { if ( --((PyObject*)(repr))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repr)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repr)))); } while (0);
                    goto fail;
                }
                argmaxchar = ((__builtin_expect(!((((PyASCIIObject*)repr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2672, "PyUnicode_IS_READY(repr)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2672, "PyUnicode_Check(repr)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2672, "PyUnicode_IS_READY(repr)") : (void)0), ((PyASCIIObject*)repr)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2672, "PyUnicode_Check(repr)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2672, "PyUnicode_IS_READY(repr)") : (void)0), ((PyASCIIObject *)(repr))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2672, "PyUnicode_Check(repr)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2672, "PyUnicode_IS_READY(repr)") : (void)0), ((PyASCIIObject *)(repr))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                maxchar = ((maxchar) | (argmaxchar));
                n += ((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2674, "PyUnicode_Check(repr)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2674, "PyUnicode_IS_READY(repr)") : (void)0), ((PyASCIIObject *)(repr))->length);

                *callresult++ = repr;
                break;
            }
            case 'A':
            {
                PyObject *obj = __builtin_va_arg(count,PyObject *);
                PyObject *ascii;
                (__builtin_expect(!(obj), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2683, "obj") : (void)0);
                ascii = PyObject_ASCII(obj);
                if (!ascii)
                    goto fail;
                if (((__builtin_expect(!(((((((PyObject*)(ascii))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2687, "_PyUnicode_CHECK(ascii)") : (void)0), ((((PyASCIIObject*)ascii)->state.ready) ? 0 : _PyUnicode_Ready(ascii))) == -1) {
                    do { if ( --((PyObject*)(ascii))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(ascii)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(ascii)))); } while (0);
                    goto fail;
                }
                argmaxchar = ((__builtin_expect(!((((PyASCIIObject*)ascii)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2691, "PyUnicode_IS_READY(ascii)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(ascii))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2691, "PyUnicode_Check(ascii)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)ascii)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2691, "PyUnicode_IS_READY(ascii)") : (void)0), ((PyASCIIObject*)ascii)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(ascii))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2691, "PyUnicode_Check(ascii)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)ascii)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2691, "PyUnicode_IS_READY(ascii)") : (void)0), ((PyASCIIObject *)(ascii))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(ascii))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2691, "PyUnicode_Check(ascii)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)ascii)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2691, "PyUnicode_IS_READY(ascii)") : (void)0), ((PyASCIIObject *)(ascii))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                maxchar = ((maxchar) | (argmaxchar));
                n += ((__builtin_expect(!(((((((PyObject*)(ascii))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2693, "PyUnicode_Check(ascii)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)ascii)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2693, "PyUnicode_IS_READY(ascii)") : (void)0), ((PyASCIIObject *)(ascii))->length);

                *callresult++ = ascii;
                break;
            }
            default:






                n += strlen(p);
                goto expand;
            }
        } else
            n++;
    }
  expand:




    string = PyUnicode_New(n, maxchar);
    if (!string)
        goto fail;
    kind = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2719, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2719, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2720, "PyUnicode_Check(string)") : (void)0), (((PyASCIIObject*)(string))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2720, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2720, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii) ? ((void*)((PyASCIIObject*)(string) + 1)) : ((void*)((PyCompactUnicodeObject*)(string) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(string))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2720, "((PyUnicodeObject*)(string))->data.any") : (void)0), ((((PyUnicodeObject *)(string))->data.any))));
    callresult = callresults;
    numberresult = numberresults;

    for (i = 0, f = format; *f; f++) {
        if (*f == '%') {
            const char* p;

            p = f;
            f = parse_format_flags(f, ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0));



            (__builtin_expect(!(i <= ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2733, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2733, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2733, "i <= PyUnicode_GET_LENGTH(string)") : (void)0);

            switch (*f) {
            case 'c':
            {
                const int ordinal = __builtin_va_arg(vargs,int);
                do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(i++)] = (Py_UCS1)(ordinal); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(i++)] = (Py_UCS2)(ordinal); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2739, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(i++)] = (Py_UCS4)(ordinal); } } } while (0);
                break;
            }
            case 'i':
            case 'd':
            case 'u':
            case 'x':
            case 'p':
            {
                Py_ssize_t len;

                if (*f == 'p')
                    (void) __builtin_va_arg(vargs,void *);
                else
                    (void) __builtin_va_arg(vargs,int);

                len = strlen(numberresult);
                unicode_write_cstr(string, i, numberresult, len);

                i += len;
                numberresult += len;
                (__builtin_expect(!(*numberresult == '\0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2760, "*numberresult == '\\0'") : (void)0);
                numberresult++;
                (__builtin_expect(!(numberresult <= numberresults + numbersize), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2762, "numberresult <= numberresults + numbersize") : (void)0);
                break;
            }
            case 's':
            {

                Py_ssize_t size;
                (void) __builtin_va_arg(vargs,char *);
                size = ((__builtin_expect(!(((((((PyObject*)(*callresult))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2770, "PyUnicode_Check(*callresult)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*callresult)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2770, "PyUnicode_IS_READY(*callresult)") : (void)0), ((PyASCIIObject *)(*callresult))->length);
                (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(*callresult))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2771, "PyUnicode_Check(*callresult)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*callresult)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2771, "PyUnicode_IS_READY(*callresult)") : (void)0), ((PyASCIIObject *)(*callresult))->state.kind) <= ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2771, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2771, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2771, "PyUnicode_KIND(*callresult) <= PyUnicode_KIND(string)") : (void)0);
                _PyUnicode_FastCopyCharacters(string, i, *callresult, 0, size);
                i += size;

                do { if ( --((PyObject*)(*callresult))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*callresult)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*callresult)))); } while (0);

                ++callresult;
                break;
            }
            case 'U':
            {
                PyObject *obj = __builtin_va_arg(vargs,PyObject *);
                Py_ssize_t size;
                (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2784, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2784, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->state.kind) <= ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2784, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2784, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2784, "PyUnicode_KIND(obj) <= PyUnicode_KIND(string)") : (void)0);
                size = ((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2785, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2785, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->length);
                _PyUnicode_FastCopyCharacters(string, i, obj, 0, size);
                i += size;
                break;
            }
            case 'V':
            {
                Py_ssize_t size;
                PyObject *obj = __builtin_va_arg(vargs,PyObject *);
                __builtin_va_arg(vargs,const char *);
                if (obj) {
                    size = ((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2796, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2796, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->length);
                    (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2797, "PyUnicode_Check(obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2797, "PyUnicode_IS_READY(obj)") : (void)0), ((PyASCIIObject *)(obj))->state.kind) <= ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2797, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2797, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2797, "PyUnicode_KIND(obj) <= PyUnicode_KIND(string)") : (void)0);
                    _PyUnicode_FastCopyCharacters(string, i, obj, 0, size);
                    i += size;
                } else {
                    size = ((__builtin_expect(!(((((((PyObject*)(*callresult))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2801, "PyUnicode_Check(*callresult)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*callresult)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2801, "PyUnicode_IS_READY(*callresult)") : (void)0), ((PyASCIIObject *)(*callresult))->length);
                    (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(*callresult))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2803, "PyUnicode_Check(*callresult)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*callresult)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2803, "PyUnicode_IS_READY(*callresult)") : (void)0), ((PyASCIIObject *)(*callresult))->state.kind) <= ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2803, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2803, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2803, "PyUnicode_KIND(*callresult) <= PyUnicode_KIND(string)") : (void)0);

                    _PyUnicode_FastCopyCharacters(string, i, *callresult, 0, size);
                    i += size;
                    do { if ( --((PyObject*)(*callresult))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*callresult)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*callresult)))); } while (0);
                }
                ++callresult;
                break;
            }
            case 'S':
            case 'R':
            case 'A':
            {
                Py_ssize_t size = ((__builtin_expect(!(((((((PyObject*)(*callresult))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2815, "PyUnicode_Check(*callresult)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*callresult)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2815, "PyUnicode_IS_READY(*callresult)") : (void)0), ((PyASCIIObject *)(*callresult))->length);

                (void) __builtin_va_arg(vargs,PyObject *);
                (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(*callresult))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2818, "PyUnicode_Check(*callresult)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*callresult)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2818, "PyUnicode_IS_READY(*callresult)") : (void)0), ((PyASCIIObject *)(*callresult))->state.kind) <= ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2818, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2818, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2818, "PyUnicode_KIND(*callresult) <= PyUnicode_KIND(string)") : (void)0);
                _PyUnicode_FastCopyCharacters(string, i, *callresult, 0, size);
                i += size;

                do { if ( --((PyObject*)(*callresult))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*callresult)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*callresult)))); } while (0);

                ++callresult;
                break;
            }
            case '%':
                do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(i++)] = (Py_UCS1)('%'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(i++)] = (Py_UCS2)('%'); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2828, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(i++)] = (Py_UCS4)('%'); } } } while (0);
                break;
            default:
            {
                Py_ssize_t len = strlen(p);
                unicode_write_cstr(string, i, p, len);
                i += len;
                (__builtin_expect(!(i == ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2835, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2835, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2835, "i == PyUnicode_GET_LENGTH(string)") : (void)0);
                goto end;
            }
            }
        }
        else {
            (__builtin_expect(!(i < ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2841, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2841, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2841, "i < PyUnicode_GET_LENGTH(string)") : (void)0);
            do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(i++)] = (Py_UCS1)(*f); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(i++)] = (Py_UCS2)(*f); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2842, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(i++)] = (Py_UCS4)(*f); } } } while (0);
        }
    }
    (__builtin_expect(!(i == ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2845, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2845, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2845, "i == PyUnicode_GET_LENGTH(string)") : (void)0);

  end:
    if (callresults)
        PyObject_Free(callresults);
    if (numberresults)
        PyObject_Free(numberresults);
    return unicode_result(string);
  fail:
    if (callresults) {
        PyObject **callresult2 = callresults;
        while (callresult2 < callresult) {
            do { if ((*callresult2) == ((void *)0)) ; else do { if ( --((PyObject*)(*callresult2))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*callresult2)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*callresult2)))); } while (0); } while (0);
            ++callresult2;
        }
        PyObject_Free(callresults);
    }
    if (numberresults)
        PyObject_Free(numberresults);
    return ((void *)0);
}

PyObject *
PyUnicode_FromFormat(const char *format, ...)
{
    PyObject* ret;
    va_list vargs;


    __builtin_va_start(vargs,format);



    ret = PyUnicode_FromFormatV(format, vargs);
    __builtin_va_end(vargs);
    return ret;
}
# 2894 "unicodeobject.c"
static Py_ssize_t
unicode_aswidechar(PyObject *unicode,
                   wchar_t *w,
                   Py_ssize_t size)
{
    Py_ssize_t res;
    const wchar_t *wstr;

    wstr = PyUnicode_AsUnicodeAndSize(unicode, &res);
    if (wstr == ((void *)0))
        return -1;

    if (w != ((void *)0)) {
        if (size > res)
            size = res + 1;
        else
            res = size;
        ((__builtin_object_size (w, 0) != (size_t) -1) ? __builtin___memcpy_chk (w, wstr, size * sizeof(wchar_t), __builtin_object_size (w, 0)) : __inline_memcpy_chk (w, wstr, size * sizeof(wchar_t)));
        return res;
    }
    else
        return res + 1;
}

Py_ssize_t
PyUnicode_AsWideChar(PyObject *unicode,
                     wchar_t *w,
                     Py_ssize_t size)
{
    if (unicode == ((void *)0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 2924);
        return -1;
    }
    return unicode_aswidechar(unicode, w, size);
}

wchar_t*
PyUnicode_AsWideCharString(PyObject *unicode,
                           Py_ssize_t *size)
{
    wchar_t* buffer;
    Py_ssize_t buflen;

    if (unicode == ((void *)0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 2938);
        return ((void *)0);
    }

    buflen = unicode_aswidechar(unicode, ((void *)0), 0);
    if (buflen == -1)
        return ((void *)0);
    if (((Py_ssize_t)(((size_t)-1)>>1)) / sizeof(wchar_t) < buflen) {
        PyErr_NoMemory();
        return ((void *)0);
    }

    buffer = ((size_t)(buflen * sizeof(wchar_t)) > (size_t)((Py_ssize_t)(((size_t)-1)>>1)) ? ((void *)0) : malloc((buflen * sizeof(wchar_t)) ? (buflen * sizeof(wchar_t)) : 1));
    if (buffer == ((void *)0)) {
        PyErr_NoMemory();
        return ((void *)0);
    }
    buflen = unicode_aswidechar(unicode, buffer, buflen);
    if (buflen == -1) {
        free(buffer);
        return ((void *)0);
    }
    if (size != ((void *)0))
        *size = buflen;
    return buffer;
}



PyObject *
PyUnicode_FromOrdinal(int ordinal)
{
    PyObject *v;
    if (ordinal < 0 || ordinal > 0x10ffff) {
        PyErr_SetString(PyExc_ValueError,
                        "chr() arg not in range(0x110000)");
        return ((void *)0);
    }

    if ((Py_UCS4)ordinal < 256)
        return get_latin1_char((unsigned char)ordinal);

    v = PyUnicode_New(1, ordinal);
    if (v == ((void *)0))
        return ((void *)0);
    do { switch ((((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind))) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (((PyASCIIObject*)(v))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? ((void*)((PyASCIIObject*)(v) + 1)) : ((void*)((PyCompactUnicodeObject*)(v) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(v))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "((PyUnicodeObject*)(v))->data.any") : (void)0), ((((PyUnicodeObject *)(v))->data.any))))))[(0)] = (Py_UCS1)(ordinal); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (((PyASCIIObject*)(v))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? ((void*)((PyASCIIObject*)(v) + 1)) : ((void*)((PyCompactUnicodeObject*)(v) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(v))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "((PyUnicodeObject*)(v))->data.any") : (void)0), ((((PyUnicodeObject *)(v))->data.any))))))[(0)] = (Py_UCS2)(ordinal); break; } default: { (__builtin_expect(!((((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind)) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "(((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 2983, \"PyUnicode_Check(v)\") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 2983, \"PyUnicode_IS_READY(v)\") : (void)0), ((PyASCIIObject *)(v))->state.kind)) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (((PyASCIIObject*)(v))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? ((void*)((PyASCIIObject*)(v) + 1)) : ((void*)((PyCompactUnicodeObject*)(v) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(v))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2983, "((PyUnicodeObject*)(v))->data.any") : (void)0), ((((PyUnicodeObject *)(v))->data.any))))))[(0)] = (Py_UCS4)(ordinal); } } } while (0);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(v, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2984, "_PyUnicode_CheckConsistency(v, 1)") : (void)0);
    return v;
}

PyObject *
PyUnicode_FromObject(register PyObject *obj)
{


    if (((((PyObject*)(obj))->ob_type) == &PyUnicode_Type)) {
        if (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 2994, "_PyUnicode_CHECK(obj)") : (void)0), ((((PyASCIIObject*)obj)->state.ready) ? 0 : _PyUnicode_Ready(obj))) == -1)
            return ((void *)0);
        ( ((PyObject*)(obj))->ob_refcnt++);
        return obj;
    }
    if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)) {


        return _PyUnicode_Copy(obj);
    }
    PyErr_Format(PyExc_TypeError,
                 "Can't convert '%.100s' object to str implicitly",
                 (((PyObject*)(obj))->ob_type)->tp_name);
    return ((void *)0);
}

PyObject *
PyUnicode_FromEncodedObject(register PyObject *obj,
                            const char *encoding,
                            const char *errors)
{
    Py_buffer buffer;
    PyObject *v;

    if (obj == ((void *)0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 3019);
        return ((void *)0);
    }


    if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<27))) != 0)) {
        if (((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3025, "PyBytes_Check(obj)") : (void)0),(((PyVarObject*)(obj))->ob_size)) == 0)
            do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3026, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
        v = PyUnicode_Decode(
                ((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3028, "PyBytes_Check(obj)") : (void)0), (((PyBytesObject *)(obj))->ob_sval)), ((__builtin_expect(!(((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3028, "PyBytes_Check(obj)") : (void)0),(((PyVarObject*)(obj))->ob_size)),
                encoding, errors);
        return v;
    }

    if (((((((PyObject*)(obj))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_SetString(PyExc_TypeError,
                        "decoding str is not supported");
        return ((void *)0);
    }


    if (PyObject_GetBuffer(obj, &buffer, 0) < 0) {
        PyErr_Format(PyExc_TypeError,
                     "coercing to str: need bytes, bytearray "
                     "or buffer-like object, %.80s found",
                     (((PyObject*)(obj))->ob_type)->tp_name);
        return ((void *)0);
    }

    if (buffer.len == 0) {
        PyBuffer_Release(&buffer);
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3050, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    }

    v = PyUnicode_Decode((char*) buffer.buf, buffer.len, encoding, errors);
    PyBuffer_Release(&buffer);
    return v;
}




int
_Py_normalize_encoding(const char *encoding,
                   char *lower,
                   size_t lower_len)
{
    const char *e;
    char *l;
    char *l_end;

    if (encoding == ((void *)0)) {
        ((__builtin_object_size (lower, 0) != (size_t) -1) ? __builtin___strcpy_chk (lower, "utf-8", __builtin_object_size (lower, 2 > 1)) : __inline_strcpy_chk (lower, "utf-8"));
        return 1;
    }
    e = encoding;
    l = lower;
    l_end = &lower[lower_len - 1];
    while (*e) {
        if (l == l_end)
            return 0;
        if ((_Py_ctype_table[((unsigned char)((*e) & 0xff))] & 0x02)) {
            *l++ = (_Py_ctype_tolower[((unsigned char)((*e++) & 0xff))]);
        }
        else if (*e == '_') {
            *l++ = '-';
            e++;
        }
        else {
            *l++ = *e++;
        }
    }
    *l = '\0';
    return 1;
}

PyObject *
PyUnicode_Decode(const char *s,
                 Py_ssize_t size,
                 const char *encoding,
                 const char *errors)
{
    PyObject *buffer = ((void *)0), *unicode;
    Py_buffer info;
    char lower[11];


    if (_Py_normalize_encoding(encoding, lower, sizeof(lower))) {
        if ((strcmp(lower, "utf-8") == 0) ||
            (strcmp(lower, "utf8") == 0))
            return PyUnicode_DecodeUTF8Stateful(s, size, errors, ((void *)0));
        else if ((strcmp(lower, "latin-1") == 0) ||
                 (strcmp(lower, "latin1") == 0) ||
                 (strcmp(lower, "iso-8859-1") == 0))
            return PyUnicode_DecodeLatin1(s, size, errors);




        else if (strcmp(lower, "ascii") == 0)
            return PyUnicode_DecodeASCII(s, size, errors);
        else if (strcmp(lower, "utf-16") == 0)
            return PyUnicode_DecodeUTF16(s, size, errors, 0);
        else if (strcmp(lower, "utf-32") == 0)
            return PyUnicode_DecodeUTF32(s, size, errors, 0);
    }


    buffer = ((void *)0);
    if (PyBuffer_FillInfo(&info, ((void *)0), (void *)s, size, 1, ((0x0100 | (0x0010 | 0x0008)) | 0x0004)) < 0)
        goto onError;
    buffer = PyMemoryView_FromBuffer(&info);
    if (buffer == ((void *)0))
        goto onError;
    unicode = PyCodec_Decode(buffer, encoding, errors);
    if (unicode == ((void *)0))
        goto onError;
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_Format(PyExc_TypeError,
                     "decoder did not return a str object (type=%.400s)",
                     (((PyObject*)(unicode))->ob_type)->tp_name);
        do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
        goto onError;
    }
    do { if ( --((PyObject*)(buffer))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(buffer)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(buffer)))); } while (0);
    return unicode_result(unicode);

  onError:
    do { if ((buffer) == ((void *)0)) ; else do { if ( --((PyObject*)(buffer))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(buffer)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(buffer)))); } while (0); } while (0);
    return ((void *)0);
}

PyObject *
PyUnicode_AsDecodedObject(PyObject *unicode,
                          const char *encoding,
                          const char *errors)
{
    PyObject *v;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        goto onError;
    }

    if (encoding == ((void *)0))
        encoding = PyUnicode_GetDefaultEncoding();


    v = PyCodec_Decode(unicode, encoding, errors);
    if (v == ((void *)0))
        goto onError;
    return unicode_result(v);

  onError:
    return ((void *)0);
}

PyObject *
PyUnicode_AsDecodedUnicode(PyObject *unicode,
                           const char *encoding,
                           const char *errors)
{
    PyObject *v;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        goto onError;
    }

    if (encoding == ((void *)0))
        encoding = PyUnicode_GetDefaultEncoding();


    v = PyCodec_Decode(unicode, encoding, errors);
    if (v == ((void *)0))
        goto onError;
    if (!((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_Format(PyExc_TypeError,
                     "decoder did not return a str object (type=%.400s)",
                     (((PyObject*)(v))->ob_type)->tp_name);
        do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0);
        goto onError;
    }
    return unicode_result(v);

  onError:
    return ((void *)0);
}

PyObject *
PyUnicode_Encode(const Py_UNICODE *s,
                 Py_ssize_t size,
                 const char *encoding,
                 const char *errors)
{
    PyObject *v, *unicode;

    unicode = PyUnicode_FromUnicode(s, size);
    if (unicode == ((void *)0))
        return ((void *)0);
    v = PyUnicode_AsEncodedString(unicode, encoding, errors);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return v;
}

PyObject *
PyUnicode_AsEncodedObject(PyObject *unicode,
                          const char *encoding,
                          const char *errors)
{
    PyObject *v;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        goto onError;
    }

    if (encoding == ((void *)0))
        encoding = PyUnicode_GetDefaultEncoding();


    v = PyCodec_Encode(unicode, encoding, errors);
    if (v == ((void *)0))
        goto onError;
    return v;

  onError:
    return ((void *)0);
}

static size_t
wcstombs_errorpos(const wchar_t *wstr)
{
    size_t len;



    wchar_t buf[2];

    char outbuf[6];
    const wchar_t *start, *previous;




    buf[1] = 0;

    start = wstr;
    while (*wstr != L'\0')
    {
        previous = wstr;
# 3284 "unicodeobject.c"
        buf[0] = *wstr;
        wstr++;

        len = wcstombs(outbuf, buf, sizeof(outbuf));
        if (len == (size_t)-1)
            return previous - start;
    }


    return 0;
}

static int
locale_error_handler(const char *errors, int *surrogateescape)
{
    if (errors == ((void *)0)) {
        *surrogateescape = 0;
        return 0;
    }

    if (strcmp(errors, "strict") == 0) {
        *surrogateescape = 0;
        return 0;
    }
    if (strcmp(errors, "surrogateescape") == 0) {
        *surrogateescape = 1;
        return 0;
    }
    PyErr_Format(PyExc_ValueError,
                 "only 'strict' and 'surrogateescape' error handlers "
                 "are supported, not '%s'",
                 errors);
    return -1;
}

PyObject *
PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
{
    Py_ssize_t wlen, wlen2;
    wchar_t *wstr;
    PyObject *bytes = ((void *)0);
    char *errmsg;
    PyObject *reason;
    PyObject *exc;
    size_t error_pos;
    int surrogateescape;

    if (locale_error_handler(errors, &surrogateescape) < 0)
        return ((void *)0);

    wstr = PyUnicode_AsWideCharString(unicode, &wlen);
    if (wstr == ((void *)0))
        return ((void *)0);

    wlen2 = wcslen(wstr);
    if (wlen2 != wlen) {
        PyMem_Free(wstr);
        PyErr_SetString(PyExc_TypeError, "embedded null character");
        return ((void *)0);
    }

    if (surrogateescape) {

        char *str;

        str = _Py_wchar2char(wstr, &error_pos);
        if (str == ((void *)0)) {
            if (error_pos == (size_t)-1) {
                PyErr_NoMemory();
                PyMem_Free(wstr);
                return ((void *)0);
            }
            else {
                goto encode_error;
            }
        }
        PyMem_Free(wstr);

        bytes = PyBytes_FromString(str);
        PyMem_Free(str);
    }
    else {
        size_t len, len2;

        len = wcstombs(((void *)0), wstr, 0);
        if (len == (size_t)-1) {
            error_pos = (size_t)-1;
            goto encode_error;
        }

        bytes = PyBytes_FromStringAndSize(((void *)0), len);
        if (bytes == ((void *)0)) {
            PyMem_Free(wstr);
            return ((void *)0);
        }

        len2 = wcstombs(((__builtin_expect(!(((((((PyObject*)(bytes))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3380, "PyBytes_Check(bytes)") : (void)0), (((PyBytesObject *)(bytes))->ob_sval)), wstr, len+1);
        if (len2 == (size_t)-1 || len2 > len) {
            error_pos = (size_t)-1;
            goto encode_error;
        }
        PyMem_Free(wstr);
    }
    return bytes;

encode_error:
    errmsg = strerror((*__error()));
    (__builtin_expect(!(errmsg != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3391, "errmsg != NULL") : (void)0);

    if (error_pos == (size_t)-1)
        error_pos = wcstombs_errorpos(wstr);

    PyMem_Free(wstr);
    do { if ((bytes) == ((void *)0)) ; else do { if ( --((PyObject*)(bytes))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(bytes)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(bytes)))); } while (0); } while (0);

    if (errmsg != ((void *)0)) {
        size_t errlen;
        wstr = _Py_char2wchar(errmsg, &errlen);
        if (wstr != ((void *)0)) {
            reason = PyUnicode_FromWideChar(wstr, errlen);
            PyMem_Free(wstr);
        } else
            errmsg = ((void *)0);
    }
    if (errmsg == ((void *)0))
        reason = PyUnicode_FromString(
            "wcstombs() encountered an unencodable "
            "wide character");
    if (reason == ((void *)0))
        return ((void *)0);

    exc = _PyObject_CallFunction_SizeT(PyExc_UnicodeEncodeError, "sOnnO",
                                "locale", unicode,
                                (Py_ssize_t)error_pos,
                                (Py_ssize_t)(error_pos+1),
                                reason);
    do { if ( --((PyObject*)(reason))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(reason)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(reason)))); } while (0);
    if (exc != ((void *)0)) {
        PyCodec_StrictErrors(exc);
        do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    }
    return ((void *)0);
}

PyObject *
PyUnicode_EncodeFSDefault(PyObject *unicode)
{



    return _PyUnicode_AsUTF8String(unicode, "surrogateescape");
# 3455 "unicodeobject.c"
}

PyObject *
PyUnicode_AsEncodedString(PyObject *unicode,
                          const char *encoding,
                          const char *errors)
{
    PyObject *v;
    char lower[11];

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }


    if (_Py_normalize_encoding(encoding, lower, sizeof(lower))) {
        if ((strcmp(lower, "utf-8") == 0) ||
            (strcmp(lower, "utf8") == 0))
        {
            if (errors == ((void *)0) || strcmp(errors, "strict") == 0)
                return _PyUnicode_AsUTF8String(unicode, ((void *)0));
            else
                return _PyUnicode_AsUTF8String(unicode, errors);
        }
        else if ((strcmp(lower, "latin-1") == 0) ||
                 (strcmp(lower, "latin1") == 0) ||
                 (strcmp(lower, "iso-8859-1") == 0))
            return _PyUnicode_AsLatin1String(unicode, errors);




        else if (strcmp(lower, "ascii") == 0)
            return _PyUnicode_AsASCIIString(unicode, errors);
    }


    v = PyCodec_Encode(unicode, encoding, errors);
    if (v == ((void *)0))
        return ((void *)0);


    if (((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<27))) != 0))
        return v;


    if (((((PyObject*)(v))->ob_type) == (&PyByteArray_Type) || PyType_IsSubtype((((PyObject*)(v))->ob_type), (&PyByteArray_Type)))) {
        int error;
        PyObject *b;

        error = PyErr_WarnFormat(PyExc_RuntimeWarning, 1,
            "encoder %s returned bytearray instead of bytes",
            encoding);
        if (error) {
            do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0);
            return ((void *)0);
        }

        b = PyBytes_FromStringAndSize(((__builtin_expect(!(((((PyObject*)(v))->ob_type) == (&PyByteArray_Type) || PyType_IsSubtype((((PyObject*)(v))->ob_type), (&PyByteArray_Type)))), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3514, "PyByteArray_Check(v)") : (void)0), (((PyVarObject*)(v))->ob_size) ? ((PyByteArrayObject *)(v))->ob_bytes : _PyByteArray_empty_string), (((PyVarObject*)(v))->ob_size));
        do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0);
        return b;
    }

    PyErr_Format(PyExc_TypeError,
                 "encoder did not return a bytes object (type=%.400s)",
                 (((PyObject*)(v))->ob_type)->tp_name);
    do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0);
    return ((void *)0);
}

PyObject *
PyUnicode_AsEncodedUnicode(PyObject *unicode,
                           const char *encoding,
                           const char *errors)
{
    PyObject *v;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        goto onError;
    }

    if (encoding == ((void *)0))
        encoding = PyUnicode_GetDefaultEncoding();


    v = PyCodec_Encode(unicode, encoding, errors);
    if (v == ((void *)0))
        goto onError;
    if (!((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_Format(PyExc_TypeError,
                     "encoder did not return an str object (type=%.400s)",
                     (((PyObject*)(v))->ob_type)->tp_name);
        do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0);
        goto onError;
    }
    return v;

  onError:
    return ((void *)0);
}

static size_t
mbstowcs_errorpos(const char *str, size_t len)
{

    const char *start = str;
    mbstate_t mbs;
    size_t converted;
    wchar_t ch;

    ((__builtin_object_size (&mbs, 0) != (size_t) -1) ? __builtin___memset_chk (&mbs, 0, sizeof mbs, __builtin_object_size (&mbs, 0)) : __inline_memset_chk (&mbs, 0, sizeof mbs));
    while (len)
    {
        converted = mbrtowc(&ch, (char*)str, len, &mbs);
        if (converted == 0)

            break;
        if (converted == (size_t)-1 || converted == (size_t)-2) {

            return str - start;
        }
        else {
            str += converted;
            len -= converted;
        }
    }

    return 0;

    return 0;
}

PyObject*
PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len,
                              const char *errors)
{
    wchar_t smallbuf[256];
    size_t smallbuf_len = (sizeof(smallbuf) / sizeof((smallbuf)[0]) + (sizeof(char [1 - 2*!(!__builtin_types_compatible_p(typeof(smallbuf), typeof(&(smallbuf)[0])))]) - 1));
    wchar_t *wstr;
    size_t wlen, wlen2;
    PyObject *unicode;
    int surrogateescape;
    size_t error_pos;
    char *errmsg;
    PyObject *reason, *exc;

    if (locale_error_handler(errors, &surrogateescape) < 0)
        return ((void *)0);

    if (str[len] != '\0' || len != strlen(str)) {
        PyErr_SetString(PyExc_TypeError, "embedded null character");
        return ((void *)0);
    }

    if (surrogateescape)
    {
        wstr = _Py_char2wchar(str, &wlen);
        if (wstr == ((void *)0)) {
            if (wlen == (size_t)-1)
                PyErr_NoMemory();
            else
                PyErr_SetFromErrno(PyExc_OSError);
            return ((void *)0);
        }

        unicode = PyUnicode_FromWideChar(wstr, wlen);
        PyMem_Free(wstr);
    }
    else {

        wlen = mbstowcs(((void *)0), str, 0);



        if (wlen == (size_t)-1)
            goto decode_error;
        if (wlen+1 <= smallbuf_len) {
            wstr = smallbuf;
        }
        else {
            if (wlen > ((Py_ssize_t)(((size_t)-1)>>1)) / sizeof(wchar_t) - 1)
                return PyErr_NoMemory();

            wstr = PyMem_Malloc((wlen+1) * sizeof(wchar_t));
            if (!wstr)
                return PyErr_NoMemory();
        }


        wlen2 = mbstowcs(wstr, str, wlen+1);
        if (wlen2 == (size_t)-1) {
            if (wstr != smallbuf)
                PyMem_Free(wstr);
            goto decode_error;
        }



        unicode = PyUnicode_FromWideChar(wstr, wlen2);
        if (wstr != smallbuf)
            PyMem_Free(wstr);
    }
    return unicode;

decode_error:
    errmsg = strerror((*__error()));
    (__builtin_expect(!(errmsg != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3663, "errmsg != NULL") : (void)0);

    error_pos = mbstowcs_errorpos(str, len);
    if (errmsg != ((void *)0)) {
        size_t errlen;
        wstr = _Py_char2wchar(errmsg, &errlen);
        if (wstr != ((void *)0)) {
            reason = PyUnicode_FromWideChar(wstr, errlen);
            PyMem_Free(wstr);
        } else
            errmsg = ((void *)0);
    }
    if (errmsg == ((void *)0))
        reason = PyUnicode_FromString(
            "mbstowcs() encountered an invalid multibyte sequence");
    if (reason == ((void *)0))
        return ((void *)0);

    exc = _PyObject_CallFunction_SizeT(PyExc_UnicodeDecodeError, "sy#nnO",
                                "locale", str, len,
                                (Py_ssize_t)error_pos,
                                (Py_ssize_t)(error_pos+1),
                                reason);
    do { if ( --((PyObject*)(reason))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(reason)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(reason)))); } while (0);
    if (exc != ((void *)0)) {
        PyCodec_StrictErrors(exc);
        do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    }
    return ((void *)0);
}

PyObject*
PyUnicode_DecodeLocale(const char *str, const char *errors)
{
    Py_ssize_t size = (Py_ssize_t)strlen(str);
    return PyUnicode_DecodeLocaleAndSize(str, size, errors);
}


PyObject*
PyUnicode_DecodeFSDefault(const char *s) {
    Py_ssize_t size = (Py_ssize_t)strlen(s);
    return PyUnicode_DecodeFSDefaultAndSize(s, size);
}

PyObject*
PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
{



    return PyUnicode_DecodeUTF8Stateful(s, size, "surrogateescape", ((void *)0));
# 3735 "unicodeobject.c"
}


int
_PyUnicode_HasNULChars(PyObject* s)
{
    static PyObject *nul = ((void *)0);

    if (nul == ((void *)0))
        nul = PyUnicode_FromStringAndSize("\0", 1);
    if (nul == ((void *)0))
        return -1;
    return PyUnicode_Contains(s, nul);
}


int
PyUnicode_FSConverter(PyObject* arg, void* addr)
{
    PyObject *output = ((void *)0);
    Py_ssize_t size;
    void *data;
    if (arg == ((void *)0)) {
        do { if ( --((PyObject*)(*(PyObject**)addr))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*(PyObject**)addr)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*(PyObject**)addr)))); } while (0);
        return 1;
    }
    if (((((((PyObject*)(arg))->ob_type))->tp_flags & ((1L<<27))) != 0)) {
        output = arg;
        ( ((PyObject*)(output))->ob_refcnt++);
    }
    else {
        arg = PyUnicode_FromObject(arg);
        if (!arg)
            return 0;
        output = PyUnicode_EncodeFSDefault(arg);
        do { if ( --((PyObject*)(arg))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(arg)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(arg)))); } while (0);
        if (!output)
            return 0;
        if (!((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<27))) != 0)) {
            do { if ( --((PyObject*)(output))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(output)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(output)))); } while (0);
            PyErr_SetString(PyExc_TypeError, "encoder failed to return bytes");
            return 0;
        }
    }
    size = ((__builtin_expect(!(((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3779, "PyBytes_Check(output)") : (void)0),(((PyVarObject*)(output))->ob_size));
    data = ((__builtin_expect(!(((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3780, "PyBytes_Check(output)") : (void)0), (((PyBytesObject *)(output))->ob_sval));
    if (size != strlen(data)) {
        PyErr_SetString(PyExc_TypeError, "embedded NUL character");
        do { if ( --((PyObject*)(output))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(output)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(output)))); } while (0);
        return 0;
    }
    *(PyObject**)addr = output;
    return 0x20000;
}


int
PyUnicode_FSDecoder(PyObject* arg, void* addr)
{
    PyObject *output = ((void *)0);
    if (arg == ((void *)0)) {
        do { if ( --((PyObject*)(*(PyObject**)addr))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*(PyObject**)addr)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*(PyObject**)addr)))); } while (0);
        return 1;
    }
    if (((((((PyObject*)(arg))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        if (((__builtin_expect(!(((((((PyObject*)(arg))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3800, "_PyUnicode_CHECK(arg)") : (void)0), ((((PyASCIIObject*)arg)->state.ready) ? 0 : _PyUnicode_Ready(arg))) == -1)
            return 0;
        output = arg;
        ( ((PyObject*)(output))->ob_refcnt++);
    }
    else {
        arg = PyBytes_FromObject(arg);
        if (!arg)
            return 0;
        output = PyUnicode_DecodeFSDefaultAndSize(((__builtin_expect(!(((((((PyObject*)(arg))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3809, "PyBytes_Check(arg)") : (void)0), (((PyBytesObject *)(arg))->ob_sval)),
                                                  ((__builtin_expect(!(((((((PyObject*)(arg))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3810, "PyBytes_Check(arg)") : (void)0),(((PyVarObject*)(arg))->ob_size)));
        do { if ( --((PyObject*)(arg))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(arg)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(arg)))); } while (0);
        if (!output)
            return 0;
        if (!((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
            do { if ( --((PyObject*)(output))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(output)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(output)))); } while (0);
            PyErr_SetString(PyExc_TypeError, "decoder failed to return unicode");
            return 0;
        }
    }
    if (((__builtin_expect(!(((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3820, "_PyUnicode_CHECK(output)") : (void)0), ((((PyASCIIObject*)output)->state.ready) ? 0 : _PyUnicode_Ready(output))) == -1) {
        do { if ( --((PyObject*)(output))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(output)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(output)))); } while (0);
        return 0;
    }
    if (findchar(((__builtin_expect(!(((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3824, "PyUnicode_Check(output)") : (void)0), (((PyASCIIObject*)(output))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3824, "PyUnicode_Check(output)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)output)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3824, "PyUnicode_IS_READY(output)") : (void)0), ((PyASCIIObject*)output)->state.ascii) ? ((void*)((PyASCIIObject*)(output) + 1)) : ((void*)((PyCompactUnicodeObject*)(output) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(output))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3824, "((PyUnicodeObject*)(output))->data.any") : (void)0), ((((PyUnicodeObject *)(output))->data.any)))), ((__builtin_expect(!(((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3824, "PyUnicode_Check(output)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)output)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3824, "PyUnicode_IS_READY(output)") : (void)0), ((PyASCIIObject *)(output))->state.kind),
                 ((__builtin_expect(!(((((((PyObject*)(output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3825, "PyUnicode_Check(output)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)output)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3825, "PyUnicode_IS_READY(output)") : (void)0), ((PyASCIIObject *)(output))->length), 0, 1) >= 0) {
        PyErr_SetString(PyExc_TypeError, "embedded NUL character");
        do { if ( --((PyObject*)(output))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(output)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(output)))); } while (0);
        return 0;
    }
    *(PyObject**)addr = output;
    return 0x20000;
}


char*
PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *psize)
{
    PyObject *bytes;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3844, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3847, "_PyUnicode_CHECK(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3847, "PyUnicode_IS_READY(unicode)") : (void)0), (((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((char*)((PyASCIIObject*)(unicode) + 1)) : (((PyCompactUnicodeObject*)(unicode))->utf8)) == ((void *)0)) {
        (__builtin_expect(!(!(((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact))), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3848, "!PyUnicode_IS_COMPACT_ASCII(unicode)") : (void)0);
        bytes = _PyUnicode_AsUTF8String(unicode, "strict");
        if (bytes == ((void *)0))
            return ((void *)0);
        (((PyCompactUnicodeObject*)(unicode))->utf8) = PyObject_Malloc(((__builtin_expect(!(((((((PyObject*)(bytes))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3852, "PyBytes_Check(bytes)") : (void)0),(((PyVarObject*)(bytes))->ob_size)) + 1);
        if ((((PyCompactUnicodeObject*)(unicode))->utf8) == ((void *)0)) {
            do { if ( --((PyObject*)(bytes))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(bytes)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(bytes)))); } while (0);
            return ((void *)0);
        }
        (((PyCompactUnicodeObject*)(unicode))->utf8_length) = ((__builtin_expect(!(((((((PyObject*)(bytes))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3857, "PyBytes_Check(bytes)") : (void)0),(((PyVarObject*)(bytes))->ob_size));
        ((__builtin_object_size ((((PyCompactUnicodeObject*)(unicode))->utf8), 0) != (size_t) -1) ? __builtin___memcpy_chk ((((PyCompactUnicodeObject*)(unicode))->utf8), ((__builtin_expect(!(((((((PyObject*)(bytes))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3860, "PyBytes_Check(bytes)") : (void)0), (((PyBytesObject *)(bytes))->ob_sval)), (((PyCompactUnicodeObject*)(unicode))->utf8_length) + 1, __builtin_object_size ((((PyCompactUnicodeObject*)(unicode))->utf8), 0)) : __inline_memcpy_chk ((((PyCompactUnicodeObject*)(unicode))->utf8), ((__builtin_expect(!(((((((PyObject*)(bytes))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3860, "PyBytes_Check(bytes)") : (void)0), (((PyBytesObject *)(bytes))->ob_sval)), (((PyCompactUnicodeObject*)(unicode))->utf8_length) + 1));


        do { if ( --((PyObject*)(bytes))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(bytes)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(bytes)))); } while (0);
    }

    if (psize)
        *psize = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3865, "_PyUnicode_CHECK(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3865, "PyUnicode_IS_READY(unicode)") : (void)0), (((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((PyASCIIObject*)(unicode))->length : (((PyCompactUnicodeObject*)(unicode))->utf8_length));
    return ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3866, "_PyUnicode_CHECK(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3866, "PyUnicode_IS_READY(unicode)") : (void)0), (((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((char*)((PyASCIIObject*)(unicode) + 1)) : (((PyCompactUnicodeObject*)(unicode))->utf8));
}

char*
PyUnicode_AsUTF8(PyObject *unicode)
{
    return PyUnicode_AsUTF8AndSize(unicode, ((void *)0));
}

Py_UNICODE *
PyUnicode_AsUnicodeAndSize(PyObject *unicode, Py_ssize_t *size)
{
    const unsigned char *one_byte;

    const Py_UCS2 *two_bytes;





    wchar_t *w;
    wchar_t *wchar_end;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if ((((PyASCIIObject*)(unicode))->wstr) == ((void *)0)) {

        (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3895, "_PyUnicode_CHECK(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) != 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3895, "_PyUnicode_KIND(unicode) != 0") : (void)0);
        (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3896, "PyUnicode_IS_READY(unicode)") : (void)0);

        if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3898, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3898, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_4BYTE_KIND) {
# 3937 "unicodeobject.c"
            Py_FatalError("Impossible unicode object state, wstr and str "
                          "should share memory already.");
            return ((void *)0);

        }
        else {
            (((PyASCIIObject*)(unicode))->wstr) = (wchar_t *) PyObject_Malloc(sizeof(wchar_t) *
                                                  ((((PyASCIIObject *)(unicode))->length) + 1));
            if (!(((PyASCIIObject*)(unicode))->wstr)) {
                PyErr_NoMemory();
                return ((void *)0);
            }
            if (!(((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)))
                (((PyCompactUnicodeObject*)(unicode))->wstr_length) = (((PyASCIIObject *)(unicode))->length);
            w = (((PyASCIIObject*)(unicode))->wstr);
            wchar_end = w + (((PyASCIIObject *)(unicode))->length);

            if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3954, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3954, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND) {
                one_byte = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3955, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3955, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3955, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3955, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))));
                for (; w < wchar_end; ++one_byte, ++w)
                    *w = *one_byte;

                *w = 0;
            }
            else if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3961, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3961, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND) {

                two_bytes = ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3963, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3963, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3963, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3963, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))));
                for (; w < wchar_end; ++two_bytes, ++w)
                    *w = *two_bytes;

                *w = 0;
# 3976 "unicodeobject.c"
            }
            else {
                (__builtin_expect(!(0 && "This should never happen."), 0) ? __assert_rtn(__func__, "unicodeobject.c", 3978, "0 && \"This should never happen.\"") : (void)0);
            }
        }
    }
    if (size != ((void *)0))
        *size = ((((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((PyASCIIObject*)unicode)->length : ((PyCompactUnicodeObject*)unicode)->wstr_length);
    return (((PyASCIIObject*)(unicode))->wstr);
}

Py_UNICODE *
PyUnicode_AsUnicode(PyObject *unicode)
{
    return PyUnicode_AsUnicodeAndSize(unicode, ((void *)0));
}


Py_ssize_t
PyUnicode_GetSize(PyObject *unicode)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        goto onError;
    }
    return ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4001, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject *)(unicode))->wstr) ? ((((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((PyASCIIObject*)unicode)->length : ((PyCompactUnicodeObject*)unicode)->wstr_length) : ((void)PyUnicode_AsUnicode((PyObject *)(unicode)), (__builtin_expect(!(((PyASCIIObject *)(unicode))->wstr), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4001, "((PyASCIIObject *)(unicode))->wstr") : (void)0), ((((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((PyASCIIObject*)unicode)->length : ((PyCompactUnicodeObject*)unicode)->wstr_length)));

  onError:
    return -1;
}

Py_ssize_t
PyUnicode_GetLength(PyObject *unicode)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return -1;
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4014, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return -1;
    return ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4016, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4016, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
}

Py_UCS4
PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0) || ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4022, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1) {
        PyErr_BadArgument();
        return (Py_UCS4)-1;
    }
    if (index < 0 || index >= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4026, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4026, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return (Py_UCS4)-1;
    }
    return ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_IS_READY(unicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(index)] : (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(index)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4030, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(index)] ) ));
}

int
PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 ch)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0) || !(((PyASCIIObject*)(unicode))->state.compact)) {
        PyErr_BadArgument();
        return -1;
    }
    (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4040, "PyUnicode_IS_READY(unicode)") : (void)0);
    if (index < 0 || index >= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4041, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4041, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return -1;
    }
    if (unicode_check_modifiable(unicode))
        return -1;
    if (ch > ((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4047, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4047, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4047, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4047, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4047, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4047, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4047, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))))) {
        PyErr_SetString(PyExc_ValueError, "character out of range");
        return -1;
    }
    do { switch ((((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind))) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))))[(index)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))))[(index)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 4052, \"PyUnicode_Check(unicode)\") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, \"unicodeobject.c\", 4052, \"PyUnicode_IS_READY(unicode)\") : (void)0), ((PyASCIIObject *)(unicode))->state.kind)) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4052, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))))[(index)] = (Py_UCS4)(ch); } } } while (0);

    return 0;
}

const char *
PyUnicode_GetDefaultEncoding(void)
{
    return "utf-8";
}


static void
make_decode_exception(PyObject **exceptionObject,
                      const char *encoding,
                      const char *input, Py_ssize_t length,
                      Py_ssize_t startpos, Py_ssize_t endpos,
                      const char *reason)
{
    if (*exceptionObject == ((void *)0)) {
        *exceptionObject = PyUnicodeDecodeError_Create(
            encoding, input, length, startpos, endpos, reason);
    }
    else {
        if (PyUnicodeDecodeError_SetStart(*exceptionObject, startpos))
            goto onError;
        if (PyUnicodeDecodeError_SetEnd(*exceptionObject, endpos))
            goto onError;
        if (PyUnicodeDecodeError_SetReason(*exceptionObject, reason))
            goto onError;
    }
    return;

onError:
    do { if ( --((PyObject*)(*exceptionObject))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*exceptionObject)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*exceptionObject)))); } while (0);
    *exceptionObject = ((void *)0);
}
# 4096 "unicodeobject.c"
static int
unicode_decode_call_errorhandler(const char *errors, PyObject **errorHandler,
                                 const char *encoding, const char *reason,
                                 const char **input, const char **inend, Py_ssize_t *startinpos,
                                 Py_ssize_t *endinpos, PyObject **exceptionObject, const char **inptr,
                                 PyObject **output, Py_ssize_t *outpos)
{
    static char *argparse = "O!n;decoding error handler must return (str, int) tuple";

    PyObject *restuple = ((void *)0);
    PyObject *repunicode = ((void *)0);
    Py_ssize_t outsize;
    Py_ssize_t insize;
    Py_ssize_t requiredsize;
    Py_ssize_t newpos;
    PyObject *inputobj = ((void *)0);
    int res = -1;

    if (((__builtin_expect(!(((((((PyObject*)(*output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4114, "_PyUnicode_CHECK(*output)") : (void)0), ((PyASCIIObject *)(*output))->state.kind) != PyUnicode_WCHAR_KIND)
        outsize = ((__builtin_expect(!(((((((PyObject*)(*output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4115, "PyUnicode_Check(*output)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*output)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4115, "PyUnicode_IS_READY(*output)") : (void)0), ((PyASCIIObject *)(*output))->length);
    else
        outsize = (((PyCompactUnicodeObject*)(*output))->wstr_length);

    if (*errorHandler == ((void *)0)) {
        *errorHandler = PyCodec_LookupError(errors);
        if (*errorHandler == ((void *)0))
            goto onError;
    }

    make_decode_exception(exceptionObject,
        encoding,
        *input, *inend - *input,
        *startinpos, *endinpos,
        reason);
    if (*exceptionObject == ((void *)0))
        goto onError;

    restuple = PyObject_CallFunctionObjArgs(*errorHandler, *exceptionObject, ((void *)0));
    if (restuple == ((void *)0))
        goto onError;
    if (!((((((PyObject*)(restuple))->ob_type))->tp_flags & ((1L<<26))) != 0)) {
        PyErr_SetString(PyExc_TypeError, &argparse[4]);
        goto onError;
    }
    if (!_PyArg_ParseTuple_SizeT(restuple, argparse, &PyUnicode_Type, &repunicode, &newpos))
        goto onError;
    if (((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4142, "_PyUnicode_CHECK(repunicode)") : (void)0), ((((PyASCIIObject*)repunicode)->state.ready) ? 0 : _PyUnicode_Ready(repunicode))) == -1)
        goto onError;



    inputobj = PyUnicodeDecodeError_GetObject(*exceptionObject);
    if (!inputobj)
        goto onError;
    if (!((((((PyObject*)(inputobj))->ob_type))->tp_flags & ((1L<<27))) != 0)) {
        PyErr_Format(PyExc_TypeError, "exception attribute object must be bytes");
    }
    *input = ((__builtin_expect(!(((((((PyObject*)(inputobj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4153, "PyBytes_Check(inputobj)") : (void)0), (((PyBytesObject *)(inputobj))->ob_sval));
    insize = ((__builtin_expect(!(((((((PyObject*)(inputobj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4154, "PyBytes_Check(inputobj)") : (void)0),(((PyVarObject*)(inputobj))->ob_size));
    *inend = *input + insize;


    do { if ( --((PyObject*)(inputobj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(inputobj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(inputobj)))); } while (0);

    if (newpos<0)
        newpos = insize+newpos;
    if (newpos<0 || newpos>insize) {
        PyErr_Format(PyExc_IndexError, "position %zd from error handler out of bounds", newpos);
        goto onError;
    }

    if (((__builtin_expect(!(((((((PyObject*)(*output))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4167, "_PyUnicode_CHECK(*output)") : (void)0), ((PyASCIIObject *)(*output))->state.kind) != PyUnicode_WCHAR_KIND) {




        Py_ssize_t replen = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4172, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4172, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject *)(repunicode))->length);
        requiredsize = *outpos + replen + insize-newpos;
        if (requiredsize > outsize) {
            if (requiredsize<2*outsize)
                requiredsize = 2*outsize;
            if (unicode_resize(output, requiredsize) < 0)
                goto onError;
        }
        if (unicode_widen(output, *outpos,
                          ((__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4181, "PyUnicode_IS_READY(repunicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4181, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4181, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject*)repunicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4181, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4181, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject *)(repunicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4181, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4181, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject *)(repunicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))))) < 0)
            goto onError;
        _PyUnicode_FastCopyCharacters(*output, *outpos, repunicode, 0, replen);
        *outpos += replen;
    }
    else {
        wchar_t *repwstr;
        Py_ssize_t repwlen;
        repwstr = PyUnicode_AsUnicodeAndSize(repunicode, &repwlen);
        if (repwstr == ((void *)0))
            goto onError;




        requiredsize = *outpos + repwlen + insize-newpos;
        if (requiredsize > outsize) {
            if (requiredsize < 2*outsize)
                requiredsize = 2*outsize;
            if (unicode_resize(output, requiredsize) < 0)
                goto onError;
        }
        wcsncpy((((PyASCIIObject*)(*output))->wstr) + *outpos, repwstr, repwlen);
        *outpos += repwlen;
    }
    *endinpos = newpos;
    *inptr = *input + newpos;


    res = 0;

  onError:
    do { if ((restuple) == ((void *)0)) ; else do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0); } while (0);
    return res;
}
# 4266 "unicodeobject.c"
static
char utf7_category[128] = {

    3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 2, 3, 3,

    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,

    2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 3, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,

    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1, 1, 1,

    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 3, 3,
};
# 4298 "unicodeobject.c"
PyObject *
PyUnicode_DecodeUTF7(const char *s,
                     Py_ssize_t size,
                     const char *errors)
{
    return PyUnicode_DecodeUTF7Stateful(s, size, errors, ((void *)0));
}
# 4313 "unicodeobject.c"
PyObject *
PyUnicode_DecodeUTF7Stateful(const char *s,
                             Py_ssize_t size,
                             const char *errors,
                             Py_ssize_t *consumed)
{
    const char *starts = s;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    Py_ssize_t outpos;
    const char *e;
    PyObject *unicode;
    const char *errmsg = "";
    int inShift = 0;
    Py_ssize_t shiftOutStart;
    unsigned int base64bits = 0;
    unsigned long base64buffer = 0;
    Py_UCS4 surrogate = 0;
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);


    unicode = PyUnicode_New(size, 127);
    if (!unicode)
        return ((void *)0);
    if (size == 0) {
        if (consumed)
            *consumed = 0;
        return unicode;
    }

    shiftOutStart = outpos = 0;
    e = s + size;

    while (s < e) {
        Py_UCS4 ch;
      restart:
        ch = (unsigned char) *s;

        if (inShift) {
            if ((((ch) >= 'A' && (ch) <= 'Z') || ((ch) >= 'a' && (ch) <= 'z') || ((ch) >= '0' && (ch) <= '9') || (ch) == '+' || (ch) == '/')) {
                base64buffer = (base64buffer << 6) | (((ch) >= 'A' && (ch) <= 'Z') ? (ch) - 'A' : ((ch) >= 'a' && (ch) <= 'z') ? (ch) - 'a' + 26 : ((ch) >= '0' && (ch) <= '9') ? (ch) - '0' + 52 : (ch) == '+' ? 62 : 63);
                base64bits += 6;
                s++;
                if (base64bits >= 16) {

                    Py_UCS4 outCh = (Py_UCS4)(base64buffer >> (base64bits-16));
                    base64bits -= 16;
                    base64buffer &= (1 << base64bits) - 1;
                    if (surrogate) {

                        if ((0xDC00 <= outCh && outCh <= 0xDFFF)) {
                            Py_UCS4 ch2 = (((((Py_UCS4)(surrogate) & 0x03FF) << 10) | ((Py_UCS4)(outCh) & 0x03FF)) + 0x10000);
                            if (unicode_putchar(&unicode, &outpos, ch2) < 0)
                                goto onError;
                            surrogate = 0;
                            continue;
                        }
                        else {
                            if (unicode_putchar(&unicode, &outpos, surrogate) < 0)
                                goto onError;
                            surrogate = 0;
                        }
                    }
                    if ((0xD800 <= outCh && outCh <= 0xDBFF)) {

                        surrogate = outCh;
                    }
                    else {
                        if (unicode_putchar(&unicode, &outpos, outCh) < 0)
                            goto onError;
                    }
                }
            }
            else {
                inShift = 0;
                s++;
                if (surrogate) {
                    if (unicode_putchar(&unicode, &outpos, surrogate) < 0)
                        goto onError;
                    surrogate = 0;
                }
                if (base64bits > 0) {
                    if (base64bits >= 6) {

                        errmsg = "partial character in shift sequence";
                        goto utf7Error;
                    }
                    else {

                        if (base64buffer != 0) {
                            errmsg = "non-zero padding bits in shift sequence";
                            goto utf7Error;
                        }
                    }
                }
                if (ch != '-') {


                    if (unicode_putchar(&unicode, &outpos, ch) < 0)
                        goto onError;
                }
            }
        }
        else if ( ch == '+' ) {
            startinpos = s-starts;
            s++;
            if (s < e && *s == '-') {
                s++;
                if (unicode_putchar(&unicode, &outpos, '+') < 0)
                    goto onError;
            }
            else {
                inShift = 1;
                shiftOutStart = outpos;
                base64bits = 0;
            }
        }
        else if (((ch) <= 127 && (ch) != '+')) {
            if (unicode_putchar(&unicode, &outpos, ch) < 0)
                goto onError;
            s++;
        }
        else {
            startinpos = s-starts;
            s++;
            errmsg = "unexpected special character";
            goto utf7Error;
        }
        continue;
utf7Error:
        endinpos = s-starts;
        if (unicode_decode_call_errorhandler(
                errors, &errorHandler,
                "utf7", errmsg,
                &starts, &e, &startinpos, &endinpos, &exc, &s,
                &unicode, &outpos))
            goto onError;
    }



    if (inShift && !consumed) {

        if (surrogate ||
                (base64bits >= 6) ||
                (base64bits > 0 && base64buffer != 0)) {
            endinpos = size;
            if (unicode_decode_call_errorhandler(
                    errors, &errorHandler,
                    "utf7", "unterminated shift sequence",
                    &starts, &e, &startinpos, &endinpos, &exc, &s,
                    &unicode, &outpos))
                goto onError;
            if (s < e)
                goto restart;
        }
    }


    if (consumed) {
        if (inShift) {
            outpos = shiftOutStart;
            *consumed = startinpos;
        }
        else {
            *consumed = s-starts;
        }
    }

    if (unicode_resize(&unicode, outpos) < 0)
        goto onError;

    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return unicode_result(unicode);

  onError:
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return ((void *)0);
}


PyObject *
_PyUnicode_EncodeUTF7(PyObject *str,
                      int base64SetO,
                      int base64WhiteSpace,
                      const char *errors)
{
    int kind;
    void *data;
    Py_ssize_t len;
    PyObject *v;
    int inShift = 0;
    Py_ssize_t i;
    unsigned int base64bits = 0;
    unsigned long base64buffer = 0;
    char * out;
    char * start;

    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4515, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1)
        return ((void *)0);
    kind = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4517, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4517, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4518, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4518, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4518, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4518, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4519, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4519, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);

    if (len == 0)
        return PyBytes_FromStringAndSize(((void *)0), 0);


    if (len > ((Py_ssize_t)(((size_t)-1)>>1)) / 8)
        return PyErr_NoMemory();
    v = PyBytes_FromStringAndSize(((void *)0), len * 8);
    if (v == ((void *)0))
        return ((void *)0);

    start = out = ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4531, "PyBytes_Check(v)") : (void)0), (((PyBytesObject *)(v))->ob_sval));
    for (i = 0; i < len; ++i) {
        Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));

        if (inShift) {
            if (((ch) < 128 && (ch) > 0 && ((utf7_category[(ch)] == 0) || (!base64WhiteSpace && (utf7_category[(ch)] == 2)) || (!base64SetO && (utf7_category[(ch)] == 1))))) {

                if (base64bits) {
                    *out++ = ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(base64buffer << (6-base64bits)) & 0x3f]);
                    base64buffer = 0;
                    base64bits = 0;
                }
                inShift = 0;


                if ((((ch) >= 'A' && (ch) <= 'Z') || ((ch) >= 'a' && (ch) <= 'z') || ((ch) >= '0' && (ch) <= '9') || (ch) == '+' || (ch) == '/') || ch == '-') {
                    *out++ = '-';
                }
                *out++ = (char) ch;
            }
            else {
                goto encode_char;
            }
        }
        else {
            if (ch == '+') {
                *out++ = '+';
                        *out++ = '-';
            }
            else if (((ch) < 128 && (ch) > 0 && ((utf7_category[(ch)] == 0) || (!base64WhiteSpace && (utf7_category[(ch)] == 2)) || (!base64SetO && (utf7_category[(ch)] == 1))))) {
                *out++ = (char) ch;
            }
            else {
                *out++ = '+';
                inShift = 1;
                goto encode_char;
            }
        }
        continue;
encode_char:
        if (ch >= 0x10000) {
            (__builtin_expect(!(ch <= 0x10ffff), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4572, "ch <= MAX_UNICODE") : (void)0);


            base64bits += 16;
            base64buffer = (base64buffer << 16) | 0xd800 | ((ch-0x10000) >> 10);
            while (base64bits >= 6) {
                *out++ = ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(base64buffer >> (base64bits-6)) & 0x3f]);
                base64bits -= 6;
            }

            ch = (0xDC00 + ((ch) & 0x3FF));
        }
        base64bits += 16;
        base64buffer = (base64buffer << 16) | ch;
        while (base64bits >= 6) {
            *out++ = ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(base64buffer >> (base64bits-6)) & 0x3f]);
            base64bits -= 6;
        }
    }
    if (base64bits)
        *out++= ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(base64buffer << (6-base64bits)) & 0x3f]);
    if (inShift)
        *out++ = '-';
    if (_PyBytes_Resize(&v, out - start) < 0)
        return ((void *)0);
    return v;
}
PyObject *
PyUnicode_EncodeUTF7(const Py_UNICODE *s,
                     Py_ssize_t size,
                     int base64SetO,
                     int base64WhiteSpace,
                     const char *errors)
{
    PyObject *result;
    PyObject *tmp = PyUnicode_FromUnicode(s, size);
    if (tmp == ((void *)0))
        return ((void *)0);
    result = _PyUnicode_EncodeUTF7(tmp, base64SetO,
                                   base64WhiteSpace, errors);
    do { if ( --((PyObject*)(tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(tmp)))); } while (0);
    return result;
}
# 4624 "unicodeobject.c"
PyObject *
PyUnicode_DecodeUTF8(const char *s,
                     Py_ssize_t size,
                     const char *errors)
{
    return PyUnicode_DecodeUTF8Stateful(s, size, errors, ((void *)0));
}

# 1 "stringlib/asciilib.h" 1
# 4633 "unicodeobject.c" 2
# 1 "stringlib/codecs.h" 1
# 18 "stringlib/codecs.h"
static inline Py_UCS4
asciilib_utf8_decode(const char **inptr, const char *end,
                       Py_UCS1 *dest,
                       Py_ssize_t *outpos)
{
    Py_UCS4 ch;
    const char *s = *inptr;
    const char *aligned_end = (const char *) ((void *)((Py_uintptr_t)(end) & ~(Py_uintptr_t)((8) - 1)));
    Py_UCS1 *p = dest + *outpos;

    while (s < end) {
        ch = (unsigned char)*s;

        if (ch < 0x80) {







            if ((!((Py_uintptr_t)(s) & (Py_uintptr_t)((8) - 1)))) {

                register const char *_s = s;
                register Py_UCS1 *_p = p;
                while (_s < aligned_end) {



                    unsigned long value = *(unsigned long *) _s;
                    if (value & 0x8080808080808080UL)
                        break;

                    _p[0] = (Py_UCS1)(value & 0xFFu);
                    _p[1] = (Py_UCS1)((value >> 8) & 0xFFu);
                    _p[2] = (Py_UCS1)((value >> 16) & 0xFFu);
                    _p[3] = (Py_UCS1)((value >> 24) & 0xFFu);

                    _p[4] = (Py_UCS1)((value >> 32) & 0xFFu);
                    _p[5] = (Py_UCS1)((value >> 40) & 0xFFu);
                    _p[6] = (Py_UCS1)((value >> 48) & 0xFFu);
                    _p[7] = (Py_UCS1)((value >> 56) & 0xFFu);
# 78 "stringlib/codecs.h"
                    _s += 8;
                    _p += 8;
                }
                s = _s;
                p = _p;
                if (s == end)
                    break;
                ch = (unsigned char)*s;
            }
            if (ch < 0x80) {
                s++;
                *p++ = ch;
                continue;
            }
        }

        if (ch < 0xE0) {

            Py_UCS4 ch2;
            if (ch < 0xC2) {



                goto InvalidStart;
            }
            if (end - s < 2) {


                break;
            }
            ch2 = (unsigned char)s[1];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0))

                goto InvalidContinuation1;
            ch = (ch << 6) + ch2 -
                 ((0xC0 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x007F) && (ch <= 0x07FF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 114, "(ch > 0x007F) && (ch <= 0x07FF)") : (void)0);
            s += 2;
            if (0x7Fu <= 0x007F ||
                (0x7Fu < 0x07FF && ch > 0x7Fu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF0) {

            Py_UCS4 ch2, ch3;
            if (end - s < 3) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

                    goto InvalidContinuation1;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xE0) {
                if (ch2 < 0xA0)


                    goto InvalidContinuation1;
            } else if (ch == 0xED && ch2 >= 0xA0) {





                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            ch = (ch << 12) + (ch2 << 6) + ch3 -
                 ((0xE0 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x07FF) && (ch <= 0xFFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 164, "(ch > 0x07FF) && (ch <= 0xFFFF)") : (void)0);
            s += 3;
            if (0x7Fu <= 0x07FF ||
                (0x7Fu < 0xFFFF && ch > 0x7Fu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF5) {

            Py_UCS4 ch2, ch3, ch4;
            if (end - s < 4) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

                    goto InvalidContinuation1;
                if (end - s < 3)
                    break;
                ch3 = (unsigned char)s[2];
                if (!((ch3) >= 0x80 && (ch3) < 0xC0))
                    goto InvalidContinuation2;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            ch4 = (unsigned char)s[3];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xF0) {
                if (ch2 < 0x90)


                    goto InvalidContinuation1;
            } else if (ch == 0xF4 && ch2 >= 0x90) {


                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            if (!((ch4) >= 0x80 && (ch4) < 0xC0)) {

                goto InvalidContinuation3;
            }
            ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
                 ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0xFFFF) && (ch <= 0x10FFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 221, "(ch > 0xFFFF) && (ch <= 0x10FFFF)") : (void)0);
            s += 4;
            if (0x7Fu <= 0xFFFF ||
                (0x7Fu < 0x10FFFF && ch > 0x7Fu))

                goto Return;
            *p++ = ch;
            continue;
        }
        goto InvalidStart;
    }
    ch = 0;
Return:
    *inptr = s;
    *outpos = p - dest;
    return ch;
InvalidStart:
    ch = 1;
    goto Return;
InvalidContinuation1:
    ch = 2;
    goto Return;
InvalidContinuation2:
    ch = 3;
    goto Return;
InvalidContinuation3:
    ch = 4;
    goto Return;
}







static inline PyObject *
asciilib_utf8_encoder(PyObject *unicode,
                        Py_UCS1 *data,
                        Py_ssize_t size,
                        const char *errors)
{


    Py_ssize_t i;
    PyObject *result;
    char *p;
    Py_ssize_t nallocated;
    Py_ssize_t nneeded;






    const Py_ssize_t max_char_size = 2;
    char stackbuf[300 * 2];
# 286 "stringlib/codecs.h"
    (__builtin_expect(!(size >= 0), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 286, "size >= 0") : (void)0);

    if (size <= 300) {




        nallocated = (int)(sizeof(stackbuf));
        result = ((void *)0);
        p = stackbuf;
    }
    else {
        if (size > ((Py_ssize_t)(((size_t)-1)>>1)) / max_char_size) {

            return PyErr_NoMemory();
        }

        nallocated = size * max_char_size;
        result = PyBytes_FromStringAndSize(((void *)0), nallocated);
        if (result == ((void *)0))
            return ((void *)0);
        p = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 307, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
    }

    for (i = 0; i < size;) {
        Py_UCS4 ch = data[i++];

        if (ch < 0x80) {

            *p++ = (char) ch;

        }
        else



        {

            *p++ = (char)(0xc0 | (ch >> 6));
            *p++ = (char)(0x80 | (ch & 0x3f));
        }
# 417 "stringlib/codecs.h"
    }

    if (result == ((void *)0)) {

        nneeded = p - stackbuf;
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 422, "nneeded <= nallocated") : (void)0);
        result = PyBytes_FromStringAndSize(stackbuf, nneeded);
    }
    else {

        nneeded = p - ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 427, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 428, "nneeded <= nallocated") : (void)0);
        _PyBytes_Resize(&result, nneeded);
    }





    return result;
# 448 "stringlib/codecs.h"
}
# 478 "stringlib/codecs.h"
static inline Py_UCS4
asciilib_utf16_decode(const unsigned char **inptr, const unsigned char *e,
                        Py_UCS1 *dest, Py_ssize_t *outpos,
                        int native_ordering)
{
    Py_UCS4 ch;
    const unsigned char *aligned_end =
            (const unsigned char *) ((void *)((Py_uintptr_t)(e) & ~(Py_uintptr_t)((8) - 1)));
    const unsigned char *q = *inptr;
    Py_UCS1 *p = dest + *outpos;


    int ihi = !!native_ordering, ilo = !native_ordering;



    --e;

    while (q < e) {
        Py_UCS4 ch2;


        if ((!((Py_uintptr_t)(q) & (Py_uintptr_t)((8) - 1)))) {

            register const unsigned char *_q = q;
            while (_q < aligned_end) {
                unsigned long block = * (unsigned long *) _q;
                if (native_ordering) {

                    if (block & (0x0001000100010001ul * (0xFFFFu & ~0x7Fu)))
                        break;
                }
                else {

                    if (block & (((((0x0001000100010001ul * (0xFFFFu & ~0x7Fu))) >> 8) & (0x0001000100010001ul * 0x00FFu)) | ((((0x0001000100010001ul * (0xFFFFu & ~0x7Fu))) & (0x0001000100010001ul * 0x00FFu)) << 8)))
                        break;

                    block >>= 8;



                }





                p[0] = (Py_UCS1)(block & 0xFFFFu);
                p[1] = (Py_UCS1)((block >> 16) & 0xFFFFu);
                p[2] = (Py_UCS1)((block >> 32) & 0xFFFFu);
                p[3] = (Py_UCS1)(block >> 48);
# 541 "stringlib/codecs.h"
                _q += 8;
                p += 8 / 2;
            }
            q = _q;
            if (q >= e)
                break;
        }

        ch = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xD800 <= ch && ch <= 0xDFFF)) {

            if (ch > 0x7Fu)

                goto Return;

            *p++ = (Py_UCS1)ch;
            continue;
        }


        if (q >= e)
            goto UnexpectedEnd;
        if (!(0xD800 <= ch && ch <= 0xDBFF))
            goto IllegalEncoding;
        ch2 = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xDC00 <= ch2 && ch2 <= 0xDFFF))
            goto IllegalSurrogate;
        ch = (((((Py_UCS4)(ch) & 0x03FF) << 10) | ((Py_UCS4)(ch2) & 0x03FF)) + 0x10000);


        goto Return;



    }
    ch = 0;
Return:
    *inptr = q;
    *outpos = p - dest;
    return ch;
UnexpectedEnd:
    ch = 1;
    goto Return;
IllegalEncoding:
    ch = 2;
    goto Return;
IllegalSurrogate:
    ch = 3;
    goto Return;
}






static inline void
asciilib_utf16_encode(unsigned short *out,
                        const Py_UCS1 *in,
                        Py_ssize_t len,
                        int native_ordering)
{
    const Py_UCS1 *end = in + len;






    if (native_ordering) {



        do { unsigned short *_to = (unsigned short *) out; const Py_UCS1 *_iter = (in); const Py_UCS1 *_end = (end); Py_ssize_t n = (_end) - (_iter); const Py_UCS1 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (unsigned short) _iter[0]; _to[1] = (unsigned short) _iter[1]; _to[2] = (unsigned short) _iter[2]; _to[3] = (unsigned short) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (unsigned short) *_iter++; } while (0);

    } else {
        const Py_UCS1 *unrolled_end = in + ((size_t)(len) & ~(size_t)((4) - 1));
        while (in < unrolled_end) {
            out[0] = ((in[0]) << 8);
            out[1] = ((in[1]) << 8);
            out[2] = ((in[2]) << 8);
            out[3] = ((in[3]) << 8);
            in += 4; out += 4;
        }
        while (in < end) {
            *out++ = ((*in) << 8);
            ++in;
        }
    }
# 660 "stringlib/codecs.h"
}
# 4634 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 4635 "unicodeobject.c" 2

# 1 "stringlib/ucs1lib.h" 1
# 4637 "unicodeobject.c" 2
# 1 "stringlib/codecs.h" 1
# 18 "stringlib/codecs.h"
static inline Py_UCS4
ucs1lib_utf8_decode(const char **inptr, const char *end,
                       Py_UCS1 *dest,
                       Py_ssize_t *outpos)
{
    Py_UCS4 ch;
    const char *s = *inptr;
    const char *aligned_end = (const char *) ((void *)((Py_uintptr_t)(end) & ~(Py_uintptr_t)((8) - 1)));
    Py_UCS1 *p = dest + *outpos;

    while (s < end) {
        ch = (unsigned char)*s;

        if (ch < 0x80) {







            if ((!((Py_uintptr_t)(s) & (Py_uintptr_t)((8) - 1)))) {

                register const char *_s = s;
                register Py_UCS1 *_p = p;
                while (_s < aligned_end) {



                    unsigned long value = *(unsigned long *) _s;
                    if (value & 0x8080808080808080UL)
                        break;

                    _p[0] = (Py_UCS1)(value & 0xFFu);
                    _p[1] = (Py_UCS1)((value >> 8) & 0xFFu);
                    _p[2] = (Py_UCS1)((value >> 16) & 0xFFu);
                    _p[3] = (Py_UCS1)((value >> 24) & 0xFFu);

                    _p[4] = (Py_UCS1)((value >> 32) & 0xFFu);
                    _p[5] = (Py_UCS1)((value >> 40) & 0xFFu);
                    _p[6] = (Py_UCS1)((value >> 48) & 0xFFu);
                    _p[7] = (Py_UCS1)((value >> 56) & 0xFFu);
# 78 "stringlib/codecs.h"
                    _s += 8;
                    _p += 8;
                }
                s = _s;
                p = _p;
                if (s == end)
                    break;
                ch = (unsigned char)*s;
            }
            if (ch < 0x80) {
                s++;
                *p++ = ch;
                continue;
            }
        }

        if (ch < 0xE0) {

            Py_UCS4 ch2;
            if (ch < 0xC2) {



                goto InvalidStart;
            }
            if (end - s < 2) {


                break;
            }
            ch2 = (unsigned char)s[1];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0))

                goto InvalidContinuation1;
            ch = (ch << 6) + ch2 -
                 ((0xC0 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x007F) && (ch <= 0x07FF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 114, "(ch > 0x007F) && (ch <= 0x07FF)") : (void)0);
            s += 2;
            if (0xFFu <= 0x007F ||
                (0xFFu < 0x07FF && ch > 0xFFu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF0) {

            Py_UCS4 ch2, ch3;
            if (end - s < 3) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

                    goto InvalidContinuation1;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xE0) {
                if (ch2 < 0xA0)


                    goto InvalidContinuation1;
            } else if (ch == 0xED && ch2 >= 0xA0) {





                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            ch = (ch << 12) + (ch2 << 6) + ch3 -
                 ((0xE0 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x07FF) && (ch <= 0xFFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 164, "(ch > 0x07FF) && (ch <= 0xFFFF)") : (void)0);
            s += 3;
            if (0xFFu <= 0x07FF ||
                (0xFFu < 0xFFFF && ch > 0xFFu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF5) {

            Py_UCS4 ch2, ch3, ch4;
            if (end - s < 4) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

                    goto InvalidContinuation1;
                if (end - s < 3)
                    break;
                ch3 = (unsigned char)s[2];
                if (!((ch3) >= 0x80 && (ch3) < 0xC0))
                    goto InvalidContinuation2;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            ch4 = (unsigned char)s[3];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xF0) {
                if (ch2 < 0x90)


                    goto InvalidContinuation1;
            } else if (ch == 0xF4 && ch2 >= 0x90) {


                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            if (!((ch4) >= 0x80 && (ch4) < 0xC0)) {

                goto InvalidContinuation3;
            }
            ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
                 ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0xFFFF) && (ch <= 0x10FFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 221, "(ch > 0xFFFF) && (ch <= 0x10FFFF)") : (void)0);
            s += 4;
            if (0xFFu <= 0xFFFF ||
                (0xFFu < 0x10FFFF && ch > 0xFFu))

                goto Return;
            *p++ = ch;
            continue;
        }
        goto InvalidStart;
    }
    ch = 0;
Return:
    *inptr = s;
    *outpos = p - dest;
    return ch;
InvalidStart:
    ch = 1;
    goto Return;
InvalidContinuation1:
    ch = 2;
    goto Return;
InvalidContinuation2:
    ch = 3;
    goto Return;
InvalidContinuation3:
    ch = 4;
    goto Return;
}







static inline PyObject *
ucs1lib_utf8_encoder(PyObject *unicode,
                        Py_UCS1 *data,
                        Py_ssize_t size,
                        const char *errors)
{


    Py_ssize_t i;
    PyObject *result;
    char *p;
    Py_ssize_t nallocated;
    Py_ssize_t nneeded;






    const Py_ssize_t max_char_size = 2;
    char stackbuf[300 * 2];
# 286 "stringlib/codecs.h"
    (__builtin_expect(!(size >= 0), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 286, "size >= 0") : (void)0);

    if (size <= 300) {




        nallocated = (int)(sizeof(stackbuf));
        result = ((void *)0);
        p = stackbuf;
    }
    else {
        if (size > ((Py_ssize_t)(((size_t)-1)>>1)) / max_char_size) {

            return PyErr_NoMemory();
        }

        nallocated = size * max_char_size;
        result = PyBytes_FromStringAndSize(((void *)0), nallocated);
        if (result == ((void *)0))
            return ((void *)0);
        p = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 307, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
    }

    for (i = 0; i < size;) {
        Py_UCS4 ch = data[i++];

        if (ch < 0x80) {

            *p++ = (char) ch;

        }
        else



        {

            *p++ = (char)(0xc0 | (ch >> 6));
            *p++ = (char)(0x80 | (ch & 0x3f));
        }
# 417 "stringlib/codecs.h"
    }

    if (result == ((void *)0)) {

        nneeded = p - stackbuf;
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 422, "nneeded <= nallocated") : (void)0);
        result = PyBytes_FromStringAndSize(stackbuf, nneeded);
    }
    else {

        nneeded = p - ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 427, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 428, "nneeded <= nallocated") : (void)0);
        _PyBytes_Resize(&result, nneeded);
    }





    return result;
# 448 "stringlib/codecs.h"
}
# 478 "stringlib/codecs.h"
static inline Py_UCS4
ucs1lib_utf16_decode(const unsigned char **inptr, const unsigned char *e,
                        Py_UCS1 *dest, Py_ssize_t *outpos,
                        int native_ordering)
{
    Py_UCS4 ch;
    const unsigned char *aligned_end =
            (const unsigned char *) ((void *)((Py_uintptr_t)(e) & ~(Py_uintptr_t)((8) - 1)));
    const unsigned char *q = *inptr;
    Py_UCS1 *p = dest + *outpos;


    int ihi = !!native_ordering, ilo = !native_ordering;



    --e;

    while (q < e) {
        Py_UCS4 ch2;


        if ((!((Py_uintptr_t)(q) & (Py_uintptr_t)((8) - 1)))) {

            register const unsigned char *_q = q;
            while (_q < aligned_end) {
                unsigned long block = * (unsigned long *) _q;
                if (native_ordering) {

                    if (block & (0x0001000100010001ul * (0xFFFFu & ~0xFFu)))
                        break;
                }
                else {

                    if (block & (((((0x0001000100010001ul * (0xFFFFu & ~0xFFu))) >> 8) & (0x0001000100010001ul * 0x00FFu)) | ((((0x0001000100010001ul * (0xFFFFu & ~0xFFu))) & (0x0001000100010001ul * 0x00FFu)) << 8)))
                        break;

                    block >>= 8;



                }





                p[0] = (Py_UCS1)(block & 0xFFFFu);
                p[1] = (Py_UCS1)((block >> 16) & 0xFFFFu);
                p[2] = (Py_UCS1)((block >> 32) & 0xFFFFu);
                p[3] = (Py_UCS1)(block >> 48);
# 541 "stringlib/codecs.h"
                _q += 8;
                p += 8 / 2;
            }
            q = _q;
            if (q >= e)
                break;
        }

        ch = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xD800 <= ch && ch <= 0xDFFF)) {

            if (ch > 0xFFu)

                goto Return;

            *p++ = (Py_UCS1)ch;
            continue;
        }


        if (q >= e)
            goto UnexpectedEnd;
        if (!(0xD800 <= ch && ch <= 0xDBFF))
            goto IllegalEncoding;
        ch2 = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xDC00 <= ch2 && ch2 <= 0xDFFF))
            goto IllegalSurrogate;
        ch = (((((Py_UCS4)(ch) & 0x03FF) << 10) | ((Py_UCS4)(ch2) & 0x03FF)) + 0x10000);


        goto Return;



    }
    ch = 0;
Return:
    *inptr = q;
    *outpos = p - dest;
    return ch;
UnexpectedEnd:
    ch = 1;
    goto Return;
IllegalEncoding:
    ch = 2;
    goto Return;
IllegalSurrogate:
    ch = 3;
    goto Return;
}






static inline void
ucs1lib_utf16_encode(unsigned short *out,
                        const Py_UCS1 *in,
                        Py_ssize_t len,
                        int native_ordering)
{
    const Py_UCS1 *end = in + len;






    if (native_ordering) {



        do { unsigned short *_to = (unsigned short *) out; const Py_UCS1 *_iter = (in); const Py_UCS1 *_end = (end); Py_ssize_t n = (_end) - (_iter); const Py_UCS1 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (unsigned short) _iter[0]; _to[1] = (unsigned short) _iter[1]; _to[2] = (unsigned short) _iter[2]; _to[3] = (unsigned short) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (unsigned short) *_iter++; } while (0);

    } else {
        const Py_UCS1 *unrolled_end = in + ((size_t)(len) & ~(size_t)((4) - 1));
        while (in < unrolled_end) {
            out[0] = ((in[0]) << 8);
            out[1] = ((in[1]) << 8);
            out[2] = ((in[2]) << 8);
            out[3] = ((in[3]) << 8);
            in += 4; out += 4;
        }
        while (in < end) {
            *out++ = ((*in) << 8);
            ++in;
        }
    }
# 660 "stringlib/codecs.h"
}
# 4638 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 4639 "unicodeobject.c" 2

# 1 "stringlib/ucs2lib.h" 1
# 4641 "unicodeobject.c" 2
# 1 "stringlib/codecs.h" 1
# 18 "stringlib/codecs.h"
static inline Py_UCS4
ucs2lib_utf8_decode(const char **inptr, const char *end,
                       Py_UCS2 *dest,
                       Py_ssize_t *outpos)
{
    Py_UCS4 ch;
    const char *s = *inptr;
    const char *aligned_end = (const char *) ((void *)((Py_uintptr_t)(end) & ~(Py_uintptr_t)((8) - 1)));
    Py_UCS2 *p = dest + *outpos;

    while (s < end) {
        ch = (unsigned char)*s;

        if (ch < 0x80) {







            if ((!((Py_uintptr_t)(s) & (Py_uintptr_t)((8) - 1)))) {

                register const char *_s = s;
                register Py_UCS2 *_p = p;
                while (_s < aligned_end) {



                    unsigned long value = *(unsigned long *) _s;
                    if (value & 0x8080808080808080UL)
                        break;

                    _p[0] = (Py_UCS2)(value & 0xFFu);
                    _p[1] = (Py_UCS2)((value >> 8) & 0xFFu);
                    _p[2] = (Py_UCS2)((value >> 16) & 0xFFu);
                    _p[3] = (Py_UCS2)((value >> 24) & 0xFFu);

                    _p[4] = (Py_UCS2)((value >> 32) & 0xFFu);
                    _p[5] = (Py_UCS2)((value >> 40) & 0xFFu);
                    _p[6] = (Py_UCS2)((value >> 48) & 0xFFu);
                    _p[7] = (Py_UCS2)((value >> 56) & 0xFFu);
# 78 "stringlib/codecs.h"
                    _s += 8;
                    _p += 8;
                }
                s = _s;
                p = _p;
                if (s == end)
                    break;
                ch = (unsigned char)*s;
            }
            if (ch < 0x80) {
                s++;
                *p++ = ch;
                continue;
            }
        }

        if (ch < 0xE0) {

            Py_UCS4 ch2;
            if (ch < 0xC2) {



                goto InvalidStart;
            }
            if (end - s < 2) {


                break;
            }
            ch2 = (unsigned char)s[1];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0))

                goto InvalidContinuation1;
            ch = (ch << 6) + ch2 -
                 ((0xC0 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x007F) && (ch <= 0x07FF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 114, "(ch > 0x007F) && (ch <= 0x07FF)") : (void)0);
            s += 2;
            if (0xFFFFu <= 0x007F ||
                (0xFFFFu < 0x07FF && ch > 0xFFFFu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF0) {

            Py_UCS4 ch2, ch3;
            if (end - s < 3) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

                    goto InvalidContinuation1;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xE0) {
                if (ch2 < 0xA0)


                    goto InvalidContinuation1;
            } else if (ch == 0xED && ch2 >= 0xA0) {





                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            ch = (ch << 12) + (ch2 << 6) + ch3 -
                 ((0xE0 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x07FF) && (ch <= 0xFFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 164, "(ch > 0x07FF) && (ch <= 0xFFFF)") : (void)0);
            s += 3;
            if (0xFFFFu <= 0x07FF ||
                (0xFFFFu < 0xFFFF && ch > 0xFFFFu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF5) {

            Py_UCS4 ch2, ch3, ch4;
            if (end - s < 4) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

                    goto InvalidContinuation1;
                if (end - s < 3)
                    break;
                ch3 = (unsigned char)s[2];
                if (!((ch3) >= 0x80 && (ch3) < 0xC0))
                    goto InvalidContinuation2;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            ch4 = (unsigned char)s[3];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xF0) {
                if (ch2 < 0x90)


                    goto InvalidContinuation1;
            } else if (ch == 0xF4 && ch2 >= 0x90) {


                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            if (!((ch4) >= 0x80 && (ch4) < 0xC0)) {

                goto InvalidContinuation3;
            }
            ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
                 ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0xFFFF) && (ch <= 0x10FFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 221, "(ch > 0xFFFF) && (ch <= 0x10FFFF)") : (void)0);
            s += 4;
            if (0xFFFFu <= 0xFFFF ||
                (0xFFFFu < 0x10FFFF && ch > 0xFFFFu))

                goto Return;
            *p++ = ch;
            continue;
        }
        goto InvalidStart;
    }
    ch = 0;
Return:
    *inptr = s;
    *outpos = p - dest;
    return ch;
InvalidStart:
    ch = 1;
    goto Return;
InvalidContinuation1:
    ch = 2;
    goto Return;
InvalidContinuation2:
    ch = 3;
    goto Return;
InvalidContinuation3:
    ch = 4;
    goto Return;
}







static inline PyObject *
ucs2lib_utf8_encoder(PyObject *unicode,
                        Py_UCS2 *data,
                        Py_ssize_t size,
                        const char *errors)
{


    Py_ssize_t i;
    PyObject *result;
    char *p;
    Py_ssize_t nallocated;
    Py_ssize_t nneeded;

    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);
    PyObject *rep = ((void *)0);





    const Py_ssize_t max_char_size = 3;
    char stackbuf[300 * 3];





    (__builtin_expect(!(size >= 0), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 286, "size >= 0") : (void)0);

    if (size <= 300) {




        nallocated = (int)(sizeof(stackbuf));
        result = ((void *)0);
        p = stackbuf;
    }
    else {
        if (size > ((Py_ssize_t)(((size_t)-1)>>1)) / max_char_size) {

            return PyErr_NoMemory();
        }

        nallocated = size * max_char_size;
        result = PyBytes_FromStringAndSize(((void *)0), nallocated);
        if (result == ((void *)0))
            return ((void *)0);
        p = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 307, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
    }

    for (i = 0; i < size;) {
        Py_UCS4 ch = data[i++];

        if (ch < 0x80) {

            *p++ = (char) ch;

        }
        else

        if (ch < 0x0800)

        {

            *p++ = (char)(0xc0 | (ch >> 6));
            *p++ = (char)(0x80 | (ch & 0x3f));
        }

        else if ((0xD800 <= ch && ch <= 0xDFFF)) {
            Py_ssize_t newpos;
            Py_ssize_t repsize, k, startpos;
            startpos = i-1;
            rep = unicode_encode_call_errorhandler(
                  errors, &errorHandler, "utf-8", "surrogates not allowed",
                  unicode, &exc, startpos, startpos+1, &newpos);
            if (!rep)
                goto error;

            if (((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0))
                repsize = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 339, "PyBytes_Check(rep)") : (void)0),(((PyVarObject*)(rep))->ob_size));
            else
                repsize = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 341, "PyUnicode_Check(rep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)rep)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 341, "PyUnicode_IS_READY(rep)") : (void)0), ((PyASCIIObject *)(rep))->length);

            if (repsize > max_char_size) {
                Py_ssize_t offset;

                if (result == ((void *)0))
                    offset = p - stackbuf;
                else
                    offset = p - ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 349, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));

                if (nallocated > ((Py_ssize_t)(((size_t)-1)>>1)) - repsize + max_char_size) {

                    PyErr_NoMemory();
                    goto error;
                }
                nallocated += repsize - max_char_size;
                if (result != ((void *)0)) {
                    if (_PyBytes_Resize(&result, nallocated) < 0)
                        goto error;
                } else {
                    result = PyBytes_FromStringAndSize(((void *)0), nallocated);
                    if (result == ((void *)0))
                        goto error;
                    ((__builtin_object_size (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), 0) != (size_t) -1) ? __builtin___memcpy_chk (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), stackbuf, offset, __builtin_object_size (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), 0)) : __inline_memcpy_chk (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), stackbuf, offset));
                }
                p = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 366, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)) + offset;
            }

            if (((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)) {
                char *prep = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 370, "PyBytes_Check(rep)") : (void)0), (((PyBytesObject *)(rep))->ob_sval));
                for(k = repsize; k > 0; k--)
                    *p++ = *prep++;
            } else {
                enum PyUnicode_Kind repkind;
                void *repdata;

                if (((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 377, "_PyUnicode_CHECK(rep)") : (void)0), ((((PyASCIIObject*)rep)->state.ready) ? 0 : _PyUnicode_Ready(rep))) < 0)
                    goto error;
                repkind = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 379, "PyUnicode_Check(rep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)rep)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 379, "PyUnicode_IS_READY(rep)") : (void)0), ((PyASCIIObject *)(rep))->state.kind);
                repdata = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "PyUnicode_Check(rep)") : (void)0), (((PyASCIIObject*)(rep))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "PyUnicode_Check(rep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)rep)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "PyUnicode_IS_READY(rep)") : (void)0), ((PyASCIIObject*)rep)->state.ascii) ? ((void*)((PyASCIIObject*)(rep) + 1)) : ((void*)((PyCompactUnicodeObject*)(rep) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(rep))->data.any), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "((PyUnicodeObject*)(rep))->data.any") : (void)0), ((((PyUnicodeObject *)(rep))->data.any))));

                for(k=0; k<repsize; k++) {
                    Py_UCS4 c = ((Py_UCS4) ((repkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(repdata))[(k)] : ((repkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(repdata))[(k)] : ((const Py_UCS4 *)(repdata))[(k)] ) ));
                    if (0x80 <= c) {
                        raise_encode_exception(&exc, "utf-8",
                                               unicode,
                                               i-1, i,
                                               "surrogates not allowed");
                        goto error;
                    }
                    *p++ = (char)c;
                }
            }
            do { if (rep) { PyObject *_py_tmp = (PyObject *)(rep); (rep) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
        }
        else



        {
            *p++ = (char)(0xe0 | (ch >> 12));
            *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));
            *p++ = (char)(0x80 | (ch & 0x3f));
        }
# 417 "stringlib/codecs.h"
    }

    if (result == ((void *)0)) {

        nneeded = p - stackbuf;
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 422, "nneeded <= nallocated") : (void)0);
        result = PyBytes_FromStringAndSize(stackbuf, nneeded);
    }
    else {

        nneeded = p - ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 427, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 428, "nneeded <= nallocated") : (void)0);
        _PyBytes_Resize(&result, nneeded);
    }


    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);

    return result;


 error:
    do { if ((rep) == ((void *)0)) ; else do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((result) == ((void *)0)) ; else do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0); } while (0);
    return ((void *)0);



}
# 478 "stringlib/codecs.h"
static inline Py_UCS4
ucs2lib_utf16_decode(const unsigned char **inptr, const unsigned char *e,
                        Py_UCS2 *dest, Py_ssize_t *outpos,
                        int native_ordering)
{
    Py_UCS4 ch;
    const unsigned char *aligned_end =
            (const unsigned char *) ((void *)((Py_uintptr_t)(e) & ~(Py_uintptr_t)((8) - 1)));
    const unsigned char *q = *inptr;
    Py_UCS2 *p = dest + *outpos;


    int ihi = !!native_ordering, ilo = !native_ordering;



    --e;

    while (q < e) {
        Py_UCS4 ch2;


        if ((!((Py_uintptr_t)(q) & (Py_uintptr_t)((8) - 1)))) {

            register const unsigned char *_q = q;
            while (_q < aligned_end) {
                unsigned long block = * (unsigned long *) _q;
                if (native_ordering) {

                    if (block & (0x0001000100010001ul * 0x8000u))
                        break;
                }
                else {

                    if (block & (((((0x0001000100010001ul * 0x8000u)) >> 8) & (0x0001000100010001ul * 0x00FFu)) | ((((0x0001000100010001ul * 0x8000u)) & (0x0001000100010001ul * 0x00FFu)) << 8)))
                        break;



                    block = ((((block) >> 8) & (0x0001000100010001ul * 0x00FFu)) | (((block) & (0x0001000100010001ul * 0x00FFu)) << 8));

                }





                p[0] = (Py_UCS2)(block & 0xFFFFu);
                p[1] = (Py_UCS2)((block >> 16) & 0xFFFFu);
                p[2] = (Py_UCS2)((block >> 32) & 0xFFFFu);
                p[3] = (Py_UCS2)(block >> 48);
# 541 "stringlib/codecs.h"
                _q += 8;
                p += 8 / 2;
            }
            q = _q;
            if (q >= e)
                break;
        }

        ch = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xD800 <= ch && ch <= 0xDFFF)) {





            *p++ = (Py_UCS2)ch;
            continue;
        }


        if (q >= e)
            goto UnexpectedEnd;
        if (!(0xD800 <= ch && ch <= 0xDBFF))
            goto IllegalEncoding;
        ch2 = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xDC00 <= ch2 && ch2 <= 0xDFFF))
            goto IllegalSurrogate;
        ch = (((((Py_UCS4)(ch) & 0x03FF) << 10) | ((Py_UCS4)(ch2) & 0x03FF)) + 0x10000);


        goto Return;



    }
    ch = 0;
Return:
    *inptr = q;
    *outpos = p - dest;
    return ch;
UnexpectedEnd:
    ch = 1;
    goto Return;
IllegalEncoding:
    ch = 2;
    goto Return;
IllegalSurrogate:
    ch = 3;
    goto Return;
}






static inline void
ucs2lib_utf16_encode(unsigned short *out,
                        const Py_UCS2 *in,
                        Py_ssize_t len,
                        int native_ordering)
{
    const Py_UCS2 *end = in + len;






    if (native_ordering) {

        ((__builtin_object_size (out, 0) != (size_t) -1) ? __builtin___memcpy_chk (out, in, 2 * len, __builtin_object_size (out, 0)) : __inline_memcpy_chk (out, in, 2 * len));



    } else {
        const Py_UCS2 *unrolled_end = in + ((size_t)(len) & ~(size_t)((4) - 1));
        while (in < unrolled_end) {
            out[0] = (((in[0]) << 8) | ((in[0]) >> 8));
            out[1] = (((in[1]) << 8) | ((in[1]) >> 8));
            out[2] = (((in[2]) << 8) | ((in[2]) >> 8));
            out[3] = (((in[3]) << 8) | ((in[3]) >> 8));
            in += 4; out += 4;
        }
        while (in < end) {
            *out++ = (((*in) << 8) | ((*in) >> 8));
            ++in;
        }
    }
# 660 "stringlib/codecs.h"
}
# 4642 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 4643 "unicodeobject.c" 2

# 1 "stringlib/ucs4lib.h" 1
# 4645 "unicodeobject.c" 2
# 1 "stringlib/codecs.h" 1
# 18 "stringlib/codecs.h"
static inline Py_UCS4
ucs4lib_utf8_decode(const char **inptr, const char *end,
                       Py_UCS4 *dest,
                       Py_ssize_t *outpos)
{
    Py_UCS4 ch;
    const char *s = *inptr;
    const char *aligned_end = (const char *) ((void *)((Py_uintptr_t)(end) & ~(Py_uintptr_t)((8) - 1)));
    Py_UCS4 *p = dest + *outpos;

    while (s < end) {
        ch = (unsigned char)*s;

        if (ch < 0x80) {







            if ((!((Py_uintptr_t)(s) & (Py_uintptr_t)((8) - 1)))) {

                register const char *_s = s;
                register Py_UCS4 *_p = p;
                while (_s < aligned_end) {



                    unsigned long value = *(unsigned long *) _s;
                    if (value & 0x8080808080808080UL)
                        break;

                    _p[0] = (Py_UCS4)(value & 0xFFu);
                    _p[1] = (Py_UCS4)((value >> 8) & 0xFFu);
                    _p[2] = (Py_UCS4)((value >> 16) & 0xFFu);
                    _p[3] = (Py_UCS4)((value >> 24) & 0xFFu);

                    _p[4] = (Py_UCS4)((value >> 32) & 0xFFu);
                    _p[5] = (Py_UCS4)((value >> 40) & 0xFFu);
                    _p[6] = (Py_UCS4)((value >> 48) & 0xFFu);
                    _p[7] = (Py_UCS4)((value >> 56) & 0xFFu);
# 78 "stringlib/codecs.h"
                    _s += 8;
                    _p += 8;
                }
                s = _s;
                p = _p;
                if (s == end)
                    break;
                ch = (unsigned char)*s;
            }
            if (ch < 0x80) {
                s++;
                *p++ = ch;
                continue;
            }
        }

        if (ch < 0xE0) {

            Py_UCS4 ch2;
            if (ch < 0xC2) {



                goto InvalidStart;
            }
            if (end - s < 2) {


                break;
            }
            ch2 = (unsigned char)s[1];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0))

                goto InvalidContinuation1;
            ch = (ch << 6) + ch2 -
                 ((0xC0 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x007F) && (ch <= 0x07FF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 114, "(ch > 0x007F) && (ch <= 0x07FF)") : (void)0);
            s += 2;
            if (0x10FFFFu <= 0x007F ||
                (0x10FFFFu < 0x07FF && ch > 0x10FFFFu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF0) {

            Py_UCS4 ch2, ch3;
            if (end - s < 3) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

                    goto InvalidContinuation1;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xE0) {
                if (ch2 < 0xA0)


                    goto InvalidContinuation1;
            } else if (ch == 0xED && ch2 >= 0xA0) {





                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            ch = (ch << 12) + (ch2 << 6) + ch3 -
                 ((0xE0 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0x07FF) && (ch <= 0xFFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 164, "(ch > 0x07FF) && (ch <= 0xFFFF)") : (void)0);
            s += 3;
            if (0x10FFFFu <= 0x07FF ||
                (0x10FFFFu < 0xFFFF && ch > 0x10FFFFu))

                goto Return;
            *p++ = ch;
            continue;
        }

        if (ch < 0xF5) {

            Py_UCS4 ch2, ch3, ch4;
            if (end - s < 4) {


                if (end - s < 2)
                    break;
                ch2 = (unsigned char)s[1];
                if (!((ch2) >= 0x80 && (ch2) < 0xC0) ||
                    (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

                    goto InvalidContinuation1;
                if (end - s < 3)
                    break;
                ch3 = (unsigned char)s[2];
                if (!((ch3) >= 0x80 && (ch3) < 0xC0))
                    goto InvalidContinuation2;
                break;
            }
            ch2 = (unsigned char)s[1];
            ch3 = (unsigned char)s[2];
            ch4 = (unsigned char)s[3];
            if (!((ch2) >= 0x80 && (ch2) < 0xC0)) {

                goto InvalidContinuation1;
            }
            if (ch == 0xF0) {
                if (ch2 < 0x90)


                    goto InvalidContinuation1;
            } else if (ch == 0xF4 && ch2 >= 0x90) {


                goto InvalidContinuation1;
            }
            if (!((ch3) >= 0x80 && (ch3) < 0xC0)) {

                goto InvalidContinuation2;
            }
            if (!((ch4) >= 0x80 && (ch4) < 0xC0)) {

                goto InvalidContinuation3;
            }
            ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
                 ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);
            (__builtin_expect(!((ch > 0xFFFF) && (ch <= 0x10FFFF)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 221, "(ch > 0xFFFF) && (ch <= 0x10FFFF)") : (void)0);
            s += 4;
            if (0x10FFFFu <= 0xFFFF ||
                (0x10FFFFu < 0x10FFFF && ch > 0x10FFFFu))

                goto Return;
            *p++ = ch;
            continue;
        }
        goto InvalidStart;
    }
    ch = 0;
Return:
    *inptr = s;
    *outpos = p - dest;
    return ch;
InvalidStart:
    ch = 1;
    goto Return;
InvalidContinuation1:
    ch = 2;
    goto Return;
InvalidContinuation2:
    ch = 3;
    goto Return;
InvalidContinuation3:
    ch = 4;
    goto Return;
}







static inline PyObject *
ucs4lib_utf8_encoder(PyObject *unicode,
                        Py_UCS4 *data,
                        Py_ssize_t size,
                        const char *errors)
{


    Py_ssize_t i;
    PyObject *result;
    char *p;
    Py_ssize_t nallocated;
    Py_ssize_t nneeded;

    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);
    PyObject *rep = ((void *)0);
# 282 "stringlib/codecs.h"
    const Py_ssize_t max_char_size = 4;
    char stackbuf[300 * 4];


    (__builtin_expect(!(size >= 0), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 286, "size >= 0") : (void)0);

    if (size <= 300) {




        nallocated = (int)(sizeof(stackbuf));
        result = ((void *)0);
        p = stackbuf;
    }
    else {
        if (size > ((Py_ssize_t)(((size_t)-1)>>1)) / max_char_size) {

            return PyErr_NoMemory();
        }

        nallocated = size * max_char_size;
        result = PyBytes_FromStringAndSize(((void *)0), nallocated);
        if (result == ((void *)0))
            return ((void *)0);
        p = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 307, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
    }

    for (i = 0; i < size;) {
        Py_UCS4 ch = data[i++];

        if (ch < 0x80) {

            *p++ = (char) ch;

        }
        else

        if (ch < 0x0800)

        {

            *p++ = (char)(0xc0 | (ch >> 6));
            *p++ = (char)(0x80 | (ch & 0x3f));
        }

        else if ((0xD800 <= ch && ch <= 0xDFFF)) {
            Py_ssize_t newpos;
            Py_ssize_t repsize, k, startpos;
            startpos = i-1;
            rep = unicode_encode_call_errorhandler(
                  errors, &errorHandler, "utf-8", "surrogates not allowed",
                  unicode, &exc, startpos, startpos+1, &newpos);
            if (!rep)
                goto error;

            if (((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0))
                repsize = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 339, "PyBytes_Check(rep)") : (void)0),(((PyVarObject*)(rep))->ob_size));
            else
                repsize = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 341, "PyUnicode_Check(rep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)rep)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 341, "PyUnicode_IS_READY(rep)") : (void)0), ((PyASCIIObject *)(rep))->length);

            if (repsize > max_char_size) {
                Py_ssize_t offset;

                if (result == ((void *)0))
                    offset = p - stackbuf;
                else
                    offset = p - ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 349, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));

                if (nallocated > ((Py_ssize_t)(((size_t)-1)>>1)) - repsize + max_char_size) {

                    PyErr_NoMemory();
                    goto error;
                }
                nallocated += repsize - max_char_size;
                if (result != ((void *)0)) {
                    if (_PyBytes_Resize(&result, nallocated) < 0)
                        goto error;
                } else {
                    result = PyBytes_FromStringAndSize(((void *)0), nallocated);
                    if (result == ((void *)0))
                        goto error;
                    ((__builtin_object_size (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), 0) != (size_t) -1) ? __builtin___memcpy_chk (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), stackbuf, offset, __builtin_object_size (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), 0)) : __inline_memcpy_chk (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 364, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)), stackbuf, offset));
                }
                p = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 366, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval)) + offset;
            }

            if (((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)) {
                char *prep = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 370, "PyBytes_Check(rep)") : (void)0), (((PyBytesObject *)(rep))->ob_sval));
                for(k = repsize; k > 0; k--)
                    *p++ = *prep++;
            } else {
                enum PyUnicode_Kind repkind;
                void *repdata;

                if (((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 377, "_PyUnicode_CHECK(rep)") : (void)0), ((((PyASCIIObject*)rep)->state.ready) ? 0 : _PyUnicode_Ready(rep))) < 0)
                    goto error;
                repkind = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 379, "PyUnicode_Check(rep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)rep)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 379, "PyUnicode_IS_READY(rep)") : (void)0), ((PyASCIIObject *)(rep))->state.kind);
                repdata = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "PyUnicode_Check(rep)") : (void)0), (((PyASCIIObject*)(rep))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "PyUnicode_Check(rep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)rep)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "PyUnicode_IS_READY(rep)") : (void)0), ((PyASCIIObject*)rep)->state.ascii) ? ((void*)((PyASCIIObject*)(rep) + 1)) : ((void*)((PyCompactUnicodeObject*)(rep) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(rep))->data.any), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 380, "((PyUnicodeObject*)(rep))->data.any") : (void)0), ((((PyUnicodeObject *)(rep))->data.any))));

                for(k=0; k<repsize; k++) {
                    Py_UCS4 c = ((Py_UCS4) ((repkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(repdata))[(k)] : ((repkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(repdata))[(k)] : ((const Py_UCS4 *)(repdata))[(k)] ) ));
                    if (0x80 <= c) {
                        raise_encode_exception(&exc, "utf-8",
                                               unicode,
                                               i-1, i,
                                               "surrogates not allowed");
                        goto error;
                    }
                    *p++ = (char)c;
                }
            }
            do { if (rep) { PyObject *_py_tmp = (PyObject *)(rep); (rep) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
        }
        else

        if (ch < 0x10000)

        {
            *p++ = (char)(0xe0 | (ch >> 12));
            *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));
            *p++ = (char)(0x80 | (ch & 0x3f));
        }

        else
        {
            (__builtin_expect(!(ch <= 0x10ffff), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 408, "ch <= MAX_UNICODE") : (void)0);

            *p++ = (char)(0xf0 | (ch >> 18));
            *p++ = (char)(0x80 | ((ch >> 12) & 0x3f));
            *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));
            *p++ = (char)(0x80 | (ch & 0x3f));
        }


    }

    if (result == ((void *)0)) {

        nneeded = p - stackbuf;
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 422, "nneeded <= nallocated") : (void)0);
        result = PyBytes_FromStringAndSize(stackbuf, nneeded);
    }
    else {

        nneeded = p - ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 427, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
        (__builtin_expect(!(nneeded <= nallocated), 0) ? __assert_rtn(__func__, "stringlib/codecs.h", 428, "nneeded <= nallocated") : (void)0);
        _PyBytes_Resize(&result, nneeded);
    }


    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);

    return result;


 error:
    do { if ((rep) == ((void *)0)) ; else do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((result) == ((void *)0)) ; else do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0); } while (0);
    return ((void *)0);



}
# 478 "stringlib/codecs.h"
static inline Py_UCS4
ucs4lib_utf16_decode(const unsigned char **inptr, const unsigned char *e,
                        Py_UCS4 *dest, Py_ssize_t *outpos,
                        int native_ordering)
{
    Py_UCS4 ch;
    const unsigned char *aligned_end =
            (const unsigned char *) ((void *)((Py_uintptr_t)(e) & ~(Py_uintptr_t)((8) - 1)));
    const unsigned char *q = *inptr;
    Py_UCS4 *p = dest + *outpos;


    int ihi = !!native_ordering, ilo = !native_ordering;



    --e;

    while (q < e) {
        Py_UCS4 ch2;


        if ((!((Py_uintptr_t)(q) & (Py_uintptr_t)((8) - 1)))) {

            register const unsigned char *_q = q;
            while (_q < aligned_end) {
                unsigned long block = * (unsigned long *) _q;
                if (native_ordering) {

                    if (block & (0x0001000100010001ul * 0x8000u))
                        break;
                }
                else {

                    if (block & (((((0x0001000100010001ul * 0x8000u)) >> 8) & (0x0001000100010001ul * 0x00FFu)) | ((((0x0001000100010001ul * 0x8000u)) & (0x0001000100010001ul * 0x00FFu)) << 8)))
                        break;



                    block = ((((block) >> 8) & (0x0001000100010001ul * 0x00FFu)) | (((block) & (0x0001000100010001ul * 0x00FFu)) << 8));

                }





                p[0] = (Py_UCS4)(block & 0xFFFFu);
                p[1] = (Py_UCS4)((block >> 16) & 0xFFFFu);
                p[2] = (Py_UCS4)((block >> 32) & 0xFFFFu);
                p[3] = (Py_UCS4)(block >> 48);
# 541 "stringlib/codecs.h"
                _q += 8;
                p += 8 / 2;
            }
            q = _q;
            if (q >= e)
                break;
        }

        ch = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xD800 <= ch && ch <= 0xDFFF)) {





            *p++ = (Py_UCS4)ch;
            continue;
        }


        if (q >= e)
            goto UnexpectedEnd;
        if (!(0xD800 <= ch && ch <= 0xDBFF))
            goto IllegalEncoding;
        ch2 = (q[ihi] << 8) | q[ilo];
        q += 2;
        if (!(0xDC00 <= ch2 && ch2 <= 0xDFFF))
            goto IllegalSurrogate;
        ch = (((((Py_UCS4)(ch) & 0x03FF) << 10) | ((Py_UCS4)(ch2) & 0x03FF)) + 0x10000);




        *p++ = (Py_UCS4)ch;

    }
    ch = 0;
Return:
    *inptr = q;
    *outpos = p - dest;
    return ch;
UnexpectedEnd:
    ch = 1;
    goto Return;
IllegalEncoding:
    ch = 2;
    goto Return;
IllegalSurrogate:
    ch = 3;
    goto Return;
}






static inline void
ucs4lib_utf16_encode(unsigned short *out,
                        const Py_UCS4 *in,
                        Py_ssize_t len,
                        int native_ordering)
{
    const Py_UCS4 *end = in + len;
# 633 "stringlib/codecs.h"
    if (native_ordering) {
        while (in < end) {
            Py_UCS4 ch = *in++;
            if (ch < 0x10000)
                *out++ = ch;
            else {
                out[0] = (0xD800 - (0x10000 >> 10) + ((ch) >> 10));
                out[1] = (0xDC00 + ((ch) & 0x3FF));
                out += 2;
            }
        }
    } else {
        while (in < end) {
            Py_UCS4 ch = *in++;
            if (ch < 0x10000)
                *out++ = ((((Py_UCS2)ch) << 8) | (((Py_UCS2)ch) >> 8));
            else {
                Py_UCS2 ch1 = (0xD800 - (0x10000 >> 10) + ((ch) >> 10));
                Py_UCS2 ch2 = (0xDC00 + ((ch) & 0x3FF));
                out[0] = (((ch1) << 8) | ((ch1) >> 8));
                out[1] = (((ch2) << 8) | ((ch2) >> 8));
                out += 2;
            }
        }
    }


}
# 4646 "unicodeobject.c" 2
# 1 "stringlib/undef.h" 1
# 4647 "unicodeobject.c" 2
# 4658 "unicodeobject.c"
static Py_ssize_t
ascii_decode(const char *start, const char *end, Py_UCS1 *dest)
{
    const char *p = start;
    const char *aligned_end = (const char *) ((void *)((Py_uintptr_t)(end) & ~(Py_uintptr_t)((8) - 1)));


    (__builtin_expect(!((!((Py_uintptr_t)(dest) & (Py_uintptr_t)((8) - 1)))), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4665, "_Py_IS_ALIGNED(dest, SIZEOF_LONG)") : (void)0);
    if ((!((Py_uintptr_t)(p) & (Py_uintptr_t)((8) - 1)))) {



        register const char *_p = p;
        register Py_UCS1 * q = dest;
        while (_p < aligned_end) {
            unsigned long value = *(const unsigned long *) _p;
            if (value & 0x8080808080808080UL)
                break;
            *((unsigned long *)q) = value;
            _p += 8;
            q += 8;
        }
        p = _p;
        while (p < end) {
            if ((unsigned char)*p & 0x80)
                break;
            *q++ = *p++;
        }
        return p - start;
    }

    while (p < end) {


        if ((!((Py_uintptr_t)(p) & (Py_uintptr_t)((8) - 1)))) {

            register const char *_p = p;
            while (_p < aligned_end) {
                unsigned long value = *(unsigned long *) _p;
                if (value & 0x8080808080808080UL)
                    break;
                _p += 8;
            }
            p = _p;
            if (_p == end)
                break;
        }
        if ((unsigned char)*p & 0x80)
            break;
        ++p;
    }
    ((__builtin_object_size (dest, 0) != (size_t) -1) ? __builtin___memcpy_chk (dest, start, p - start, __builtin_object_size (dest, 0)) : __inline_memcpy_chk (dest, start, p - start));
    return p - start;
}

PyObject *
PyUnicode_DecodeUTF8Stateful(const char *s,
                             Py_ssize_t size,
                             const char *errors,
                             Py_ssize_t *consumed)
{
    PyObject *unicode;
    const char *starts = s;
    const char *end = s + size;
    Py_ssize_t outpos;

    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    const char *errmsg = "";
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);

    if (size == 0) {
        if (consumed)
            *consumed = 0;
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4733, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    }


    if (size == 1 && (unsigned char)s[0] < 128) {
        if (consumed)
            *consumed = 1;
        return get_latin1_char((unsigned char)s[0]);
    }

    unicode = PyUnicode_New(size, 127);
    if (!unicode)
        return ((void *)0);

    outpos = ascii_decode(s, end, ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4747, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4747, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4747, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4747, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))));
    s += outpos;
    while (s < end) {
        Py_UCS4 ch;
        int kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4751, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4751, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
        if (kind == PyUnicode_1BYTE_KIND) {
            if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4753, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4753, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
                ch = asciilib_utf8_decode(&s, end,
                        ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4755, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4755, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4755, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4755, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos);
            else
                ch = ucs1lib_utf8_decode(&s, end,
                        ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4758, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4758, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4758, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4758, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos);
        } else if (kind == PyUnicode_2BYTE_KIND) {
            ch = ucs2lib_utf8_decode(&s, end,
                    ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4761, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4761, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4761, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4761, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos);
        } else {
            (__builtin_expect(!(kind == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4763, "kind == PyUnicode_4BYTE_KIND") : (void)0);
            ch = ucs4lib_utf8_decode(&s, end,
                    ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4765, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4765, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4765, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4765, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos);
        }

        switch (ch) {
        case 0:
            if (s == end || consumed)
                goto End;
            errmsg = "unexpected end of data";
            startinpos = s - starts;
            endinpos = end - starts;
            break;
        case 1:
            errmsg = "invalid start byte";
            startinpos = s - starts;
            endinpos = startinpos + 1;
            break;
        case 2:
        case 3:
        case 4:
            errmsg = "invalid continuation byte";
            startinpos = s - starts;
            endinpos = startinpos + ch - 1;
            break;
        default:
            if (unicode_putchar(&unicode, &outpos, ch) < 0)
                goto onError;
            continue;
        }

        if (unicode_decode_call_errorhandler(
                errors, &errorHandler,
                "utf-8", errmsg,
                &starts, &end, &startinpos, &endinpos, &exc, &s,
                &unicode, &outpos))
            goto onError;
    }

End:
    if (unicode_resize(&unicode, outpos) < 0)
        goto onError;

    if (consumed)
        *consumed = s - starts;

    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4811, "_PyUnicode_CheckConsistency(unicode, 1)") : (void)0);
    return unicode;

onError:
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((unicode) == ((void *)0)) ; else do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0); } while (0);
    return ((void *)0);
}
# 4829 "unicodeobject.c"
wchar_t*
_Py_DecodeUTF8_surrogateescape(const char *s, Py_ssize_t size)
{
    const char *e;
    wchar_t *unicode;
    Py_ssize_t outpos;



    if (((Py_ssize_t)(((size_t)-1)>>1)) / sizeof(wchar_t) < (size + 1))
        return ((void *)0);
    unicode = PyMem_Malloc((size + 1) * sizeof(wchar_t));
    if (!unicode)
        return ((void *)0);


    e = s + size;
    outpos = 0;
    while (s < e) {
        Py_UCS4 ch;

        ch = ucs4lib_utf8_decode(&s, e, (Py_UCS4 *)unicode, &outpos);



        if (ch > 0xFF) {

            (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4856, "0") : (void)0);






        }
        else {
            if (!ch && s == e)
                break;

            unicode[outpos++] = 0xDC00 + (unsigned char)*s++;
        }
    }
    unicode[outpos] = L'\0';
    return unicode;
}
# 4884 "unicodeobject.c"
PyObject *
_PyUnicode_AsUTF8String(PyObject *unicode, const char *errors)
{
    enum PyUnicode_Kind kind;
    void *data;
    Py_ssize_t size;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4896, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4899, "_PyUnicode_CHECK(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4899, "PyUnicode_IS_READY(unicode)") : (void)0), (((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((char*)((PyASCIIObject*)(unicode) + 1)) : (((PyCompactUnicodeObject*)(unicode))->utf8)))
        return PyBytes_FromStringAndSize(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4900, "_PyUnicode_CHECK(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4900, "PyUnicode_IS_READY(unicode)") : (void)0), (((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((char*)((PyASCIIObject*)(unicode) + 1)) : (((PyCompactUnicodeObject*)(unicode))->utf8)),
                                         ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4901, "_PyUnicode_CHECK(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4901, "PyUnicode_IS_READY(unicode)") : (void)0), (((PyASCIIObject*)unicode)->state.ascii && (((PyASCIIObject*)(unicode))->state.compact)) ? ((PyASCIIObject*)(unicode))->length : (((PyCompactUnicodeObject*)(unicode))->utf8_length)));

    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4903, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4903, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4904, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4904, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4904, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4904, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
    size = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4905, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4905, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);

    switch (kind) {
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4909, "0") : (void)0);
    case PyUnicode_1BYTE_KIND:

        (__builtin_expect(!(!((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4912, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4912, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 4912, "!PyUnicode_IS_ASCII(unicode)") : (void)0);
        return ucs1lib_utf8_encoder(unicode, data, size, errors);
    case PyUnicode_2BYTE_KIND:
        return ucs2lib_utf8_encoder(unicode, data, size, errors);
    case PyUnicode_4BYTE_KIND:
        return ucs4lib_utf8_encoder(unicode, data, size, errors);
    }
}

PyObject *
PyUnicode_EncodeUTF8(const Py_UNICODE *s,
                     Py_ssize_t size,
                     const char *errors)
{
    PyObject *v, *unicode;

    unicode = PyUnicode_FromUnicode(s, size);
    if (unicode == ((void *)0))
        return ((void *)0);
    v = _PyUnicode_AsUTF8String(unicode, errors);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return v;
}

PyObject *
PyUnicode_AsUTF8String(PyObject *unicode)
{
    return _PyUnicode_AsUTF8String(unicode, ((void *)0));
}



PyObject *
PyUnicode_DecodeUTF32(const char *s,
                      Py_ssize_t size,
                      const char *errors,
                      int *byteorder)
{
    return PyUnicode_DecodeUTF32Stateful(s, size, errors, byteorder, ((void *)0));
}

PyObject *
PyUnicode_DecodeUTF32Stateful(const char *s,
                              Py_ssize_t size,
                              const char *errors,
                              int *byteorder,
                              Py_ssize_t *consumed)
{
    const char *starts = s;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    Py_ssize_t outpos;
    PyObject *unicode;
    const unsigned char *q, *e;
    int bo = 0;
    const char *errmsg = "";


    int iorder[] = {0, 1, 2, 3};



    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);

    q = (unsigned char *)s;
    e = q + size;

    if (byteorder)
        bo = *byteorder;





    if (bo == 0) {
        if (size >= 4) {
            const Py_UCS4 bom = (q[iorder[3]] << 24) | (q[iorder[2]] << 16) |
                (q[iorder[1]] << 8) | q[iorder[0]];

            if (bom == 0x0000FEFF) {
                q += 4;
                bo = -1;
            }
            else if (bom == 0xFFFE0000) {
                q += 4;
                bo = 1;
            }
# 5010 "unicodeobject.c"
        }
    }

    if (bo == -1) {

        iorder[0] = 0;
        iorder[1] = 1;
        iorder[2] = 2;
        iorder[3] = 3;
    }
    else if (bo == 1) {

        iorder[0] = 3;
        iorder[1] = 2;
        iorder[2] = 1;
        iorder[3] = 0;
    }


    unicode = PyUnicode_New((size+3)/4, 127);
    if (!unicode)
        return ((void *)0);
    if (size == 0)
        return unicode;
    outpos = 0;

    while (q < e) {
        Py_UCS4 ch;

        if (e-q<4) {
            if (consumed)
                break;
            errmsg = "truncated data";
            startinpos = ((const char *)q)-starts;
            endinpos = ((const char *)e)-starts;
            goto utf32Error;


        }
        ch = (q[iorder[3]] << 24) | (q[iorder[2]] << 16) |
            (q[iorder[1]] << 8) | q[iorder[0]];

        if (ch >= 0x110000)
        {
            errmsg = "codepoint not in range(0x110000)";
            startinpos = ((const char *)q)-starts;
            endinpos = startinpos+4;
            goto utf32Error;
        }
        if (unicode_putchar(&unicode, &outpos, ch) < 0)
            goto onError;
        q += 4;
        continue;
      utf32Error:
        if (unicode_decode_call_errorhandler(
                errors, &errorHandler,
                "utf32", errmsg,
                &starts, (const char **)&e, &startinpos, &endinpos, &exc, (const char **)&q,
                &unicode, &outpos))
            goto onError;
    }

    if (byteorder)
        *byteorder = bo;

    if (consumed)
        *consumed = (const char *)q-starts;


    if (unicode_resize(&unicode, outpos) < 0)
        goto onError;

    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return unicode_result(unicode);

  onError:
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);
}

PyObject *
_PyUnicode_EncodeUTF32(PyObject *str,
                       const char *errors,
                       int byteorder)
{
    int kind;
    void *data;
    Py_ssize_t len;
    PyObject *v;
    unsigned char *p;
    Py_ssize_t nsize, i;


    int iorder[] = {0, 1, 2, 3};
# 5120 "unicodeobject.c"
    if (!((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5124, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1)
        return ((void *)0);
    kind = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5126, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5126, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5127, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5127, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5127, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5127, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5128, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5128, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);

    nsize = len + (byteorder == 0);
    if (nsize > ((Py_ssize_t)(((size_t)-1)>>1)) / 4)
        return PyErr_NoMemory();
    v = PyBytes_FromStringAndSize(((void *)0), nsize * 4);
    if (v == ((void *)0))
        return ((void *)0);

    p = (unsigned char *)((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5137, "PyBytes_Check(v)") : (void)0), (((PyBytesObject *)(v))->ob_sval));
    if (byteorder == 0)
        do { p[iorder[3]] = ((0xFEFF) >> 24) & 0xff; p[iorder[2]] = ((0xFEFF) >> 16) & 0xff; p[iorder[1]] = ((0xFEFF) >> 8) & 0xff; p[iorder[0]] = (0xFEFF) & 0xff; p += 4; } while(0);
    if (len == 0)
        goto done;

    if (byteorder == -1) {

        iorder[0] = 0;
        iorder[1] = 1;
        iorder[2] = 2;
        iorder[3] = 3;
    }
    else if (byteorder == 1) {

        iorder[0] = 3;
        iorder[1] = 2;
        iorder[2] = 1;
        iorder[3] = 0;
    }

    for (i = 0; i < len; i++)
        do { p[iorder[3]] = ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))) >> 24) & 0xff; p[iorder[2]] = ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))) >> 16) & 0xff; p[iorder[1]] = ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))) >> 8) & 0xff; p[iorder[0]] = (((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))) & 0xff; p += 4; } while(0);

  done:
    return v;

}

PyObject *
PyUnicode_EncodeUTF32(const Py_UNICODE *s,
                      Py_ssize_t size,
                      const char *errors,
                      int byteorder)
{
    PyObject *result;
    PyObject *tmp = PyUnicode_FromUnicode(s, size);
    if (tmp == ((void *)0))
        return ((void *)0);
    result = _PyUnicode_EncodeUTF32(tmp, errors, byteorder);
    do { if ( --((PyObject*)(tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(tmp)))); } while (0);
    return result;
}

PyObject *
PyUnicode_AsUTF32String(PyObject *unicode)
{
    return _PyUnicode_EncodeUTF32(unicode, ((void *)0), 0);
}



PyObject *
PyUnicode_DecodeUTF16(const char *s,
                      Py_ssize_t size,
                      const char *errors,
                      int *byteorder)
{
    return PyUnicode_DecodeUTF16Stateful(s, size, errors, byteorder, ((void *)0));
}

PyObject *
PyUnicode_DecodeUTF16Stateful(const char *s,
                              Py_ssize_t size,
                              const char *errors,
                              int *byteorder,
                              Py_ssize_t *consumed)
{
    const char *starts = s;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    Py_ssize_t outpos;
    PyObject *unicode;
    const unsigned char *q, *e;
    int bo = 0;
    int native_ordering;
    const char *errmsg = "";
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);

    q = (unsigned char *)s;
    e = q + size;

    if (byteorder)
        bo = *byteorder;





    if (bo == 0 && size >= 2) {
        const Py_UCS4 bom = (q[1] << 8) | q[0];
        if (bom == 0xFEFF) {
            q += 2;
            bo = -1;
        }
        else if (bom == 0xFFFE) {
            q += 2;
            bo = 1;
        }
        if (byteorder)
            *byteorder = bo;
    }

    if (q == e) {
        if (consumed)
            *consumed = size;
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5244, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    }


    native_ordering = bo <= 0;






    unicode = PyUnicode_New((e - q + 1) / 2, 127);
    if (!unicode)
        return ((void *)0);

    outpos = 0;
    while (1) {
        Py_UCS4 ch = 0;
        if (e - q >= 2) {
            int kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5263, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5263, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
            if (kind == PyUnicode_1BYTE_KIND) {
                if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5265, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5265, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
                    ch = asciilib_utf16_decode(&q, e,
                            ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5267, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5267, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5267, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5267, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos,
                            native_ordering);
                else
                    ch = ucs1lib_utf16_decode(&q, e,
                            ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5271, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5271, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5271, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5271, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos,
                            native_ordering);
            } else if (kind == PyUnicode_2BYTE_KIND) {
                ch = ucs2lib_utf16_decode(&q, e,
                        ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5275, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5275, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5275, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5275, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos,
                        native_ordering);
            } else {
                (__builtin_expect(!(kind == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5278, "kind == PyUnicode_4BYTE_KIND") : (void)0);
                ch = ucs4lib_utf16_decode(&q, e,
                        ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5280, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5280, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5280, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5280, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))))), &outpos,
                        native_ordering);
            }
        }

        switch (ch)
        {
        case 0:

            if (q == e || consumed)
                goto End;
            errmsg = "truncated data";
            startinpos = ((const char *)q) - starts;
            endinpos = ((const char *)e) - starts;
            break;


        case 1:
            q -= 2;
            if (consumed)
                goto End;
            errmsg = "unexpected end of data";
            startinpos = ((const char *)q) - starts;
            endinpos = ((const char *)e) - starts;
            break;
        case 2:
            errmsg = "illegal encoding";
            startinpos = ((const char *)q) - 2 - starts;
            endinpos = startinpos + 2;
            break;
        case 3:
            errmsg = "illegal UTF-16 surrogate";
            startinpos = ((const char *)q) - 4 - starts;
            endinpos = startinpos + 2;
            break;
        default:
            if (unicode_putchar(&unicode, &outpos, ch) < 0)
                goto onError;
            continue;
        }

        if (unicode_decode_call_errorhandler(
                errors,
                &errorHandler,
                "utf16", errmsg,
                &starts,
                (const char **)&e,
                &startinpos,
                &endinpos,
                &exc,
                (const char **)&q,
                &unicode,
                &outpos))
            goto onError;
    }

End:
    if (consumed)
        *consumed = (const char *)q-starts;


    if (unicode_resize(&unicode, outpos) < 0)
        goto onError;

    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return unicode_result(unicode);

  onError:
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);
}

PyObject *
_PyUnicode_EncodeUTF16(PyObject *str,
                       const char *errors,
                       int byteorder)
{
    enum PyUnicode_Kind kind;
    const void *data;
    Py_ssize_t len;
    PyObject *v;
    unsigned short *out;
    Py_ssize_t bytesize;
    Py_ssize_t pairs;



    int native_ordering = byteorder <= 0;


    if (!((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5377, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1)
        return ((void *)0);
    kind = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5379, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5379, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5380, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5380, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5380, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5380, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5381, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5381, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);

    pairs = 0;
    if (kind == PyUnicode_4BYTE_KIND) {
        const Py_UCS4 *in = (const Py_UCS4 *)data;
        const Py_UCS4 *end = in + len;
        while (in < end)
            if (*in++ >= 0x10000)
                pairs++;
    }
    if (len > ((Py_ssize_t)(((size_t)-1)>>1)) / 2 - pairs - (byteorder == 0))
        return PyErr_NoMemory();
    bytesize = (len + pairs + (byteorder == 0)) * 2;
    v = PyBytes_FromStringAndSize(((void *)0), bytesize);
    if (v == ((void *)0))
        return ((void *)0);


    (__builtin_expect(!((!((Py_uintptr_t)(((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5399, "PyBytes_Check(v)") : (void)0), (((PyBytesObject *)(v))->ob_sval))) & (Py_uintptr_t)((2) - 1)))), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5399, "_Py_IS_ALIGNED(PyBytes_AS_STRING(v), 2)") : (void)0);
    out = (unsigned short *)((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5400, "PyBytes_Check(v)") : (void)0), (((PyBytesObject *)(v))->ob_sval));
    if (byteorder == 0)
        *out++ = 0xFEFF;
    if (len == 0)
        goto done;

    switch (kind) {
    case PyUnicode_1BYTE_KIND: {
        ucs1lib_utf16_encode(out, (const Py_UCS1 *)data, len, native_ordering);
        break;
    }
    case PyUnicode_2BYTE_KIND: {
        ucs2lib_utf16_encode(out, (const Py_UCS2 *)data, len, native_ordering);
        break;
    }
    case PyUnicode_4BYTE_KIND: {
        ucs4lib_utf16_encode(out, (const Py_UCS4 *)data, len, native_ordering);
        break;
    }
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5420, "0") : (void)0);
    }

  done:
    return v;
}

PyObject *
PyUnicode_EncodeUTF16(const Py_UNICODE *s,
                      Py_ssize_t size,
                      const char *errors,
                      int byteorder)
{
    PyObject *result;
    PyObject *tmp = PyUnicode_FromUnicode(s, size);
    if (tmp == ((void *)0))
        return ((void *)0);
    result = _PyUnicode_EncodeUTF16(tmp, errors, byteorder);
    do { if ( --((PyObject*)(tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(tmp)))); } while (0);
    return result;
}

PyObject *
PyUnicode_AsUTF16String(PyObject *unicode)
{
    return _PyUnicode_EncodeUTF16(unicode, ((void *)0), 0);
}
# 5456 "unicodeobject.c"
static Py_ssize_t
length_of_escaped_ascii_string(const char *s, Py_ssize_t size)
{
    const unsigned char *p = (const unsigned char *)s;
    const unsigned char *end = p + size;
    Py_ssize_t length = 0;

    if (size < 0)
        return -1;

    for (; p < end; ++p) {
        if (*p > 127) {

            return -1;
        }
        else if (*p != '\\') {

            ++length;
        }
        else {

            ++p;


            if (p >= end || *p > 127)
                return -1;
            switch (*p) {
            case '\n':

                break;
            case '\\': case '\'': case '\"':
            case 'b': case 'f': case 't':
            case 'n': case 'r': case 'v': case 'a':
                ++length;
                break;
            case '0': case '1': case '2': case '3':
            case '4': case '5': case '6': case '7':
            case 'x': case 'u': case 'U': case 'N':

                return -1;
            default:

                length += 2;
            }
        }
    }
    return length;
}

static _PyUnicode_Name_CAPI *ucnhash_CAPI = ((void *)0);

PyObject *
PyUnicode_DecodeUnicodeEscape(const char *s,
                              Py_ssize_t size,
                              const char *errors)
{
    const char *starts = s;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    PyObject *v;
    const char *end;
    char* message;
    Py_UCS4 chr = 0xffffffff;
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);
    Py_ssize_t len;
    Py_ssize_t i;

    len = length_of_escaped_ascii_string(s, size);






    if (len >= 0) {
        v = PyUnicode_New(len, 127);
        if (!v)
            goto onError;
        (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5535, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5535, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind) == PyUnicode_1BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5535, "PyUnicode_KIND(v) == PyUnicode_1BYTE_KIND") : (void)0);
    }
    else {





        v = PyUnicode_New(size, 127);
        if (!v)
            goto onError;
        len = size;
    }

    if (size == 0)
        return v;
    i = 0;
    end = s + size;

    while (s < end) {
        unsigned char c;
        Py_UCS4 x;
        int digits;



        (__builtin_expect(!(i <= len), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5561, "i <= len") : (void)0);


        if (*s != '\\') {
            if (unicode_putchar(&v, &i, (unsigned char) *s++) < 0)
                goto onError;
            continue;
        }

        startinpos = s-starts;

        s++;
        c = *s++;
        if (s > end)
            c = '\0';



        (__builtin_expect(!(i < len || (i == len && c == '\n')), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5579, "i < len || (i == len && c == '\\n')") : (void)0);

        switch (c) {
# 5590 "unicodeobject.c"
        case '\n': break;
        case '\\': do { if (unicode_putchar(&v, &i, '\\') < 0) goto onError; }while(0); break;
        case '\'': do { if (unicode_putchar(&v, &i, '\'') < 0) goto onError; }while(0); break;
        case '\"': do { if (unicode_putchar(&v, &i, '\"') < 0) goto onError; }while(0); break;
        case 'b': do { if (unicode_putchar(&v, &i, '\b') < 0) goto onError; }while(0); break;

        case 'f': do { if (unicode_putchar(&v, &i, '\014') < 0) goto onError; }while(0); break;
        case 't': do { if (unicode_putchar(&v, &i, '\t') < 0) goto onError; }while(0); break;
        case 'n': do { if (unicode_putchar(&v, &i, '\n') < 0) goto onError; }while(0); break;
        case 'r': do { if (unicode_putchar(&v, &i, '\r') < 0) goto onError; }while(0); break;

        case 'v': do { if (unicode_putchar(&v, &i, '\013') < 0) goto onError; }while(0); break;

        case 'a': do { if (unicode_putchar(&v, &i, '\007') < 0) goto onError; }while(0); break;


        case '0': case '1': case '2': case '3':
        case '4': case '5': case '6': case '7':
            x = s[-1] - '0';
            if (s < end && '0' <= *s && *s <= '7') {
                x = (x<<3) + *s++ - '0';
                if (s < end && '0' <= *s && *s <= '7')
                    x = (x<<3) + *s++ - '0';
            }
            do { if (unicode_putchar(&v, &i, x) < 0) goto onError; }while(0);
            break;



        case 'x':
            digits = 2;
            message = "truncated \\xXX escape";
            goto hexescape;


        case 'u':
            digits = 4;
            message = "truncated \\uXXXX escape";
            goto hexescape;


        case 'U':
            digits = 8;
            message = "truncated \\UXXXXXXXX escape";
        hexescape:
            chr = 0;
            if (end - s < digits) {

                for (; s < end; ++s) {
                    c = (unsigned char)*s;
                    if (!(_Py_ctype_table[((unsigned char)((c) & 0xff))] & 0x10))
                        goto error;
                }
                goto error;
            }
            for (; digits--; ++s) {
                c = (unsigned char)*s;
                if (!(_Py_ctype_table[((unsigned char)((c) & 0xff))] & 0x10))
                    goto error;
                chr = (chr<<4) & ~0xF;
                if (c >= '0' && c <= '9')
                    chr += c - '0';
                else if (c >= 'a' && c <= 'f')
                    chr += 10 + c - 'a';
                else
                    chr += 10 + c - 'A';
            }
            if (chr == 0xffffffff && PyErr_Occurred())


                break;
        store:

            message = "illegal Unicode character";
            if (chr > 0x10ffff)
                goto error;
            do { if (unicode_putchar(&v, &i, chr) < 0) goto onError; }while(0);
            break;


        case 'N':
            message = "malformed \\N character escape";
            if (ucnhash_CAPI == ((void *)0)) {

                ucnhash_CAPI = (_PyUnicode_Name_CAPI *)PyCapsule_Import(
                                                "unicodedata.ucnhash_CAPI", 1);
                if (ucnhash_CAPI == ((void *)0))
                    goto ucnhashError;
            }
            if (*s == '{') {
                const char *start = s+1;

                while (*s != '}' && s < end)
                    s++;
                if (s > start && s < end && *s == '}') {

                    message = "unknown Unicode character name";
                    s++;
                    if (s - start - 1 <= 2147483647 &&
                        ucnhash_CAPI->getcode(((void *)0), start, (int)(s-start-1),
                                              &chr, 0))
                        goto store;
                }
            }
            goto error;

        default:
            if (s > end) {
                message = "\\ at end of string";
                s--;
                goto error;
            }
            else {
                do { if (unicode_putchar(&v, &i, '\\') < 0) goto onError; }while(0);
                do { if (unicode_putchar(&v, &i, (unsigned char)s[-1]) < 0) goto onError; }while(0);
            }
            break;
        }
        continue;

      error:
        endinpos = s-starts;
        if (unicode_decode_call_errorhandler(
                errors, &errorHandler,
                "unicodeescape", message,
                &starts, &end, &startinpos, &endinpos, &exc, &s,
                &v, &i))
            goto onError;
        len = ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5718, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5718, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length);
        continue;
    }


    if (unicode_resize(&v, i) < 0)
        goto onError;
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return unicode_result(v);

  ucnhashError:
    PyErr_SetString(
        PyExc_UnicodeError,
        "\\N escapes not supported (can't load unicodedata module)"
        );
    do { if ((v) == ((void *)0)) ; else do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);

  onError:
    do { if ((v) == ((void *)0)) ; else do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);
}
# 5753 "unicodeobject.c"
PyObject *
PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
{
    Py_ssize_t i, len;
    PyObject *repr;
    char *p;
    int kind;
    void *data;
    Py_ssize_t expandsize = 0;
# 5771 "unicodeobject.c"
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5775, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);
    len = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5777, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5777, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5778, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5778, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5779, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5779, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5779, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5779, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
    switch (kind) {
    case PyUnicode_1BYTE_KIND: expandsize = 4; break;
    case PyUnicode_2BYTE_KIND: expandsize = 6; break;
    case PyUnicode_4BYTE_KIND: expandsize = 10; break;
    }

    if (len == 0)
        return PyBytes_FromStringAndSize(((void *)0), 0);

    if (len > (((Py_ssize_t)(((size_t)-1)>>1)) - 2 - 1) / expandsize)
        return PyErr_NoMemory();

    repr = PyBytes_FromStringAndSize(((void *)0),
                                     2
                                     + expandsize*len
                                     + 1);
    if (repr == ((void *)0))
        return ((void *)0);

    p = ((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5799, "PyBytes_Check(repr)") : (void)0), (((PyBytesObject *)(repr))->ob_sval));

    for (i = 0; i < len; i++) {
        Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));


        if (ch == '\\') {
            *p++ = '\\';
            *p++ = (char) ch;
            continue;
        }


        else if (ch >= 0x10000) {
            (__builtin_expect(!(ch <= 0x10ffff), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5813, "ch <= MAX_UNICODE") : (void)0);
            *p++ = '\\';
            *p++ = 'U';
            *p++ = Py_hexdigits[(ch >> 28) & 0x0000000F];
            *p++ = Py_hexdigits[(ch >> 24) & 0x0000000F];
            *p++ = Py_hexdigits[(ch >> 20) & 0x0000000F];
            *p++ = Py_hexdigits[(ch >> 16) & 0x0000000F];
            *p++ = Py_hexdigits[(ch >> 12) & 0x0000000F];
            *p++ = Py_hexdigits[(ch >> 8) & 0x0000000F];
            *p++ = Py_hexdigits[(ch >> 4) & 0x0000000F];
            *p++ = Py_hexdigits[ch & 0x0000000F];
            continue;
        }


        if (ch >= 256) {
            *p++ = '\\';
            *p++ = 'u';
            *p++ = Py_hexdigits[(ch >> 12) & 0x000F];
            *p++ = Py_hexdigits[(ch >> 8) & 0x000F];
            *p++ = Py_hexdigits[(ch >> 4) & 0x000F];
            *p++ = Py_hexdigits[ch & 0x000F];
        }


        else if (ch == '\t') {
            *p++ = '\\';
            *p++ = 't';
        }
        else if (ch == '\n') {
            *p++ = '\\';
            *p++ = 'n';
        }
        else if (ch == '\r') {
            *p++ = '\\';
            *p++ = 'r';
        }


        else if (ch < ' ' || ch >= 0x7F) {
            *p++ = '\\';
            *p++ = 'x';
            *p++ = Py_hexdigits[(ch >> 4) & 0x000F];
            *p++ = Py_hexdigits[ch & 0x000F];
        }


        else
            *p++ = (char) ch;
    }

    (__builtin_expect(!(p - ((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5864, "PyBytes_Check(repr)") : (void)0), (((PyBytesObject *)(repr))->ob_sval)) > 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5864, "p - PyBytes_AS_STRING(repr) > 0") : (void)0);
    if (_PyBytes_Resize(&repr, p - ((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 5865, "PyBytes_Check(repr)") : (void)0), (((PyBytesObject *)(repr))->ob_sval))) < 0)
        return ((void *)0);
    return repr;
}

PyObject *
PyUnicode_EncodeUnicodeEscape(const Py_UNICODE *s,
                              Py_ssize_t size)
{
    PyObject *result;
    PyObject *tmp = PyUnicode_FromUnicode(s, size);
    if (tmp == ((void *)0))
        return ((void *)0);
    result = PyUnicode_AsUnicodeEscapeString(tmp);
    do { if ( --((PyObject*)(tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(tmp)))); } while (0);
    return result;
}



PyObject *
PyUnicode_DecodeRawUnicodeEscape(const char *s,
                                 Py_ssize_t size,
                                 const char *errors)
{
    const char *starts = s;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    Py_ssize_t outpos;
    PyObject *v;
    const char *end;
    const char *bs;
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);





    v = PyUnicode_New(size, 127);
    if (v == ((void *)0))
        goto onError;
    if (size == 0)
        return v;
    outpos = 0;
    end = s + size;
    while (s < end) {
        unsigned char c;
        Py_UCS4 x;
        int i;
        int count;


        if (*s != '\\') {
            if (unicode_putchar(&v, &outpos, (unsigned char)*s++) < 0)
                goto onError;
            continue;
        }
        startinpos = s-starts;



        bs = s;
        for (;s < end;) {
            if (*s != '\\')
                break;
            if (unicode_putchar(&v, &outpos, (unsigned char)*s++) < 0)
                goto onError;
        }
        if (((s - bs) & 1) == 0 ||
            s >= end ||
            (*s != 'u' && *s != 'U')) {
            continue;
        }
        outpos--;
        count = *s=='u' ? 4 : 8;
        s++;


        for (x = 0, i = 0; i < count; ++i, ++s) {
            c = (unsigned char)*s;
            if (!(_Py_ctype_table[((unsigned char)((c) & 0xff))] & 0x10)) {
                endinpos = s-starts;
                if (unicode_decode_call_errorhandler(
                        errors, &errorHandler,
                        "rawunicodeescape", "truncated \\uXXXX",
                        &starts, &end, &startinpos, &endinpos, &exc, &s,
                        &v, &outpos))
                    goto onError;
                goto nextByte;
            }
            x = (x<<4) & ~0xF;
            if (c >= '0' && c <= '9')
                x += c - '0';
            else if (c >= 'a' && c <= 'f')
                x += 10 + c - 'a';
            else
                x += 10 + c - 'A';
        }
        if (x <= 0x10ffff) {
            if (unicode_putchar(&v, &outpos, x) < 0)
                goto onError;
        } else {
            endinpos = s-starts;
            if (unicode_decode_call_errorhandler(
                    errors, &errorHandler,
                    "rawunicodeescape", "\\Uxxxxxxxx out of range",
                    &starts, &end, &startinpos, &endinpos, &exc, &s,
                    &v, &outpos))
                goto onError;
        }
      nextByte:
        ;
    }
    if (unicode_resize(&v, outpos) < 0)
        goto onError;
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return unicode_result(v);

  onError:
    do { if ((v) == ((void *)0)) ; else do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);
}


PyObject *
PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
{
    PyObject *repr;
    char *p;
    char *q;
    Py_ssize_t expandsize, pos;
    int kind;
    void *data;
    Py_ssize_t len;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6008, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);
    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6010, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6010, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6011, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6011, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6011, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6011, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6012, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6012, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);


    expandsize = kind * 2 + 2;

    if (len > ((Py_ssize_t)(((size_t)-1)>>1)) / expandsize)
        return PyErr_NoMemory();

    repr = PyBytes_FromStringAndSize(((void *)0), expandsize * len);
    if (repr == ((void *)0))
        return ((void *)0);
    if (len == 0)
        return repr;

    p = q = ((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6026, "PyBytes_Check(repr)") : (void)0), (((PyBytesObject *)(repr))->ob_sval));
    for (pos = 0; pos < len; pos++) {
        Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(pos)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(pos)] : ((const Py_UCS4 *)(data))[(pos)] ) ));

        if (ch >= 0x10000) {
            (__builtin_expect(!(ch <= 0x10ffff), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6031, "ch <= MAX_UNICODE") : (void)0);
            *p++ = '\\';
            *p++ = 'U';
            *p++ = Py_hexdigits[(ch >> 28) & 0xf];
            *p++ = Py_hexdigits[(ch >> 24) & 0xf];
            *p++ = Py_hexdigits[(ch >> 20) & 0xf];
            *p++ = Py_hexdigits[(ch >> 16) & 0xf];
            *p++ = Py_hexdigits[(ch >> 12) & 0xf];
            *p++ = Py_hexdigits[(ch >> 8) & 0xf];
            *p++ = Py_hexdigits[(ch >> 4) & 0xf];
            *p++ = Py_hexdigits[ch & 15];
        }

        else if (ch >= 256) {
            *p++ = '\\';
            *p++ = 'u';
            *p++ = Py_hexdigits[(ch >> 12) & 0xf];
            *p++ = Py_hexdigits[(ch >> 8) & 0xf];
            *p++ = Py_hexdigits[(ch >> 4) & 0xf];
            *p++ = Py_hexdigits[ch & 15];
        }

        else
            *p++ = (char) ch;
    }

    (__builtin_expect(!(p > q), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6057, "p > q") : (void)0);
    if (_PyBytes_Resize(&repr, p - q) < 0)
        return ((void *)0);
    return repr;
}

PyObject *
PyUnicode_EncodeRawUnicodeEscape(const Py_UNICODE *s,
                                 Py_ssize_t size)
{
    PyObject *result;
    PyObject *tmp = PyUnicode_FromUnicode(s, size);
    if (tmp == ((void *)0))
        return ((void *)0);
    result = PyUnicode_AsRawUnicodeEscapeString(tmp);
    do { if ( --((PyObject*)(tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(tmp)))); } while (0);
    return result;
}



PyObject *
_PyUnicode_DecodeUnicodeInternal(const char *s,
                                 Py_ssize_t size,
                                 const char *errors)
{
    const char *starts = s;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    Py_ssize_t outpos;
    PyObject *v;
    const char *end;
    const char *reason;
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);

    if (PyErr_WarnEx(PyExc_DeprecationWarning,
                     "unicode_internal codec has been deprecated",
                     1))
        return ((void *)0);


    v = PyUnicode_New((size+4 -1)/ 4, 127);
    if (v == ((void *)0))
        goto onError;
    if (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6102, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6102, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length) == 0)
        return v;
    outpos = 0;
    end = s + size;

    while (s < end) {
        Py_UNICODE uch;
        Py_UCS4 ch;
        if (end - s < 4) {
            endinpos = end-starts;
            reason = "truncated input";
            goto error;
        }


        ((char *) &uch)[0] = s[0];
        ((char *) &uch)[1] = s[1];

        ((char *) &uch)[2] = s[2];
        ((char *) &uch)[3] = s[3];

        ch = uch;



        if (ch > 0x10ffff) {
            endinpos = s - starts + 4;
            reason = "illegal code point (> 0x10FFFF)";
            goto error;
        }

        s += 4;
# 6148 "unicodeobject.c"
        if (unicode_putchar(&v, &outpos, ch) < 0)
            goto onError;
        continue;

  error:
        startinpos = s - starts;
        if (unicode_decode_call_errorhandler(
                errors, &errorHandler,
                "unicode_internal", reason,
                &starts, &end, &startinpos, &endinpos, &exc, &s,
                &v, &outpos))
            goto onError;
    }

    if (unicode_resize(&v, outpos) < 0)
        goto onError;
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return unicode_result(v);

  onError:
    do { if ((v) == ((void *)0)) ; else do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);
}



PyObject *
PyUnicode_DecodeLatin1(const char *s,
                       Py_ssize_t size,
                       const char *errors)
{

    return _PyUnicode_FromUCS1((unsigned char*)s, size);
}


static void
make_encode_exception(PyObject **exceptionObject,
                      const char *encoding,
                      PyObject *unicode,
                      Py_ssize_t startpos, Py_ssize_t endpos,
                      const char *reason)
{
    if (*exceptionObject == ((void *)0)) {
        *exceptionObject = _PyObject_CallFunction_SizeT(
            PyExc_UnicodeEncodeError, "sOnns",
            encoding, unicode, startpos, endpos, reason);
    }
    else {
        if (PyUnicodeEncodeError_SetStart(*exceptionObject, startpos))
            goto onError;
        if (PyUnicodeEncodeError_SetEnd(*exceptionObject, endpos))
            goto onError;
        if (PyUnicodeEncodeError_SetReason(*exceptionObject, reason))
            goto onError;
        return;
      onError:
        do { if ( --((PyObject*)(*exceptionObject))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*exceptionObject)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*exceptionObject)))); } while (0);
        *exceptionObject = ((void *)0);
    }
}


static void
raise_encode_exception(PyObject **exceptionObject,
                       const char *encoding,
                       PyObject *unicode,
                       Py_ssize_t startpos, Py_ssize_t endpos,
                       const char *reason)
{
    make_encode_exception(exceptionObject,
                          encoding, unicode, startpos, endpos, reason);
    if (*exceptionObject != ((void *)0))
        PyCodec_StrictErrors(*exceptionObject);
}





static PyObject *
unicode_encode_call_errorhandler(const char *errors,
                                 PyObject **errorHandler,
                                 const char *encoding, const char *reason,
                                 PyObject *unicode, PyObject **exceptionObject,
                                 Py_ssize_t startpos, Py_ssize_t endpos,
                                 Py_ssize_t *newpos)
{
    static char *argparse = "On;encoding error handler must return (str/bytes, int) tuple";
    Py_ssize_t len;
    PyObject *restuple;
    PyObject *resunicode;

    if (*errorHandler == ((void *)0)) {
        *errorHandler = PyCodec_LookupError(errors);
        if (*errorHandler == ((void *)0))
            return ((void *)0);
    }

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6250, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);
    len = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6252, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6252, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);

    make_encode_exception(exceptionObject,
                          encoding, unicode, startpos, endpos, reason);
    if (*exceptionObject == ((void *)0))
        return ((void *)0);

    restuple = PyObject_CallFunctionObjArgs(
        *errorHandler, *exceptionObject, ((void *)0));
    if (restuple == ((void *)0))
        return ((void *)0);
    if (!((((((PyObject*)(restuple))->ob_type))->tp_flags & ((1L<<26))) != 0)) {
        PyErr_SetString(PyExc_TypeError, &argparse[3]);
        do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
        return ((void *)0);
    }
    if (!_PyArg_ParseTuple_SizeT(restuple, argparse,
                          &resunicode, newpos)) {
        do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
        return ((void *)0);
    }
    if (!((((((PyObject*)(resunicode))->ob_type))->tp_flags & ((1L<<28))) != 0) && !((((((PyObject*)(resunicode))->ob_type))->tp_flags & ((1L<<27))) != 0)) {
        PyErr_SetString(PyExc_TypeError, &argparse[3]);
        do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
        return ((void *)0);
    }
    if (*newpos<0)
        *newpos = len + *newpos;
    if (*newpos<0 || *newpos>len) {
        PyErr_Format(PyExc_IndexError, "position %zd from error handler out of bounds", *newpos);
        do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
        return ((void *)0);
    }
    ( ((PyObject*)(resunicode))->ob_refcnt++);
    do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
    return resunicode;
}

static PyObject *
unicode_encode_ucs1(PyObject *unicode,
                    const char *errors,
                    unsigned int limit)
{

    Py_ssize_t pos=0, size;
    int kind;
    void *data;

    PyObject *res;

    char *str;

    Py_ssize_t ressize;
    const char *encoding = (limit == 256) ? "latin-1" : "ascii";
    const char *reason = (limit == 256) ? "ordinal not in range(256)" : "ordinal not in range(128)";
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);


    int known_errorHandler = -1;

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6313, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);
    size = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6315, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6315, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6316, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6316, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6317, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6317, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6317, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6317, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));


    if (size == 0)
        return PyBytes_FromStringAndSize(((void *)0), 0);
    res = PyBytes_FromStringAndSize(((void *)0), size);
    if (res == ((void *)0))
        return ((void *)0);
    str = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6325, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval));
    ressize = size;

    while (pos < size) {
        Py_UCS4 c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(pos)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(pos)] : ((const Py_UCS4 *)(data))[(pos)] ) ));


        if (c<limit) {

            *str++ = (char)c;
            ++pos;
        }
        else {
            Py_ssize_t requiredsize;
            PyObject *repunicode;
            Py_ssize_t repsize, newpos, respos, i;

            Py_ssize_t collstart = pos;
            Py_ssize_t collend = pos;

            while ((collend < size) && (((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(collend)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(collend)] : ((const Py_UCS4 *)(data))[(collend)] ) ))>=limit))
                ++collend;

            if (known_errorHandler==-1) {
                if ((errors==((void *)0)) || (!strcmp(errors, "strict")))
                    known_errorHandler = 1;
                else if (!strcmp(errors, "replace"))
                    known_errorHandler = 2;
                else if (!strcmp(errors, "ignore"))
                    known_errorHandler = 3;
                else if (!strcmp(errors, "xmlcharrefreplace"))
                    known_errorHandler = 4;
                else
                    known_errorHandler = 0;
            }
            switch (known_errorHandler) {
            case 1:
                raise_encode_exception(&exc, encoding, unicode, collstart, collend, reason);
                goto onError;
            case 2:
                while (collstart++<collend)
                    *str++ = '?';
            case 3:
                pos = collend;
                break;
            case 4:
                respos = str - ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6371, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval));

                for (i = collstart, repsize = 0; i < collend; ++i) {
                    Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
                    if (ch < 10)
                        repsize += 2+1+1;
                    else if (ch < 100)
                        repsize += 2+2+1;
                    else if (ch < 1000)
                        repsize += 2+3+1;
                    else if (ch < 10000)
                        repsize += 2+4+1;
                    else if (ch < 100000)
                        repsize += 2+5+1;
                    else if (ch < 1000000)
                        repsize += 2+6+1;
                    else {
                        (__builtin_expect(!(ch <= 0x10ffff), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6388, "ch <= MAX_UNICODE") : (void)0);
                        repsize += 2+7+1;
                    }
                }
                requiredsize = respos+repsize+(size-collend);
                if (requiredsize > ressize) {
                    if (requiredsize<2*ressize)
                        requiredsize = 2*ressize;
                    if (_PyBytes_Resize(&res, requiredsize))
                        goto onError;
                    str = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6398, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval)) + respos;
                    ressize = requiredsize;
                }

                for (i = collstart; i < collend; ++i) {
                    str += __builtin___sprintf_chk (str, 0, __builtin_object_size (str, 2 > 1), "&#%d;", ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) )));
                }
                pos = collend;
                break;
            default:
                repunicode = unicode_encode_call_errorhandler(errors, &errorHandler,
                                                              encoding, reason, unicode, &exc,
                                                              collstart, collend, &newpos);
                if (repunicode == ((void *)0) || (((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0) &&
                                           ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6412, "_PyUnicode_CHECK(repunicode)") : (void)0), ((((PyASCIIObject*)repunicode)->state.ready) ? 0 : _PyUnicode_Ready(repunicode))) == -1))
                    goto onError;
                if (((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<27))) != 0)) {

                    repsize = PyBytes_Size(repunicode);
                    if (repsize > 1) {

                        respos = str - ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6419, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval));
                        if (_PyBytes_Resize(&res, ressize+repsize-1)) {
                            do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                            goto onError;
                        }
                        str = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6424, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval)) + respos;
                        ressize += repsize-1;
                    }
                    ((__builtin_object_size (str, 0) != (size_t) -1) ? __builtin___memcpy_chk (str, PyBytes_AsString(repunicode), repsize, __builtin_object_size (str, 0)) : __inline_memcpy_chk (str, PyBytes_AsString(repunicode), repsize));
                    str += repsize;
                    pos = newpos;
                    do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                    break;
                }



                respos = str - ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6436, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval));
                repsize = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6437, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6437, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject *)(repunicode))->length);
                requiredsize = respos+repsize+(size-collend);
                if (requiredsize > ressize) {
                    if (requiredsize<2*ressize)
                        requiredsize = 2*ressize;
                    if (_PyBytes_Resize(&res, requiredsize)) {
                        do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                        goto onError;
                    }
                    str = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6446, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval)) + respos;
                    ressize = requiredsize;
                }


                for (i = 0; repsize-->0; ++i, ++str) {
                    c = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_IS_READY(repunicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject *)((repunicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (((PyASCIIObject*)((repunicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject*)(repunicode))->state.ascii) ? ((void*)((PyASCIIObject*)((repunicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((repunicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((repunicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "((PyUnicodeObject*)((repunicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((repunicode)))->data.any))))))[(i)] : (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject *)((repunicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (((PyASCIIObject*)((repunicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject*)(repunicode))->state.ascii) ? ((void*)((PyASCIIObject*)((repunicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((repunicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((repunicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "((PyUnicodeObject*)((repunicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((repunicode)))->data.any))))))[(i)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (((PyASCIIObject*)((repunicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject*)(repunicode))->state.ascii) ? ((void*)((PyASCIIObject*)((repunicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((repunicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((repunicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6452, "((PyUnicodeObject*)((repunicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((repunicode)))->data.any))))))[(i)] ) ));
                    if (c >= limit) {
                        raise_encode_exception(&exc, encoding, unicode,
                                               pos, pos+1, reason);
                        do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                        goto onError;
                    }
                    *str = (char)c;
                }
                pos = newpos;
                do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
            }
        }
    }

    size = str - ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6467, "PyBytes_Check(res)") : (void)0), (((PyBytesObject *)(res))->ob_sval));
    if (size < ressize) {
        (__builtin_expect(!(size >= 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6469, "size >= 0") : (void)0);
        if (_PyBytes_Resize(&res, size) < 0)
            goto onError;
    }

    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return res;

  onError:
    do { if ((res) == ((void *)0)) ; else do { if ( --((PyObject*)(res))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(res)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(res)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);
}


PyObject *
PyUnicode_EncodeLatin1(const Py_UNICODE *p,
                       Py_ssize_t size,
                       const char *errors)
{
    PyObject *result;
    PyObject *unicode = PyUnicode_FromUnicode(p, size);
    if (unicode == ((void *)0))
        return ((void *)0);
    result = unicode_encode_ucs1(unicode, errors, 256);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return result;
}

PyObject *
_PyUnicode_AsLatin1String(PyObject *unicode, const char *errors)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6507, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);


    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6511, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6511, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND)
        return PyBytes_FromStringAndSize(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6512, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6512, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6512, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6512, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))),
                                         ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6513, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6513, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length));


    return unicode_encode_ucs1(unicode, errors, 256);
}

PyObject*
PyUnicode_AsLatin1String(PyObject *unicode)
{
    return _PyUnicode_AsLatin1String(unicode, ((void *)0));
}



PyObject *
PyUnicode_DecodeASCII(const char *s,
                      Py_ssize_t size,
                      const char *errors)
{
    const char *starts = s;
    PyObject *unicode;
    int kind;
    void *data;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    Py_ssize_t outpos;
    const char *e;
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);

    if (size == 0)
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6544, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);


    if (size == 1 && (unsigned char)s[0] < 128)
        return get_latin1_char((unsigned char)s[0]);

    unicode = PyUnicode_New(size, 127);
    if (unicode == ((void *)0))
        goto onError;

    e = s + size;
    data = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6555, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6555, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6555, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6555, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))));
    outpos = ascii_decode(s, e, (Py_UCS1 *)data);
    if (outpos == size)
        return unicode;

    s += outpos;
    kind = PyUnicode_1BYTE_KIND;
    while (s < e) {
        register unsigned char c = (unsigned char)*s;
        if (c < 128) {
            do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(outpos++)] = (Py_UCS1)(c); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(outpos++)] = (Py_UCS2)(c); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6565, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(outpos++)] = (Py_UCS4)(c); } } } while (0);
            ++s;
        }
        else {
            startinpos = s-starts;
            endinpos = startinpos + 1;
            if (unicode_decode_call_errorhandler(
                    errors, &errorHandler,
                    "ascii", "ordinal not in range(128)",
                    &starts, &e, &startinpos, &endinpos, &exc, &s,
                    &unicode, &outpos))
                goto onError;
            kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6577, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6577, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
            data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6578, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6578, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6578, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6578, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
        }
    }
    if (unicode_resize(&unicode, outpos) < 0)
        goto onError;
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6585, "_PyUnicode_CheckConsistency(unicode, 1)") : (void)0);
    return unicode;

  onError:
    do { if ((unicode) == ((void *)0)) ; else do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return ((void *)0);
}


PyObject *
PyUnicode_EncodeASCII(const Py_UNICODE *p,
                      Py_ssize_t size,
                      const char *errors)
{
    PyObject *result;
    PyObject *unicode = PyUnicode_FromUnicode(p, size);
    if (unicode == ((void *)0))
        return ((void *)0);
    result = unicode_encode_ucs1(unicode, errors, 128);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return result;
}

PyObject *
_PyUnicode_AsASCIIString(PyObject *unicode, const char *errors)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6617, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);


    if (((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6621, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6621, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6621, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6621, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6621, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6621, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6621, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))) < 128)
        return PyBytes_FromStringAndSize(((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6622, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6622, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6622, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6622, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))),
                                         ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6623, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 6623, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length));
    return unicode_encode_ucs1(unicode, errors, 128);
}

PyObject *
PyUnicode_AsASCIIString(PyObject *unicode)
{
    return _PyUnicode_AsASCIIString(unicode, ((void *)0));
}
# 7383 "unicodeobject.c"
PyObject *
PyUnicode_DecodeCharmap(const char *s,
                        Py_ssize_t size,
                        PyObject *mapping,
                        const char *errors)
{
    const char *starts = s;
    Py_ssize_t startinpos;
    Py_ssize_t endinpos;
    Py_ssize_t outpos;
    const char *e;
    PyObject *v;
    Py_ssize_t extrachars = 0;
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);


    if (mapping == ((void *)0))
        return PyUnicode_DecodeLatin1(s, size, errors);

    v = PyUnicode_New(size, 127);
    if (v == ((void *)0))
        goto onError;
    if (size == 0)
        return v;
    outpos = 0;
    e = s + size;
    if (((((PyObject*)(mapping))->ob_type) == &PyUnicode_Type)) {
        Py_ssize_t maplen;
        enum PyUnicode_Kind mapkind;
        void *mapdata;
        Py_UCS4 x;

        if (((__builtin_expect(!(((((((PyObject*)(mapping))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7416, "_PyUnicode_CHECK(mapping)") : (void)0), ((((PyASCIIObject*)mapping)->state.ready) ? 0 : _PyUnicode_Ready(mapping))) == -1)
            return ((void *)0);

        maplen = ((__builtin_expect(!(((((((PyObject*)(mapping))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7419, "PyUnicode_Check(mapping)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)mapping)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7419, "PyUnicode_IS_READY(mapping)") : (void)0), ((PyASCIIObject *)(mapping))->length);
        mapdata = ((__builtin_expect(!(((((((PyObject*)(mapping))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7420, "PyUnicode_Check(mapping)") : (void)0), (((PyASCIIObject*)(mapping))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(mapping))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7420, "PyUnicode_Check(mapping)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)mapping)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7420, "PyUnicode_IS_READY(mapping)") : (void)0), ((PyASCIIObject*)mapping)->state.ascii) ? ((void*)((PyASCIIObject*)(mapping) + 1)) : ((void*)((PyCompactUnicodeObject*)(mapping) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(mapping))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7420, "((PyUnicodeObject*)(mapping))->data.any") : (void)0), ((((PyUnicodeObject *)(mapping))->data.any))));
        mapkind = ((__builtin_expect(!(((((((PyObject*)(mapping))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7421, "PyUnicode_Check(mapping)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)mapping)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7421, "PyUnicode_IS_READY(mapping)") : (void)0), ((PyASCIIObject *)(mapping))->state.kind);
        while (s < e) {
            unsigned char ch;
            if (mapkind == PyUnicode_2BYTE_KIND && maplen >= 256) {
                enum PyUnicode_Kind outkind = ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7425, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7425, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind);
                if (outkind == PyUnicode_1BYTE_KIND) {
                    void *outdata = ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7427, "PyUnicode_Check(v)") : (void)0), (((PyASCIIObject*)(v))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7427, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7427, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? ((void*)((PyASCIIObject*)(v) + 1)) : ((void*)((PyCompactUnicodeObject*)(v) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(v))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7427, "((PyUnicodeObject*)(v))->data.any") : (void)0), ((((PyUnicodeObject *)(v))->data.any))));
                    Py_UCS4 maxchar = ((__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7428, "PyUnicode_IS_READY(v)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7428, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7428, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7428, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7428, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7428, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7428, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
                    while (s < e) {
                        unsigned char ch = *s;
                        x = ((Py_UCS4) ((PyUnicode_2BYTE_KIND) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(mapdata))[(ch)] : ((PyUnicode_2BYTE_KIND) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(mapdata))[(ch)] : ((const Py_UCS4 *)(mapdata))[(ch)] ) ));
                        if (x > maxchar)
                            goto Error;
                        do { switch ((PyUnicode_1BYTE_KIND)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(outdata))[(outpos++)] = (Py_UCS1)(x); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(outdata))[(outpos++)] = (Py_UCS2)(x); break; } default: { (__builtin_expect(!((PyUnicode_1BYTE_KIND) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7434, "(PyUnicode_1BYTE_KIND) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(outdata))[(outpos++)] = (Py_UCS4)(x); } } } while (0);
                        ++s;
                    }
                    break;
                }
                else if (outkind == PyUnicode_2BYTE_KIND) {
                    void *outdata = ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7440, "PyUnicode_Check(v)") : (void)0), (((PyASCIIObject*)(v))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7440, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7440, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? ((void*)((PyASCIIObject*)(v) + 1)) : ((void*)((PyCompactUnicodeObject*)(v) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(v))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7440, "((PyUnicodeObject*)(v))->data.any") : (void)0), ((((PyUnicodeObject *)(v))->data.any))));
                    while (s < e) {
                        unsigned char ch = *s;
                        x = ((Py_UCS4) ((PyUnicode_2BYTE_KIND) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(mapdata))[(ch)] : ((PyUnicode_2BYTE_KIND) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(mapdata))[(ch)] : ((const Py_UCS4 *)(mapdata))[(ch)] ) ));
                        if (x == 0xFFFE)
                            goto Error;
                        do { switch ((PyUnicode_2BYTE_KIND)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(outdata))[(outpos++)] = (Py_UCS1)(x); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(outdata))[(outpos++)] = (Py_UCS2)(x); break; } default: { (__builtin_expect(!((PyUnicode_2BYTE_KIND) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7446, "(PyUnicode_2BYTE_KIND) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(outdata))[(outpos++)] = (Py_UCS4)(x); } } } while (0);
                        ++s;
                    }
                    break;
                }
            }
            ch = *s;

            if (ch < maplen)
                x = ((Py_UCS4) ((mapkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(mapdata))[(ch)] : ((mapkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(mapdata))[(ch)] : ((const Py_UCS4 *)(mapdata))[(ch)] ) ));
            else
                x = 0xfffe;
Error:
            if (x == 0xfffe)
            {

                startinpos = s-starts;
                endinpos = startinpos+1;
                if (unicode_decode_call_errorhandler(
                        errors, &errorHandler,
                        "charmap", "character maps to <undefined>",
                        &starts, &e, &startinpos, &endinpos, &exc, &s,
                        &v, &outpos)) {
                    goto onError;
                }
                continue;
            }

            if (unicode_putchar(&v, &outpos, x) < 0)
                goto onError;
            ++s;
        }
    }
    else {
        while (s < e) {
            unsigned char ch = *s;
            PyObject *w, *x;


            w = PyLong_FromLong((long)ch);
            if (w == ((void *)0))
                goto onError;
            x = PyObject_GetItem(mapping, w);
            do { if ( --((PyObject*)(w))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(w)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(w)))); } while (0);
            if (x == ((void *)0)) {
                if (PyErr_ExceptionMatches(PyExc_LookupError)) {

                    PyErr_Clear();
                    goto Undefined;
                } else
                    goto onError;
            }


            if (x == (&_Py_NoneStruct))
                goto Undefined;
            if (((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
                long value = PyLong_AsLong(x);
                if (value == 0xFFFE)
                    goto Undefined;
                if (value < 0 || value > 0x10ffff) {
                    PyErr_Format(PyExc_TypeError,
                                 "character mapping must be in range(0x%lx)",
                                 (unsigned long)0x10ffff + 1);
                    do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
                    goto onError;
                }
                if (unicode_putchar(&v, &outpos, value) < 0) {
                    do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
                    goto onError;
                }
            }
            else if (((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
                Py_ssize_t targetsize;

                if (((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7521, "_PyUnicode_CHECK(x)") : (void)0), ((((PyASCIIObject*)x)->state.ready) ? 0 : _PyUnicode_Ready(x))) == -1) {
                    do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
                    goto onError;
                }
                targetsize = ((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7525, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7525, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject *)(x))->length);

                if (targetsize == 1) {

                    Py_UCS4 value = ((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_IS_READY(x)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(x))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_IS_READY((x))") : (void)0), ((PyASCIIObject *)((x)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (((PyASCIIObject*)((x)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(x))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_IS_READY((x))") : (void)0), ((PyASCIIObject*)(x))->state.ascii) ? ((void*)((PyASCIIObject*)((x)) + 1)) : ((void*)((PyCompactUnicodeObject*)((x)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((x)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "((PyUnicodeObject*)((x)))->data.any") : (void)0), ((((PyUnicodeObject *)((x)))->data.any))))))[(0)] : (((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(x))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_IS_READY((x))") : (void)0), ((PyASCIIObject *)((x)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (((PyASCIIObject*)((x)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(x))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_IS_READY((x))") : (void)0), ((PyASCIIObject*)(x))->state.ascii) ? ((void*)((PyASCIIObject*)((x)) + 1)) : ((void*)((PyCompactUnicodeObject*)((x)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((x)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "((PyUnicodeObject*)((x)))->data.any") : (void)0), ((((PyUnicodeObject *)((x)))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (((PyASCIIObject*)((x)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((x)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_Check((x))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(x))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "PyUnicode_IS_READY((x))") : (void)0), ((PyASCIIObject*)(x))->state.ascii) ? ((void*)((PyASCIIObject*)((x)) + 1)) : ((void*)((PyCompactUnicodeObject*)((x)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((x)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7529, "((PyUnicodeObject*)((x)))->data.any") : (void)0), ((((PyUnicodeObject *)((x)))->data.any))))))[(0)] ) ));
                    if (value == 0xFFFE)
                        goto Undefined;
                    if (unicode_putchar(&v, &outpos, value) < 0) {
                        do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
                        goto onError;
                    }
                }
                else if (targetsize > 1) {

                    if (targetsize > extrachars) {

                        Py_ssize_t needed = (targetsize - extrachars) + (targetsize << 2);

                        extrachars += needed;

                        if (unicode_resize(&v,
                                           ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7546, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7546, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length) + needed) < 0)
                        {
                            do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
                            goto onError;
                        }
                    }
                    if (unicode_widen(&v, outpos,
                                      ((__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7553, "PyUnicode_IS_READY(x)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7553, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7553, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject*)x)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7553, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7553, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject *)(x))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7553, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7553, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject *)(x))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))))) < 0) {
                        do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
                        goto onError;
                    }
                    PyUnicode_CopyCharacters(v, outpos, x, 0, targetsize);
                    outpos += targetsize;
                    extrachars -= targetsize;
                }

            }
            else {

                PyErr_SetString(PyExc_TypeError,
                                "character mapping must return integer, None or str");
                do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
                goto onError;
            }
            do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
            ++s;
            continue;
Undefined:

            do { if ((x) == ((void *)0)) ; else do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0); } while (0);
            startinpos = s-starts;
            endinpos = startinpos+1;
            if (unicode_decode_call_errorhandler(
                    errors, &errorHandler,
                    "charmap", "character maps to <undefined>",
                    &starts, &e, &startinpos, &endinpos, &exc, &s,
                    &v, &outpos)) {
                goto onError;
            }
        }
    }
    if (unicode_resize(&v, outpos) < 0)
        goto onError;
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    return unicode_result(v);

  onError:
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((v) == ((void *)0)) ; else do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0); } while (0);
    return ((void *)0);
}



struct encoding_map {
    PyObject ob_base;
    unsigned char level1[32];
    int count2, count3;
    unsigned char level23[1];
};

static PyObject*
encoding_map_size(PyObject *obj, PyObject* args)
{
    struct encoding_map *map = (struct encoding_map*)obj;
    return PyLong_FromLong(sizeof(*map) - 1 + 16*map->count2 +
                           128*map->count3);
}

static PyMethodDef encoding_map_methods[] = {
    {"size", encoding_map_size, 0x0004,
     "Return the size (in bytes) of this object" },
    { 0 }
};

static void
encoding_map_dealloc(PyObject* o)
{
    PyObject_Free(o);
}

static PyTypeObject EncodingMapType = {
    { { 1, ((void *)0) }, 0 },
    "EncodingMap",
    sizeof(struct encoding_map),
    0,

    encoding_map_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    ( 0 | (1L<<18) | 0),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    encoding_map_methods,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

PyObject*
PyUnicode_BuildEncodingMap(PyObject* string)
{
    PyObject *result;
    struct encoding_map *mresult;
    int i;
    int need_dict = 0;
    unsigned char level1[32];
    unsigned char level2[512];
    unsigned char *mlevel1, *mlevel2, *mlevel3;
    int count2 = 0, count3 = 0;
    int kind;
    void *data;
    Py_ssize_t length;
    Py_UCS4 ch;

    if (!((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0) || !((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7689, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7689, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    kind = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7693, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7693, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7694, "PyUnicode_Check(string)") : (void)0), (((PyASCIIObject*)(string))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7694, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7694, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii) ? ((void*)((PyASCIIObject*)(string) + 1)) : ((void*)((PyCompactUnicodeObject*)(string) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(string))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7694, "((PyUnicodeObject*)(string))->data.any") : (void)0), ((((PyUnicodeObject *)(string))->data.any))));
    length = ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7695, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7695, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length);
    length = (((length) > (256)) ? (256) : (length));
    ((__builtin_object_size (level1, 0) != (size_t) -1) ? __builtin___memset_chk (level1, 0xFF, sizeof level1, __builtin_object_size (level1, 0)) : __inline_memset_chk (level1, 0xFF, sizeof level1));
    ((__builtin_object_size (level2, 0) != (size_t) -1) ? __builtin___memset_chk (level2, 0xFF, sizeof level2, __builtin_object_size (level2, 0)) : __inline_memset_chk (level2, 0xFF, sizeof level2));




    if (((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) )) != 0)
        need_dict = 1;
    for (i = 1; i < length; i++) {
        int l1, l2;
        ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        if (ch == 0 || ch > 0xFFFF) {
            need_dict = 1;
            break;
        }
        if (ch == 0xFFFE)

            continue;
        l1 = ch >> 11;
        l2 = ch >> 7;
        if (level1[l1] == 0xFF)
            level1[l1] = count2++;
        if (level2[l2] == 0xFF)
            level2[l2] = count3++;
    }

    if (count2 >= 0xFF || count3 >= 0xFF)
        need_dict = 1;

    if (need_dict) {
        PyObject *result = PyDict_New();
        PyObject *key, *value;
        if (!result)
            return ((void *)0);
        for (i = 0; i < length; i++) {
            key = PyLong_FromLong(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) )));
            value = PyLong_FromLong(i);
            if (!key || !value)
                goto failed1;
            if (PyDict_SetItem(result, key, value) == -1)
                goto failed1;
            do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0);
            do { if ( --((PyObject*)(value))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(value)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(value)))); } while (0);
        }
        return result;
      failed1:
        do { if ((key) == ((void *)0)) ; else do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0); } while (0);
        do { if ((value) == ((void *)0)) ; else do { if ( --((PyObject*)(value))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(value)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(value)))); } while (0); } while (0);
        do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0);
        return ((void *)0);
    }


    result = PyObject_Malloc(sizeof(struct encoding_map) +
                             16*count2 + 128*count3 - 1);
    if (!result)
        return PyErr_NoMemory();
    PyObject_Init(result, &EncodingMapType);
    mresult = (struct encoding_map*)result;
    mresult->count2 = count2;
    mresult->count3 = count3;
    mlevel1 = mresult->level1;
    mlevel2 = mresult->level23;
    mlevel3 = mresult->level23 + 16*count2;
    ((__builtin_object_size (mlevel1, 0) != (size_t) -1) ? __builtin___memcpy_chk (mlevel1, level1, 32, __builtin_object_size (mlevel1, 0)) : __inline_memcpy_chk (mlevel1, level1, 32));
    ((__builtin_object_size (mlevel2, 0) != (size_t) -1) ? __builtin___memset_chk (mlevel2, 0xFF, 16*count2, __builtin_object_size (mlevel2, 0)) : __inline_memset_chk (mlevel2, 0xFF, 16*count2));
    ((__builtin_object_size (mlevel3, 0) != (size_t) -1) ? __builtin___memset_chk (mlevel3, 0, 128*count3, __builtin_object_size (mlevel3, 0)) : __inline_memset_chk (mlevel3, 0, 128*count3));
    count3 = 0;
    for (i = 1; i < length; i++) {
        int o1, o2, o3, i2, i3;
        Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        if (ch == 0xFFFE)

            continue;
        o1 = ch>>11;
        o2 = (ch>>7) & 0xF;
        i2 = 16*mlevel1[o1] + o2;
        if (mlevel2[i2] == 0xFF)
            mlevel2[i2] = count3++;
        o3 = ch & 0x7F;
        i3 = 128*mlevel2[i2] + o3;
        mlevel3[i3] = i;
    }
    return result;
}

static int
encoding_map_lookup(Py_UCS4 c, PyObject *mapping)
{
    struct encoding_map *map = (struct encoding_map*)mapping;
    int l1 = c>>11;
    int l2 = (c>>7) & 0xF;
    int l3 = c & 0x7F;
    int i;

    if (c > 0xFFFF)
        return -1;
    if (c == 0)
        return 0;

    i = map->level1[l1];
    if (i == 0xFF) {
        return -1;
    }

    i = map->level23[16*i+l2];
    if (i == 0xFF) {
        return -1;
    }

    i = map->level23[16*map->count2 + 128*i + l3];
    if (i == 0) {
        return -1;
    }
    return i;
}




static PyObject *
charmapencode_lookup(Py_UCS4 c, PyObject *mapping)
{
    PyObject *w = PyLong_FromLong((long)c);
    PyObject *x;

    if (w == ((void *)0))
        return ((void *)0);
    x = PyObject_GetItem(mapping, w);
    do { if ( --((PyObject*)(w))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(w)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(w)))); } while (0);
    if (x == ((void *)0)) {
        if (PyErr_ExceptionMatches(PyExc_LookupError)) {

            PyErr_Clear();
            x = (&_Py_NoneStruct);
            ( ((PyObject*)(x))->ob_refcnt++);
            return x;
        } else
            return ((void *)0);
    }
    else if (x == (&_Py_NoneStruct))
        return x;
    else if (((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
        long value = PyLong_AsLong(x);
        if (value < 0 || value > 255) {
            PyErr_SetString(PyExc_TypeError,
                            "character mapping must be in range(256)");
            do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
            return ((void *)0);
        }
        return x;
    }
    else if (((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<27))) != 0))
        return x;
    else {

        PyErr_Format(PyExc_TypeError,
                     "character mapping must return integer, bytes or None, not %.400s",
                     x->ob_type->tp_name);
        do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
        return ((void *)0);
    }
}

static int
charmapencode_resize(PyObject **outobj, Py_ssize_t *outpos, Py_ssize_t requiredsize)
{
    Py_ssize_t outsize = ((__builtin_expect(!(((((((PyObject*)(*outobj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7864, "PyBytes_Check(*outobj)") : (void)0),(((PyVarObject*)(*outobj))->ob_size));

    if (requiredsize < 2*outsize)
        requiredsize = 2*outsize;
    if (_PyBytes_Resize(outobj, requiredsize))
        return -1;
    return 0;
}

typedef enum charmapencode_result {
    enc_SUCCESS, enc_FAILED, enc_EXCEPTION
} charmapencode_result;






static charmapencode_result
charmapencode_output(Py_UCS4 c, PyObject *mapping,
                     PyObject **outobj, Py_ssize_t *outpos)
{
    PyObject *rep;
    char *outstart;
    Py_ssize_t outsize = ((__builtin_expect(!(((((((PyObject*)(*outobj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7888, "PyBytes_Check(*outobj)") : (void)0),(((PyVarObject*)(*outobj))->ob_size));

    if ((((PyObject*)(mapping))->ob_type) == &EncodingMapType) {
        int res = encoding_map_lookup(c, mapping);
        Py_ssize_t requiredsize = *outpos+1;
        if (res == -1)
            return enc_FAILED;
        if (outsize<requiredsize)
            if (charmapencode_resize(outobj, outpos, requiredsize))
                return enc_EXCEPTION;
        outstart = ((__builtin_expect(!(((((((PyObject*)(*outobj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7898, "PyBytes_Check(*outobj)") : (void)0), (((PyBytesObject *)(*outobj))->ob_sval));
        outstart[(*outpos)++] = (char)res;
        return enc_SUCCESS;
    }

    rep = charmapencode_lookup(c, mapping);
    if (rep==((void *)0))
        return enc_EXCEPTION;
    else if (rep==(&_Py_NoneStruct)) {
        do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0);
        return enc_FAILED;
    } else {
        if (((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
            Py_ssize_t requiredsize = *outpos+1;
            if (outsize<requiredsize)
                if (charmapencode_resize(outobj, outpos, requiredsize)) {
                    do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0);
                    return enc_EXCEPTION;
                }
            outstart = ((__builtin_expect(!(((((((PyObject*)(*outobj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7917, "PyBytes_Check(*outobj)") : (void)0), (((PyBytesObject *)(*outobj))->ob_sval));
            outstart[(*outpos)++] = (char)PyLong_AsLong(rep);
        }
        else {
            const char *repchars = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7921, "PyBytes_Check(rep)") : (void)0), (((PyBytesObject *)(rep))->ob_sval));
            Py_ssize_t repsize = ((__builtin_expect(!(((((((PyObject*)(rep))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7922, "PyBytes_Check(rep)") : (void)0),(((PyVarObject*)(rep))->ob_size));
            Py_ssize_t requiredsize = *outpos+repsize;
            if (outsize<requiredsize)
                if (charmapencode_resize(outobj, outpos, requiredsize)) {
                    do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0);
                    return enc_EXCEPTION;
                }
            outstart = ((__builtin_expect(!(((((((PyObject*)(*outobj))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7929, "PyBytes_Check(*outobj)") : (void)0), (((PyBytesObject *)(*outobj))->ob_sval));
            ((__builtin_object_size (outstart + *outpos, 0) != (size_t) -1) ? __builtin___memcpy_chk (outstart + *outpos, repchars, repsize, __builtin_object_size (outstart + *outpos, 0)) : __inline_memcpy_chk (outstart + *outpos, repchars, repsize));
            *outpos += repsize;
        }
    }
    do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0);
    return enc_SUCCESS;
}



static int
charmap_encoding_error(
    PyObject *unicode, Py_ssize_t *inpos, PyObject *mapping,
    PyObject **exceptionObject,
    int *known_errorHandler, PyObject **errorHandler, const char *errors,
    PyObject **res, Py_ssize_t *respos)
{
    PyObject *repunicode = ((void *)0);
    Py_ssize_t size, repsize;
    Py_ssize_t newpos;
    enum PyUnicode_Kind kind;
    void *data;
    Py_ssize_t index;

    Py_ssize_t collstartpos = *inpos;
    Py_ssize_t collendpos = *inpos+1;
    Py_ssize_t collpos;
    char *encoding = "charmap";
    char *reason = "character maps to <undefined>";
    charmapencode_result x;
    Py_UCS4 ch;
    int val;

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7963, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return -1;
    size = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7965, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7965, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);

    while (collendpos < size) {
        PyObject *rep;
        if ((((PyObject*)(mapping))->ob_type) == &EncodingMapType) {
            ch = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_IS_READY(unicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collendpos)] : (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collendpos)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7970, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collendpos)] ) ));
            val = encoding_map_lookup(ch, mapping);
            if (val != -1)
                break;
            ++collendpos;
            continue;
        }

        ch = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_IS_READY(unicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collendpos)] : (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collendpos)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 7978, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collendpos)] ) ));
        rep = charmapencode_lookup(ch, mapping);
        if (rep==((void *)0))
            return -1;
        else if (rep!=(&_Py_NoneStruct)) {
            do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0);
            break;
        }
        do { if ( --((PyObject*)(rep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(rep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(rep)))); } while (0);
        ++collendpos;
    }


    if (*known_errorHandler==-1) {
        if ((errors==((void *)0)) || (!strcmp(errors, "strict")))
            *known_errorHandler = 1;
        else if (!strcmp(errors, "replace"))
            *known_errorHandler = 2;
        else if (!strcmp(errors, "ignore"))
            *known_errorHandler = 3;
        else if (!strcmp(errors, "xmlcharrefreplace"))
            *known_errorHandler = 4;
        else
            *known_errorHandler = 0;
    }
    switch (*known_errorHandler) {
    case 1:
        raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);
        return -1;
    case 2:
        for (collpos = collstartpos; collpos<collendpos; ++collpos) {
            x = charmapencode_output('?', mapping, res, respos);
            if (x==enc_EXCEPTION) {
                return -1;
            }
            else if (x==enc_FAILED) {
                raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);
                return -1;
            }
        }

    case 3:
        *inpos = collendpos;
        break;
    case 4:

        for (collpos = collstartpos; collpos < collendpos; ++collpos) {
            char buffer[2+29+1+1];
            char *cp;
            __builtin___sprintf_chk (buffer, 0, __builtin_object_size (buffer, 2 > 1), "&#%d;", (int)((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_IS_READY(unicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collpos)] : (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collpos)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8027, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(collpos)] ) )));
            for (cp = buffer; *cp; ++cp) {
                x = charmapencode_output(*cp, mapping, res, respos);
                if (x==enc_EXCEPTION)
                    return -1;
                else if (x==enc_FAILED) {
                    raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);
                    return -1;
                }
            }
        }
        *inpos = collendpos;
        break;
    default:
        repunicode = unicode_encode_call_errorhandler(errors, errorHandler,
                                                      encoding, reason, unicode, exceptionObject,
                                                      collstartpos, collendpos, &newpos);
        if (repunicode == ((void *)0))
            return -1;
        if (((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<27))) != 0)) {

            Py_ssize_t outsize = PyBytes_Size(*res);
            Py_ssize_t requiredsize;
            repsize = PyBytes_Size(repunicode);
            requiredsize = *respos + repsize;
            if (requiredsize > outsize)

                if (charmapencode_resize(res, respos, requiredsize)) {
                    do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                    return -1;
                }
            ((__builtin_object_size (PyBytes_AsString(*res) + *respos, 0) != (size_t) -1) ? __builtin___memcpy_chk (PyBytes_AsString(*res) + *respos, PyBytes_AsString(repunicode), repsize, __builtin_object_size (PyBytes_AsString(*res) + *respos, 0)) : __inline_memcpy_chk (PyBytes_AsString(*res) + *respos, PyBytes_AsString(repunicode), repsize));

            *respos += repsize;
            *inpos = newpos;
            do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
            break;
        }

        if (((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8066, "_PyUnicode_CHECK(repunicode)") : (void)0), ((((PyASCIIObject*)repunicode)->state.ready) ? 0 : _PyUnicode_Ready(repunicode))) == -1) {
            do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
            return -1;
        }
        repsize = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8070, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8070, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject *)(repunicode))->length);
        data = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8071, "PyUnicode_Check(repunicode)") : (void)0), (((PyASCIIObject*)(repunicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8071, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8071, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject*)repunicode)->state.ascii) ? ((void*)((PyASCIIObject*)(repunicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(repunicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(repunicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8071, "((PyUnicodeObject*)(repunicode))->data.any") : (void)0), ((((PyUnicodeObject *)(repunicode))->data.any))));
        kind = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8072, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8072, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject *)(repunicode))->state.kind);
        for (index = 0; index < repsize; index++) {
            Py_UCS4 repch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(index)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(index)] : ((const Py_UCS4 *)(data))[(index)] ) ));
            x = charmapencode_output(repch, mapping, res, respos);
            if (x==enc_EXCEPTION) {
                do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                return -1;
            }
            else if (x==enc_FAILED) {
                do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);
                return -1;
            }
        }
        *inpos = newpos;
        do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
    }
    return 0;
}

PyObject *
_PyUnicode_EncodeCharmap(PyObject *unicode,
                         PyObject *mapping,
                         const char *errors)
{

    PyObject *res = ((void *)0);

    Py_ssize_t inpos = 0;
    Py_ssize_t size;

    Py_ssize_t respos = 0;
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);



    int known_errorHandler = -1;

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8111, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);
    size = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8113, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8113, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);


    if (mapping == ((void *)0))
        return unicode_encode_ucs1(unicode, errors, 256);



    res = PyBytes_FromStringAndSize(((void *)0), size);
    if (res == ((void *)0))
        goto onError;
    if (size == 0)
        return res;

    while (inpos<size) {
        Py_UCS4 ch = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_IS_READY(unicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(inpos)] : (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject *)((unicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(inpos)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (((PyASCIIObject*)((unicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((unicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_Check((unicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(unicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "PyUnicode_IS_READY((unicode))") : (void)0), ((PyASCIIObject*)(unicode))->state.ascii) ? ((void*)((PyASCIIObject*)((unicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((unicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((unicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8128, "((PyUnicodeObject*)((unicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((unicode)))->data.any))))))[(inpos)] ) ));

        charmapencode_result x = charmapencode_output(ch, mapping, &res, &respos);
        if (x==enc_EXCEPTION)
            goto onError;
        if (x==enc_FAILED) {
            if (charmap_encoding_error(unicode, &inpos, mapping,
                                       &exc,
                                       &known_errorHandler, &errorHandler, errors,
                                       &res, &respos)) {
                goto onError;
            }
        }
        else

            ++inpos;
    }


    if (respos<((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8147, "PyBytes_Check(res)") : (void)0),(((PyVarObject*)(res))->ob_size)))
        if (_PyBytes_Resize(&res, respos) < 0)
            goto onError;

    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    return res;

  onError:
    do { if ((res) == ((void *)0)) ; else do { if ( --((PyObject*)(res))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(res)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(res)))); } while (0); } while (0);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    return ((void *)0);
}


PyObject *
PyUnicode_EncodeCharmap(const Py_UNICODE *p,
                        Py_ssize_t size,
                        PyObject *mapping,
                        const char *errors)
{
    PyObject *result;
    PyObject *unicode = PyUnicode_FromUnicode(p, size);
    if (unicode == ((void *)0))
        return ((void *)0);
    result = _PyUnicode_EncodeCharmap(unicode, mapping, errors);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return result;
}

PyObject *
PyUnicode_AsCharmapString(PyObject *unicode,
                          PyObject *mapping)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0) || mapping == ((void *)0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    return _PyUnicode_EncodeCharmap(unicode, mapping, ((void *)0));
}


static void
make_translate_exception(PyObject **exceptionObject,
                         PyObject *unicode,
                         Py_ssize_t startpos, Py_ssize_t endpos,
                         const char *reason)
{
    if (*exceptionObject == ((void *)0)) {
        *exceptionObject = _PyUnicodeTranslateError_Create(
            unicode, startpos, endpos, reason);
    }
    else {
        if (PyUnicodeTranslateError_SetStart(*exceptionObject, startpos))
            goto onError;
        if (PyUnicodeTranslateError_SetEnd(*exceptionObject, endpos))
            goto onError;
        if (PyUnicodeTranslateError_SetReason(*exceptionObject, reason))
            goto onError;
        return;
      onError:
        do { if ( --((PyObject*)(*exceptionObject))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*exceptionObject)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*exceptionObject)))); } while (0);
        *exceptionObject = ((void *)0);
    }
}


static void
raise_translate_exception(PyObject **exceptionObject,
                          PyObject *unicode,
                          Py_ssize_t startpos, Py_ssize_t endpos,
                          const char *reason)
{
    make_translate_exception(exceptionObject,
                             unicode, startpos, endpos, reason);
    if (*exceptionObject != ((void *)0))
        PyCodec_StrictErrors(*exceptionObject);
}





static PyObject *
unicode_translate_call_errorhandler(const char *errors,
                                    PyObject **errorHandler,
                                    const char *reason,
                                    PyObject *unicode, PyObject **exceptionObject,
                                    Py_ssize_t startpos, Py_ssize_t endpos,
                                    Py_ssize_t *newpos)
{
    static char *argparse = "O!n;translating error handler must return (str, int) tuple";

    Py_ssize_t i_newpos;
    PyObject *restuple;
    PyObject *resunicode;

    if (*errorHandler == ((void *)0)) {
        *errorHandler = PyCodec_LookupError(errors);
        if (*errorHandler == ((void *)0))
            return ((void *)0);
    }

    make_translate_exception(exceptionObject,
                             unicode, startpos, endpos, reason);
    if (*exceptionObject == ((void *)0))
        return ((void *)0);

    restuple = PyObject_CallFunctionObjArgs(
        *errorHandler, *exceptionObject, ((void *)0));
    if (restuple == ((void *)0))
        return ((void *)0);
    if (!((((((PyObject*)(restuple))->ob_type))->tp_flags & ((1L<<26))) != 0)) {
        PyErr_SetString(PyExc_TypeError, &argparse[4]);
        do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
        return ((void *)0);
    }
    if (!_PyArg_ParseTuple_SizeT(restuple, argparse, &PyUnicode_Type,
                          &resunicode, &i_newpos)) {
        do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
        return ((void *)0);
    }
    if (i_newpos<0)
        *newpos = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8271, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8271, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)+i_newpos;
    else
        *newpos = i_newpos;
    if (*newpos<0 || *newpos>((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8274, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8274, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)) {
        PyErr_Format(PyExc_IndexError, "position %zd from error handler out of bounds", *newpos);
        do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
        return ((void *)0);
    }
    ( ((PyObject*)(resunicode))->ob_refcnt++);
    do { if ( --((PyObject*)(restuple))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(restuple)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(restuple)))); } while (0);
    return resunicode;
}




static int
charmaptranslate_lookup(Py_UCS4 c, PyObject *mapping, PyObject **result)
{
    PyObject *w = PyLong_FromLong((long)c);
    PyObject *x;

    if (w == ((void *)0))
        return -1;
    x = PyObject_GetItem(mapping, w);
    do { if ( --((PyObject*)(w))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(w)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(w)))); } while (0);
    if (x == ((void *)0)) {
        if (PyErr_ExceptionMatches(PyExc_LookupError)) {

            PyErr_Clear();
            *result = ((void *)0);
            return 0;
        } else
            return -1;
    }
    else if (x == (&_Py_NoneStruct)) {
        *result = x;
        return 0;
    }
    else if (((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
        long value = PyLong_AsLong(x);
        long max = PyUnicode_GetMax();
        if (value < 0 || value > max) {
            PyErr_Format(PyExc_TypeError,
                         "character mapping must be in range(0x%x)", max+1);
            do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
            return -1;
        }
        *result = x;
        return 0;
    }
    else if (((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        *result = x;
        return 0;
    }
    else {

        PyErr_SetString(PyExc_TypeError,
                        "character mapping must return integer, None or str");
        do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0);
        return -1;
    }
}



static int
charmaptranslate_makespace(Py_UCS4 **outobj, Py_ssize_t *psize,
                               Py_ssize_t requiredsize)
{
    Py_ssize_t oldsize = *psize;
    Py_UCS4 *new_outobj;
    if (requiredsize > oldsize) {

        if (requiredsize < 2 * oldsize)
            requiredsize = 2 * oldsize;
        new_outobj = PyMem_Realloc(*outobj, requiredsize * sizeof(Py_UCS4));
        if (new_outobj == 0)
            return -1;
        *outobj = new_outobj;
        *psize = requiredsize;
    }
    return 0;
}






static int
charmaptranslate_output(PyObject *input, Py_ssize_t ipos,
                        PyObject *mapping, Py_UCS4 **output,
                        Py_ssize_t *osize, Py_ssize_t *opos,
                        PyObject **res)
{
    Py_UCS4 curinp = ((__builtin_expect(!(((((((PyObject*)(input))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check(input)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)input)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_IS_READY(input)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(input))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_IS_READY((input))") : (void)0), ((PyASCIIObject *)((input)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (((PyASCIIObject*)((input)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(input))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_IS_READY((input))") : (void)0), ((PyASCIIObject*)(input))->state.ascii) ? ((void*)((PyASCIIObject*)((input)) + 1)) : ((void*)((PyCompactUnicodeObject*)((input)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((input)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "((PyUnicodeObject*)((input)))->data.any") : (void)0), ((((PyUnicodeObject *)((input)))->data.any))))))[(ipos)] : (((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(input))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_IS_READY((input))") : (void)0), ((PyASCIIObject *)((input)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (((PyASCIIObject*)((input)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(input))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_IS_READY((input))") : (void)0), ((PyASCIIObject*)(input))->state.ascii) ? ((void*)((PyASCIIObject*)((input)) + 1)) : ((void*)((PyCompactUnicodeObject*)((input)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((input)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "((PyUnicodeObject*)((input)))->data.any") : (void)0), ((((PyUnicodeObject *)((input)))->data.any))))))[(ipos)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (((PyASCIIObject*)((input)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((input)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_Check((input))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(input))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "PyUnicode_IS_READY((input))") : (void)0), ((PyASCIIObject*)(input))->state.ascii) ? ((void*)((PyASCIIObject*)((input)) + 1)) : ((void*)((PyCompactUnicodeObject*)((input)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((input)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8367, "((PyUnicodeObject*)((input)))->data.any") : (void)0), ((((PyUnicodeObject *)((input)))->data.any))))))[(ipos)] ) ));
    if (charmaptranslate_lookup(curinp, mapping, res))
        return -1;
    if (*res==((void *)0)) {

        (*output)[(*opos)++] = curinp;
    }
    else if (*res==(&_Py_NoneStruct))
        ;
    else if (((((((PyObject*)(*res))->ob_type))->tp_flags & ((1L<<24))) != 0)) {

        (*output)[(*opos)++] = (Py_UCS4)PyLong_AsLong(*res);
    }
    else if (((((((PyObject*)(*res))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        Py_ssize_t repsize;
        if (((__builtin_expect(!(((((((PyObject*)(*res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8382, "_PyUnicode_CHECK(*res)") : (void)0), ((((PyASCIIObject*)*res)->state.ready) ? 0 : _PyUnicode_Ready(*res))) == -1)
            return -1;
        repsize = ((__builtin_expect(!(((((((PyObject*)(*res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8384, "PyUnicode_Check(*res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8384, "PyUnicode_IS_READY(*res)") : (void)0), ((PyASCIIObject *)(*res))->length);
        if (repsize==1) {

            (*output)[(*opos)++] = ((__builtin_expect(!(((((((PyObject*)(*res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check(*res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_IS_READY(*res)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject *)((*res)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (((PyASCIIObject*)((*res)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject*)(*res))->state.ascii) ? ((void*)((PyASCIIObject*)((*res)) + 1)) : ((void*)((PyCompactUnicodeObject*)((*res)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((*res)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "((PyUnicodeObject*)((*res)))->data.any") : (void)0), ((((PyUnicodeObject *)((*res)))->data.any))))))[(0)] : (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject *)((*res)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (((PyASCIIObject*)((*res)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject*)(*res))->state.ascii) ? ((void*)((PyASCIIObject*)((*res)) + 1)) : ((void*)((PyCompactUnicodeObject*)((*res)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((*res)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "((PyUnicodeObject*)((*res)))->data.any") : (void)0), ((((PyUnicodeObject *)((*res)))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (((PyASCIIObject*)((*res)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject*)(*res))->state.ascii) ? ((void*)((PyASCIIObject*)((*res)) + 1)) : ((void*)((PyCompactUnicodeObject*)((*res)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((*res)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8387, "((PyUnicodeObject*)((*res)))->data.any") : (void)0), ((((PyUnicodeObject *)((*res)))->data.any))))))[(0)] ) ));
        }
        else if (repsize!=0) {

            Py_ssize_t requiredsize = *opos +
                (((__builtin_expect(!(((((((PyObject*)(input))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8392, "PyUnicode_Check(input)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)input)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8392, "PyUnicode_IS_READY(input)") : (void)0), ((PyASCIIObject *)(input))->length) - ipos) +
                repsize - 1;
            Py_ssize_t i;
            if (charmaptranslate_makespace(output, osize, requiredsize))
                return -1;
            for(i = 0; i < repsize; i++)
                (*output)[(*opos)++] = ((__builtin_expect(!(((((((PyObject*)(*res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check(*res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)*res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_IS_READY(*res)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject *)((*res)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (((PyASCIIObject*)((*res)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject*)(*res))->state.ascii) ? ((void*)((PyASCIIObject*)((*res)) + 1)) : ((void*)((PyCompactUnicodeObject*)((*res)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((*res)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "((PyUnicodeObject*)((*res)))->data.any") : (void)0), ((((PyUnicodeObject *)((*res)))->data.any))))))[(i)] : (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject *)((*res)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (((PyASCIIObject*)((*res)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject*)(*res))->state.ascii) ? ((void*)((PyASCIIObject*)((*res)) + 1)) : ((void*)((PyCompactUnicodeObject*)((*res)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((*res)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "((PyUnicodeObject*)((*res)))->data.any") : (void)0), ((((PyUnicodeObject *)((*res)))->data.any))))))[(i)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (((PyASCIIObject*)((*res)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((*res)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_Check((*res))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(*res))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "PyUnicode_IS_READY((*res))") : (void)0), ((PyASCIIObject*)(*res))->state.ascii) ? ((void*)((PyASCIIObject*)((*res)) + 1)) : ((void*)((PyCompactUnicodeObject*)((*res)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((*res)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8398, "((PyUnicodeObject*)((*res)))->data.any") : (void)0), ((((PyUnicodeObject *)((*res)))->data.any))))))[(i)] ) ));
        }
    }
    else
        return -1;
    return 0;
}

PyObject *
_PyUnicode_TranslateCharmap(PyObject *input,
                            PyObject *mapping,
                            const char *errors)
{

    char *idata;
    Py_ssize_t size, i;
    int kind;

    Py_UCS4 *output = ((void *)0);
    Py_ssize_t osize;
    PyObject *res;

    Py_ssize_t opos;
    char *reason = "character maps to <undefined>";
    PyObject *errorHandler = ((void *)0);
    PyObject *exc = ((void *)0);



    int known_errorHandler = -1;

    if (mapping == ((void *)0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }

    if (((__builtin_expect(!(((((((PyObject*)(input))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8434, "_PyUnicode_CHECK(input)") : (void)0), ((((PyASCIIObject*)input)->state.ready) ? 0 : _PyUnicode_Ready(input))) == -1)
        return ((void *)0);
    idata = (char*)((__builtin_expect(!(((((((PyObject*)(input))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8436, "PyUnicode_Check(input)") : (void)0), (((PyASCIIObject*)(input))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(input))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8436, "PyUnicode_Check(input)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)input)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8436, "PyUnicode_IS_READY(input)") : (void)0), ((PyASCIIObject*)input)->state.ascii) ? ((void*)((PyASCIIObject*)(input) + 1)) : ((void*)((PyCompactUnicodeObject*)(input) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(input))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8436, "((PyUnicodeObject*)(input))->data.any") : (void)0), ((((PyUnicodeObject *)(input))->data.any))));
    kind = ((__builtin_expect(!(((((((PyObject*)(input))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8437, "PyUnicode_Check(input)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)input)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8437, "PyUnicode_IS_READY(input)") : (void)0), ((PyASCIIObject *)(input))->state.kind);
    size = ((__builtin_expect(!(((((((PyObject*)(input))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8438, "PyUnicode_Check(input)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)input)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8438, "PyUnicode_IS_READY(input)") : (void)0), ((PyASCIIObject *)(input))->length);
    i = 0;

    if (size == 0) {
        ( ((PyObject*)(input))->ob_refcnt++);
        return input;
    }



    osize = size;
    output = PyMem_Malloc(osize * sizeof(Py_UCS4));
    opos = 0;
    if (output == ((void *)0)) {
        PyErr_NoMemory();
        goto onError;
    }

    while (i<size) {

        PyObject *x = ((void *)0);
        if (charmaptranslate_output(input, i, mapping,
                                    &output, &osize, &opos, &x)) {
            do { if ((x) == ((void *)0)) ; else do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0); } while (0);
            goto onError;
        }
        do { if ((x) == ((void *)0)) ; else do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0); } while (0);
        if (x!=(&_Py_NoneStruct))
            ++i;
        else {
            PyObject *repunicode = ((void *)0);
            Py_ssize_t repsize;
            Py_ssize_t newpos;
            Py_ssize_t uni2;

            Py_ssize_t collstart = i;
            Py_ssize_t collend = i+1;
            Py_ssize_t coll;


            while (collend < size) {
                if (charmaptranslate_lookup(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(idata))[(collend)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(idata))[(collend)] : ((const Py_UCS4 *)(idata))[(collend)] ) )), mapping, &x))
                    goto onError;
                do { if ((x) == ((void *)0)) ; else do { if ( --((PyObject*)(x))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(x)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(x)))); } while (0); } while (0);
                if (x!=(&_Py_NoneStruct))
                    break;
                ++collend;
            }


            if (known_errorHandler==-1) {
                if ((errors==((void *)0)) || (!strcmp(errors, "strict")))
                    known_errorHandler = 1;
                else if (!strcmp(errors, "replace"))
                    known_errorHandler = 2;
                else if (!strcmp(errors, "ignore"))
                    known_errorHandler = 3;
                else if (!strcmp(errors, "xmlcharrefreplace"))
                    known_errorHandler = 4;
                else
                    known_errorHandler = 0;
            }
            switch (known_errorHandler) {
            case 1:
                raise_translate_exception(&exc, input, collstart,
                                          collend, reason);
                goto onError;
            case 2:

                for (coll = collstart; coll<collend; coll++)
                    output[opos++] = '?';

            case 3:
                i = collend;
                break;
            case 4:

                for (i = collstart; i < collend; ++i) {
                    char buffer[2+29+1+1];
                    char *cp;
                    __builtin___sprintf_chk (buffer, 0, __builtin_object_size (buffer, 2 > 1), "&#%d;", ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(idata))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(idata))[(i)] : ((const Py_UCS4 *)(idata))[(i)] ) )));
                    if (charmaptranslate_makespace(&output, &osize,
                                                   opos+strlen(buffer)+(size-collend)))
                        goto onError;
                    for (cp = buffer; *cp; ++cp)
                        output[opos++] = *cp;
                }
                i = collend;
                break;
            default:
                repunicode = unicode_translate_call_errorhandler(errors, &errorHandler,
                                                                 reason, input, &exc,
                                                                 collstart, collend, &newpos);
                if (repunicode == ((void *)0))
                    goto onError;
                if (((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8533, "_PyUnicode_CHECK(repunicode)") : (void)0), ((((PyASCIIObject*)repunicode)->state.ready) ? 0 : _PyUnicode_Ready(repunicode))) == -1) {
                    do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                    goto onError;
                }

                repsize = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8538, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8538, "PyUnicode_IS_READY(repunicode)") : (void)0), ((PyASCIIObject *)(repunicode))->length);
                if (charmaptranslate_makespace(&output, &osize,
                                               opos+repsize+(size-collend))) {
                    do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
                    goto onError;
                }
                for (uni2 = 0; repsize-->0; ++uni2)
                    output[opos++] = ((__builtin_expect(!(((((((PyObject*)(repunicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check(repunicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repunicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_IS_READY(repunicode)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject *)((repunicode)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (((PyASCIIObject*)((repunicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject*)(repunicode))->state.ascii) ? ((void*)((PyASCIIObject*)((repunicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((repunicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((repunicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "((PyUnicodeObject*)((repunicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((repunicode)))->data.any))))))[(uni2)] : (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject *)((repunicode)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (((PyASCIIObject*)((repunicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject*)(repunicode))->state.ascii) ? ((void*)((PyASCIIObject*)((repunicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((repunicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((repunicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "((PyUnicodeObject*)((repunicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((repunicode)))->data.any))))))[(uni2)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (((PyASCIIObject*)((repunicode)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((repunicode)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_Check((repunicode))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(repunicode))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "PyUnicode_IS_READY((repunicode))") : (void)0), ((PyASCIIObject*)(repunicode))->state.ascii) ? ((void*)((PyASCIIObject*)((repunicode)) + 1)) : ((void*)((PyCompactUnicodeObject*)((repunicode)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((repunicode)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8545, "((PyUnicodeObject*)((repunicode)))->data.any") : (void)0), ((((PyUnicodeObject *)((repunicode)))->data.any))))))[(uni2)] ) ));
                i = newpos;
                do { if ( --((PyObject*)(repunicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(repunicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(repunicode)))); } while (0);
            }
        }
    }
    res = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND, output, opos);
    if (!res)
        goto onError;
    PyMem_Free(output);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    return res;

  onError:
    PyMem_Free(output);
    do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
    do { if ((errorHandler) == ((void *)0)) ; else do { if ( --((PyObject*)(errorHandler))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(errorHandler)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(errorHandler)))); } while (0); } while (0);
    return ((void *)0);
}


PyObject *
PyUnicode_TranslateCharmap(const Py_UNICODE *p,
                           Py_ssize_t size,
                           PyObject *mapping,
                           const char *errors)
{
    PyObject *result;
    PyObject *unicode = PyUnicode_FromUnicode(p, size);
    if (!unicode)
        return ((void *)0);
    result = _PyUnicode_TranslateCharmap(unicode, mapping, errors);
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return result;
}

PyObject *
PyUnicode_Translate(PyObject *str,
                    PyObject *mapping,
                    const char *errors)
{
    PyObject *result;

    str = PyUnicode_FromObject(str);
    if (str == ((void *)0))
        return ((void *)0);
    result = _PyUnicode_TranslateCharmap(str, mapping, errors);
    do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
    return result;
}

static Py_UCS4
fix_decimal_and_space_to_ascii(PyObject *self)
{


    const Py_ssize_t len = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8602, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8602, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    const int kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8603, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8603, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    void *data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8604, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8604, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8604, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8604, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    Py_UCS4 maxchar = 127, ch, fixed;
    int modified = 0;
    Py_ssize_t i;

    for (i = 0; i < len; ++i) {
        ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        fixed = 0;
        if (ch > 127) {
            if (((ch) < 128U ? _Py_ascii_whitespace[(ch)] : _PyUnicode_IsWhitespace(ch)))
                fixed = ' ';
            else {
                const int decimal = _PyUnicode_ToDecimalDigit(ch);
                if (decimal >= 0)
                    fixed = '0' + decimal;
            }
            if (fixed != 0) {
                modified = 1;
                maxchar = ((maxchar) | (fixed));
                do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(i)] = (Py_UCS1)(fixed); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(i)] = (Py_UCS2)(fixed); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8623, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(i)] = (Py_UCS4)(fixed); } } } while (0);
            }
            else
                maxchar = ((maxchar) | (ch));
        }
    }

    return (modified) ? maxchar : 0;
}

PyObject *
_PyUnicode_TransformDecimalAndSpaceToASCII(PyObject *unicode)
{
    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 8637);
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8640, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8642, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8642, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8642, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8642, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8642, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8642, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8642, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))) <= 127) {

        ( ((PyObject*)(unicode))->ob_refcnt++);
        return unicode;
    }
    return fixup(unicode, fix_decimal_and_space_to_ascii);
}

PyObject *
PyUnicode_TransformDecimalToASCII(Py_UNICODE *s,
                                  Py_ssize_t length)
{
    PyObject *decimal;
    Py_ssize_t i;
    Py_UCS4 maxchar;
    enum PyUnicode_Kind kind;
    void *data;

    maxchar = 127;
    for (i = 0; i < length; i++) {
        Py_UNICODE ch = s[i];
        if (ch > 127) {
            int decimal = _PyUnicode_ToDecimalDigit(ch);
            if (decimal >= 0)
                ch = '0' + decimal;
            maxchar = ((maxchar) | (ch));
        }
    }


    decimal = PyUnicode_New(length, maxchar);
    if (decimal == ((void *)0))
        return decimal;
    kind = ((__builtin_expect(!(((((((PyObject*)(decimal))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8675, "PyUnicode_Check(decimal)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)decimal)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8675, "PyUnicode_IS_READY(decimal)") : (void)0), ((PyASCIIObject *)(decimal))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(decimal))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8676, "PyUnicode_Check(decimal)") : (void)0), (((PyASCIIObject*)(decimal))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(decimal))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8676, "PyUnicode_Check(decimal)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)decimal)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8676, "PyUnicode_IS_READY(decimal)") : (void)0), ((PyASCIIObject*)decimal)->state.ascii) ? ((void*)((PyASCIIObject*)(decimal) + 1)) : ((void*)((PyCompactUnicodeObject*)(decimal) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(decimal))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8676, "((PyUnicodeObject*)(decimal))->data.any") : (void)0), ((((PyUnicodeObject *)(decimal))->data.any))));

    for (i = 0; i < length; i++) {
        Py_UNICODE ch = s[i];
        if (ch > 127) {
            int decimal = _PyUnicode_ToDecimalDigit(ch);
            if (decimal >= 0)
                ch = '0' + decimal;
        }
        do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(i)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(i)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8685, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(i)] = (Py_UCS4)(ch); } } } while (0);
    }
    return unicode_result(decimal);
}


int
PyUnicode_EncodeDecimal(Py_UNICODE *s,
                        Py_ssize_t length,
                        char *output,
                        const char *errors)
{
    PyObject *unicode;
    Py_ssize_t i;
    enum PyUnicode_Kind kind;
    void *data;

    if (output == ((void *)0)) {
        PyErr_BadArgument();
        return -1;
    }

    unicode = PyUnicode_FromUnicode(s, length);
    if (unicode == ((void *)0))
        return -1;

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8711, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1) {
        do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
        return -1;
    }
    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8715, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8715, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8716, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8716, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8716, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8716, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));

    for (i=0; i < length; ) {
        PyObject *exc;
        Py_UCS4 ch;
        int decimal;
        Py_ssize_t startpos;

        ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));

        if (((ch) < 128U ? _Py_ascii_whitespace[(ch)] : _PyUnicode_IsWhitespace(ch))) {
            *output++ = ' ';
            i++;
            continue;
        }
        decimal = _PyUnicode_ToDecimalDigit(ch);
        if (decimal >= 0) {
            *output++ = '0' + decimal;
            i++;
            continue;
        }
        if (0 < ch && ch < 256) {
            *output++ = (char)ch;
            i++;
            continue;
        }

        startpos = i;
        exc = ((void *)0);
        raise_encode_exception(&exc, "decimal", unicode,
                               startpos, startpos+1,
                               "invalid decimal Unicode string");
        do { if ((exc) == ((void *)0)) ; else do { if ( --((PyObject*)(exc))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(exc)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(exc)))); } while (0); } while (0);
        do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
        return -1;
    }

    *output++ = '\0';
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return 0;
}



static Py_ssize_t
any_find_slice(int direction, PyObject* s1, PyObject* s2,
               Py_ssize_t start,
               Py_ssize_t end)
{
    int kind1, kind2, kind;
    void *buf1, *buf2;
    Py_ssize_t len1, len2, result;

    kind1 = ((__builtin_expect(!(((((((PyObject*)(s1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8769, "PyUnicode_Check(s1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8769, "PyUnicode_IS_READY(s1)") : (void)0), ((PyASCIIObject *)(s1))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(s2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8770, "PyUnicode_Check(s2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8770, "PyUnicode_IS_READY(s2)") : (void)0), ((PyASCIIObject *)(s2))->state.kind);
    kind = kind1 > kind2 ? kind1 : kind2;
    buf1 = ((__builtin_expect(!(((((((PyObject*)(s1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8772, "PyUnicode_Check(s1)") : (void)0), (((PyASCIIObject*)(s1))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8772, "PyUnicode_Check(s1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8772, "PyUnicode_IS_READY(s1)") : (void)0), ((PyASCIIObject*)s1)->state.ascii) ? ((void*)((PyASCIIObject*)(s1) + 1)) : ((void*)((PyCompactUnicodeObject*)(s1) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s1))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8772, "((PyUnicodeObject*)(s1))->data.any") : (void)0), ((((PyUnicodeObject *)(s1))->data.any))));
    buf2 = ((__builtin_expect(!(((((((PyObject*)(s2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8773, "PyUnicode_Check(s2)") : (void)0), (((PyASCIIObject*)(s2))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(s2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8773, "PyUnicode_Check(s2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8773, "PyUnicode_IS_READY(s2)") : (void)0), ((PyASCIIObject*)s2)->state.ascii) ? ((void*)((PyASCIIObject*)(s2) + 1)) : ((void*)((PyCompactUnicodeObject*)(s2) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(s2))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8773, "((PyUnicodeObject*)(s2))->data.any") : (void)0), ((((PyUnicodeObject *)(s2))->data.any))));
    if (kind1 != kind)
        buf1 = _PyUnicode_AsKind(s1, kind);
    if (!buf1)
        return -2;
    if (kind2 != kind)
        buf2 = _PyUnicode_AsKind(s2, kind);
    if (!buf2) {
        if (kind1 != kind) PyMem_Free(buf1);
        return -2;
    }
    len1 = ((__builtin_expect(!(((((((PyObject*)(s1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8784, "PyUnicode_Check(s1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8784, "PyUnicode_IS_READY(s1)") : (void)0), ((PyASCIIObject *)(s1))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(s2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8785, "PyUnicode_Check(s2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8785, "PyUnicode_IS_READY(s2)") : (void)0), ((PyASCIIObject *)(s2))->length);

    if (direction > 0) {
        switch (kind) {
        case PyUnicode_1BYTE_KIND:
            if (((__builtin_expect(!(((((((PyObject*)(s1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8790, "PyUnicode_Check(s1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8790, "PyUnicode_IS_READY(s1)") : (void)0), ((PyASCIIObject*)s1)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(s2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8790, "PyUnicode_Check(s2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8790, "PyUnicode_IS_READY(s2)") : (void)0), ((PyASCIIObject*)s2)->state.ascii))
                result = asciilib_find_slice(buf1, len1, buf2, len2, start, end);
            else
                result = ucs1lib_find_slice(buf1, len1, buf2, len2, start, end);
            break;
        case PyUnicode_2BYTE_KIND:
            result = ucs2lib_find_slice(buf1, len1, buf2, len2, start, end);
            break;
        case PyUnicode_4BYTE_KIND:
            result = ucs4lib_find_slice(buf1, len1, buf2, len2, start, end);
            break;
        default:
            (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8802, "0") : (void)0); result = -2;
        }
    }
    else {
        switch (kind) {
        case PyUnicode_1BYTE_KIND:
            if (((__builtin_expect(!(((((((PyObject*)(s1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8808, "PyUnicode_Check(s1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8808, "PyUnicode_IS_READY(s1)") : (void)0), ((PyASCIIObject*)s1)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(s2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8808, "PyUnicode_Check(s2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8808, "PyUnicode_IS_READY(s2)") : (void)0), ((PyASCIIObject*)s2)->state.ascii))
                result = asciilib_rfind_slice(buf1, len1, buf2, len2, start, end);
            else
                result = ucs1lib_rfind_slice(buf1, len1, buf2, len2, start, end);
            break;
        case PyUnicode_2BYTE_KIND:
            result = ucs2lib_rfind_slice(buf1, len1, buf2, len2, start, end);
            break;
        case PyUnicode_4BYTE_KIND:
            result = ucs4lib_rfind_slice(buf1, len1, buf2, len2, start, end);
            break;
        default:
            (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8820, "0") : (void)0); result = -2;
        }
    }

    if (kind1 != kind)
        PyMem_Free(buf1);
    if (kind2 != kind)
        PyMem_Free(buf2);

    return result;
}

Py_ssize_t
_PyUnicode_InsertThousandsGrouping(
    PyObject *unicode, Py_ssize_t index,
    Py_ssize_t n_buffer,
    void *digits, Py_ssize_t n_digits,
    Py_ssize_t min_width,
    const char *grouping, PyObject *thousands_sep,
    Py_UCS4 *maxchar)
{
    unsigned int kind, thousands_sep_kind;
    char *data, *thousands_sep_data;
    Py_ssize_t thousands_sep_len;
    Py_ssize_t len;

    if (unicode != ((void *)0)) {
        kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8847, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8847, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
        data = (char *) ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8848, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8848, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8848, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8848, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))) + index * kind;
    }
    else {
        kind = PyUnicode_1BYTE_KIND;
        data = ((void *)0);
    }
    thousands_sep_kind = ((__builtin_expect(!(((((((PyObject*)(thousands_sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8854, "PyUnicode_Check(thousands_sep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)thousands_sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8854, "PyUnicode_IS_READY(thousands_sep)") : (void)0), ((PyASCIIObject *)(thousands_sep))->state.kind);
    thousands_sep_data = ((__builtin_expect(!(((((((PyObject*)(thousands_sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8855, "PyUnicode_Check(thousands_sep)") : (void)0), (((PyASCIIObject*)(thousands_sep))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(thousands_sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8855, "PyUnicode_Check(thousands_sep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)thousands_sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8855, "PyUnicode_IS_READY(thousands_sep)") : (void)0), ((PyASCIIObject*)thousands_sep)->state.ascii) ? ((void*)((PyASCIIObject*)(thousands_sep) + 1)) : ((void*)((PyCompactUnicodeObject*)(thousands_sep) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(thousands_sep))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8855, "((PyUnicodeObject*)(thousands_sep))->data.any") : (void)0), ((((PyUnicodeObject *)(thousands_sep))->data.any))));
    thousands_sep_len = ((__builtin_expect(!(((((((PyObject*)(thousands_sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8856, "PyUnicode_Check(thousands_sep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)thousands_sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8856, "PyUnicode_IS_READY(thousands_sep)") : (void)0), ((PyASCIIObject *)(thousands_sep))->length);
    if (unicode != ((void *)0) && thousands_sep_kind != kind) {
        if (thousands_sep_kind < kind) {
            thousands_sep_data = _PyUnicode_AsKind(thousands_sep, kind);
            if (!thousands_sep_data)
                return -1;
        }
        else {
            data = _PyUnicode_AsKind(unicode, thousands_sep_kind);
            if (!data)
                return -1;
        }
    }

    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        if (unicode != ((void *)0) && ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8872, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8872, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii))
            len = asciilib_InsertThousandsGrouping(
                (Py_UCS1 *) data, n_buffer, (Py_UCS1 *) digits, n_digits,
                min_width, grouping,
                (Py_UCS1 *) thousands_sep_data, thousands_sep_len);
        else
            len = ucs1lib_InsertThousandsGrouping(
                (Py_UCS1*)data, n_buffer, (Py_UCS1*)digits, n_digits,
                min_width, grouping,
                (Py_UCS1 *) thousands_sep_data, thousands_sep_len);
        break;
    case PyUnicode_2BYTE_KIND:
        len = ucs2lib_InsertThousandsGrouping(
            (Py_UCS2 *) data, n_buffer, (Py_UCS2 *) digits, n_digits,
            min_width, grouping,
            (Py_UCS2 *) thousands_sep_data, thousands_sep_len);
        break;
    case PyUnicode_4BYTE_KIND:
        len = ucs4lib_InsertThousandsGrouping(
            (Py_UCS4 *) data, n_buffer, (Py_UCS4 *) digits, n_digits,
            min_width, grouping,
            (Py_UCS4 *) thousands_sep_data, thousands_sep_len);
        break;
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8896, "0") : (void)0);
        return -1;
    }
    if (unicode != ((void *)0) && thousands_sep_kind != kind) {
        if (thousands_sep_kind < kind)
            PyMem_Free(thousands_sep_data);
        else
            PyMem_Free(data);
    }
    if (unicode == ((void *)0)) {
        *maxchar = 127;
        if (len != n_digits) {
            *maxchar = ((*maxchar) | (((__builtin_expect(!((((PyASCIIObject*)thousands_sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8909, "PyUnicode_IS_READY(thousands_sep)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(thousands_sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8909, "PyUnicode_Check(thousands_sep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)thousands_sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8909, "PyUnicode_IS_READY(thousands_sep)") : (void)0), ((PyASCIIObject*)thousands_sep)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(thousands_sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8909, "PyUnicode_Check(thousands_sep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)thousands_sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8909, "PyUnicode_IS_READY(thousands_sep)") : (void)0), ((PyASCIIObject *)(thousands_sep))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(thousands_sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8909, "PyUnicode_Check(thousands_sep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)thousands_sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8909, "PyUnicode_IS_READY(thousands_sep)") : (void)0), ((PyASCIIObject *)(thousands_sep))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))))));

        }
    }
    return len;
}
# 8931 "unicodeobject.c"
Py_ssize_t
PyUnicode_Count(PyObject *str,
                PyObject *substr,
                Py_ssize_t start,
                Py_ssize_t end)
{
    Py_ssize_t result;
    PyObject* str_obj;
    PyObject* sub_obj;
    int kind1, kind2, kind;
    void *buf1 = ((void *)0), *buf2 = ((void *)0);
    Py_ssize_t len1, len2;

    str_obj = PyUnicode_FromObject(str);
    if (!str_obj)
        return -1;
    sub_obj = PyUnicode_FromObject(substr);
    if (!sub_obj) {
        do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
        return -1;
    }
    if (((__builtin_expect(!(((((((PyObject*)(sub_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8952, "_PyUnicode_CHECK(sub_obj)") : (void)0), ((((PyASCIIObject*)sub_obj)->state.ready) ? 0 : _PyUnicode_Ready(sub_obj))) == -1 || ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8952, "_PyUnicode_CHECK(str_obj)") : (void)0), ((((PyASCIIObject*)str_obj)->state.ready) ? 0 : _PyUnicode_Ready(str_obj))) == -1) {
        do { if ( --((PyObject*)(sub_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub_obj)))); } while (0);
        do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
        return -1;
    }

    kind1 = ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8958, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8958, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(sub_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8959, "PyUnicode_Check(sub_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sub_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8959, "PyUnicode_IS_READY(sub_obj)") : (void)0), ((PyASCIIObject *)(sub_obj))->state.kind);
    kind = kind1;
    buf1 = ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8961, "PyUnicode_Check(str_obj)") : (void)0), (((PyASCIIObject*)(str_obj))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8961, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8961, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject*)str_obj)->state.ascii) ? ((void*)((PyASCIIObject*)(str_obj) + 1)) : ((void*)((PyCompactUnicodeObject*)(str_obj) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str_obj))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8961, "((PyUnicodeObject*)(str_obj))->data.any") : (void)0), ((((PyUnicodeObject *)(str_obj))->data.any))));
    buf2 = ((__builtin_expect(!(((((((PyObject*)(sub_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8962, "PyUnicode_Check(sub_obj)") : (void)0), (((PyASCIIObject*)(sub_obj))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(sub_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8962, "PyUnicode_Check(sub_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sub_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8962, "PyUnicode_IS_READY(sub_obj)") : (void)0), ((PyASCIIObject*)sub_obj)->state.ascii) ? ((void*)((PyASCIIObject*)(sub_obj) + 1)) : ((void*)((PyCompactUnicodeObject*)(sub_obj) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(sub_obj))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8962, "((PyUnicodeObject*)(sub_obj))->data.any") : (void)0), ((((PyUnicodeObject *)(sub_obj))->data.any))));
    if (kind2 != kind) {
        if (kind2 > kind) {
            do { if ( --((PyObject*)(sub_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub_obj)))); } while (0);
            do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
            return 0;
        }
        buf2 = _PyUnicode_AsKind(sub_obj, kind);
    }
    if (!buf2)
        goto onError;
    len1 = ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8973, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8973, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(sub_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8974, "PyUnicode_Check(sub_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sub_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8974, "PyUnicode_IS_READY(sub_obj)") : (void)0), ((PyASCIIObject *)(sub_obj))->length);

    if (end > len1) end = len1; else if (end < 0) { end += len1; if (end < 0) end = 0; } if (start < 0) { start += len1; if (start < 0) start = 0; };
    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8979, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8979, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject*)str_obj)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(sub_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8979, "PyUnicode_Check(sub_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sub_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 8979, "PyUnicode_IS_READY(sub_obj)") : (void)0), ((PyASCIIObject*)sub_obj)->state.ascii))
            result = asciilib_count(
                ((Py_UCS1*)buf1) + start, end - start,
                buf2, len2, ((Py_ssize_t)(((size_t)-1)>>1))
                );
        else
            result = ucs1lib_count(
                ((Py_UCS1*)buf1) + start, end - start,
                buf2, len2, ((Py_ssize_t)(((size_t)-1)>>1))
                );
        break;
    case PyUnicode_2BYTE_KIND:
        result = ucs2lib_count(
            ((Py_UCS2*)buf1) + start, end - start,
            buf2, len2, ((Py_ssize_t)(((size_t)-1)>>1))
            );
        break;
    case PyUnicode_4BYTE_KIND:
        result = ucs4lib_count(
            ((Py_UCS4*)buf1) + start, end - start,
            buf2, len2, ((Py_ssize_t)(((size_t)-1)>>1))
            );
        break;
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9003, "0") : (void)0); result = 0;
    }

    do { if ( --((PyObject*)(sub_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub_obj)))); } while (0);
    do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);

    if (kind2 != kind)
        PyMem_Free(buf2);

    return result;
  onError:
    do { if ( --((PyObject*)(sub_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub_obj)))); } while (0);
    do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
    if (kind2 != kind && buf2)
        PyMem_Free(buf2);
    return -1;
}

Py_ssize_t
PyUnicode_Find(PyObject *str,
               PyObject *sub,
               Py_ssize_t start,
               Py_ssize_t end,
               int direction)
{
    Py_ssize_t result;

    str = PyUnicode_FromObject(str);
    if (!str)
        return -2;
    sub = PyUnicode_FromObject(sub);
    if (!sub) {
        do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
        return -2;
    }
    if (((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9038, "_PyUnicode_CHECK(sub)") : (void)0), ((((PyASCIIObject*)sub)->state.ready) ? 0 : _PyUnicode_Ready(sub))) == -1 || ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9038, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1) {
        do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);
        do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
        return -2;
    }

    result = any_find_slice(direction,
        str, sub, start, end
        );

    do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
    do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);

    return result;
}

Py_ssize_t
PyUnicode_FindChar(PyObject *str, Py_UCS4 ch,
                   Py_ssize_t start, Py_ssize_t end,
                   int direction)
{
    int kind;
    Py_ssize_t result;
    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9061, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1)
        return -2;
    if (start < 0 || end < 0) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return -2;
    }
    if (end > ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9067, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9067, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length))
        end = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9068, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9068, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9069, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9069, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind);
    result = findchar(((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9070, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9070, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9070, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9070, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))))) + kind*start,
                      kind, end-start, ch, direction);
    if (result == -1)
        return -1;
    else
        return start + result;
}

static int
tailmatch(PyObject *self,
          PyObject *substring,
          Py_ssize_t start,
          Py_ssize_t end,
          int direction)
{
    int kind_self;
    int kind_sub;
    void *data_self;
    void *data_sub;
    Py_ssize_t offset;
    Py_ssize_t i;
    Py_ssize_t end_sub;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9093, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1 ||
        ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9094, "_PyUnicode_CHECK(substring)") : (void)0), ((((PyASCIIObject*)substring)->state.ready) ? 0 : _PyUnicode_Ready(substring))) == -1)
        return 0;

    if (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9097, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9097, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->length) == 0)
        return 1;

    if (end > ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length)) end = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length); else if (end < 0) { end += ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length); if (end < 0) end = 0; } if (start < 0) { start += ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9100, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length); if (start < 0) start = 0; };
    end -= ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9101, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9101, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->length);
    if (end < start)
        return 0;

    kind_self = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9105, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9105, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data_self = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9106, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9106, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9106, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9106, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    kind_sub = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9107, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9107, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->state.kind);
    data_sub = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9108, "PyUnicode_Check(substring)") : (void)0), (((PyASCIIObject*)(substring))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9108, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9108, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject*)substring)->state.ascii) ? ((void*)((PyASCIIObject*)(substring) + 1)) : ((void*)((PyCompactUnicodeObject*)(substring) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(substring))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9108, "((PyUnicodeObject*)(substring))->data.any") : (void)0), ((((PyUnicodeObject *)(substring))->data.any))));
    end_sub = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9109, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9109, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->length) - 1;

    if (direction > 0)
        offset = end;
    else
        offset = start;

    if (((Py_UCS4) ((kind_self) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data_self))[(offset)] : ((kind_self) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data_self))[(offset)] : ((const Py_UCS4 *)(data_self))[(offset)] ) )) ==
        ((Py_UCS4) ((kind_sub) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data_sub))[(0)] : ((kind_sub) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data_sub))[(0)] : ((const Py_UCS4 *)(data_sub))[(0)] ) )) &&
        ((Py_UCS4) ((kind_self) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data_self))[(offset + end_sub)] : ((kind_self) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data_self))[(offset + end_sub)] : ((const Py_UCS4 *)(data_self))[(offset + end_sub)] ) )) ==
        ((Py_UCS4) ((kind_sub) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data_sub))[(end_sub)] : ((kind_sub) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data_sub))[(end_sub)] : ((const Py_UCS4 *)(data_sub))[(end_sub)] ) ))) {

        if (kind_self == kind_sub) {
            return ! memcmp((char *)data_self +
                                (offset * ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9123, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9123, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->state.kind)),
                            data_sub,
                            ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9125, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9125, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->length) *
                                ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9126, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9126, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->state.kind));
        }

        else {




            for (i = 1; i < end_sub; ++i) {
                if (((Py_UCS4) ((kind_self) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data_self))[(offset + i)] : ((kind_self) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data_self))[(offset + i)] : ((const Py_UCS4 *)(data_self))[(offset + i)] ) )) !=
                    ((Py_UCS4) ((kind_sub) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data_sub))[(i)] : ((kind_sub) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data_sub))[(i)] : ((const Py_UCS4 *)(data_sub))[(i)] ) )))
                    return 0;
            }
            return 1;
        }
    }

    return 0;
}

Py_ssize_t
PyUnicode_Tailmatch(PyObject *str,
                    PyObject *substr,
                    Py_ssize_t start,
                    Py_ssize_t end,
                    int direction)
{
    Py_ssize_t result;

    str = PyUnicode_FromObject(str);
    if (str == ((void *)0))
        return -1;
    substr = PyUnicode_FromObject(substr);
    if (substr == ((void *)0)) {
        do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
        return -1;
    }

    result = tailmatch(str, substr,
                       start, end, direction);
    do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
    do { if ( --((PyObject*)(substr))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substr)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substr)))); } while (0);
    return result;
}




static PyObject *
fixup(PyObject *self,
      Py_UCS4 (*fixfct)(PyObject *s))
{
    PyObject *u;
    Py_UCS4 maxchar_old, maxchar_new = 0;
    PyObject *v;

    u = _PyUnicode_Copy(self);
    if (u == ((void *)0))
        return ((void *)0);
    maxchar_old = ((__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9185, "PyUnicode_IS_READY(u)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9185, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9185, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9185, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9185, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9185, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9185, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));





    maxchar_new = fixfct(u);

    if (maxchar_new == 0) {
                        ;
        if (((((PyObject*)(self))->ob_type) == &PyUnicode_Type)) {
            do { if ( --((PyObject*)(u))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(u)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(u)))); } while (0);
            ( ((PyObject*)(self))->ob_refcnt++);
            return self;
        }
        else
            return u;
    }

    maxchar_new = align_maxchar(maxchar_new);

    if (maxchar_new == maxchar_old)
        return u;



    v = PyUnicode_New(((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9211, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9211, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxchar_new);
    if (v == ((void *)0)) {
        do { if ( --((PyObject*)(u))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(u)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(u)))); } while (0);
        return ((void *)0);
    }
    if (maxchar_new > maxchar_old) {



        _PyUnicode_FastCopyCharacters(v, 0,
                                      self, 0, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9221, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9221, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length));
        maxchar_old = fixfct(v);
        (__builtin_expect(!(maxchar_old > 0 && maxchar_old <= maxchar_new), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9223, "maxchar_old > 0 && maxchar_old <= maxchar_new") : (void)0);
    }
    else {
        _PyUnicode_FastCopyCharacters(v, 0,
                                      u, 0, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9227, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9227, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length));
    }
    do { if ( --((PyObject*)(u))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(u)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(u)))); } while (0);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(v, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9230, "_PyUnicode_CheckConsistency(v, 1)") : (void)0);
    return v;
}

static PyObject *
ascii_upper_or_lower(PyObject *self, int lower)
{
    Py_ssize_t len = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9237, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9237, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    char *resdata, *data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9238, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9238, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9238, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9238, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    PyObject *res;

    res = PyUnicode_New(len, 127);
    if (res == ((void *)0))
        return ((void *)0);
    resdata = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9244, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9244, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9244, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9244, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))));
    if (lower)
        _Py_bytes_lower(resdata, data, len);
    else
        _Py_bytes_upper(resdata, data, len);
    return res;
}

static Py_UCS4
handle_capital_sigma(int kind, void *data, Py_ssize_t length, Py_ssize_t i)
{
    Py_ssize_t j;
    int final_sigma;
    Py_UCS4 c;






    for (j = i - 1; j >= 0; j--) {
        c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(j)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(j)] : ((const Py_UCS4 *)(data))[(j)] ) ));
        if (!_PyUnicode_IsCaseIgnorable(c))
            break;
    }
    final_sigma = j >= 0 && _PyUnicode_IsCased(c);
    if (final_sigma) {
        for (j = i + 1; j < length; j++) {
            c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(j)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(j)] : ((const Py_UCS4 *)(data))[(j)] ) ));
            if (!_PyUnicode_IsCaseIgnorable(c))
                break;
        }
        final_sigma = j == length || !_PyUnicode_IsCased(c);
    }
    return (final_sigma) ? 0x3C2 : 0x3C3;
}

static int
lower_ucs4(int kind, void *data, Py_ssize_t length, Py_ssize_t i,
           Py_UCS4 c, Py_UCS4 *mapped)
{

    if (c == 0x3A3) {
        mapped[0] = handle_capital_sigma(kind, data, length, i);
        return 1;
    }
    return _PyUnicode_ToLowerFull(c, mapped);
}

static Py_ssize_t
do_capitalize(int kind, void *data, Py_ssize_t length, Py_UCS4 *res, Py_UCS4 *maxchar)
{
    Py_ssize_t i, k = 0;
    int n_res, j;
    Py_UCS4 c, mapped[3];

    c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ));
    n_res = _PyUnicode_ToUpperFull(c, mapped);
    for (j = 0; j < n_res; j++) {
        *maxchar = ((*maxchar) | (mapped[j]));
        res[k++] = mapped[j];
    }
    for (i = 1; i < length; i++) {
        c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        n_res = lower_ucs4(kind, data, length, i, c, mapped);
        for (j = 0; j < n_res; j++) {
            *maxchar = ((*maxchar) | (mapped[j]));
            res[k++] = mapped[j];
        }
    }
    return k;
}

static Py_ssize_t
do_swapcase(int kind, void *data, Py_ssize_t length, Py_UCS4 *res, Py_UCS4 *maxchar) {
    Py_ssize_t i, k = 0;

    for (i = 0; i < length; i++) {
        Py_UCS4 c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) )), mapped[3];
        int n_res, j;
        if (_PyUnicode_IsUppercase(c)) {
            n_res = lower_ucs4(kind, data, length, i, c, mapped);
        }
        else if (_PyUnicode_IsLowercase(c)) {
            n_res = _PyUnicode_ToUpperFull(c, mapped);
        }
        else {
            n_res = 1;
            mapped[0] = c;
        }
        for (j = 0; j < n_res; j++) {
            *maxchar = ((*maxchar) | (mapped[j]));
            res[k++] = mapped[j];
        }
    }
    return k;
}

static Py_ssize_t
do_upper_or_lower(int kind, void *data, Py_ssize_t length, Py_UCS4 *res,
                  Py_UCS4 *maxchar, int lower)
{
    Py_ssize_t i, k = 0;

    for (i = 0; i < length; i++) {
        Py_UCS4 c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) )), mapped[3];
        int n_res, j;
        if (lower)
            n_res = lower_ucs4(kind, data, length, i, c, mapped);
        else
            n_res = _PyUnicode_ToUpperFull(c, mapped);
        for (j = 0; j < n_res; j++) {
            *maxchar = ((*maxchar) | (mapped[j]));
            res[k++] = mapped[j];
        }
    }
    return k;
}

static Py_ssize_t
do_upper(int kind, void *data, Py_ssize_t length, Py_UCS4 *res, Py_UCS4 *maxchar)
{
    return do_upper_or_lower(kind, data, length, res, maxchar, 0);
}

static Py_ssize_t
do_lower(int kind, void *data, Py_ssize_t length, Py_UCS4 *res, Py_UCS4 *maxchar)
{
    return do_upper_or_lower(kind, data, length, res, maxchar, 1);
}

static Py_ssize_t
do_casefold(int kind, void *data, Py_ssize_t length, Py_UCS4 *res, Py_UCS4 *maxchar)
{
    Py_ssize_t i, k = 0;

    for (i = 0; i < length; i++) {
        Py_UCS4 c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        Py_UCS4 mapped[3];
        int j, n_res = _PyUnicode_ToFoldedFull(c, mapped);
        for (j = 0; j < n_res; j++) {
            *maxchar = ((*maxchar) | (mapped[j]));
            res[k++] = mapped[j];
        }
    }
    return k;
}

static Py_ssize_t
do_title(int kind, void *data, Py_ssize_t length, Py_UCS4 *res, Py_UCS4 *maxchar)
{
    Py_ssize_t i, k = 0;
    int previous_is_cased;

    previous_is_cased = 0;
    for (i = 0; i < length; i++) {
        const Py_UCS4 c = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        Py_UCS4 mapped[3];
        int n_res, j;

        if (previous_is_cased)
            n_res = lower_ucs4(kind, data, length, i, c, mapped);
        else
            n_res = _PyUnicode_ToTitleFull(c, mapped);

        for (j = 0; j < n_res; j++) {
            *maxchar = ((*maxchar) | (mapped[j]));
            res[k++] = mapped[j];
        }

        previous_is_cased = _PyUnicode_IsCased(c);
    }
    return k;
}

static PyObject *
case_operation(PyObject *self,
               Py_ssize_t (*perform)(int, void *, Py_ssize_t, Py_UCS4 *, Py_UCS4 *))
{
    PyObject *res = ((void *)0);
    Py_ssize_t length, newlength = 0;
    int kind, outkind;
    void *data, *outdata;
    Py_UCS4 maxchar = 0, *tmp, *tmpend;

    (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9429, "PyUnicode_IS_READY(self)") : (void)0);

    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9431, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9431, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9432, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9432, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9432, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9432, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9433, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9433, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    tmp = ((size_t)(sizeof(Py_UCS4) * 3 * length) > (size_t)((Py_ssize_t)(((size_t)-1)>>1)) ? ((void *)0) : malloc((sizeof(Py_UCS4) * 3 * length) ? (sizeof(Py_UCS4) * 3 * length) : 1));
    if (tmp == ((void *)0))
        return PyErr_NoMemory();
    newlength = perform(kind, data, length, tmp, &maxchar);
    res = PyUnicode_New(newlength, maxchar);
    if (res == ((void *)0))
        goto leave;
    tmpend = tmp + newlength;
    outdata = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9442, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9442, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9442, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9442, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))));
    outkind = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9443, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9443, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->state.kind);
    switch (outkind) {
    case PyUnicode_1BYTE_KIND:
        do { Py_UCS1 *_to = (Py_UCS1 *) outdata; const Py_UCS4 *_iter = (tmp); const Py_UCS4 *_end = (tmpend); Py_ssize_t n = (_end) - (_iter); const Py_UCS4 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS1) _iter[0]; _to[1] = (Py_UCS1) _iter[1]; _to[2] = (Py_UCS1) _iter[2]; _to[3] = (Py_UCS1) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS1) *_iter++; } while (0);
        break;
    case PyUnicode_2BYTE_KIND:
        do { Py_UCS2 *_to = (Py_UCS2 *) outdata; const Py_UCS4 *_iter = (tmp); const Py_UCS4 *_end = (tmpend); Py_ssize_t n = (_end) - (_iter); const Py_UCS4 *_unrolled_end = _iter + ((size_t)(n) & ~(size_t)((4) - 1)); while (_iter < (_unrolled_end)) { _to[0] = (Py_UCS2) _iter[0]; _to[1] = (Py_UCS2) _iter[1]; _to[2] = (Py_UCS2) _iter[2]; _to[3] = (Py_UCS2) _iter[3]; _iter += 4; _to += 4; } while (_iter < (_end)) *_to++ = (Py_UCS2) *_iter++; } while (0);
        break;
    case PyUnicode_4BYTE_KIND:
        ((__builtin_object_size (outdata, 0) != (size_t) -1) ? __builtin___memcpy_chk (outdata, tmp, sizeof(Py_UCS4) * newlength, __builtin_object_size (outdata, 0)) : __inline_memcpy_chk (outdata, tmp, sizeof(Py_UCS4) * newlength));
        break;
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9455, "0") : (void)0);
        break;
    }
  leave:
    free(tmp);
    return res;
}

PyObject *
PyUnicode_Join(PyObject *separator, PyObject *seq)
{
    PyObject *sep = ((void *)0);
    Py_ssize_t seplen;
    PyObject *res = ((void *)0);
    PyObject *fseq;
    Py_ssize_t seqlen;
    PyObject **items;
    PyObject *item;
    Py_ssize_t sz, i, res_offset;
    Py_UCS4 maxchar;
    Py_UCS4 item_maxchar;
    int use_memcpy;
    unsigned char *res_data = ((void *)0), *sep_data = ((void *)0);
    PyObject *last_obj;
    unsigned int kind = 0;

    fseq = PySequence_Fast(seq, "");
    if (fseq == ((void *)0)) {
        return ((void *)0);
    }





    seqlen = (((((((PyObject*)(fseq))->ob_type))->tp_flags & ((1L<<25))) != 0) ? (((PyVarObject*)(fseq))->ob_size) : (((PyVarObject*)(fseq))->ob_size));

    if (seqlen == 0) {
        do { if ( --((PyObject*)(fseq))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(fseq)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(fseq)))); } while (0);
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9494, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    }


    last_obj = ((void *)0);
    items = (((((((PyObject*)(fseq))->ob_type))->tp_flags & ((1L<<25))) != 0) ? ((PyListObject *)(fseq))->ob_item : ((PyTupleObject *)(fseq))->ob_item);
    if (seqlen == 1) {
        if (((((PyObject*)(items[0]))->ob_type) == &PyUnicode_Type)) {
            res = items[0];
            ( ((PyObject*)(res))->ob_refcnt++);
            do { if ( --((PyObject*)(fseq))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(fseq)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(fseq)))); } while (0);
            return res;
        }
        seplen = 0;
        maxchar = 0;
    }
    else {

        if (separator == ((void *)0)) {

            sep = PyUnicode_FromOrdinal(' ');
            if (!sep)
                goto onError;
            seplen = 1;
            maxchar = 32;
        }
        else {
            if (!((((((PyObject*)(separator))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
                PyErr_Format(PyExc_TypeError,
                             "separator: expected str instance,"
                             " %.80s found",
                             (((PyObject*)(separator))->ob_type)->tp_name);
                goto onError;
            }
            if (((__builtin_expect(!(((((((PyObject*)(separator))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9528, "_PyUnicode_CHECK(separator)") : (void)0), ((((PyASCIIObject*)separator)->state.ready) ? 0 : _PyUnicode_Ready(separator))))
                goto onError;
            sep = separator;
            seplen = ((__builtin_expect(!(((((((PyObject*)(separator))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9531, "PyUnicode_Check(separator)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)separator)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9531, "PyUnicode_IS_READY(separator)") : (void)0), ((PyASCIIObject *)(separator))->length);
            maxchar = ((__builtin_expect(!((((PyASCIIObject*)separator)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9532, "PyUnicode_IS_READY(separator)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(separator))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9532, "PyUnicode_Check(separator)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)separator)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9532, "PyUnicode_IS_READY(separator)") : (void)0), ((PyASCIIObject*)separator)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(separator))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9532, "PyUnicode_Check(separator)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)separator)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9532, "PyUnicode_IS_READY(separator)") : (void)0), ((PyASCIIObject *)(separator))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(separator))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9532, "PyUnicode_Check(separator)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)separator)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9532, "PyUnicode_IS_READY(separator)") : (void)0), ((PyASCIIObject *)(separator))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));


            ( ((PyObject*)(sep))->ob_refcnt++);
        }
        last_obj = sep;
    }






    sz = 0;



    use_memcpy = 1;

    for (i = 0; i < seqlen; i++) {
        const Py_ssize_t old_sz = sz;
        item = items[i];
        if (!((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
            PyErr_Format(PyExc_TypeError,
                         "sequence item %zd: expected str instance,"
                         " %.80s found",
                         i, (((PyObject*)(item))->ob_type)->tp_name);
            goto onError;
        }
        if (((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9561, "_PyUnicode_CHECK(item)") : (void)0), ((((PyASCIIObject*)item)->state.ready) ? 0 : _PyUnicode_Ready(item))) == -1)
            goto onError;
        sz += ((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9563, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9563, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject *)(item))->length);
        item_maxchar = ((__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9564, "PyUnicode_IS_READY(item)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9564, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9564, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject*)item)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9564, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9564, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject *)(item))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9564, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9564, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject *)(item))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
        maxchar = ((maxchar) | (item_maxchar));
        if (i != 0)
            sz += seplen;
        if (sz < old_sz || sz > ((Py_ssize_t)(((size_t)-1)>>1))) {
            PyErr_SetString(PyExc_OverflowError,
                            "join() result is too long for a Python string");
            goto onError;
        }
        if (use_memcpy && last_obj != ((void *)0)) {
            if (((__builtin_expect(!(((((((PyObject*)(last_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9574, "PyUnicode_Check(last_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)last_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9574, "PyUnicode_IS_READY(last_obj)") : (void)0), ((PyASCIIObject *)(last_obj))->state.kind) != ((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9574, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9574, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject *)(item))->state.kind))
                use_memcpy = 0;
        }
        last_obj = item;
    }

    res = PyUnicode_New(sz, maxchar);
    if (res == ((void *)0))
        goto onError;





    if (use_memcpy) {
        res_data = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9589, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9589, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9589, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9589, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any)))));
        kind = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9590, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9590, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->state.kind);
        if (seplen != 0)
            sep_data = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9592, "PyUnicode_Check(sep)") : (void)0), (((PyASCIIObject*)(sep))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(sep))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9592, "PyUnicode_Check(sep)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9592, "PyUnicode_IS_READY(sep)") : (void)0), ((PyASCIIObject*)sep)->state.ascii) ? ((void*)((PyASCIIObject*)(sep) + 1)) : ((void*)((PyCompactUnicodeObject*)(sep) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(sep))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9592, "((PyUnicodeObject*)(sep))->data.any") : (void)0), ((((PyUnicodeObject *)(sep))->data.any)))));
    }

    for (i = 0, res_offset = 0; i < seqlen; ++i) {
        Py_ssize_t itemlen;
        item = items[i];

        if (i && seplen != 0) {
            if (use_memcpy) {
                ((__builtin_object_size (res_data, 0) != (size_t) -1) ? __builtin___memcpy_chk (res_data, sep_data, kind * seplen, __builtin_object_size (res_data, 0)) : __inline_memcpy_chk (res_data, sep_data, kind * seplen));


                res_data += kind * seplen;
            }
            else {
                _PyUnicode_FastCopyCharacters(res, res_offset, sep, 0, seplen);
                res_offset += seplen;
            }
        }
        itemlen = ((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9611, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9611, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject *)(item))->length);
        if (itemlen != 0) {
            if (use_memcpy) {
                ((__builtin_object_size (res_data, 0) != (size_t) -1) ? __builtin___memcpy_chk (res_data, ((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "PyUnicode_Check(item)") : (void)0), (((PyASCIIObject*)(item))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject*)item)->state.ascii) ? ((void*)((PyASCIIObject*)(item) + 1)) : ((void*)((PyCompactUnicodeObject*)(item) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(item))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "((PyUnicodeObject*)(item))->data.any") : (void)0), ((((PyUnicodeObject *)(item))->data.any)))), kind * itemlen, __builtin_object_size (res_data, 0)) : __inline_memcpy_chk (res_data, ((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "PyUnicode_Check(item)") : (void)0), (((PyASCIIObject*)(item))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(item))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "PyUnicode_Check(item)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)item)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "PyUnicode_IS_READY(item)") : (void)0), ((PyASCIIObject*)item)->state.ascii) ? ((void*)((PyASCIIObject*)(item) + 1)) : ((void*)((PyCompactUnicodeObject*)(item) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(item))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9616, "((PyUnicodeObject*)(item))->data.any") : (void)0), ((((PyUnicodeObject *)(item))->data.any)))), kind * itemlen));


                res_data += kind * itemlen;
            }
            else {
                _PyUnicode_FastCopyCharacters(res, res_offset, item, 0, itemlen);
                res_offset += itemlen;
            }
        }
    }
    if (use_memcpy)
        (__builtin_expect(!(res_data == ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9627, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9627, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9627, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9627, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))))) + kind * ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9627, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9627, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9627, "res_data == PyUnicode_1BYTE_DATA(res) + kind * PyUnicode_GET_LENGTH(res)") : (void)0);

    else
        (__builtin_expect(!(res_offset == ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9629, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9629, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9629, "res_offset == PyUnicode_GET_LENGTH(res)") : (void)0);

    do { if ( --((PyObject*)(fseq))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(fseq)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(fseq)))); } while (0);
    do { if ((sep) == ((void *)0)) ; else do { if ( --((PyObject*)(sep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep)))); } while (0); } while (0);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(res, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9633, "_PyUnicode_CheckConsistency(res, 1)") : (void)0);
    return res;

  onError:
    do { if ( --((PyObject*)(fseq))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(fseq)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(fseq)))); } while (0);
    do { if ((sep) == ((void *)0)) ; else do { if ( --((PyObject*)(sep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep)))); } while (0); } while (0);
    do { if ((res) == ((void *)0)) ; else do { if ( --((PyObject*)(res))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(res)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(res)))); } while (0); } while (0);
    return ((void *)0);
}
# 9667 "unicodeobject.c"
void
_PyUnicode_FastFill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length,
                    Py_UCS4 fill_char)
{
    const enum PyUnicode_Kind kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9671, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9671, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    const void *data = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9672, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9672, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9672, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9672, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));
    (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9673, "PyUnicode_IS_READY(unicode)") : (void)0);
    (__builtin_expect(!(unicode_modifiable(unicode)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9674, "unicode_modifiable(unicode)") : (void)0);
    (__builtin_expect(!(fill_char <= ((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))))), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9675, "fill_char <= PyUnicode_MAX_CHAR_VALUE(unicode)") : (void)0);
    (__builtin_expect(!(start >= 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9676, "start >= 0") : (void)0);
    (__builtin_expect(!(start + length <= ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9677, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9677, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9677, "start + length <= PyUnicode_GET_LENGTH(unicode)") : (void)0);
    do { Py_ssize_t i_ = 0; (__builtin_expect(!(kind != PyUnicode_WCHAR_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9678, "kind != PyUnicode_WCHAR_KIND") : (void)0); switch ((kind)) { case PyUnicode_1BYTE_KIND: { unsigned char * to_ = (unsigned char *)((data)) + (start); ((__builtin_object_size (to_, 0) != (size_t) -1) ? __builtin___memset_chk (to_, (unsigned char)fill_char, (length), __builtin_object_size (to_, 0)) : __inline_memset_chk (to_, (unsigned char)fill_char, (length))); break; } case PyUnicode_2BYTE_KIND: { Py_UCS2 * to_ = (Py_UCS2 *)((data)) + (start); for (; i_ < (length); ++i_, ++to_) *to_ = (fill_char); break; } case PyUnicode_4BYTE_KIND: { Py_UCS4 * to_ = (Py_UCS4 *)((data)) + (start); for (; i_ < (length); ++i_, ++to_) *to_ = (fill_char); break; default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9678, "0") : (void)0); } } } while (0);
}

Py_ssize_t
PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length,
               Py_UCS4 fill_char)
{
    Py_ssize_t maxlen;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 9688);
        return -1;
    }
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9691, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return -1;
    if (unicode_check_modifiable(unicode))
        return -1;

    if (start < 0) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return -1;
    }
    if (fill_char > ((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9700, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9700, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9700, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9700, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9700, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9700, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9700, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))))) {
        PyErr_SetString(PyExc_ValueError,
                         "fill character is bigger than "
                         "the string maximum character");
        return -1;
    }

    maxlen = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9707, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9707, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length) - start;
    length = (((maxlen) > (length)) ? (length) : (maxlen));
    if (length <= 0)
        return 0;

    _PyUnicode_FastFill(unicode, start, length, fill_char);
    return length;
}

static PyObject *
pad(PyObject *self,
    Py_ssize_t left,
    Py_ssize_t right,
    Py_UCS4 fill)
{
    PyObject *u;
    Py_UCS4 maxchar;
    int kind;
    void *data;

    if (left < 0)
        left = 0;
    if (right < 0)
        right = 0;

    if (left == 0 && right == 0)
        return unicode_result_unchanged(self);

    if (left > ((Py_ssize_t)(((size_t)-1)>>1)) - (((PyASCIIObject *)(self))->length) ||
        right > ((Py_ssize_t)(((size_t)-1)>>1)) - (left + (((PyASCIIObject *)(self))->length))) {
        PyErr_SetString(PyExc_OverflowError, "padded string is too long");
        return ((void *)0);
    }
    maxchar = ((__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9740, "PyUnicode_IS_READY(self)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9740, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9740, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9740, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9740, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9740, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9740, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
    maxchar = ((maxchar) | (fill));
    u = PyUnicode_New(left + (((PyASCIIObject *)(self))->length) + right, maxchar);
    if (!u)
        return ((void *)0);

    kind = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9746, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9746, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9747, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9747, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9747, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9747, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))));
    if (left)
        do { Py_ssize_t i_ = 0; (__builtin_expect(!(kind != PyUnicode_WCHAR_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9749, "kind != PyUnicode_WCHAR_KIND") : (void)0); switch ((kind)) { case PyUnicode_1BYTE_KIND: { unsigned char * to_ = (unsigned char *)((data)) + (0); ((__builtin_object_size (to_, 0) != (size_t) -1) ? __builtin___memset_chk (to_, (unsigned char)fill, (left), __builtin_object_size (to_, 0)) : __inline_memset_chk (to_, (unsigned char)fill, (left))); break; } case PyUnicode_2BYTE_KIND: { Py_UCS2 * to_ = (Py_UCS2 *)((data)) + (0); for (; i_ < (left); ++i_, ++to_) *to_ = (fill); break; } case PyUnicode_4BYTE_KIND: { Py_UCS4 * to_ = (Py_UCS4 *)((data)) + (0); for (; i_ < (left); ++i_, ++to_) *to_ = (fill); break; default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9749, "0") : (void)0); } } } while (0);
    if (right)
        do { Py_ssize_t i_ = 0; (__builtin_expect(!(kind != PyUnicode_WCHAR_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9751, "kind != PyUnicode_WCHAR_KIND") : (void)0); switch ((kind)) { case PyUnicode_1BYTE_KIND: { unsigned char * to_ = (unsigned char *)((data)) + (left + (((PyASCIIObject *)(self))->length)); ((__builtin_object_size (to_, 0) != (size_t) -1) ? __builtin___memset_chk (to_, (unsigned char)fill, (right), __builtin_object_size (to_, 0)) : __inline_memset_chk (to_, (unsigned char)fill, (right))); break; } case PyUnicode_2BYTE_KIND: { Py_UCS2 * to_ = (Py_UCS2 *)((data)) + (left + (((PyASCIIObject *)(self))->length)); for (; i_ < (right); ++i_, ++to_) *to_ = (fill); break; } case PyUnicode_4BYTE_KIND: { Py_UCS4 * to_ = (Py_UCS4 *)((data)) + (left + (((PyASCIIObject *)(self))->length)); for (; i_ < (right); ++i_, ++to_) *to_ = (fill); break; default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9751, "0") : (void)0); } } } while (0);
    _PyUnicode_FastCopyCharacters(u, left, self, 0, (((PyASCIIObject *)(self))->length));
    (__builtin_expect(!(_PyUnicode_CheckConsistency(u, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9753, "_PyUnicode_CheckConsistency(u, 1)") : (void)0);
    return u;
}

PyObject *
PyUnicode_Splitlines(PyObject *string, int keepends)
{
    PyObject *list;

    string = PyUnicode_FromObject(string);
    if (string == ((void *)0))
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9765, "_PyUnicode_CHECK(string)") : (void)0), ((((PyASCIIObject*)string)->state.ready) ? 0 : _PyUnicode_Ready(string))) == -1) {
        do { if ( --((PyObject*)(string))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(string)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(string)))); } while (0);
        return ((void *)0);
    }

    switch (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9770, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9770, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->state.kind)) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9772, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9772, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii))
            list = asciilib_splitlines(
                string, ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9774, "PyUnicode_Check(string)") : (void)0), (((PyASCIIObject*)(string))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9774, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9774, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii) ? ((void*)((PyASCIIObject*)(string) + 1)) : ((void*)((PyCompactUnicodeObject*)(string) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(string))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9774, "((PyUnicodeObject*)(string))->data.any") : (void)0), ((((PyUnicodeObject *)(string))->data.any))))),
                ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9775, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9775, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length), keepends);
        else
            list = ucs1lib_splitlines(
                string, ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9778, "PyUnicode_Check(string)") : (void)0), (((PyASCIIObject*)(string))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9778, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9778, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii) ? ((void*)((PyASCIIObject*)(string) + 1)) : ((void*)((PyCompactUnicodeObject*)(string) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(string))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9778, "((PyUnicodeObject*)(string))->data.any") : (void)0), ((((PyUnicodeObject *)(string))->data.any))))),
                ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9779, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9779, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length), keepends);
        break;
    case PyUnicode_2BYTE_KIND:
        list = ucs2lib_splitlines(
            string, ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9783, "PyUnicode_Check(string)") : (void)0), (((PyASCIIObject*)(string))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9783, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9783, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii) ? ((void*)((PyASCIIObject*)(string) + 1)) : ((void*)((PyCompactUnicodeObject*)(string) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(string))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9783, "((PyUnicodeObject*)(string))->data.any") : (void)0), ((((PyUnicodeObject *)(string))->data.any))))),
            ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9784, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9784, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length), keepends);
        break;
    case PyUnicode_4BYTE_KIND:
        list = ucs4lib_splitlines(
            string, ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9788, "PyUnicode_Check(string)") : (void)0), (((PyASCIIObject*)(string))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9788, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9788, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject*)string)->state.ascii) ? ((void*)((PyASCIIObject*)(string) + 1)) : ((void*)((PyCompactUnicodeObject*)(string) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(string))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9788, "((PyUnicodeObject*)(string))->data.any") : (void)0), ((((PyUnicodeObject *)(string))->data.any))))),
            ((__builtin_expect(!(((((((PyObject*)(string))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9789, "PyUnicode_Check(string)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)string)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9789, "PyUnicode_IS_READY(string)") : (void)0), ((PyASCIIObject *)(string))->length), keepends);
        break;
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9792, "0") : (void)0);
        list = 0;
    }
    do { if ( --((PyObject*)(string))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(string)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(string)))); } while (0);
    return list;
}

static PyObject *
split(PyObject *self,
      PyObject *substring,
      Py_ssize_t maxcount)
{
    int kind1, kind2, kind;
    void *buf1, *buf2;
    Py_ssize_t len1, len2;
    PyObject* out;

    if (maxcount < 0)
        maxcount = ((Py_ssize_t)(((size_t)-1)>>1));

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9812, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    if (substring == ((void *)0))
        switch (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9816, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9816, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind)) {
        case PyUnicode_1BYTE_KIND:
            if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9818, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9818, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii))
                return asciilib_split_whitespace(
                    self, ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9820, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9820, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9820, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9820, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                    ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9821, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9821, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                    );
            else
                return ucs1lib_split_whitespace(
                    self, ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9825, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9825, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9825, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9825, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                    ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9826, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9826, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                    );
        case PyUnicode_2BYTE_KIND:
            return ucs2lib_split_whitespace(
                self, ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9830, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9830, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9830, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9830, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9831, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9831, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                );
        case PyUnicode_4BYTE_KIND:
            return ucs4lib_split_whitespace(
                self, ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9835, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9835, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9835, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9835, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9836, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9836, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                );
        default:
            (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9839, "0") : (void)0);
            return ((void *)0);
        }

    if (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9843, "_PyUnicode_CHECK(substring)") : (void)0), ((((PyASCIIObject*)substring)->state.ready) ? 0 : _PyUnicode_Ready(substring))) == -1)
        return ((void *)0);

    kind1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9846, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9846, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9847, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9847, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->state.kind);
    kind = kind1 > kind2 ? kind1 : kind2;
    buf1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9849, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9849, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9849, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9849, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    buf2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9850, "PyUnicode_Check(substring)") : (void)0), (((PyASCIIObject*)(substring))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9850, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9850, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject*)substring)->state.ascii) ? ((void*)((PyASCIIObject*)(substring) + 1)) : ((void*)((PyCompactUnicodeObject*)(substring) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(substring))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9850, "((PyUnicodeObject*)(substring))->data.any") : (void)0), ((((PyUnicodeObject *)(substring))->data.any))));
    if (kind1 != kind)
        buf1 = _PyUnicode_AsKind(self, kind);
    if (!buf1)
        return ((void *)0);
    if (kind2 != kind)
        buf2 = _PyUnicode_AsKind(substring, kind);
    if (!buf2) {
        if (kind1 != kind) PyMem_Free(buf1);
        return ((void *)0);
    }
    len1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9861, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9861, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9862, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9862, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->length);

    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9866, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9866, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9866, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9866, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject*)substring)->state.ascii))
            out = asciilib_split(
                self, buf1, len1, buf2, len2, maxcount);
        else
            out = ucs1lib_split(
                self, buf1, len1, buf2, len2, maxcount);
        break;
    case PyUnicode_2BYTE_KIND:
        out = ucs2lib_split(
            self, buf1, len1, buf2, len2, maxcount);
        break;
    case PyUnicode_4BYTE_KIND:
        out = ucs4lib_split(
            self, buf1, len1, buf2, len2, maxcount);
        break;
    default:
        out = ((void *)0);
    }
    if (kind1 != kind)
        PyMem_Free(buf1);
    if (kind2 != kind)
        PyMem_Free(buf2);
    return out;
}

static PyObject *
rsplit(PyObject *self,
       PyObject *substring,
       Py_ssize_t maxcount)
{
    int kind1, kind2, kind;
    void *buf1, *buf2;
    Py_ssize_t len1, len2;
    PyObject* out;

    if (maxcount < 0)
        maxcount = ((Py_ssize_t)(((size_t)-1)>>1));

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9904, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    if (substring == ((void *)0))
        switch (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9908, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9908, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind)) {
        case PyUnicode_1BYTE_KIND:
            if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9910, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9910, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii))
                return asciilib_rsplit_whitespace(
                    self, ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9912, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9912, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9912, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9912, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                    ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9913, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9913, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                    );
            else
                return ucs1lib_rsplit_whitespace(
                    self, ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9917, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9917, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9917, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9917, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                    ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9918, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9918, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                    );
        case PyUnicode_2BYTE_KIND:
            return ucs2lib_rsplit_whitespace(
                self, ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9922, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9922, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9922, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9922, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9923, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9923, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                );
        case PyUnicode_4BYTE_KIND:
            return ucs4lib_rsplit_whitespace(
                self, ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9927, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9927, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9927, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9927, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))))),
                ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9928, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9928, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), maxcount
                );
        default:
            (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9931, "0") : (void)0);
            return ((void *)0);
        }

    if (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9935, "_PyUnicode_CHECK(substring)") : (void)0), ((((PyASCIIObject*)substring)->state.ready) ? 0 : _PyUnicode_Ready(substring))) == -1)
        return ((void *)0);

    kind1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9938, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9938, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9939, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9939, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->state.kind);
    kind = kind1 > kind2 ? kind1 : kind2;
    buf1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9941, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9941, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9941, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9941, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    buf2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9942, "PyUnicode_Check(substring)") : (void)0), (((PyASCIIObject*)(substring))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9942, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9942, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject*)substring)->state.ascii) ? ((void*)((PyASCIIObject*)(substring) + 1)) : ((void*)((PyCompactUnicodeObject*)(substring) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(substring))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9942, "((PyUnicodeObject*)(substring))->data.any") : (void)0), ((((PyUnicodeObject *)(substring))->data.any))));
    if (kind1 != kind)
        buf1 = _PyUnicode_AsKind(self, kind);
    if (!buf1)
        return ((void *)0);
    if (kind2 != kind)
        buf2 = _PyUnicode_AsKind(substring, kind);
    if (!buf2) {
        if (kind1 != kind) PyMem_Free(buf1);
        return ((void *)0);
    }
    len1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9953, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9953, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9954, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9954, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->length);

    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9958, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9958, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9958, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9958, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject*)substring)->state.ascii))
            out = asciilib_rsplit(
                self, buf1, len1, buf2, len2, maxcount);
        else
            out = ucs1lib_rsplit(
                self, buf1, len1, buf2, len2, maxcount);
        break;
    case PyUnicode_2BYTE_KIND:
        out = ucs2lib_rsplit(
            self, buf1, len1, buf2, len2, maxcount);
        break;
    case PyUnicode_4BYTE_KIND:
        out = ucs4lib_rsplit(
            self, buf1, len1, buf2, len2, maxcount);
        break;
    default:
        out = ((void *)0);
    }
    if (kind1 != kind)
        PyMem_Free(buf1);
    if (kind2 != kind)
        PyMem_Free(buf2);
    return out;
}

static Py_ssize_t
anylib_find(int kind, PyObject *str1, void *buf1, Py_ssize_t len1,
            PyObject *str2, void *buf2, Py_ssize_t len2, Py_ssize_t offset)
{
    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9989, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9989, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject*)str1)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9989, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9989, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject*)str2)->state.ascii))
            return asciilib_find(buf1, len1, buf2, len2, offset);
        else
            return ucs1lib_find(buf1, len1, buf2, len2, offset);
    case PyUnicode_2BYTE_KIND:
        return ucs2lib_find(buf1, len1, buf2, len2, offset);
    case PyUnicode_4BYTE_KIND:
        return ucs4lib_find(buf1, len1, buf2, len2, offset);
    }
    (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 9998, "0") : (void)0);
    return -1;
}

static Py_ssize_t
anylib_count(int kind, PyObject *sstr, void* sbuf, Py_ssize_t slen,
             PyObject *str1, void *buf1, Py_ssize_t len1, Py_ssize_t maxcount)
{
    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(sstr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10008, "PyUnicode_Check(sstr)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sstr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10008, "PyUnicode_IS_READY(sstr)") : (void)0), ((PyASCIIObject*)sstr)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10008, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10008, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject*)str1)->state.ascii))
            return asciilib_count(sbuf, slen, buf1, len1, maxcount);
        else
            return ucs1lib_count(sbuf, slen, buf1, len1, maxcount);
    case PyUnicode_2BYTE_KIND:
        return ucs2lib_count(sbuf, slen, buf1, len1, maxcount);
    case PyUnicode_4BYTE_KIND:
        return ucs4lib_count(sbuf, slen, buf1, len1, maxcount);
    }
    (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10017, "0") : (void)0);
    return 0;
}

static PyObject *
replace(PyObject *self, PyObject *str1,
        PyObject *str2, Py_ssize_t maxcount)
{
    PyObject *u;
    char *sbuf = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10026, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10026, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10026, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10026, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    char *buf1 = ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10027, "PyUnicode_Check(str1)") : (void)0), (((PyASCIIObject*)(str1))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10027, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10027, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject*)str1)->state.ascii) ? ((void*)((PyASCIIObject*)(str1) + 1)) : ((void*)((PyCompactUnicodeObject*)(str1) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str1))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10027, "((PyUnicodeObject*)(str1))->data.any") : (void)0), ((((PyUnicodeObject *)(str1))->data.any))));
    char *buf2 = ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10028, "PyUnicode_Check(str2)") : (void)0), (((PyASCIIObject*)(str2))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10028, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10028, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject*)str2)->state.ascii) ? ((void*)((PyASCIIObject*)(str2) + 1)) : ((void*)((PyCompactUnicodeObject*)(str2) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str2))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10028, "((PyUnicodeObject*)(str2))->data.any") : (void)0), ((((PyUnicodeObject *)(str2))->data.any))));
    int srelease = 0, release1 = 0, release2 = 0;
    int skind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10030, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10030, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    int kind1 = ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10031, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10031, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject *)(str1))->state.kind);
    int kind2 = ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10032, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10032, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject *)(str2))->state.kind);
    Py_ssize_t slen = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10033, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10033, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    Py_ssize_t len1 = ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10034, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10034, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject *)(str1))->length);
    Py_ssize_t len2 = ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10035, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10035, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject *)(str2))->length);
    int mayshrink;
    Py_UCS4 maxchar, maxchar_str2;

    if (maxcount < 0)
        maxcount = ((Py_ssize_t)(((size_t)-1)>>1));
    else if (maxcount == 0 || slen == 0)
        goto nothing;

    if (str1 == str2)
        goto nothing;
    if (skind < kind1)

        goto nothing;

    maxchar = ((__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10050, "PyUnicode_IS_READY(self)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10050, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10050, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10050, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10050, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10050, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10050, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
    maxchar_str2 = ((__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10051, "PyUnicode_IS_READY(str2)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10051, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10051, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject*)str2)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10051, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10051, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject *)(str2))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10051, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10051, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject *)(str2))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));


    mayshrink = (maxchar_str2 < maxchar);
    maxchar = ((maxchar) | (maxchar_str2));

    if (len1 == len2) {

        if (len1 == 0)
            goto nothing;
        if (len1 == 1) {

            Py_UCS4 u1, u2;
            int rkind;
            Py_ssize_t index, pos;
            char *src;

            u1 = ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_IS_READY(str1)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str1))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_IS_READY((str1))") : (void)0), ((PyASCIIObject *)((str1)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (((PyASCIIObject*)((str1)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str1))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_IS_READY((str1))") : (void)0), ((PyASCIIObject*)(str1))->state.ascii) ? ((void*)((PyASCIIObject*)((str1)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str1)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str1)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "((PyUnicodeObject*)((str1)))->data.any") : (void)0), ((((PyUnicodeObject *)((str1)))->data.any))))))[(0)] : (((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str1))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_IS_READY((str1))") : (void)0), ((PyASCIIObject *)((str1)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (((PyASCIIObject*)((str1)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str1))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_IS_READY((str1))") : (void)0), ((PyASCIIObject*)(str1))->state.ascii) ? ((void*)((PyASCIIObject*)((str1)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str1)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str1)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "((PyUnicodeObject*)((str1)))->data.any") : (void)0), ((((PyUnicodeObject *)((str1)))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (((PyASCIIObject*)((str1)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str1)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_Check((str1))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str1))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "PyUnicode_IS_READY((str1))") : (void)0), ((PyASCIIObject*)(str1))->state.ascii) ? ((void*)((PyASCIIObject*)((str1)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str1)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str1)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10068, "((PyUnicodeObject*)((str1)))->data.any") : (void)0), ((((PyUnicodeObject *)((str1)))->data.any))))))[(0)] ) ));
            pos = findchar(sbuf, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10069, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10069, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind), slen, u1, 1);
            if (pos < 0)
                goto nothing;
            u2 = ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_IS_READY(str2)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str2))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_IS_READY((str2))") : (void)0), ((PyASCIIObject *)((str2)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (((PyASCIIObject*)((str2)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str2))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_IS_READY((str2))") : (void)0), ((PyASCIIObject*)(str2))->state.ascii) ? ((void*)((PyASCIIObject*)((str2)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str2)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str2)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "((PyUnicodeObject*)((str2)))->data.any") : (void)0), ((((PyUnicodeObject *)((str2)))->data.any))))))[(0)] : (((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str2))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_IS_READY((str2))") : (void)0), ((PyASCIIObject *)((str2)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (((PyASCIIObject*)((str2)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str2))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_IS_READY((str2))") : (void)0), ((PyASCIIObject*)(str2))->state.ascii) ? ((void*)((PyASCIIObject*)((str2)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str2)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str2)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "((PyUnicodeObject*)((str2)))->data.any") : (void)0), ((((PyUnicodeObject *)((str2)))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (((PyASCIIObject*)((str2)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str2)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_Check((str2))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str2))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "PyUnicode_IS_READY((str2))") : (void)0), ((PyASCIIObject*)(str2))->state.ascii) ? ((void*)((PyASCIIObject*)((str2)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str2)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str2)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10072, "((PyUnicodeObject*)((str2)))->data.any") : (void)0), ((((PyUnicodeObject *)((str2)))->data.any))))))[(0)] ) ));
            u = PyUnicode_New(slen, maxchar);
            if (!u)
                goto error;
            _PyUnicode_FastCopyCharacters(u, 0, self, 0, slen);
            rkind = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10077, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10077, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind);

            do { switch ((rkind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))))))[(pos)] = (Py_UCS1)(u2); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))))))[(pos)] = (Py_UCS2)(u2); break; } default: { (__builtin_expect(!((rkind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "(rkind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10079, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))))))[(pos)] = (Py_UCS4)(u2); } } } while (0);
            index = 0;
            src = sbuf;
            while (--maxcount)
            {
                pos++;
                src += pos * ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10085, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10085, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
                slen -= pos;
                index += pos;
                pos = findchar(src, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10088, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10088, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind), slen, u1, 1);
                if (pos < 0)
                    break;
                do { switch ((rkind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))))))[(index + pos)] = (Py_UCS1)(u2); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))))))[(index + pos)] = (Py_UCS2)(u2); break; } default: { (__builtin_expect(!((rkind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "(rkind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10091, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))))))[(index + pos)] = (Py_UCS4)(u2); } } } while (0);
            }
        }
        else {
            int rkind = skind;
            char *res;
            Py_ssize_t i;

            if (kind1 < rkind) {

                buf1 = _PyUnicode_AsKind(str1, rkind);
                if (!buf1) goto error;
                release1 = 1;
            }
            i = anylib_find(rkind, self, sbuf, slen, str1, buf1, len1, 0);
            if (i < 0)
                goto nothing;
            if (rkind > kind2) {

                buf2 = _PyUnicode_AsKind(str2, rkind);
                if (!buf2) goto error;
                release2 = 1;
            }
            else if (rkind < kind2) {

                rkind = kind2;
                if (release1) PyMem_Free(buf1);
                release1 = 0;
                sbuf = _PyUnicode_AsKind(self, rkind);
                if (!sbuf) goto error;
                srelease = 1;
                buf1 = _PyUnicode_AsKind(str1, rkind);
                if (!buf1) goto error;
                release1 = 1;
            }
            u = PyUnicode_New(slen, maxchar);
            if (!u)
                goto error;
            (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10129, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10129, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind) == rkind), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10129, "PyUnicode_KIND(u) == rkind") : (void)0);
            res = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10130, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10130, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10130, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10130, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))));

            ((__builtin_object_size (res, 0) != (size_t) -1) ? __builtin___memcpy_chk (res, sbuf, rkind * slen, __builtin_object_size (res, 0)) : __inline_memcpy_chk (res, sbuf, rkind * slen));

            ((__builtin_object_size (res + rkind * i, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * i, buf2, rkind * len2, __builtin_object_size (res + rkind * i, 0)) : __inline_memcpy_chk (res + rkind * i, buf2, rkind * len2));


            i += len1;

            while ( --maxcount > 0) {
                i = anylib_find(rkind, self,
                                sbuf+rkind*i, slen-i,
                                str1, buf1, len1, i);
                if (i == -1)
                    break;
                ((__builtin_object_size (res + rkind * i, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * i, buf2, rkind * len2, __builtin_object_size (res + rkind * i, 0)) : __inline_memcpy_chk (res + rkind * i, buf2, rkind * len2));


                i += len1;
            }
        }
    }
    else {
        Py_ssize_t n, i, j, ires;
        Py_ssize_t new_size;
        int rkind = skind;
        char *res;

        if (kind1 < rkind) {

            buf1 = _PyUnicode_AsKind(str1, rkind);
            if (!buf1) goto error;
            release1 = 1;
        }
        n = anylib_count(rkind, self, sbuf, slen, str1, buf1, len1, maxcount);
        if (n == 0)
            goto nothing;
        if (kind2 < rkind) {

            buf2 = _PyUnicode_AsKind(str2, rkind);
            if (!buf2) goto error;
            release2 = 1;
        }
        else if (kind2 > rkind) {

            rkind = kind2;
            sbuf = _PyUnicode_AsKind(self, rkind);
            if (!sbuf) goto error;
            srelease = 1;
            if (release1) PyMem_Free(buf1);
            release1 = 0;
            buf1 = _PyUnicode_AsKind(str1, rkind);
            if (!buf1) goto error;
            release1 = 1;
        }


        if (len2 > len1 && len2 - len1 > (((Py_ssize_t)(((size_t)-1)>>1)) - slen) / n) {
                PyErr_SetString(PyExc_OverflowError,
                                "replace string is too long");
                goto error;
        }
        new_size = slen + n * (len2 - len1);
        if (new_size == 0) {
            do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10194, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0);
            if (!unicode_empty)
                goto error;
            u = unicode_empty;
            goto done;
        }
        if (new_size > (((Py_ssize_t)(((size_t)-1)>>1)) >> (rkind-1))) {
            PyErr_SetString(PyExc_OverflowError,
                            "replace string is too long");
            goto error;
        }
        u = PyUnicode_New(new_size, maxchar);
        if (!u)
            goto error;
        (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10208, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10208, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind) == rkind), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10208, "PyUnicode_KIND(u) == rkind") : (void)0);
        res = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10209, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10209, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10209, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10209, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))));
        ires = i = 0;
        if (len1 > 0) {
            while (n-- > 0) {

                j = anylib_find(rkind, self,
                                sbuf + rkind * i, slen-i,
                                str1, buf1, len1, i);
                if (j == -1)
                    break;
                else if (j > i) {

                    ((__builtin_object_size (res + rkind * ires, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind * (j-i), __builtin_object_size (res + rkind * ires, 0)) : __inline_memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind * (j-i)));


                    ires += j - i;
                }

                if (len2 > 0) {
                    ((__builtin_object_size (res + rkind * ires, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * ires, buf2, rkind * len2, __builtin_object_size (res + rkind * ires, 0)) : __inline_memcpy_chk (res + rkind * ires, buf2, rkind * len2));


                    ires += len2;
                }
                i = j + len1;
            }
            if (i < slen)

                ((__builtin_object_size (res + rkind * ires, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind * (slen-i), __builtin_object_size (res + rkind * ires, 0)) : __inline_memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind * (slen-i)));


        }
        else {

            while (n > 0) {
                ((__builtin_object_size (res + rkind * ires, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * ires, buf2, rkind * len2, __builtin_object_size (res + rkind * ires, 0)) : __inline_memcpy_chk (res + rkind * ires, buf2, rkind * len2));


                ires += len2;
                if (--n <= 0)
                    break;
                ((__builtin_object_size (res + rkind * ires, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind, __builtin_object_size (res + rkind * ires, 0)) : __inline_memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind));


                ires++;
                i++;
            }
            ((__builtin_object_size (res + rkind * ires, 0) != (size_t) -1) ? __builtin___memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind * (slen-i), __builtin_object_size (res + rkind * ires, 0)) : __inline_memcpy_chk (res + rkind * ires, sbuf + rkind * i, rkind * (slen-i)));


        }
    }

    if (mayshrink) {
        unicode_adjust_maxchar(&u);
        if (u == ((void *)0))
            goto error;
    }

  done:
    if (srelease)
        free(sbuf);
    if (release1)
        free(buf1);
    if (release2)
        free(buf2);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(u, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10275, "_PyUnicode_CheckConsistency(u, 1)") : (void)0);
    return u;

  nothing:

    if (srelease)
        free(sbuf);
    if (release1)
        free(buf1);
    if (release2)
        free(buf2);
    return unicode_result_unchanged(self);

  error:
    if (srelease && sbuf)
        free(sbuf);
    if (release1 && buf1)
        free(buf1);
    if (release2 && buf2)
        free(buf2);
    return ((void *)0);
}



static char title__doc__[] = "S.title() -> str\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case.";





static PyObject*
unicode_title(PyObject *self)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10309, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    return case_operation(self, do_title);
}

static char capitalize__doc__[] = "S.capitalize() -> str\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case.";





static PyObject*
unicode_capitalize(PyObject *self)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10323, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10325, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10325, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length) == 0)
        return unicode_result_unchanged(self);
    return case_operation(self, do_capitalize);
}

static char casefold__doc__[] = "S.casefold() -> str\n\nReturn a version of S suitable for caseless comparisons.";




static PyObject *
unicode_casefold(PyObject *self)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10338, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10340, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10340, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii))
        return ascii_upper_or_lower(self, 1);
    return case_operation(self, do_casefold);
}




static int
convert_uc(PyObject *obj, void *addr)
{
    Py_UCS4 *fillcharloc = (Py_UCS4 *)addr;
    PyObject *uniobj;

    uniobj = PyUnicode_FromObject(obj);
    if (uniobj == ((void *)0)) {
        PyErr_SetString(PyExc_TypeError,
                        "The fill character cannot be converted to Unicode");
        return 0;
    }
    if (((__builtin_expect(!(((((((PyObject*)(uniobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10360, "PyUnicode_Check(uniobj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uniobj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10360, "PyUnicode_IS_READY(uniobj)") : (void)0), ((PyASCIIObject *)(uniobj))->length) != 1) {
        PyErr_SetString(PyExc_TypeError,
                        "The fill character must be exactly one character long");
        do { if ( --((PyObject*)(uniobj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(uniobj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(uniobj)))); } while (0);
        return 0;
    }
    *fillcharloc = ((__builtin_expect(!(((((((PyObject*)(uniobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check(uniobj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uniobj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_IS_READY(uniobj)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(uniobj))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_IS_READY((uniobj))") : (void)0), ((PyASCIIObject *)((uniobj)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (((PyASCIIObject*)((uniobj)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(uniobj))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_IS_READY((uniobj))") : (void)0), ((PyASCIIObject*)(uniobj))->state.ascii) ? ((void*)((PyASCIIObject*)((uniobj)) + 1)) : ((void*)((PyCompactUnicodeObject*)((uniobj)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((uniobj)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "((PyUnicodeObject*)((uniobj)))->data.any") : (void)0), ((((PyUnicodeObject *)((uniobj)))->data.any))))))[(0)] : (((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(uniobj))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_IS_READY((uniobj))") : (void)0), ((PyASCIIObject *)((uniobj)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (((PyASCIIObject*)((uniobj)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(uniobj))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_IS_READY((uniobj))") : (void)0), ((PyASCIIObject*)(uniobj))->state.ascii) ? ((void*)((PyASCIIObject*)((uniobj)) + 1)) : ((void*)((PyCompactUnicodeObject*)((uniobj)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((uniobj)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "((PyUnicodeObject*)((uniobj)))->data.any") : (void)0), ((((PyUnicodeObject *)((uniobj)))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (((PyASCIIObject*)((uniobj)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((uniobj)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_Check((uniobj))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(uniobj))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "PyUnicode_IS_READY((uniobj))") : (void)0), ((PyASCIIObject*)(uniobj))->state.ascii) ? ((void*)((PyASCIIObject*)((uniobj)) + 1)) : ((void*)((PyCompactUnicodeObject*)((uniobj)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((uniobj)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10366, "((PyUnicodeObject*)((uniobj)))->data.any") : (void)0), ((((PyUnicodeObject *)((uniobj)))->data.any))))))[(0)] ) ));
    do { if ( --((PyObject*)(uniobj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(uniobj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(uniobj)))); } while (0);
    return 1;
}

static char center__doc__[] = "S.center(width[, fillchar]) -> str\n\nReturn S centered in a string of length width. Padding is\ndone using the specified fill character (default is a space)";





static PyObject *
unicode_center(PyObject *self, PyObject *args)
{
    Py_ssize_t marg, left;
    Py_ssize_t width;
    Py_UCS4 fillchar = ' ';

    if (!_PyArg_ParseTuple_SizeT(args, "n|O&:center", &width, convert_uc, &fillchar))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10387, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10390, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10390, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length) >= width)
        return unicode_result_unchanged(self);

    marg = width - ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10393, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10393, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    left = marg / 2 + (marg & width & 1);

    return pad(self, left, marg - left, fillchar);
}



static int
unicode_compare(PyObject *str1, PyObject *str2)
{
    int kind1, kind2;
    void *data1, *data2;
    Py_ssize_t len1, len2, i;

    kind1 = ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10408, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10408, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject *)(str1))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10409, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10409, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject *)(str2))->state.kind);
    data1 = ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10410, "PyUnicode_Check(str1)") : (void)0), (((PyASCIIObject*)(str1))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10410, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10410, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject*)str1)->state.ascii) ? ((void*)((PyASCIIObject*)(str1) + 1)) : ((void*)((PyCompactUnicodeObject*)(str1) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str1))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10410, "((PyUnicodeObject*)(str1))->data.any") : (void)0), ((((PyUnicodeObject *)(str1))->data.any))));
    data2 = ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10411, "PyUnicode_Check(str2)") : (void)0), (((PyASCIIObject*)(str2))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10411, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10411, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject*)str2)->state.ascii) ? ((void*)((PyASCIIObject*)(str2) + 1)) : ((void*)((PyCompactUnicodeObject*)(str2) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str2))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10411, "((PyUnicodeObject*)(str2))->data.any") : (void)0), ((((PyUnicodeObject *)(str2))->data.any))));
    len1 = ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10412, "PyUnicode_Check(str1)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str1)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10412, "PyUnicode_IS_READY(str1)") : (void)0), ((PyASCIIObject *)(str1))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10413, "PyUnicode_Check(str2)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str2)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10413, "PyUnicode_IS_READY(str2)") : (void)0), ((PyASCIIObject *)(str2))->length);

    for (i = 0; i < len1 && i < len2; ++i) {
        Py_UCS4 c1, c2;
        c1 = ((Py_UCS4) ((kind1) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data1))[(i)] : ((kind1) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data1))[(i)] : ((const Py_UCS4 *)(data1))[(i)] ) ));
        c2 = ((Py_UCS4) ((kind2) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data2))[(i)] : ((kind2) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data2))[(i)] : ((const Py_UCS4 *)(data2))[(i)] ) ));

        if (c1 != c2)
            return (c1 < c2) ? -1 : 1;
    }

    return (len1 < len2) ? -1 : (len1 != len2);
}

int
PyUnicode_Compare(PyObject *left, PyObject *right)
{
    if (((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0) && ((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        if (((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10431, "_PyUnicode_CHECK(left)") : (void)0), ((((PyASCIIObject*)left)->state.ready) ? 0 : _PyUnicode_Ready(left))) == -1 ||
            ((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10432, "_PyUnicode_CHECK(right)") : (void)0), ((((PyASCIIObject*)right)->state.ready) ? 0 : _PyUnicode_Ready(right))) == -1)
            return -1;
        return unicode_compare(left, right);
    }
    PyErr_Format(PyExc_TypeError,
                 "Can't compare %.100s and %.100s",
                 left->ob_type->tp_name,
                 right->ob_type->tp_name);
    return -1;
}

int
PyUnicode_CompareWithASCIIString(PyObject* uni, const char* str)
{
    Py_ssize_t i;
    int kind;
    void *data;
    Py_UCS4 chr;

    (__builtin_expect(!(((((((PyObject*)(uni))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10451, "_PyUnicode_CHECK(uni)") : (void)0);
    if (((__builtin_expect(!(((((((PyObject*)(uni))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10452, "_PyUnicode_CHECK(uni)") : (void)0), ((((PyASCIIObject*)uni)->state.ready) ? 0 : _PyUnicode_Ready(uni))) == -1)
        return -1;
    kind = ((__builtin_expect(!(((((((PyObject*)(uni))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10454, "PyUnicode_Check(uni)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uni)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10454, "PyUnicode_IS_READY(uni)") : (void)0), ((PyASCIIObject *)(uni))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(uni))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10455, "PyUnicode_Check(uni)") : (void)0), (((PyASCIIObject*)(uni))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(uni))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10455, "PyUnicode_Check(uni)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uni)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10455, "PyUnicode_IS_READY(uni)") : (void)0), ((PyASCIIObject*)uni)->state.ascii) ? ((void*)((PyASCIIObject*)(uni) + 1)) : ((void*)((PyCompactUnicodeObject*)(uni) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(uni))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10455, "((PyUnicodeObject*)(uni))->data.any") : (void)0), ((((PyUnicodeObject *)(uni))->data.any))));

    for (i = 0; (chr = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))) && str[i]; i++)
        if (chr != str[i])
            return (chr < (unsigned char)(str[i])) ? -1 : 1;


    if (((__builtin_expect(!(((((((PyObject*)(uni))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10462, "PyUnicode_Check(uni)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uni)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10462, "PyUnicode_IS_READY(uni)") : (void)0), ((PyASCIIObject *)(uni))->length) != i || chr)
        return 1;
    if (str[i])
        return -1;
    return 0;
}





PyObject *
PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
{
    int result;

    if (((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0) && ((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyObject *v;
        if (((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10480, "_PyUnicode_CHECK(left)") : (void)0), ((((PyASCIIObject*)left)->state.ready) ? 0 : _PyUnicode_Ready(left))) == -1 ||
            ((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10481, "_PyUnicode_CHECK(right)") : (void)0), ((((PyASCIIObject*)right)->state.ready) ? 0 : _PyUnicode_Ready(right))) == -1)
            return ((void *)0);
        if (((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10483, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10483, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject *)(left))->length) != ((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10483, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10483, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject *)(right))->length) ||
            ((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10484, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10484, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject *)(left))->state.kind) != ((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10484, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10484, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject *)(right))->state.kind)) {
            if (op == 2) {
                ( ((PyObject*)(((PyObject *) &_Py_FalseStruct)))->ob_refcnt++);
                return ((PyObject *) &_Py_FalseStruct);
            }
            if (op == 3) {
                ( ((PyObject*)(((PyObject *) &_Py_TrueStruct)))->ob_refcnt++);
                return ((PyObject *) &_Py_TrueStruct);
            }
        }
        if (left == right)
            result = 0;
        else
            result = unicode_compare(left, right);


        switch (op) {
        case 2:
            v = ((result == 0) ? ((PyObject *) &_Py_TrueStruct) : ((PyObject *) &_Py_FalseStruct));
            break;
        case 3:
            v = ((result != 0) ? ((PyObject *) &_Py_TrueStruct) : ((PyObject *) &_Py_FalseStruct));
            break;
        case 1:
            v = ((result <= 0) ? ((PyObject *) &_Py_TrueStruct) : ((PyObject *) &_Py_FalseStruct));
            break;
        case 5:
            v = ((result >= 0) ? ((PyObject *) &_Py_TrueStruct) : ((PyObject *) &_Py_FalseStruct));
            break;
        case 0:
            v = ((result == -1) ? ((PyObject *) &_Py_TrueStruct) : ((PyObject *) &_Py_FalseStruct));
            break;
        case 4:
            v = ((result == 1) ? ((PyObject *) &_Py_TrueStruct) : ((PyObject *) &_Py_FalseStruct));
            break;
        default:
            PyErr_BadArgument();
            return ((void *)0);
        }
        ( ((PyObject*)(v))->ob_refcnt++);
        return v;
    }

    return ( ((PyObject*)((&_Py_NotImplementedStruct)))->ob_refcnt++), (&_Py_NotImplementedStruct);
}

int
PyUnicode_Contains(PyObject *container, PyObject *element)
{
    PyObject *str, *sub;
    int kind1, kind2, kind;
    void *buf1, *buf2;
    Py_ssize_t len1, len2;
    int result;


    sub = PyUnicode_FromObject(element);
    if (!sub) {
        PyErr_Format(PyExc_TypeError,
                     "'in <string>' requires string as left operand, not %s",
                     element->ob_type->tp_name);
        return -1;
    }

    str = PyUnicode_FromObject(container);
    if (!str) {
        do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);
        return -1;
    }
    if (((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10553, "_PyUnicode_CHECK(sub)") : (void)0), ((((PyASCIIObject*)sub)->state.ready) ? 0 : _PyUnicode_Ready(sub))) == -1 || ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10553, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1) {
        do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);
        do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
    }

    kind1 = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10558, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10558, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10559, "PyUnicode_Check(sub)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sub)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10559, "PyUnicode_IS_READY(sub)") : (void)0), ((PyASCIIObject *)(sub))->state.kind);
    kind = kind1;
    buf1 = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10561, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10561, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10561, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10561, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))));
    buf2 = ((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10562, "PyUnicode_Check(sub)") : (void)0), (((PyASCIIObject*)(sub))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10562, "PyUnicode_Check(sub)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sub)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10562, "PyUnicode_IS_READY(sub)") : (void)0), ((PyASCIIObject*)sub)->state.ascii) ? ((void*)((PyASCIIObject*)(sub) + 1)) : ((void*)((PyCompactUnicodeObject*)(sub) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(sub))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10562, "((PyUnicodeObject*)(sub))->data.any") : (void)0), ((((PyUnicodeObject *)(sub))->data.any))));
    if (kind2 != kind) {
        if (kind2 > kind) {
            do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);
            do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
            return 0;
        }
        buf2 = _PyUnicode_AsKind(sub, kind);
    }
    if (!buf2) {
        do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);
        do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
        return -1;
    }
    len1 = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10576, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10576, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(sub))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10577, "PyUnicode_Check(sub)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sub)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10577, "PyUnicode_IS_READY(sub)") : (void)0), ((PyASCIIObject *)(sub))->length);

    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        result = ucs1lib_find(buf1, len1, buf2, len2, 0) != -1;
        break;
    case PyUnicode_2BYTE_KIND:
        result = ucs2lib_find(buf1, len1, buf2, len2, 0) != -1;
        break;
    case PyUnicode_4BYTE_KIND:
        result = ucs4lib_find(buf1, len1, buf2, len2, 0) != -1;
        break;
    default:
        result = -1;
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10591, "0") : (void)0);
    }

    do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
    do { if ( --((PyObject*)(sub))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sub)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sub)))); } while (0);

    if (kind2 != kind)
        PyMem_Free(buf2);

    return result;
}



PyObject *
PyUnicode_Concat(PyObject *left, PyObject *right)
{
    PyObject *u = ((void *)0), *v = ((void *)0), *w;
    Py_UCS4 maxchar, maxchar2;
    Py_ssize_t u_len, v_len, new_len;


    u = PyUnicode_FromObject(left);
    if (u == ((void *)0))
        goto onError;
    v = PyUnicode_FromObject(right);
    if (v == ((void *)0))
        goto onError;


    if (v == unicode_empty) {
        do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0);
        return u;
    }
    if (u == unicode_empty) {
        do { if ( --((PyObject*)(u))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(u)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(u)))); } while (0);
        return v;
    }

    u_len = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10630, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10630, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->length);
    v_len = ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10631, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10631, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length);
    if (u_len > ((Py_ssize_t)(((size_t)-1)>>1)) - v_len) {
        PyErr_SetString(PyExc_OverflowError,
                        "strings are too large to concat");
        goto onError;
    }
    new_len = u_len + v_len;

    maxchar = ((__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10639, "PyUnicode_IS_READY(u)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10639, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10639, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10639, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10639, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10639, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10639, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
    maxchar2 = ((__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10640, "PyUnicode_IS_READY(v)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10640, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10640, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10640, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10640, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10640, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10640, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
    maxchar = ((maxchar) | (maxchar2));


    w = PyUnicode_New(new_len, maxchar);
    if (w == ((void *)0))
        goto onError;
    _PyUnicode_FastCopyCharacters(w, 0, u, 0, u_len);
    _PyUnicode_FastCopyCharacters(w, u_len, v, 0, v_len);
    do { if ( --((PyObject*)(u))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(u)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(u)))); } while (0);
    do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(w, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10651, "_PyUnicode_CheckConsistency(w, 1)") : (void)0);
    return w;

  onError:
    do { if ((u) == ((void *)0)) ; else do { if ( --((PyObject*)(u))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(u)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(u)))); } while (0); } while (0);
    do { if ((v) == ((void *)0)) ; else do { if ( --((PyObject*)(v))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(v)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(v)))); } while (0); } while (0);
    return ((void *)0);
}

void
PyUnicode_Append(PyObject **p_left, PyObject *right)
{
    PyObject *left, *res;
    Py_UCS4 maxchar, maxchar2;
    Py_ssize_t left_len, right_len, new_len;

    if (p_left == ((void *)0)) {
        if (!PyErr_Occurred())
            _PyErr_BadInternalCall("unicodeobject.c", 10669);
        return;
    }
    left = *p_left;
    if (right == ((void *)0) || left == ((void *)0) || !((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        if (!PyErr_Occurred())
            _PyErr_BadInternalCall("unicodeobject.c", 10675);
        goto error;
    }

    if (((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10679, "_PyUnicode_CHECK(left)") : (void)0), ((((PyASCIIObject*)left)->state.ready) ? 0 : _PyUnicode_Ready(left))) == -1)
        goto error;
    if (((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10681, "_PyUnicode_CHECK(right)") : (void)0), ((((PyASCIIObject*)right)->state.ready) ? 0 : _PyUnicode_Ready(right))) == -1)
        goto error;


    if (left == unicode_empty) {
        do { if ( --((PyObject*)(left))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(left)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(left)))); } while (0);
        ( ((PyObject*)(right))->ob_refcnt++);
        *p_left = right;
        return;
    }
    if (right == unicode_empty)
        return;

    left_len = ((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10694, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10694, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject *)(left))->length);
    right_len = ((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10695, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10695, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject *)(right))->length);
    if (left_len > ((Py_ssize_t)(((size_t)-1)>>1)) - right_len) {
        PyErr_SetString(PyExc_OverflowError,
                        "strings are too large to concat");
        goto error;
    }
    new_len = left_len + right_len;

    if (unicode_modifiable(left)
        && ((((PyObject*)(right))->ob_type) == &PyUnicode_Type)
        && ((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10705, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10705, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject *)(right))->state.kind) <= ((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10705, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10705, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject *)(left))->state.kind)




        && !(((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10710, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10710, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject*)left)->state.ascii) && !((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10710, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10710, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject*)right)->state.ascii)))
    {

        if (unicode_resize(p_left, new_len) != 0) {






            goto error;
        }

        _PyUnicode_FastCopyCharacters(*p_left, left_len, right, 0, right_len);
    }
    else {
        maxchar = ((__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10726, "PyUnicode_IS_READY(left)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10726, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10726, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject*)left)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10726, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10726, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject *)(left))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(left))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10726, "PyUnicode_Check(left)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)left)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10726, "PyUnicode_IS_READY(left)") : (void)0), ((PyASCIIObject *)(left))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
        maxchar2 = ((__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10727, "PyUnicode_IS_READY(right)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10727, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10727, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject*)right)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10727, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10727, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject *)(right))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(right))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10727, "PyUnicode_Check(right)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)right)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10727, "PyUnicode_IS_READY(right)") : (void)0), ((PyASCIIObject *)(right))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
        maxchar = ((maxchar) | (maxchar2));


        res = PyUnicode_New(new_len, maxchar);
        if (res == ((void *)0))
            goto error;
        _PyUnicode_FastCopyCharacters(res, 0, left, 0, left_len);
        _PyUnicode_FastCopyCharacters(res, left_len, right, 0, right_len);
        do { if ( --((PyObject*)(left))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(left)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(left)))); } while (0);
        *p_left = res;
    }
    (__builtin_expect(!(_PyUnicode_CheckConsistency(*p_left, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10739, "_PyUnicode_CheckConsistency(*p_left, 1)") : (void)0);
    return;

error:
    do { if (*p_left) { PyObject *_py_tmp = (PyObject *)(*p_left); (*p_left) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
}

void
PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
{
    PyUnicode_Append(pleft, right);
    do { if ((right) == ((void *)0)) ; else do { if ( --((PyObject*)(right))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(right)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(right)))); } while (0); } while (0);
}

static char count__doc__[] = "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation.";






static PyObject *
unicode_count(PyObject *self, PyObject *args)
{
    PyObject *substring;
    Py_ssize_t start = 0;
    Py_ssize_t end = ((Py_ssize_t)(((size_t)-1)>>1));
    PyObject *result;
    int kind1, kind2, kind;
    void *buf1, *buf2;
    Py_ssize_t len1, len2, iresult;

    if (!stringlib_parse_args_finds_unicode("count", args, &substring,
                                            &start, &end))
        return ((void *)0);

    kind1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10775, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10775, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10776, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10776, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->state.kind);
    if (kind2 > kind1)
        return PyLong_FromLong(0);
    kind = kind1;
    buf1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10780, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10780, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10780, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10780, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    buf2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10781, "PyUnicode_Check(substring)") : (void)0), (((PyASCIIObject*)(substring))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10781, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10781, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject*)substring)->state.ascii) ? ((void*)((PyASCIIObject*)(substring) + 1)) : ((void*)((PyCompactUnicodeObject*)(substring) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(substring))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10781, "((PyUnicodeObject*)(substring))->data.any") : (void)0), ((((PyUnicodeObject *)(substring))->data.any))));
    if (kind2 != kind)
        buf2 = _PyUnicode_AsKind(substring, kind);
    if (!buf2) {
        do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);
        return ((void *)0);
    }
    len1 = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10788, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10788, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10789, "PyUnicode_Check(substring)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)substring)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10789, "PyUnicode_IS_READY(substring)") : (void)0), ((PyASCIIObject *)(substring))->length);

    if (end > len1) end = len1; else if (end < 0) { end += len1; if (end < 0) end = 0; } if (start < 0) { start += len1; if (start < 0) start = 0; };
    switch (kind) {
    case PyUnicode_1BYTE_KIND:
        iresult = ucs1lib_count(
            ((Py_UCS1*)buf1) + start, end - start,
            buf2, len2, ((Py_ssize_t)(((size_t)-1)>>1))
            );
        break;
    case PyUnicode_2BYTE_KIND:
        iresult = ucs2lib_count(
            ((Py_UCS2*)buf1) + start, end - start,
            buf2, len2, ((Py_ssize_t)(((size_t)-1)>>1))
            );
        break;
    case PyUnicode_4BYTE_KIND:
        iresult = ucs4lib_count(
            ((Py_UCS4*)buf1) + start, end - start,
            buf2, len2, ((Py_ssize_t)(((size_t)-1)>>1))
            );
        break;
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10812, "0") : (void)0); iresult = 0;
    }

    result = PyLong_FromSsize_t(iresult);

    if (kind2 != kind)
        PyMem_Free(buf2);

    do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);

    return result;
}

static char encode__doc__[] = "S.encode(encoding='utf-8', errors='strict') -> bytes\n\nEncode S using the codec registered for encoding. Default encoding\nis 'utf-8'. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors.";
# 10835 "unicodeobject.c"
static PyObject *
unicode_encode(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"encoding", "errors", 0};
    char *encoding = ((void *)0);
    char *errors = ((void *)0);

    if (!_PyArg_ParseTupleAndKeywords_SizeT(args, kwargs, "|ss:encode",
                                     kwlist, &encoding, &errors))
        return ((void *)0);
    return PyUnicode_AsEncodedString(self, encoding, errors);
}

static char expandtabs__doc__[] = "S.expandtabs([tabsize]) -> str\n\nReturn a copy of S where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed.";





static PyObject*
unicode_expandtabs(PyObject *self, PyObject *args)
{
    Py_ssize_t i, j, line_pos, src_len, incr;
    Py_UCS4 ch;
    PyObject *u;
    void *src_data, *dest_data;
    int tabsize = 8;
    int kind;
    int found;

    if (!_PyArg_ParseTuple_SizeT(args, "|i:expandtabs", &tabsize))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10868, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);


    src_len = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10872, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10872, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    i = j = line_pos = 0;
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10874, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10874, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    src_data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10875, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10875, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10875, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10875, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    found = 0;
    for (; i < src_len; i++) {
        ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(src_data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(src_data))[(i)] : ((const Py_UCS4 *)(src_data))[(i)] ) ));
        if (ch == '\t') {
            found = 1;
            if (tabsize > 0) {
                incr = tabsize - (line_pos % tabsize);
                if (j > ((Py_ssize_t)(((size_t)-1)>>1)) - incr)
                    goto overflow;
                line_pos += incr;
                j += incr;
            }
        }
        else {
            if (j > ((Py_ssize_t)(((size_t)-1)>>1)) - 1)
                goto overflow;
            line_pos++;
            j++;
            if (ch == '\n' || ch == '\r')
                line_pos = 0;
        }
    }
    if (!found)
        return unicode_result_unchanged(self);


    u = PyUnicode_New(j, ((__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10902, "PyUnicode_IS_READY(self)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10902, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10902, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10902, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10902, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10902, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10902, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))));
    if (!u)
        return ((void *)0);
    dest_data = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10905, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10905, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10905, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10905, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))));

    i = j = line_pos = 0;

    for (; i < src_len; i++) {
        ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(src_data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(src_data))[(i)] : ((const Py_UCS4 *)(src_data))[(i)] ) ));
        if (ch == '\t') {
            if (tabsize > 0) {
                incr = tabsize - (line_pos % tabsize);
                line_pos += incr;
                do { Py_ssize_t i_ = 0; (__builtin_expect(!(kind != PyUnicode_WCHAR_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10915, "kind != PyUnicode_WCHAR_KIND") : (void)0); switch ((kind)) { case PyUnicode_1BYTE_KIND: { unsigned char * to_ = (unsigned char *)((dest_data)) + (j); ((__builtin_object_size (to_, 0) != (size_t) -1) ? __builtin___memset_chk (to_, (unsigned char)' ', (incr), __builtin_object_size (to_, 0)) : __inline_memset_chk (to_, (unsigned char)' ', (incr))); break; } case PyUnicode_2BYTE_KIND: { Py_UCS2 * to_ = (Py_UCS2 *)((dest_data)) + (j); for (; i_ < (incr); ++i_, ++to_) *to_ = (' '); break; } case PyUnicode_4BYTE_KIND: { Py_UCS4 * to_ = (Py_UCS4 *)((dest_data)) + (j); for (; i_ < (incr); ++i_, ++to_) *to_ = (' '); break; default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10915, "0") : (void)0); } } } while (0);
                j += incr;
            }
        }
        else {
            line_pos++;
            do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(dest_data))[(j)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(dest_data))[(j)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10921, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(dest_data))[(j)] = (Py_UCS4)(ch); } } } while (0);
            j++;
            if (ch == '\n' || ch == '\r')
                line_pos = 0;
        }
    }
    (__builtin_expect(!(j == ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10927, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10927, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->length)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10927, "j == PyUnicode_GET_LENGTH(u)") : (void)0);
    return unicode_result(u);

  overflow:
    PyErr_SetString(PyExc_OverflowError, "new string is too long");
    return ((void *)0);
}

static char find__doc__[] = "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
# 10944 "unicodeobject.c"
static PyObject *
unicode_find(PyObject *self, PyObject *args)
{
    PyObject *substring;
    Py_ssize_t start;
    Py_ssize_t end;
    Py_ssize_t result;

    if (!stringlib_parse_args_finds_unicode("find", args, &substring,
                                            &start, &end))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10956, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10958, "_PyUnicode_CHECK(substring)") : (void)0), ((((PyASCIIObject*)substring)->state.ready) ? 0 : _PyUnicode_Ready(substring))) == -1)
        return ((void *)0);

    result = any_find_slice(1, self, substring, start, end);

    do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);

    if (result == -2)
        return ((void *)0);

    return PyLong_FromSsize_t(result);
}

static PyObject *
unicode_getitem(PyObject *self, Py_ssize_t index)
{
    void *data;
    enum PyUnicode_Kind kind;
    Py_UCS4 ch;
    PyObject *res;

    if (!((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0) || ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10979, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    if (index < 0 || index >= ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10983, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10983, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length)) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return ((void *)0);
    }
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10987, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10987, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10988, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10988, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10988, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10988, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(index)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(index)] : ((const Py_UCS4 *)(data))[(index)] ) ));
    if (ch < 256)
        return get_latin1_char(ch);

    res = PyUnicode_New(1, ch);
    if (res == ((void *)0))
        return ((void *)0);
    kind = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10996, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10996, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject *)(res))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10997, "PyUnicode_Check(res)") : (void)0), (((PyASCIIObject*)(res))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(res))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10997, "PyUnicode_Check(res)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)res)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10997, "PyUnicode_IS_READY(res)") : (void)0), ((PyASCIIObject*)res)->state.ascii) ? ((void*)((PyASCIIObject*)(res) + 1)) : ((void*)((PyCompactUnicodeObject*)(res) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(res))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10997, "((PyUnicodeObject*)(res))->data.any") : (void)0), ((((PyUnicodeObject *)(res))->data.any))));
    do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(0)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(0)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10998, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(0)] = (Py_UCS4)(ch); } } } while (0);
    (__builtin_expect(!(_PyUnicode_CheckConsistency(res, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 10999, "_PyUnicode_CheckConsistency(res, 1)") : (void)0);
    return res;
}



static Py_hash_t
unicode_hash(PyObject *self)
{
    Py_ssize_t len;
    Py_uhash_t x;




    if ((((PyASCIIObject *)(self))->hash) != -1)
        return (((PyASCIIObject *)(self))->hash);
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11016, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return -1;
    len = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11018, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11018, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);




    if (len == 0) {
        (((PyASCIIObject *)(self))->hash) = 0;
        return 0;
    }







    x = (Py_uhash_t) _Py_HashSecret.prefix;
    switch (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11035, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11035, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind)) {
    case PyUnicode_1BYTE_KIND: {
        const unsigned char *c = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11037, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11037, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11037, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11037, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any)))));
        x ^= (Py_uhash_t) *c << 7; while (--len >= 0) x = (1000003UL * x) ^ (Py_uhash_t) *c++;;
        break;
    }
    case PyUnicode_2BYTE_KIND: {
        const Py_UCS2 *s = ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11042, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11042, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11042, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11042, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any)))));
        x ^= (Py_uhash_t) *s << 7; while (--len >= 0) x = (1000003UL * x) ^ (Py_uhash_t) *s++;;
        break;
    }
    default: {
        Py_UCS4 *l;
        (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11049, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11049, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind) == PyUnicode_4BYTE_KIND && "Impossible switch case in unicode_hash"), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11049, "PyUnicode_KIND(self) == PyUnicode_4BYTE_KIND && \"Impossible switch case in unicode_hash\"") : (void)0);

        l = ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11050, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11050, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11050, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11050, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any)))));
        x ^= (Py_uhash_t) *l << 7; while (--len >= 0) x = (1000003UL * x) ^ (Py_uhash_t) *l++;;
        break;
    }
    }
    x ^= (Py_uhash_t) ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11055, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11055, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    x ^= (Py_uhash_t) _Py_HashSecret.suffix;

    if (x == -1)
        x = -2;
    (((PyASCIIObject *)(self))->hash) = x;
    return x;
}


static char index__doc__[] = "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found.";




static PyObject *
unicode_index(PyObject *self, PyObject *args)
{
    Py_ssize_t result;
    PyObject *substring;
    Py_ssize_t start;
    Py_ssize_t end;

    if (!stringlib_parse_args_finds_unicode("index", args, &substring,
                                            &start, &end))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11082, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11084, "_PyUnicode_CHECK(substring)") : (void)0), ((((PyASCIIObject*)substring)->state.ready) ? 0 : _PyUnicode_Ready(substring))) == -1)
        return ((void *)0);

    result = any_find_slice(1, self, substring, start, end);

    do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);

    if (result == -2)
        return ((void *)0);

    if (result < 0) {
        PyErr_SetString(PyExc_ValueError, "substring not found");
        return ((void *)0);
    }

    return PyLong_FromSsize_t(result);
}

static char islower__doc__[] = "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise.";





static PyObject*
unicode_islower(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;
    int cased;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11116, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11118, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11118, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11119, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11119, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11120, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11120, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11120, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11120, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1)
        return PyBool_FromLong(
            _PyUnicode_IsLowercase(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ))));


    if (length == 0)
        return PyBool_FromLong(0);

    cased = 0;
    for (i = 0; i < length; i++) {
        const Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));

        if (_PyUnicode_IsUppercase(ch) || _PyUnicode_IsTitlecase(ch))
            return PyBool_FromLong(0);
        else if (!cased && _PyUnicode_IsLowercase(ch))
            cased = 1;
    }
    return PyBool_FromLong(cased);
}

static char isupper__doc__[] = "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise.";





static PyObject*
unicode_isupper(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;
    int cased;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11157, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11159, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11159, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11160, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11160, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11161, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11161, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11161, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11161, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1)
        return PyBool_FromLong(
            _PyUnicode_IsUppercase(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ))) != 0);


    if (length == 0)
        return PyBool_FromLong(0);

    cased = 0;
    for (i = 0; i < length; i++) {
        const Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));

        if (_PyUnicode_IsLowercase(ch) || _PyUnicode_IsTitlecase(ch))
            return PyBool_FromLong(0);
        else if (!cased && _PyUnicode_IsUppercase(ch))
            cased = 1;
    }
    return PyBool_FromLong(cased);
}

static char istitle__doc__[] = "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise.";







static PyObject*
unicode_istitle(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;
    int cased, previous_is_cased;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11200, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11202, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11202, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11203, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11203, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11204, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11204, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11204, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11204, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1) {
        Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ));
        return PyBool_FromLong((_PyUnicode_IsTitlecase(ch) != 0) ||
                               (_PyUnicode_IsUppercase(ch) != 0));
    }


    if (length == 0)
        return PyBool_FromLong(0);

    cased = 0;
    previous_is_cased = 0;
    for (i = 0; i < length; i++) {
        const Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));

        if (_PyUnicode_IsUppercase(ch) || _PyUnicode_IsTitlecase(ch)) {
            if (previous_is_cased)
                return PyBool_FromLong(0);
            previous_is_cased = 1;
            cased = 1;
        }
        else if (_PyUnicode_IsLowercase(ch)) {
            if (!previous_is_cased)
                return PyBool_FromLong(0);
            previous_is_cased = 1;
            cased = 1;
        }
        else
            previous_is_cased = 0;
    }
    return PyBool_FromLong(cased);
}

static char isspace__doc__[] = "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise.";





static PyObject*
unicode_isspace(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11253, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11255, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11255, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11256, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11256, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11257, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11257, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11257, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11257, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1)
        return PyBool_FromLong(
            ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ))) < 128U ? _Py_ascii_whitespace[(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) )))] : _PyUnicode_IsWhitespace(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) )))));


    if (length == 0)
        return PyBool_FromLong(0);

    for (i = 0; i < length; i++) {
        const Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        if (!((ch) < 128U ? _Py_ascii_whitespace[(ch)] : _PyUnicode_IsWhitespace(ch)))
            return PyBool_FromLong(0);
    }
    return PyBool_FromLong(1);
}

static char isalpha__doc__[] = "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise.";





static PyObject*
unicode_isalpha(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11289, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11291, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11291, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11292, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11292, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11293, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11293, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11293, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11293, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1)
        return PyBool_FromLong(
            _PyUnicode_IsAlpha(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ))));


    if (length == 0)
        return PyBool_FromLong(0);

    for (i = 0; i < length; i++) {
        if (!_PyUnicode_IsAlpha(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))))
            return PyBool_FromLong(0);
    }
    return PyBool_FromLong(1);
}

static char isalnum__doc__[] = "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise.";





static PyObject*
unicode_isalnum(PyObject *self)
{
    int kind;
    void *data;
    Py_ssize_t len, i;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11324, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11327, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11327, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11328, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11328, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11328, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11328, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11329, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11329, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);


    if (len == 1) {
        const Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ));
        return PyBool_FromLong((_PyUnicode_IsAlpha(ch) || _PyUnicode_IsDecimalDigit(ch) || _PyUnicode_IsDigit(ch) || _PyUnicode_IsNumeric(ch)));
    }


    if (len == 0)
        return PyBool_FromLong(0);

    for (i = 0; i < len; i++) {
        const Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ));
        if (!(_PyUnicode_IsAlpha(ch) || _PyUnicode_IsDecimalDigit(ch) || _PyUnicode_IsDigit(ch) || _PyUnicode_IsNumeric(ch)))
            return PyBool_FromLong(0);
    }
    return PyBool_FromLong(1);
}

static char isdecimal__doc__[] = "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise.";





static PyObject*
unicode_isdecimal(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11362, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11364, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11364, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11365, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11365, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11366, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11366, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11366, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11366, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1)
        return PyBool_FromLong(
            _PyUnicode_IsDecimalDigit(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ))));


    if (length == 0)
        return PyBool_FromLong(0);

    for (i = 0; i < length; i++) {
        if (!_PyUnicode_IsDecimalDigit(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))))
            return PyBool_FromLong(0);
    }
    return PyBool_FromLong(1);
}

static char isdigit__doc__[] = "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise.";





static PyObject*
unicode_isdigit(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11397, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11399, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11399, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11400, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11400, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11401, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11401, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11401, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11401, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1) {
        const Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ));
        return PyBool_FromLong(_PyUnicode_IsDigit(ch));
    }


    if (length == 0)
        return PyBool_FromLong(0);

    for (i = 0; i < length; i++) {
        if (!_PyUnicode_IsDigit(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))))
            return PyBool_FromLong(0);
    }
    return PyBool_FromLong(1);
}

static char isnumeric__doc__[] = "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise.";





static PyObject*
unicode_isnumeric(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11433, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11435, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11435, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11436, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11436, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11437, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11437, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11437, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11437, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1)
        return PyBool_FromLong(
            _PyUnicode_IsNumeric(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ))));


    if (length == 0)
        return PyBool_FromLong(0);

    for (i = 0; i < length; i++) {
        if (!_PyUnicode_IsNumeric(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))))
            return PyBool_FromLong(0);
    }
    return PyBool_FromLong(1);
}

int
PyUnicode_IsIdentifier(PyObject *self)
{
    int kind;
    void *data;
    Py_ssize_t i;
    Py_UCS4 first;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11463, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1) {
        Py_FatalError("identifier not ready");
        return 0;
    }


    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11469, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11469, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length) == 0)
        return 0;
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11471, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11471, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11472, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11472, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11472, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11472, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
# 11482 "unicodeobject.c"
    first = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ));
    if (!_PyUnicode_IsXidStart(first) && first != 0x5F )
        return 0;

    for (i = 1; i < ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11486, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11486, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length); i++)
        if (!_PyUnicode_IsXidContinue(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))))
            return 0;
    return 1;
}

static char isidentifier__doc__[] = "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according\nto the language definition.\n\nUse keyword.iskeyword() to test for reserved identifiers\nsuch as \"def\" and \"class\".\n";
# 11501 "unicodeobject.c"
static PyObject*
unicode_isidentifier(PyObject *self)
{
    return PyBool_FromLong(PyUnicode_IsIdentifier(self));
}

static char isprintable__doc__[] = "S.isprintable() -> bool\n\nReturn True if all characters in S are considered\nprintable in repr() or S is empty, False otherwise.";





static PyObject*
unicode_isprintable(PyObject *self)
{
    Py_ssize_t i, length;
    int kind;
    void *data;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11520, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11522, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11522, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11523, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11523, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11524, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11524, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11524, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11524, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));


    if (length == 1)
        return PyBool_FromLong(
            _PyUnicode_IsPrintable(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) ))));

    for (i = 0; i < length; i++) {
        if (!_PyUnicode_IsPrintable(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) )))) {
            return ( ((PyObject*)(((PyObject *) &_Py_FalseStruct)))->ob_refcnt++), ((PyObject *) &_Py_FalseStruct);
        }
    }
    return ( ((PyObject*)(((PyObject *) &_Py_TrueStruct)))->ob_refcnt++), ((PyObject *) &_Py_TrueStruct);
}

static char join__doc__[] = "S.join(iterable) -> str\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S.";





static PyObject*
unicode_join(PyObject *self, PyObject *data)
{
    return PyUnicode_Join(self, data);
}

static Py_ssize_t
unicode_length(PyObject *self)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11554, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return -1;
    return ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11556, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11556, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
}

static char ljust__doc__[] = "S.ljust(width[, fillchar]) -> str\n\nReturn S left-justified in a Unicode string of length width. Padding is\ndone using the specified fill character (default is a space).";





static PyObject *
unicode_ljust(PyObject *self, PyObject *args)
{
    Py_ssize_t width;
    Py_UCS4 fillchar = ' ';

    if (!_PyArg_ParseTuple_SizeT(args, "n|O&:ljust", &width, convert_uc, &fillchar))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11574, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11577, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11577, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length) >= width)
        return unicode_result_unchanged(self);

    return pad(self, 0, width - ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11580, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11580, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), fillchar);
}

static char lower__doc__[] = "S.lower() -> str\n\nReturn a copy of the string S converted to lowercase.";




static PyObject*
unicode_lower(PyObject *self)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11591, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11593, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11593, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii))
        return ascii_upper_or_lower(self, 1);
    return case_operation(self, do_lower);
}






static const char *stripformat[] = {"|O:lstrip", "|O:rstrip", "|O:strip"};




PyObject *
_PyUnicode_XStrip(PyObject *self, int striptype, PyObject *sepobj)
{
    void *data;
    int kind;
    Py_ssize_t i, j, len;
    unsigned long sepmask;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11616, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1 || ((__builtin_expect(!(((((((PyObject*)(sepobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11616, "_PyUnicode_CHECK(sepobj)") : (void)0), ((((PyASCIIObject*)sepobj)->state.ready) ? 0 : _PyUnicode_Ready(sepobj))) == -1)
        return ((void *)0);

    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11619, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11619, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11620, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11620, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11620, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11620, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11621, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11621, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    sepmask = make_bloom_mask(((__builtin_expect(!(((((((PyObject*)(sepobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11622, "PyUnicode_Check(sepobj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sepobj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11622, "PyUnicode_IS_READY(sepobj)") : (void)0), ((PyASCIIObject *)(sepobj))->state.kind),
                              ((__builtin_expect(!(((((((PyObject*)(sepobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11623, "PyUnicode_Check(sepobj)") : (void)0), (((PyASCIIObject*)(sepobj))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(sepobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11623, "PyUnicode_Check(sepobj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sepobj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11623, "PyUnicode_IS_READY(sepobj)") : (void)0), ((PyASCIIObject*)sepobj)->state.ascii) ? ((void*)((PyASCIIObject*)(sepobj) + 1)) : ((void*)((PyCompactUnicodeObject*)(sepobj) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(sepobj))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11623, "((PyUnicodeObject*)(sepobj))->data.any") : (void)0), ((((PyUnicodeObject *)(sepobj))->data.any)))),
                              ((__builtin_expect(!(((((((PyObject*)(sepobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11624, "PyUnicode_Check(sepobj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sepobj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11624, "PyUnicode_IS_READY(sepobj)") : (void)0), ((PyASCIIObject *)(sepobj))->length));

    i = 0;
    if (striptype != 1) {
        while (i < len &&
               (((sepmask & (1UL << ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))) & (64 - 1))))) && (PyUnicode_FindChar(sepobj, ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) )), 0, ((__builtin_expect(!(((((((PyObject*)(sepobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11629, "PyUnicode_Check(sepobj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sepobj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11629, "PyUnicode_IS_READY(sepobj)") : (void)0), ((PyASCIIObject *)(sepobj))->length), 1) >= 0))) {
            i++;
        }
    }

    j = len;
    if (striptype != 0) {
        do {
            j--;
        } while (j >= i &&
                 (((sepmask & (1UL << ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(j)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(j)] : ((const Py_UCS4 *)(data))[(j)] ) ))) & (64 - 1))))) && (PyUnicode_FindChar(sepobj, ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(j)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(j)] : ((const Py_UCS4 *)(data))[(j)] ) )), 0, ((__builtin_expect(!(((((((PyObject*)(sepobj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11639, "PyUnicode_Check(sepobj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sepobj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11639, "PyUnicode_IS_READY(sepobj)") : (void)0), ((PyASCIIObject *)(sepobj))->length), 1) >= 0)));
        j++;
    }

    return PyUnicode_Substring(self, i, j);
}

PyObject*
PyUnicode_Substring(PyObject *self, Py_ssize_t start, Py_ssize_t end)
{
    unsigned char *data;
    int kind;
    Py_ssize_t length;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11653, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    length = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11656, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11656, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
    end = (((end) > (length)) ? (length) : (end));

    if (start == 0 && end == length)
        return unicode_result_unchanged(self);

    if (start < 0 || end < 0) {
        PyErr_SetString(PyExc_IndexError, "string index out of range");
        return ((void *)0);
    }
    if (start >= length || end < start)
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11667, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);

    length = end - start;
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11670, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11670, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii)) {
        data = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11671, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11671, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11671, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11671, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any)))));
        return _PyUnicode_FromASCII((char*)(data + start), length);
    }
    else {
        kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11675, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11675, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
        data = ((Py_UCS1*)((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11676, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11676, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11676, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11676, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any)))));
        return PyUnicode_FromKindAndData(kind,
                                         data + kind * start,
                                         length);
    }
}

static PyObject *
do_strip(PyObject *self, int striptype)
{
    int kind;
    void *data;
    Py_ssize_t len, i, j;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11690, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11693, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11693, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11694, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11694, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11694, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11694, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
    len = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11695, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11695, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);

    i = 0;
    if (striptype != 1) {
        while (i < len && ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))) < 128U ? _Py_ascii_whitespace[(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) )))] : _PyUnicode_IsWhitespace(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(i)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(i)] : ((const Py_UCS4 *)(data))[(i)] ) ))))) {
            i++;
        }
    }

    j = len;
    if (striptype != 0) {
        do {
            j--;
        } while (j >= i && ((((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(j)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(j)] : ((const Py_UCS4 *)(data))[(j)] ) ))) < 128U ? _Py_ascii_whitespace[(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(j)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(j)] : ((const Py_UCS4 *)(data))[(j)] ) )))] : _PyUnicode_IsWhitespace(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(j)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(j)] : ((const Py_UCS4 *)(data))[(j)] ) )))));
        j++;
    }

    return PyUnicode_Substring(self, i, j);
}


static PyObject *
do_argstrip(PyObject *self, int striptype, PyObject *args)
{
    PyObject *sep = ((void *)0);

    if (!_PyArg_ParseTuple_SizeT(args, (char *)stripformat[striptype], &sep))
        return ((void *)0);

    if (sep != ((void *)0) && sep != (&_Py_NoneStruct)) {
        if (((((((PyObject*)(sep))->ob_type))->tp_flags & ((1L<<28))) != 0))
            return _PyUnicode_XStrip(self, striptype, sep);
        else {
            PyErr_Format(PyExc_TypeError,
                         "%s arg must be None or str",
                         (stripformat[striptype]+3));
            return ((void *)0);
        }
    }

    return do_strip(self, striptype);
}


static char strip__doc__[] = "S.strip([chars]) -> str\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.";






static PyObject *
unicode_strip(PyObject *self, PyObject *args)
{
    if ((((PyVarObject*)(args))->ob_size) == 0)
        return do_strip(self, 2);
    else
        return do_argstrip(self, 2, args);
}


static char lstrip__doc__[] = "S.lstrip([chars]) -> str\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.";





static PyObject *
unicode_lstrip(PyObject *self, PyObject *args)
{
    if ((((PyVarObject*)(args))->ob_size) == 0)
        return do_strip(self, 0);
    else
        return do_argstrip(self, 0, args);
}


static char rstrip__doc__[] = "S.rstrip([chars]) -> str\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.";





static PyObject *
unicode_rstrip(PyObject *self, PyObject *args)
{
    if ((((PyVarObject*)(args))->ob_size) == 0)
        return do_strip(self, 1);
    else
        return do_argstrip(self, 1, args);
}


static PyObject*
unicode_repeat(PyObject *str, Py_ssize_t len)
{
    PyObject *u;
    Py_ssize_t nchars, n;

    if (len < 1)
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11795, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);


    if (len == 1)
        return unicode_result_unchanged(str);

    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11801, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1)
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11804, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11804, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length) > ((Py_ssize_t)(((size_t)-1)>>1)) / len) {
        PyErr_SetString(PyExc_OverflowError,
                        "repeated string is too long");
        return ((void *)0);
    }
    nchars = len * ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11809, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11809, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);

    u = PyUnicode_New(nchars, ((__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11811, "PyUnicode_IS_READY(str)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11811, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11811, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11811, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11811, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11811, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11811, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))));
    if (!u)
        return ((void *)0);
    (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11814, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11814, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind) == ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11814, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11814, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11814, "PyUnicode_KIND(u) == PyUnicode_KIND(str)") : (void)0);

    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11816, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11816, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length) == 1) {
        const int kind = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11817, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11817, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind);
        const Py_UCS4 fill_char = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))))))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11818, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any))))))[(0)] ) ));
        if (kind == PyUnicode_1BYTE_KIND) {
            void *to = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11820, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11820, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11820, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11820, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))));
            ((__builtin_object_size (to, 0) != (size_t) -1) ? __builtin___memset_chk (to, (unsigned char)fill_char, len, __builtin_object_size (to, 0)) : __inline_memset_chk (to, (unsigned char)fill_char, len));
        }
        else if (kind == PyUnicode_2BYTE_KIND) {
            Py_UCS2 *ucs2 = ((Py_UCS2*)((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11824, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11824, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11824, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11824, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any)))));
            for (n = 0; n < len; ++n)
                ucs2[n] = fill_char;
        } else {
            Py_UCS4 *ucs4 = ((Py_UCS4*)((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11828, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11828, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11828, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11828, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any)))));
            (__builtin_expect(!(kind == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11829, "kind == PyUnicode_4BYTE_KIND") : (void)0);
            for (n = 0; n < len; ++n)
                ucs4[n] = fill_char;
        }
    }
    else {

        Py_ssize_t done = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11836, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11836, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);
        const Py_ssize_t char_size = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11837, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11837, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind);
        char *to = (char *) ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11838, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11838, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11838, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11838, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))));
        ((__builtin_object_size (to, 0) != (size_t) -1) ? __builtin___memcpy_chk (to, ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any)))), ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length) * char_size, __builtin_object_size (to, 0)) : __inline_memcpy_chk (to, ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_Check(str)") : (void)0), (((PyASCIIObject*)(str))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? ((void*)((PyASCIIObject*)(str) + 1)) : ((void*)((PyCompactUnicodeObject*)(str) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "((PyUnicodeObject*)(str))->data.any") : (void)0), ((((PyUnicodeObject *)(str))->data.any)))), ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11840, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length) * char_size));

        while (done < nchars) {
            n = (done <= nchars-done) ? done : nchars-done;
            ((__builtin_object_size (to + (done * char_size), 0) != (size_t) -1) ? __builtin___memcpy_chk (to + (done * char_size), to, n * char_size, __builtin_object_size (to + (done * char_size), 0)) : __inline_memcpy_chk (to + (done * char_size), to, n * char_size));
            done += n;
        }
    }

    (__builtin_expect(!(_PyUnicode_CheckConsistency(u, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11848, "_PyUnicode_CheckConsistency(u, 1)") : (void)0);
    return u;
}

PyObject *
PyUnicode_Replace(PyObject *obj,
                  PyObject *subobj,
                  PyObject *replobj,
                  Py_ssize_t maxcount)
{
    PyObject *self;
    PyObject *str1;
    PyObject *str2;
    PyObject *result;

    self = PyUnicode_FromObject(obj);
    if (self == ((void *)0))
        return ((void *)0);
    str1 = PyUnicode_FromObject(subobj);
    if (str1 == ((void *)0)) {
        do { if ( --((PyObject*)(self))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(self)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(self)))); } while (0);
        return ((void *)0);
    }
    str2 = PyUnicode_FromObject(replobj);
    if (str2 == ((void *)0)) {
        do { if ( --((PyObject*)(self))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(self)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(self)))); } while (0);
        do { if ( --((PyObject*)(str1))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str1)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str1)))); } while (0);
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11877, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1 ||
        ((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11878, "_PyUnicode_CHECK(str1)") : (void)0), ((((PyASCIIObject*)str1)->state.ready) ? 0 : _PyUnicode_Ready(str1))) == -1 ||
        ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11879, "_PyUnicode_CHECK(str2)") : (void)0), ((((PyASCIIObject*)str2)->state.ready) ? 0 : _PyUnicode_Ready(str2))) == -1)
        result = ((void *)0);
    else
        result = replace(self, str1, str2, maxcount);
    do { if ( --((PyObject*)(self))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(self)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(self)))); } while (0);
    do { if ( --((PyObject*)(str1))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str1)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str1)))); } while (0);
    do { if ( --((PyObject*)(str2))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str2)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str2)))); } while (0);
    return result;
}

static char replace__doc__[] = "S.replace(old, new[, count]) -> str\n\nReturn a copy of S with all occurrences of substring\nold replaced by new.  If the optional argument count is\ngiven, only the first count occurrences are replaced.";






static PyObject*
unicode_replace(PyObject *self, PyObject *args)
{
    PyObject *str1;
    PyObject *str2;
    Py_ssize_t maxcount = -1;
    PyObject *result;

    if (!_PyArg_ParseTuple_SizeT(args, "OO|n:replace", &str1, &str2, &maxcount))
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11906, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    str1 = PyUnicode_FromObject(str1);
    if (str1 == ((void *)0))
        return ((void *)0);
    str2 = PyUnicode_FromObject(str2);
    if (str2 == ((void *)0)) {
        do { if ( --((PyObject*)(str1))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str1)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str1)))); } while (0);
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(str1))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11916, "_PyUnicode_CHECK(str1)") : (void)0), ((((PyASCIIObject*)str1)->state.ready) ? 0 : _PyUnicode_Ready(str1))) == -1 || ((__builtin_expect(!(((((((PyObject*)(str2))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11916, "_PyUnicode_CHECK(str2)") : (void)0), ((((PyASCIIObject*)str2)->state.ready) ? 0 : _PyUnicode_Ready(str2))) == -1)
        result = ((void *)0);
    else
        result = replace(self, str1, str2, maxcount);

    do { if ( --((PyObject*)(str1))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str1)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str1)))); } while (0);
    do { if ( --((PyObject*)(str2))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str2)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str2)))); } while (0);
    return result;
}

static PyObject *
unicode_repr(PyObject *unicode)
{
    PyObject *repr;
    Py_ssize_t isize;
    Py_ssize_t osize, squote, dquote, i, o;
    Py_UCS4 max, quote;
    int ikind, okind;
    void *idata, *odata;

    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11936, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1)
        return ((void *)0);

    isize = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11939, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11939, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);
    idata = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11940, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11940, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11940, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11940, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any))));



    osize = 2;
    max = 127;
    squote = dquote = 0;
    ikind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11947, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11947, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    for (i = 0; i < isize; i++) {
        Py_UCS4 ch = ((Py_UCS4) ((ikind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(idata))[(i)] : ((ikind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(idata))[(i)] : ((const Py_UCS4 *)(idata))[(i)] ) ));
        switch (ch) {
        case '\'': squote++; osize++; break;
        case '"': dquote++; osize++; break;
        case '\\': case '\t': case '\r': case '\n':
            osize += 2; break;
        default:

            if (ch < ' ' || ch == 0x7f)
                osize += 4;
            else if (ch < 0x7f)
                osize++;
            else if (_PyUnicode_IsPrintable(ch)) {
                osize++;
                max = ch > max ? ch : max;
            }
            else if (ch < 0x100)
                osize += 4;
            else if (ch < 0x10000)
                osize += 6;
            else
                osize += 10;
        }
    }

    quote = '\'';
    if (squote) {
        if (dquote)


            osize += squote;
        else
            quote = '"';
    }

    repr = PyUnicode_New(osize, max);
    if (repr == ((void *)0))
        return ((void *)0);
    okind = ((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11987, "PyUnicode_Check(repr)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11987, "PyUnicode_IS_READY(repr)") : (void)0), ((PyASCIIObject *)(repr))->state.kind);
    odata = ((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11988, "PyUnicode_Check(repr)") : (void)0), (((PyASCIIObject*)(repr))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(repr))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11988, "PyUnicode_Check(repr)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)repr)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11988, "PyUnicode_IS_READY(repr)") : (void)0), ((PyASCIIObject*)repr)->state.ascii) ? ((void*)((PyASCIIObject*)(repr) + 1)) : ((void*)((PyCompactUnicodeObject*)(repr) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(repr))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11988, "((PyUnicodeObject*)(repr))->data.any") : (void)0), ((((PyUnicodeObject *)(repr))->data.any))));

    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(0)] = (Py_UCS1)(quote); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(0)] = (Py_UCS2)(quote); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11990, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(0)] = (Py_UCS4)(quote); } } } while (0);
    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(osize-1)] = (Py_UCS1)(quote); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(osize-1)] = (Py_UCS2)(quote); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11991, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(osize-1)] = (Py_UCS4)(quote); } } } while (0);

    for (i = 0, o = 1; i < isize; i++) {
        Py_UCS4 ch = ((Py_UCS4) ((ikind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(idata))[(i)] : ((ikind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(idata))[(i)] : ((const Py_UCS4 *)(idata))[(i)] ) ));


        if ((ch == quote) || (ch == '\\')) {
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('\\'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('\\'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11998, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('\\'); } } } while (0);
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 11999, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(ch); } } } while (0);
            continue;
        }


        if (ch == '\t') {
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('\\'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('\\'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12005, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('\\'); } } } while (0);
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('t'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('t'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12006, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('t'); } } } while (0);
        }
        else if (ch == '\n') {
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('\\'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('\\'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12009, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('\\'); } } } while (0);
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('n'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('n'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12010, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('n'); } } } while (0);
        }
        else if (ch == '\r') {
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('\\'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('\\'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12013, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('\\'); } } } while (0);
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('r'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('r'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12014, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('r'); } } } while (0);
        }


        else if (ch < ' ' || ch == 0x7F) {
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('\\'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('\\'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12019, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('\\'); } } } while (0);
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('x'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('x'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12020, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('x'); } } } while (0);
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 4) & 0x000F]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 4) & 0x000F]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12021, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 4) & 0x000F]); } } } while (0);
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[ch & 0x000F]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[ch & 0x000F]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12022, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[ch & 0x000F]); } } } while (0);
        }


        else if (ch < 0x7F) {
            do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12027, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(ch); } } } while (0);
        }


        else {



            if (!_PyUnicode_IsPrintable(ch)) {
                do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('\\'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('\\'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12036, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('\\'); } } } while (0);

                if (ch <= 0xff) {
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('x'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('x'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12039, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('x'); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 4) & 0x000F]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 4) & 0x000F]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12040, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 4) & 0x000F]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[ch & 0x000F]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[ch & 0x000F]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12041, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[ch & 0x000F]); } } } while (0);
                }

                else if (ch <= 0xffff) {
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('u'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('u'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12045, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('u'); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 12) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 12) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12046, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 12) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 8) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 8) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12047, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 8) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 4) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 4) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12048, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 4) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[ch & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[ch & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12049, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[ch & 0xF]); } } } while (0);
                }

                else {
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)('U'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)('U'); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12053, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)('U'); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 28) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 28) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12054, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 28) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 24) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 24) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12055, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 24) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 20) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 20) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12056, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 20) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 16) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 16) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12057, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 16) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 12) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 12) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12058, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 12) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 8) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 8) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12059, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 8) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[(ch >> 4) & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[(ch >> 4) & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12060, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[(ch >> 4) & 0xF]); } } } while (0);
                    do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(Py_hexdigits[ch & 0xF]); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(Py_hexdigits[ch & 0xF]); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12061, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(Py_hexdigits[ch & 0xF]); } } } while (0);
                }
            }

            else {
                do { switch ((okind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(odata))[(o++)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(odata))[(o++)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((okind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12066, "(okind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(odata))[(o++)] = (Py_UCS4)(ch); } } } while (0);
            }
        }
    }

    (__builtin_expect(!(_PyUnicode_CheckConsistency(repr, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12071, "_PyUnicode_CheckConsistency(repr, 1)") : (void)0);
    return repr;
}

static char rfind__doc__[] = "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure.";
# 12084 "unicodeobject.c"
static PyObject *
unicode_rfind(PyObject *self, PyObject *args)
{
    PyObject *substring;
    Py_ssize_t start;
    Py_ssize_t end;
    Py_ssize_t result;

    if (!stringlib_parse_args_finds_unicode("rfind", args, &substring,
                                            &start, &end))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12096, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12098, "_PyUnicode_CHECK(substring)") : (void)0), ((((PyASCIIObject*)substring)->state.ready) ? 0 : _PyUnicode_Ready(substring))) == -1)
        return ((void *)0);

    result = any_find_slice(-1, self, substring, start, end);

    do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);

    if (result == -2)
        return ((void *)0);

    return PyLong_FromSsize_t(result);
}

static char rindex__doc__[] = "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found.";




static PyObject *
unicode_rindex(PyObject *self, PyObject *args)
{
    PyObject *substring;
    Py_ssize_t start;
    Py_ssize_t end;
    Py_ssize_t result;

    if (!stringlib_parse_args_finds_unicode("rindex", args, &substring,
                                            &start, &end))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12128, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12130, "_PyUnicode_CHECK(substring)") : (void)0), ((((PyASCIIObject*)substring)->state.ready) ? 0 : _PyUnicode_Ready(substring))) == -1)
        return ((void *)0);

    result = any_find_slice(-1, self, substring, start, end);

    do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);

    if (result == -2)
        return ((void *)0);

    if (result < 0) {
        PyErr_SetString(PyExc_ValueError, "substring not found");
        return ((void *)0);
    }

    return PyLong_FromSsize_t(result);
}

static char rjust__doc__[] = "S.rjust(width[, fillchar]) -> str\n\nReturn S right-justified in a string of length width. Padding is\ndone using the specified fill character (default is a space).";





static PyObject *
unicode_rjust(PyObject *self, PyObject *args)
{
    Py_ssize_t width;
    Py_UCS4 fillchar = ' ';

    if (!_PyArg_ParseTuple_SizeT(args, "n|O&:rjust", &width, convert_uc, &fillchar))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12163, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12166, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12166, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length) >= width)
        return unicode_result_unchanged(self);

    return pad(self, width - ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12169, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12169, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length), 0, fillchar);
}

PyObject *
PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
{
    PyObject *result;

    s = PyUnicode_FromObject(s);
    if (s == ((void *)0))
        return ((void *)0);
    if (sep != ((void *)0)) {
        sep = PyUnicode_FromObject(sep);
        if (sep == ((void *)0)) {
            do { if ( --((PyObject*)(s))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(s)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(s)))); } while (0);
            return ((void *)0);
        }
    }

    result = split(s, sep, maxsplit);

    do { if ( --((PyObject*)(s))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(s)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(s)))); } while (0);
    do { if ((sep) == ((void *)0)) ; else do { if ( --((PyObject*)(sep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep)))); } while (0); } while (0);
    return result;
}

static char split__doc__[] = "S.split(sep=None, maxsplit=-1) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result.";
# 12204 "unicodeobject.c"
static PyObject*
unicode_split(PyObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"sep", "maxsplit", 0};
    PyObject *substring = (&_Py_NoneStruct);
    Py_ssize_t maxcount = -1;

    if (!_PyArg_ParseTupleAndKeywords_SizeT(args, kwds, "|On:split",
                                     kwlist, &substring, &maxcount))
        return ((void *)0);

    if (substring == (&_Py_NoneStruct))
        return split(self, ((void *)0), maxcount);
    else if (((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0))
        return split(self, substring, maxcount);
    else
        return PyUnicode_Split(self, substring, maxcount);
}

PyObject *
PyUnicode_Partition(PyObject *str_in, PyObject *sep_in)
{
    PyObject* str_obj;
    PyObject* sep_obj;
    PyObject* out;
    int kind1, kind2, kind;
    void *buf1 = ((void *)0), *buf2 = ((void *)0);
    Py_ssize_t len1, len2;

    str_obj = PyUnicode_FromObject(str_in);
    if (!str_obj)
        return ((void *)0);
    sep_obj = PyUnicode_FromObject(sep_in);
    if (!sep_obj) {
        do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12241, "_PyUnicode_CHECK(sep_obj)") : (void)0), ((((PyASCIIObject*)sep_obj)->state.ready) ? 0 : _PyUnicode_Ready(sep_obj))) == -1 || ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12241, "_PyUnicode_CHECK(str_obj)") : (void)0), ((((PyASCIIObject*)str_obj)->state.ready) ? 0 : _PyUnicode_Ready(str_obj))) == -1) {
        do { if ( --((PyObject*)(sep_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep_obj)))); } while (0);
        do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
        return ((void *)0);
    }

    kind1 = ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12247, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12247, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12248, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12248, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject *)(sep_obj))->state.kind);
    kind = (((kind1) > (kind2)) ? (kind1) : (kind2));
    buf1 = ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12250, "PyUnicode_Check(str_obj)") : (void)0), (((PyASCIIObject*)(str_obj))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12250, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12250, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject*)str_obj)->state.ascii) ? ((void*)((PyASCIIObject*)(str_obj) + 1)) : ((void*)((PyCompactUnicodeObject*)(str_obj) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str_obj))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12250, "((PyUnicodeObject*)(str_obj))->data.any") : (void)0), ((((PyUnicodeObject *)(str_obj))->data.any))));
    if (kind1 != kind)
        buf1 = _PyUnicode_AsKind(str_obj, kind);
    if (!buf1)
        goto onError;
    buf2 = ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12255, "PyUnicode_Check(sep_obj)") : (void)0), (((PyASCIIObject*)(sep_obj))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12255, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12255, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject*)sep_obj)->state.ascii) ? ((void*)((PyASCIIObject*)(sep_obj) + 1)) : ((void*)((PyCompactUnicodeObject*)(sep_obj) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(sep_obj))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12255, "((PyUnicodeObject*)(sep_obj))->data.any") : (void)0), ((((PyUnicodeObject *)(sep_obj))->data.any))));
    if (kind2 != kind)
        buf2 = _PyUnicode_AsKind(sep_obj, kind);
    if (!buf2)
        goto onError;
    len1 = ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12260, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12260, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12261, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12261, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject *)(sep_obj))->length);

    switch (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12263, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12263, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->state.kind)) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12265, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12265, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject*)str_obj)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12265, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12265, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject*)sep_obj)->state.ascii))
            out = asciilib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);
        else
            out = ucs1lib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);
        break;
    case PyUnicode_2BYTE_KIND:
        out = ucs2lib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);
        break;
    case PyUnicode_4BYTE_KIND:
        out = ucs4lib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);
        break;
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12277, "0") : (void)0);
        out = 0;
    }

    do { if ( --((PyObject*)(sep_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep_obj)))); } while (0);
    do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
    if (kind1 != kind)
        PyMem_Free(buf1);
    if (kind2 != kind)
        PyMem_Free(buf2);

    return out;
  onError:
    do { if ( --((PyObject*)(sep_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep_obj)))); } while (0);
    do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
    if (kind1 != kind && buf1)
        PyMem_Free(buf1);
    if (kind2 != kind && buf2)
        PyMem_Free(buf2);
    return ((void *)0);
}


PyObject *
PyUnicode_RPartition(PyObject *str_in, PyObject *sep_in)
{
    PyObject* str_obj;
    PyObject* sep_obj;
    PyObject* out;
    int kind1, kind2, kind;
    void *buf1 = ((void *)0), *buf2 = ((void *)0);
    Py_ssize_t len1, len2;

    str_obj = PyUnicode_FromObject(str_in);
    if (!str_obj)
        return ((void *)0);
    sep_obj = PyUnicode_FromObject(sep_in);
    if (!sep_obj) {
        do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
        return ((void *)0);
    }

    kind1 = ((__builtin_expect(!(((((((PyObject*)(str_in))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12319, "PyUnicode_Check(str_in)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_in)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12319, "PyUnicode_IS_READY(str_in)") : (void)0), ((PyASCIIObject *)(str_in))->state.kind);
    kind2 = ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12320, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12320, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject *)(sep_obj))->state.kind);
    kind = (((kind1) > (kind2)) ? (kind1) : (kind2));
    buf1 = ((__builtin_expect(!(((((((PyObject*)(str_in))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12322, "PyUnicode_Check(str_in)") : (void)0), (((PyASCIIObject*)(str_in))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(str_in))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12322, "PyUnicode_Check(str_in)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_in)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12322, "PyUnicode_IS_READY(str_in)") : (void)0), ((PyASCIIObject*)str_in)->state.ascii) ? ((void*)((PyASCIIObject*)(str_in) + 1)) : ((void*)((PyCompactUnicodeObject*)(str_in) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(str_in))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12322, "((PyUnicodeObject*)(str_in))->data.any") : (void)0), ((((PyUnicodeObject *)(str_in))->data.any))));
    if (kind1 != kind)
        buf1 = _PyUnicode_AsKind(str_in, kind);
    if (!buf1)
        goto onError;
    buf2 = ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12327, "PyUnicode_Check(sep_obj)") : (void)0), (((PyASCIIObject*)(sep_obj))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12327, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12327, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject*)sep_obj)->state.ascii) ? ((void*)((PyASCIIObject*)(sep_obj) + 1)) : ((void*)((PyCompactUnicodeObject*)(sep_obj) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(sep_obj))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12327, "((PyUnicodeObject*)(sep_obj))->data.any") : (void)0), ((((PyUnicodeObject *)(sep_obj))->data.any))));
    if (kind2 != kind)
        buf2 = _PyUnicode_AsKind(sep_obj, kind);
    if (!buf2)
        goto onError;
    len1 = ((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12332, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12332, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject *)(str_obj))->length);
    len2 = ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12333, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12333, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject *)(sep_obj))->length);

    switch (((__builtin_expect(!(((((((PyObject*)(str_in))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12335, "PyUnicode_Check(str_in)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_in)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12335, "PyUnicode_IS_READY(str_in)") : (void)0), ((PyASCIIObject *)(str_in))->state.kind)) {
    case PyUnicode_1BYTE_KIND:
        if (((__builtin_expect(!(((((((PyObject*)(str_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12337, "PyUnicode_Check(str_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12337, "PyUnicode_IS_READY(str_obj)") : (void)0), ((PyASCIIObject*)str_obj)->state.ascii) && ((__builtin_expect(!(((((((PyObject*)(sep_obj))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12337, "PyUnicode_Check(sep_obj)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)sep_obj)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12337, "PyUnicode_IS_READY(sep_obj)") : (void)0), ((PyASCIIObject*)sep_obj)->state.ascii))
            out = asciilib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);
        else
            out = ucs1lib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);
        break;
    case PyUnicode_2BYTE_KIND:
        out = ucs2lib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);
        break;
    case PyUnicode_4BYTE_KIND:
        out = ucs4lib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);
        break;
    default:
        (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12349, "0") : (void)0);
        out = 0;
    }

    do { if ( --((PyObject*)(sep_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep_obj)))); } while (0);
    do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
    if (kind1 != kind)
        PyMem_Free(buf1);
    if (kind2 != kind)
        PyMem_Free(buf2);

    return out;
  onError:
    do { if ( --((PyObject*)(sep_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep_obj)))); } while (0);
    do { if ( --((PyObject*)(str_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str_obj)))); } while (0);
    if (kind1 != kind && buf1)
        PyMem_Free(buf1);
    if (kind2 != kind && buf2)
        PyMem_Free(buf2);
    return ((void *)0);
}

static char partition__doc__[] = "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings.";






static PyObject*
unicode_partition(PyObject *self, PyObject *separator)
{
    return PyUnicode_Partition(self, separator);
}

static char rpartition__doc__[] = "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If the\nseparator is not found, return two empty strings and S.";






static PyObject*
unicode_rpartition(PyObject *self, PyObject *separator)
{
    return PyUnicode_RPartition(self, separator);
}

PyObject *
PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
{
    PyObject *result;

    s = PyUnicode_FromObject(s);
    if (s == ((void *)0))
        return ((void *)0);
    if (sep != ((void *)0)) {
        sep = PyUnicode_FromObject(sep);
        if (sep == ((void *)0)) {
            do { if ( --((PyObject*)(s))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(s)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(s)))); } while (0);
            return ((void *)0);
        }
    }

    result = rsplit(s, sep, maxsplit);

    do { if ( --((PyObject*)(s))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(s)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(s)))); } while (0);
    do { if ((sep) == ((void *)0)) ; else do { if ( --((PyObject*)(sep))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(sep)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(sep)))); } while (0); } while (0);
    return result;
}

static char rsplit__doc__[] = "S.rsplit(sep=None, maxsplit=-1) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator.";
# 12429 "unicodeobject.c"
static PyObject*
unicode_rsplit(PyObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"sep", "maxsplit", 0};
    PyObject *substring = (&_Py_NoneStruct);
    Py_ssize_t maxcount = -1;

    if (!_PyArg_ParseTupleAndKeywords_SizeT(args, kwds, "|On:rsplit",
                                     kwlist, &substring, &maxcount))
        return ((void *)0);

    if (substring == (&_Py_NoneStruct))
        return rsplit(self, ((void *)0), maxcount);
    else if (((((((PyObject*)(substring))->ob_type))->tp_flags & ((1L<<28))) != 0))
        return rsplit(self, substring, maxcount);
    else
        return PyUnicode_RSplit(self, substring, maxcount);
}

static char splitlines__doc__[] = "S.splitlines([keepends]) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true.";






static PyObject*
unicode_splitlines(PyObject *self, PyObject *args, PyObject *kwds)
{
    static char *kwlist[] = {"keepends", 0};
    int keepends = 0;

    if (!_PyArg_ParseTupleAndKeywords_SizeT(args, kwds, "|i:splitlines",
                                     kwlist, &keepends))
        return ((void *)0);

    return PyUnicode_Splitlines(self, keepends);
}

static
PyObject *unicode_str(PyObject *self)
{
    return unicode_result_unchanged(self);
}

static char swapcase__doc__[] = "S.swapcase() -> str\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa.";





static PyObject*
unicode_swapcase(PyObject *self)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12483, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    return case_operation(self, do_swapcase);
}

static char maketrans__doc__[] = "str.maketrans(x[, y[, z]]) -> dict (static method)\n\nReturn a translation table usable for str.translate().\nIf there is only one argument, it must be a dictionary mapping Unicode\nordinals (integers) or characters to Unicode ordinals, strings or None.\nCharacter keys will be then converted to ordinals.\nIf there are two arguments, they must be strings of equal length, and\nin the resulting dictionary, each character in x will be mapped to the\ncharacter at the same position in y. If there is a third argument, it\nmust be a string, whose characters will be mapped to None in the result.";
# 12500 "unicodeobject.c"
static PyObject*
unicode_maketrans(PyObject *null, PyObject *args)
{
    PyObject *x, *y = ((void *)0), *z = ((void *)0);
    PyObject *new = ((void *)0), *key, *value;
    Py_ssize_t i = 0;
    int res;

    if (!_PyArg_ParseTuple_SizeT(args, "O|UU:maketrans", &x, &y, &z))
        return ((void *)0);
    new = PyDict_New();
    if (!new)
        return ((void *)0);
    if (y != ((void *)0)) {
        int x_kind, y_kind, z_kind;
        void *x_data, *y_data, *z_data;


        if (!((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
            PyErr_SetString(PyExc_TypeError, "first maketrans argument must "
                            "be a string if there is a second argument");
            goto err;
        }
        if (((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12523, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12523, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject *)(x))->length) != ((__builtin_expect(!(((((((PyObject*)(y))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12523, "PyUnicode_Check(y)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)y)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12523, "PyUnicode_IS_READY(y)") : (void)0), ((PyASCIIObject *)(y))->length)) {
            PyErr_SetString(PyExc_ValueError, "the first two maketrans "
                            "arguments must have equal length");
            goto err;
        }

        x_kind = ((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12529, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12529, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject *)(x))->state.kind);
        y_kind = ((__builtin_expect(!(((((((PyObject*)(y))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12530, "PyUnicode_Check(y)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)y)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12530, "PyUnicode_IS_READY(y)") : (void)0), ((PyASCIIObject *)(y))->state.kind);
        x_data = ((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12531, "PyUnicode_Check(x)") : (void)0), (((PyASCIIObject*)(x))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12531, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12531, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject*)x)->state.ascii) ? ((void*)((PyASCIIObject*)(x) + 1)) : ((void*)((PyCompactUnicodeObject*)(x) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(x))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12531, "((PyUnicodeObject*)(x))->data.any") : (void)0), ((((PyUnicodeObject *)(x))->data.any))));
        y_data = ((__builtin_expect(!(((((((PyObject*)(y))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12532, "PyUnicode_Check(y)") : (void)0), (((PyASCIIObject*)(y))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(y))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12532, "PyUnicode_Check(y)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)y)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12532, "PyUnicode_IS_READY(y)") : (void)0), ((PyASCIIObject*)y)->state.ascii) ? ((void*)((PyASCIIObject*)(y) + 1)) : ((void*)((PyCompactUnicodeObject*)(y) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(y))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12532, "((PyUnicodeObject*)(y))->data.any") : (void)0), ((((PyUnicodeObject *)(y))->data.any))));
        for (i = 0; i < ((__builtin_expect(!(((((((PyObject*)(x))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12533, "PyUnicode_Check(x)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)x)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12533, "PyUnicode_IS_READY(x)") : (void)0), ((PyASCIIObject *)(x))->length); i++) {
            key = PyLong_FromLong(((Py_UCS4) ((x_kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(x_data))[(i)] : ((x_kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(x_data))[(i)] : ((const Py_UCS4 *)(x_data))[(i)] ) )));
            if (!key)
                goto err;
            value = PyLong_FromLong(((Py_UCS4) ((y_kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(y_data))[(i)] : ((y_kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(y_data))[(i)] : ((const Py_UCS4 *)(y_data))[(i)] ) )));
            if (!value) {
                do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0);
                goto err;
            }
            res = PyDict_SetItem(new, key, value);
            do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0);
            do { if ( --((PyObject*)(value))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(value)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(value)))); } while (0);
            if (res < 0)
                goto err;
        }

        if (z != ((void *)0)) {
            z_kind = ((__builtin_expect(!(((((((PyObject*)(z))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12550, "PyUnicode_Check(z)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)z)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12550, "PyUnicode_IS_READY(z)") : (void)0), ((PyASCIIObject *)(z))->state.kind);
            z_data = ((__builtin_expect(!(((((((PyObject*)(z))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12551, "PyUnicode_Check(z)") : (void)0), (((PyASCIIObject*)(z))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(z))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12551, "PyUnicode_Check(z)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)z)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12551, "PyUnicode_IS_READY(z)") : (void)0), ((PyASCIIObject*)z)->state.ascii) ? ((void*)((PyASCIIObject*)(z) + 1)) : ((void*)((PyCompactUnicodeObject*)(z) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(z))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12551, "((PyUnicodeObject*)(z))->data.any") : (void)0), ((((PyUnicodeObject *)(z))->data.any))));
            for (i = 0; i < ((__builtin_expect(!(((((((PyObject*)(z))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12552, "PyUnicode_Check(z)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)z)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12552, "PyUnicode_IS_READY(z)") : (void)0), ((PyASCIIObject *)(z))->length); i++) {
                key = PyLong_FromLong(((Py_UCS4) ((z_kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(z_data))[(i)] : ((z_kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(z_data))[(i)] : ((const Py_UCS4 *)(z_data))[(i)] ) )));
                if (!key)
                    goto err;
                res = PyDict_SetItem(new, key, (&_Py_NoneStruct));
                do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0);
                if (res < 0)
                    goto err;
            }
        }
    } else {
        int kind;
        void *data;


        if (!((((PyObject*)(x))->ob_type) == &PyDict_Type)) {
            PyErr_SetString(PyExc_TypeError, "if you give only one argument "
                            "to maketrans it must be a dict");
            goto err;
        }

        while (PyDict_Next(x, &i, &key, &value)) {
            if (((((((PyObject*)(key))->ob_type))->tp_flags & ((1L<<28))) != 0)) {

                PyObject *newkey;
                if (((__builtin_expect(!(((((((PyObject*)(key))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12577, "PyUnicode_Check(key)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)key)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12577, "PyUnicode_IS_READY(key)") : (void)0), ((PyASCIIObject *)(key))->length) != 1) {
                    PyErr_SetString(PyExc_ValueError, "string keys in translate "
                                    "table must be of length 1");
                    goto err;
                }
                kind = ((__builtin_expect(!(((((((PyObject*)(key))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12582, "PyUnicode_Check(key)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)key)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12582, "PyUnicode_IS_READY(key)") : (void)0), ((PyASCIIObject *)(key))->state.kind);
                data = ((__builtin_expect(!(((((((PyObject*)(key))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12583, "PyUnicode_Check(key)") : (void)0), (((PyASCIIObject*)(key))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(key))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12583, "PyUnicode_Check(key)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)key)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12583, "PyUnicode_IS_READY(key)") : (void)0), ((PyASCIIObject*)key)->state.ascii) ? ((void*)((PyASCIIObject*)(key) + 1)) : ((void*)((PyCompactUnicodeObject*)(key) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(key))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12583, "((PyUnicodeObject*)(key))->data.any") : (void)0), ((((PyUnicodeObject *)(key))->data.any))));
                newkey = PyLong_FromLong(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(0)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(0)] : ((const Py_UCS4 *)(data))[(0)] ) )));
                if (!newkey)
                    goto err;
                res = PyDict_SetItem(new, newkey, value);
                do { if ( --((PyObject*)(newkey))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(newkey)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(newkey)))); } while (0);
                if (res < 0)
                    goto err;
            } else if (((((((PyObject*)(key))->ob_type))->tp_flags & ((1L<<24))) != 0)) {

                if (PyDict_SetItem(new, key, value) < 0)
                    goto err;
            } else {
                PyErr_SetString(PyExc_TypeError, "keys in translate table must "
                                "be strings or integers");
                goto err;
            }
        }
    }
    return new;
  err:
    do { if ( --((PyObject*)(new))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(new)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(new)))); } while (0);
    return ((void *)0);
}

static char translate__doc__[] = "S.translate(table) -> str\n\nReturn a copy of the string S, where all characters have been mapped\nthrough the given translation table, which must be a mapping of\nUnicode ordinals to Unicode ordinals, strings, or None.\nUnmapped characters are left untouched. Characters mapped to None\nare deleted.";
# 12617 "unicodeobject.c"
static PyObject*
unicode_translate(PyObject *self, PyObject *table)
{
    return _PyUnicode_TranslateCharmap(self, table, "ignore");
}

static char upper__doc__[] = "S.upper() -> str\n\nReturn a copy of S converted to uppercase.";




static PyObject*
unicode_upper(PyObject *self)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12631, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12633, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12633, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii))
        return ascii_upper_or_lower(self, 0);
    return case_operation(self, do_upper);
}

static char zfill__doc__[] = "S.zfill(width) -> str\n\nPad a numeric string S with zeros on the left, to fill a field\nof the specified width. The string S is never truncated.";





static PyObject *
unicode_zfill(PyObject *self, PyObject *args)
{
    Py_ssize_t fill;
    PyObject *u;
    Py_ssize_t width;
    int kind;
    void *data;
    Py_UCS4 chr;

    if (!_PyArg_ParseTuple_SizeT(args, "n:zfill", &width))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12657, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12660, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12660, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length) >= width)
        return unicode_result_unchanged(self);

    fill = width - ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12663, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12663, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);

    u = pad(self, fill, 0, '0');

    if (u == ((void *)0))
        return ((void *)0);

    kind = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12670, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12670, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject *)(u))->state.kind);
    data = ((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12671, "PyUnicode_Check(u)") : (void)0), (((PyASCIIObject*)(u))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(u))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12671, "PyUnicode_Check(u)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)u)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12671, "PyUnicode_IS_READY(u)") : (void)0), ((PyASCIIObject*)u)->state.ascii) ? ((void*)((PyASCIIObject*)(u) + 1)) : ((void*)((PyCompactUnicodeObject*)(u) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(u))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12671, "((PyUnicodeObject*)(u))->data.any") : (void)0), ((((PyUnicodeObject *)(u))->data.any))));
    chr = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(fill)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(fill)] : ((const Py_UCS4 *)(data))[(fill)] ) ));

    if (chr == '+' || chr == '-') {

        do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(0)] = (Py_UCS1)(chr); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(0)] = (Py_UCS2)(chr); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12676, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(0)] = (Py_UCS4)(chr); } } } while (0);
        do { switch ((kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(data))[(fill)] = (Py_UCS1)('0'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(data))[(fill)] = (Py_UCS2)('0'); break; } default: { (__builtin_expect(!((kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12677, "(kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(data))[(fill)] = (Py_UCS4)('0'); } } } while (0);
    }

    (__builtin_expect(!(_PyUnicode_CheckConsistency(u, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12680, "_PyUnicode_CheckConsistency(u, 1)") : (void)0);
    return u;
}
# 12692 "unicodeobject.c"
static char startswith__doc__[] = "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try.";







static PyObject *
unicode_startswith(PyObject *self,
                   PyObject *args)
{
    PyObject *subobj;
    PyObject *substring;
    Py_ssize_t start = 0;
    Py_ssize_t end = ((Py_ssize_t)(((size_t)-1)>>1));
    int result;

    if (!stringlib_parse_args_finds("startswith", args, &subobj, &start, &end))
        return ((void *)0);
    if (((((((PyObject*)(subobj))->ob_type))->tp_flags & ((1L<<26))) != 0)) {
        Py_ssize_t i;
        for (i = 0; i < (((PyVarObject*)(subobj))->ob_size); i++) {
            substring = PyUnicode_FromObject((((PyTupleObject *)(subobj))->ob_item[i]));
            if (substring == ((void *)0))
                return ((void *)0);
            result = tailmatch(self, substring, start, end, -1);
            do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);
            if (result) {
                return ( ((PyObject*)(((PyObject *) &_Py_TrueStruct)))->ob_refcnt++), ((PyObject *) &_Py_TrueStruct);
            }
        }

        return ( ((PyObject*)(((PyObject *) &_Py_FalseStruct)))->ob_refcnt++), ((PyObject *) &_Py_FalseStruct);
    }
    substring = PyUnicode_FromObject(subobj);
    if (substring == ((void *)0)) {
        if (PyErr_ExceptionMatches(PyExc_TypeError))
            PyErr_Format(PyExc_TypeError, "startswith first arg must be str or "
                         "a tuple of str, not %s", (((PyObject*)(subobj))->ob_type)->tp_name);
        return ((void *)0);
    }
    result = tailmatch(self, substring, start, end, -1);
    do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);
    return PyBool_FromLong(result);
}


static char endswith__doc__[] = "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try.";







static PyObject *
unicode_endswith(PyObject *self,
                 PyObject *args)
{
    PyObject *subobj;
    PyObject *substring;
    Py_ssize_t start = 0;
    Py_ssize_t end = ((Py_ssize_t)(((size_t)-1)>>1));
    int result;

    if (!stringlib_parse_args_finds("endswith", args, &subobj, &start, &end))
        return ((void *)0);
    if (((((((PyObject*)(subobj))->ob_type))->tp_flags & ((1L<<26))) != 0)) {
        Py_ssize_t i;
        for (i = 0; i < (((PyVarObject*)(subobj))->ob_size); i++) {
            substring = PyUnicode_FromObject(
                (((PyTupleObject *)(subobj))->ob_item[i]));
            if (substring == ((void *)0))
                return ((void *)0);
            result = tailmatch(self, substring, start, end, +1);
            do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);
            if (result) {
                return ( ((PyObject*)(((PyObject *) &_Py_TrueStruct)))->ob_refcnt++), ((PyObject *) &_Py_TrueStruct);
            }
        }
        return ( ((PyObject*)(((PyObject *) &_Py_FalseStruct)))->ob_refcnt++), ((PyObject *) &_Py_FalseStruct);
    }
    substring = PyUnicode_FromObject(subobj);
    if (substring == ((void *)0)) {
        if (PyErr_ExceptionMatches(PyExc_TypeError))
            PyErr_Format(PyExc_TypeError, "endswith first arg must be str or "
                         "a tuple of str, not %s", (((PyObject*)(subobj))->ob_type)->tp_name);
        return ((void *)0);
    }
    result = tailmatch(self, substring, start, end, +1);
    do { if ( --((PyObject*)(substring))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(substring)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(substring)))); } while (0);
    return PyBool_FromLong(result);
}

static inline void
_PyUnicodeWriter_Update(_PyUnicodeWriter *writer)
{
    writer->size = ((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12790, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12790, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject *)(writer->buffer))->length);
    writer->maxchar = ((__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12791, "PyUnicode_IS_READY(writer->buffer)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12791, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12791, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject*)writer->buffer)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12791, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12791, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject *)(writer->buffer))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12791, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12791, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject *)(writer->buffer))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
    writer->data = ((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12792, "PyUnicode_Check(writer->buffer)") : (void)0), (((PyASCIIObject*)(writer->buffer))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12792, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12792, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject*)writer->buffer)->state.ascii) ? ((void*)((PyASCIIObject*)(writer->buffer) + 1)) : ((void*)((PyCompactUnicodeObject*)(writer->buffer) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(writer->buffer))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12792, "((PyUnicodeObject*)(writer->buffer))->data.any") : (void)0), ((((PyUnicodeObject *)(writer->buffer))->data.any))));
    writer->kind = ((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12793, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12793, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject *)(writer->buffer))->state.kind);
}

void
_PyUnicodeWriter_Init(_PyUnicodeWriter *writer, Py_ssize_t min_length)
{
    ((__builtin_object_size (writer, 0) != (size_t) -1) ? __builtin___memset_chk (writer, 0, sizeof(*writer), __builtin_object_size (writer, 0)) : __inline_memset_chk (writer, 0, sizeof(*writer)));



    writer->min_length = (((min_length) > (100)) ? (min_length) : (100));
    writer->overallocate = (min_length > 0);
}

int
_PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,
                                 Py_ssize_t length, Py_UCS4 maxchar)
{
    Py_ssize_t newlen;
    PyObject *newbuffer;

    (__builtin_expect(!(length > 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12814, "length > 0") : (void)0);

    if (length > ((Py_ssize_t)(((size_t)-1)>>1)) - writer->pos) {
        PyErr_NoMemory();
        return -1;
    }
    newlen = writer->pos + length;

    if (writer->buffer == ((void *)0)) {
        if (writer->overallocate) {

            if (newlen <= (((Py_ssize_t)(((size_t)-1)>>1)) - newlen / 4))
                newlen += newlen / 4;
            if (newlen < writer->min_length)
                newlen = writer->min_length;
        }
        writer->buffer = PyUnicode_New(newlen, maxchar);
        if (writer->buffer == ((void *)0))
            return -1;
        _PyUnicodeWriter_Update(writer);
        return 0;
    }

    if (newlen > writer->size) {
        if (writer->overallocate) {

            if (newlen <= (((Py_ssize_t)(((size_t)-1)>>1)) - newlen / 4))
                newlen += newlen / 4;
            if (newlen < writer->min_length)
                newlen = writer->min_length;
        }

        if (maxchar > writer->maxchar || writer->readonly) {

            newbuffer = PyUnicode_New(newlen, maxchar);
            if (newbuffer == ((void *)0))
                return -1;
            _PyUnicode_FastCopyCharacters(newbuffer, 0,
                                          writer->buffer, 0, writer->pos);
            do { if ( --((PyObject*)(writer->buffer))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(writer->buffer)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(writer->buffer)))); } while (0);
            writer->readonly = 0;
        }
        else {
            newbuffer = resize_compact(writer->buffer, newlen);
            if (newbuffer == ((void *)0))
                return -1;
        }
        writer->buffer = newbuffer;
        _PyUnicodeWriter_Update(writer);
    }
    else if (maxchar > writer->maxchar) {
        (__builtin_expect(!(!writer->readonly), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12865, "!writer->readonly") : (void)0);
        newbuffer = PyUnicode_New(writer->size, maxchar);
        if (newbuffer == ((void *)0))
            return -1;
        _PyUnicode_FastCopyCharacters(newbuffer, 0,
                                      writer->buffer, 0, writer->pos);
        do { if ( --((PyObject*)(writer->buffer))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(writer->buffer)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(writer->buffer)))); } while (0);
        writer->buffer = newbuffer;
        _PyUnicodeWriter_Update(writer);
    }
    return 0;
}

int
_PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
{
    Py_UCS4 maxchar;
    Py_ssize_t len;

    if (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12884, "_PyUnicode_CHECK(str)") : (void)0), ((((PyASCIIObject*)str)->state.ready) ? 0 : _PyUnicode_Ready(str))) == -1)
        return -1;
    len = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12886, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12886, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->length);
    if (len == 0)
        return 0;
    maxchar = ((__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12889, "PyUnicode_IS_READY(str)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12889, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12889, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject*)str)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12889, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12889, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12889, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12889, "PyUnicode_IS_READY(str)") : (void)0), ((PyASCIIObject *)(str))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU)))));
    if (maxchar > writer->maxchar || len > writer->size - writer->pos) {
        if (writer->buffer == ((void *)0) && !writer->overallocate) {
            ( ((PyObject*)(str))->ob_refcnt++);
            writer->buffer = str;
            _PyUnicodeWriter_Update(writer);
            writer->readonly = 1;
            writer->size = 0;
            writer->pos += len;
            return 0;
        }
        if (_PyUnicodeWriter_PrepareInternal(writer, len, maxchar) == -1)
            return -1;
    }
    _PyUnicode_FastCopyCharacters(writer->buffer, writer->pos,
                                  str, 0, len);
    writer->pos += len;
    return 0;
}

PyObject *
_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
{
    if (writer->pos == 0) {
        do { if ((writer->buffer) == ((void *)0)) ; else do { if ( --((PyObject*)(writer->buffer))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(writer->buffer)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(writer->buffer)))); } while (0); } while (0);
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12914, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    }
    if (writer->readonly) {
        (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12917, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12917, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject *)(writer->buffer))->length) == writer->pos), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12917, "PyUnicode_GET_LENGTH(writer->buffer) == writer->pos") : (void)0);
        return writer->buffer;
    }
    if (((__builtin_expect(!(((((((PyObject*)(writer->buffer))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12920, "PyUnicode_Check(writer->buffer)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)writer->buffer)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12920, "PyUnicode_IS_READY(writer->buffer)") : (void)0), ((PyASCIIObject *)(writer->buffer))->length) != writer->pos) {
        PyObject *newbuffer;
        newbuffer = resize_compact(writer->buffer, writer->pos);
        if (newbuffer == ((void *)0)) {
            do { if ( --((PyObject*)(writer->buffer))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(writer->buffer)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(writer->buffer)))); } while (0);
            return ((void *)0);
        }
        writer->buffer = newbuffer;
    }
    (__builtin_expect(!(_PyUnicode_CheckConsistency(writer->buffer, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12929, "_PyUnicode_CheckConsistency(writer->buffer, 1)") : (void)0);
    return unicode_result_ready(writer->buffer);
}

void
_PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
{
    do { if (writer->buffer) { PyObject *_py_tmp = (PyObject *)(writer->buffer); (writer->buffer) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
}

# 1 "stringlib/unicode_format.h" 1
# 13 "stringlib/unicode_format.h"
typedef struct {
    PyObject *str;
    Py_ssize_t start, end;
} SubString;


typedef enum {
    ANS_INIT,
    ANS_AUTO,
    ANS_MANUAL
} AutoNumberState;


typedef struct {
    AutoNumberState an_state;
    int an_field_number;
} AutoNumber;



static PyObject *
build_string(SubString *input, PyObject *args, PyObject *kwargs,
             int recursion_depth, AutoNumber *auto_number);







static void
AutoNumber_Init(AutoNumber *auto_number)
{
    auto_number->an_state = ANS_INIT;
    auto_number->an_field_number = 0;
}


static inline void
SubString_init(SubString *str, PyObject *s, Py_ssize_t start, Py_ssize_t end)
{
    str->str = s;
    str->start = start;
    str->end = end;
}


static inline PyObject *
SubString_new_object(SubString *str)
{
    if (str->str == ((void *)0)) {
        ( ((PyObject*)((&_Py_NoneStruct)))->ob_refcnt++);
        return (&_Py_NoneStruct);
    }
    return PyUnicode_Substring(str->str, str->start, str->end);
}


static inline PyObject *
SubString_new_object_or_empty(SubString *str)
{
    if (str->str == ((void *)0)) {
        return PyUnicode_New(0, 0);
    }
    return SubString_new_object(str);
}




static int
autonumber_state_error(AutoNumberState state, int field_name_is_empty)
{
    if (state == ANS_MANUAL) {
        if (field_name_is_empty) {
            PyErr_SetString(PyExc_ValueError, "cannot switch from "
                            "manual field specification to "
                            "automatic field numbering");
            return 1;
        }
    }
    else {
        if (!field_name_is_empty) {
            PyErr_SetString(PyExc_ValueError, "cannot switch from "
                            "automatic field numbering to "
                            "manual field specification");
            return 1;
        }
    }
    return 0;
}






static Py_ssize_t
get_integer(const SubString *str)
{
    Py_ssize_t accumulator = 0;
    Py_ssize_t digitval;
    Py_ssize_t i;


    if (str->start >= str->end)
        return -1;

    for (i = str->start; i < str->end; i++) {
        digitval = _PyUnicode_ToDecimalDigit(((__builtin_expect(!(((((((PyObject*)(str->str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check(str->str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str->str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_IS_READY(str->str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject *)((str->str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (((PyASCIIObject*)((str->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject*)(str->str))->state.ascii) ? ((void*)((PyASCIIObject*)((str->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "((PyUnicodeObject*)((str->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str->str)))->data.any))))))[(i)] : (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject *)((str->str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (((PyASCIIObject*)((str->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject*)(str->str))->state.ascii) ? ((void*)((PyASCIIObject*)((str->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "((PyUnicodeObject*)((str->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str->str)))->data.any))))))[(i)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (((PyASCIIObject*)((str->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject*)(str->str))->state.ascii) ? ((void*)((PyASCIIObject*)((str->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 122, "((PyUnicodeObject*)((str->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str->str)))->data.any))))))[(i)] ) )));
        if (digitval < 0)
            return -1;






        if (accumulator > (((Py_ssize_t)(((size_t)-1)>>1)) - digitval) / 10) {
            PyErr_Format(PyExc_ValueError,
                         "Too many decimal digits in format string");
            return -1;
        }
        accumulator = accumulator * 10 + digitval;
    }
    return accumulator;
}






static PyObject *
getattr(PyObject *obj, SubString *name)
{
    PyObject *newobj;
    PyObject *str = SubString_new_object(name);
    if (str == ((void *)0))
        return ((void *)0);
    newobj = PyObject_GetAttr(obj, str);
    do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
    return newobj;
}


static PyObject *
getitem_sequence(PyObject *obj, Py_ssize_t idx)
{
    return PySequence_GetItem(obj, idx);
}


static PyObject *
getitem_idx(PyObject *obj, Py_ssize_t idx)
{
    PyObject *newobj;
    PyObject *idx_obj = PyLong_FromSsize_t(idx);
    if (idx_obj == ((void *)0))
        return ((void *)0);
    newobj = PyObject_GetItem(obj, idx_obj);
    do { if ( --((PyObject*)(idx_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(idx_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(idx_obj)))); } while (0);
    return newobj;
}


static PyObject *
getitem_str(PyObject *obj, SubString *name)
{
    PyObject *newobj;
    PyObject *str = SubString_new_object(name);
    if (str == ((void *)0))
        return ((void *)0);
    newobj = PyObject_GetItem(obj, str);
    do { if ( --((PyObject*)(str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(str)))); } while (0);
    return newobj;
}

typedef struct {



    SubString str;


    Py_ssize_t index;
} FieldNameIterator;


static int
FieldNameIterator_init(FieldNameIterator *self, PyObject *s,
                       Py_ssize_t start, Py_ssize_t end)
{
    SubString_init(&self->str, s, start, end);
    self->index = start;
    return 1;
}

static int
_FieldNameIterator_attr(FieldNameIterator *self, SubString *name)
{
    Py_UCS4 c;

    name->str = self->str.str;
    name->start = self->index;


    while (self->index < self->str.end) {
        c = ((__builtin_expect(!(((((((PyObject*)(self->str.str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check(self->str.str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self->str.str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_IS_READY(self->str.str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] : (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 221, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] ) ));
        switch (c) {
        case '[':
        case '.':

            self->index--;
            break;
        default:
            continue;
        }
        break;
    }

    name->end = self->index;
    return 1;
}

static int
_FieldNameIterator_item(FieldNameIterator *self, SubString *name)
{
    int bracket_seen = 0;
    Py_UCS4 c;

    name->str = self->str.str;
    name->start = self->index;


    while (self->index < self->str.end) {
        c = ((__builtin_expect(!(((((((PyObject*)(self->str.str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check(self->str.str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self->str.str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_IS_READY(self->str.str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] : (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 249, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] ) ));
        switch (c) {
        case ']':
            bracket_seen = 1;
            break;
        default:
            continue;
        }
        break;
    }

    if (!bracket_seen) {
        PyErr_SetString(PyExc_ValueError, "Missing ']' in format string");
        return 0;
    }



    name->end = self->index-1;
    return 1;
}


static int
FieldNameIterator_next(FieldNameIterator *self, int *is_attribute,
                       Py_ssize_t *name_idx, SubString *name)
{

    if (self->index >= self->str.end)
        return 1;

    switch (((__builtin_expect(!(((((((PyObject*)(self->str.str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check(self->str.str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self->str.str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_IS_READY(self->str.str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] : (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 280, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->index++)] ) ))) {
    case '.':
        *is_attribute = 1;
        if (_FieldNameIterator_attr(self, name) == 0)
            return 0;
        *name_idx = -1;
        break;
    case '[':
        *is_attribute = 0;
        if (_FieldNameIterator_item(self, name) == 0)
            return 0;
        *name_idx = get_integer(name);
        if (*name_idx == -1 && PyErr_Occurred())
            return 0;
        break;
    default:

        PyErr_SetString(PyExc_ValueError, "Only '.' or '[' may "
                        "follow ']' in format field specifier");
        return 0;
    }


    if (name->start == name->end) {
        PyErr_SetString(PyExc_ValueError, "Empty attribute in format string");
        return 0;
    }

    return 2;
}
# 318 "stringlib/unicode_format.h"
static int
field_name_split(PyObject *str, Py_ssize_t start, Py_ssize_t end, SubString *first,
                 Py_ssize_t *first_idx, FieldNameIterator *rest,
                 AutoNumber *auto_number)
{
    Py_UCS4 c;
    Py_ssize_t i = start;
    int field_name_is_empty;
    int using_numeric_index;


    while (i < end) {
        switch (c = ((__builtin_expect(!(((((((PyObject*)(str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check(str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_IS_READY(str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_IS_READY((str))") : (void)0), ((PyASCIIObject *)((str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (((PyASCIIObject*)((str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_IS_READY((str))") : (void)0), ((PyASCIIObject*)(str))->state.ascii) ? ((void*)((PyASCIIObject*)((str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "((PyUnicodeObject*)((str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str)))->data.any))))))[(i++)] : (((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_IS_READY((str))") : (void)0), ((PyASCIIObject *)((str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (((PyASCIIObject*)((str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_IS_READY((str))") : (void)0), ((PyASCIIObject*)(str))->state.ascii) ? ((void*)((PyASCIIObject*)((str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "((PyUnicodeObject*)((str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str)))->data.any))))))[(i++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (((PyASCIIObject*)((str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_Check((str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "PyUnicode_IS_READY((str))") : (void)0), ((PyASCIIObject*)(str))->state.ascii) ? ((void*)((PyASCIIObject*)((str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 330, "((PyUnicodeObject*)((str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str)))->data.any))))))[(i++)] ) ))) {
        case '[':
        case '.':


            i--;
            break;
        default:
            continue;
        }
        break;
    }


    SubString_init(first, str, start, i);
    FieldNameIterator_init(rest, str, i, end);


    *first_idx = get_integer(first);
    if (*first_idx == -1 && PyErr_Occurred())
        return 0;

    field_name_is_empty = first->start >= first->end;



    using_numeric_index = field_name_is_empty || *first_idx != -1;
# 366 "stringlib/unicode_format.h"
    if (auto_number) {


        if (auto_number->an_state == ANS_INIT && using_numeric_index)
            auto_number->an_state = field_name_is_empty ?
                ANS_AUTO : ANS_MANUAL;




        if (using_numeric_index)
            if (autonumber_state_error(auto_number->an_state,
                                       field_name_is_empty))
                return 0;


        if (field_name_is_empty)
            *first_idx = (auto_number->an_field_number)++;
    }

    return 1;
}







static PyObject *
get_field_object(SubString *input, PyObject *args, PyObject *kwargs,
                 AutoNumber *auto_number)
{
    PyObject *obj = ((void *)0);
    int ok;
    int is_attribute;
    SubString name;
    SubString first;
    Py_ssize_t index;
    FieldNameIterator rest;

    if (!field_name_split(input->str, input->start, input->end, &first,
                          &index, &rest, auto_number)) {
        goto error;
    }

    if (index == -1) {

        PyObject *key = SubString_new_object(&first);
        if (key == ((void *)0))
            goto error;




        if ((kwargs == ((void *)0)) || (obj = PyObject_GetItem(kwargs, key)) == ((void *)0)) {
            PyErr_SetObject(PyExc_KeyError, key);
            do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0);
            goto error;
        }
        do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0);
    }
    else {




        if (args == ((void *)0)) {
            PyErr_SetString(PyExc_ValueError, "Format string contains "
                            "positional fields");
            goto error;
        }


        obj = PySequence_GetItem(args, index);
        if (obj == ((void *)0))
            goto error;
    }


    while ((ok = FieldNameIterator_next(&rest, &is_attribute, &index,
                                        &name)) == 2) {
        PyObject *tmp;

        if (is_attribute)

            tmp = getattr(obj, &name);
        else

            if (index == -1)
                tmp = getitem_str(obj, &name);
            else
                if (PySequence_Check(obj))
                    tmp = getitem_sequence(obj, index);
                else

                    tmp = getitem_idx(obj, index);
        if (tmp == ((void *)0))
            goto error;


        do { if ( --((PyObject*)(obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(obj)))); } while (0);
        obj = tmp;
    }

    if (ok == 1)
        return obj;
error:
    do { if ((obj) == ((void *)0)) ; else do { if ( --((PyObject*)(obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(obj)))); } while (0); } while (0);
    return ((void *)0);
}
# 490 "stringlib/unicode_format.h"
static int
render_field(PyObject *fieldobj, SubString *format_spec, _PyUnicodeWriter *writer)
{
    int ok = 0;
    PyObject *result = ((void *)0);
    PyObject *format_spec_object = ((void *)0);
    int (*formatter) (_PyUnicodeWriter*, PyObject *, PyObject *, Py_ssize_t, Py_ssize_t) = ((void *)0);
    int err;



    if (((((PyObject*)(fieldobj))->ob_type) == &PyUnicode_Type))
        formatter = _PyUnicode_FormatAdvancedWriter;
    else if (((((PyObject*)(fieldobj))->ob_type) == &PyLong_Type))
        formatter = _PyLong_FormatAdvancedWriter;
    else if (((((PyObject*)(fieldobj))->ob_type) == &PyFloat_Type))
        formatter = _PyFloat_FormatAdvancedWriter;
    else if (((((PyObject*)(fieldobj))->ob_type) == &PyComplex_Type))
        formatter = _PyComplex_FormatAdvancedWriter;

    if (formatter) {


        err = formatter(writer, fieldobj, format_spec->str,
                        format_spec->start, format_spec->end);
        return (err == 0);
    }
    else {


        if (format_spec->str)
            format_spec_object = PyUnicode_Substring(format_spec->str,
                                                     format_spec->start,
                                                     format_spec->end);
        else
            format_spec_object = PyUnicode_New(0, 0);
        if (format_spec_object == ((void *)0))
            goto done;

        result = PyObject_Format(fieldobj, format_spec_object);
    }
    if (result == ((void *)0))
        goto done;

    if (_PyUnicodeWriter_WriteStr(writer, result) == -1)
        goto done;
    ok = 1;

done:
    do { if ((format_spec_object) == ((void *)0)) ; else do { if ( --((PyObject*)(format_spec_object))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(format_spec_object)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(format_spec_object)))); } while (0); } while (0);
    do { if ((result) == ((void *)0)) ; else do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0); } while (0);
    return ok;
}

static int
parse_field(SubString *str, SubString *field_name, SubString *format_spec,
            Py_UCS4 *conversion)
{




    Py_UCS4 c = 0;


    *conversion = '\0';
    SubString_init(format_spec, ((void *)0), 0, 0);



    field_name->str = str->str;
    field_name->start = str->start;
    while (str->start < str->end) {
        switch ((c = ((__builtin_expect(!(((((((PyObject*)(str->str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check(str->str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)str->str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_IS_READY(str->str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject *)((str->str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (((PyASCIIObject*)((str->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject*)(str->str))->state.ascii) ? ((void*)((PyASCIIObject*)((str->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "((PyUnicodeObject*)((str->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str->str)))->data.any))))))[(str->start++)] : (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject *)((str->str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (((PyASCIIObject*)((str->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject*)(str->str))->state.ascii) ? ((void*)((PyASCIIObject*)((str->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "((PyUnicodeObject*)((str->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str->str)))->data.any))))))[(str->start++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (((PyASCIIObject*)((str->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((str->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_Check((str->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(str->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "PyUnicode_IS_READY((str->str))") : (void)0), ((PyASCIIObject*)(str->str))->state.ascii) ? ((void*)((PyASCIIObject*)((str->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((str->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((str->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 563, "((PyUnicodeObject*)((str->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((str->str)))->data.any))))))[(str->start++)] ) )))) {
        case ':':
        case '!':
            break;
        default:
            continue;
        }
        break;
    }

    if (c == '!' || c == ':') {


        field_name->end = str->start-1;


        format_spec->str = str->str;
        format_spec->start = str->start;
        format_spec->end = str->end;


        if (c == '!') {

            if (format_spec->start >= format_spec->end) {
                PyErr_SetString(PyExc_ValueError,
                                "end of format while looking for conversion "
                                "specifier");
                return 0;
            }
            *conversion = ((__builtin_expect(!(((((((PyObject*)(format_spec->str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check(format_spec->str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)format_spec->str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_IS_READY(format_spec->str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject *)((format_spec->str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (((PyASCIIObject*)((format_spec->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject*)(format_spec->str))->state.ascii) ? ((void*)((PyASCIIObject*)((format_spec->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((format_spec->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((format_spec->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "((PyUnicodeObject*)((format_spec->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((format_spec->str)))->data.any))))))[(format_spec->start++)] : (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject *)((format_spec->str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (((PyASCIIObject*)((format_spec->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject*)(format_spec->str))->state.ascii) ? ((void*)((PyASCIIObject*)((format_spec->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((format_spec->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((format_spec->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "((PyUnicodeObject*)((format_spec->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((format_spec->str)))->data.any))))))[(format_spec->start++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (((PyASCIIObject*)((format_spec->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject*)(format_spec->str))->state.ascii) ? ((void*)((PyASCIIObject*)((format_spec->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((format_spec->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((format_spec->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 592, "((PyUnicodeObject*)((format_spec->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((format_spec->str)))->data.any))))))[(format_spec->start++)] ) ));


            if (format_spec->start < format_spec->end) {
                c = ((__builtin_expect(!(((((((PyObject*)(format_spec->str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check(format_spec->str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)format_spec->str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_IS_READY(format_spec->str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject *)((format_spec->str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (((PyASCIIObject*)((format_spec->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject*)(format_spec->str))->state.ascii) ? ((void*)((PyASCIIObject*)((format_spec->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((format_spec->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((format_spec->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "((PyUnicodeObject*)((format_spec->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((format_spec->str)))->data.any))))))[(format_spec->start++)] : (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject *)((format_spec->str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (((PyASCIIObject*)((format_spec->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject*)(format_spec->str))->state.ascii) ? ((void*)((PyASCIIObject*)((format_spec->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((format_spec->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((format_spec->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "((PyUnicodeObject*)((format_spec->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((format_spec->str)))->data.any))))))[(format_spec->start++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (((PyASCIIObject*)((format_spec->str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((format_spec->str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_Check((format_spec->str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(format_spec->str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "PyUnicode_IS_READY((format_spec->str))") : (void)0), ((PyASCIIObject*)(format_spec->str))->state.ascii) ? ((void*)((PyASCIIObject*)((format_spec->str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((format_spec->str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((format_spec->str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 596, "((PyUnicodeObject*)((format_spec->str)))->data.any") : (void)0), ((((PyUnicodeObject *)((format_spec->str)))->data.any))))))[(format_spec->start++)] ) ));
                if (c != ':') {
                    PyErr_SetString(PyExc_ValueError,
                                    "expected ':' after format specifier");
                    return 0;
                }
            }
        }
    }
    else

        field_name->end = str->start;

    return 1;
}
# 621 "stringlib/unicode_format.h"
typedef struct {
    SubString str;
} MarkupIterator;

static int
MarkupIterator_init(MarkupIterator *self, PyObject *str,
                    Py_ssize_t start, Py_ssize_t end)
{
    SubString_init(&self->str, str, start, end);
    return 1;
}



static int
MarkupIterator_next(MarkupIterator *self, SubString *literal,
                    int *field_present, SubString *field_name,
                    SubString *format_spec, Py_UCS4 *conversion,
                    int *format_spec_needs_expanding)
{
    int at_end;
    Py_UCS4 c = 0;
    Py_ssize_t start;
    int count;
    Py_ssize_t len;
    int markup_follows = 0;


    SubString_init(literal, ((void *)0), 0, 0);
    SubString_init(field_name, ((void *)0), 0, 0);
    SubString_init(format_spec, ((void *)0), 0, 0);
    *conversion = '\0';
    *format_spec_needs_expanding = 0;
    *field_present = 0;



    if (self->str.start >= self->str.end)
        return 1;

    start = self->str.start;
# 670 "stringlib/unicode_format.h"
    while (self->str.start < self->str.end) {
        switch (c = ((__builtin_expect(!(((((((PyObject*)(self->str.str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check(self->str.str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self->str.str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_IS_READY(self->str.str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start++)] : (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 671, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start++)] ) ))) {
        case '{':
        case '}':
            markup_follows = 1;
            break;
        default:
            continue;
        }
        break;
    }

    at_end = self->str.start >= self->str.end;
    len = self->str.start - start;

    if ((c == '}') && (at_end ||
                       (c != ((__builtin_expect(!(((((((PyObject*)(self->str.str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check(self->str.str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self->str.str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_IS_READY(self->str.str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start)] : (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 687, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start)] ) ))))) {

        PyErr_SetString(PyExc_ValueError, "Single '}' encountered "
                        "in format string");
        return 0;
    }
    if (at_end && c == '{') {
        PyErr_SetString(PyExc_ValueError, "Single '{' encountered "
                        "in format string");
        return 0;
    }
    if (!at_end) {
        if (c == ((__builtin_expect(!(((((((PyObject*)(self->str.str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check(self->str.str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self->str.str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_IS_READY(self->str.str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start)] : (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 698, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start)] ) ))) {


            self->str.start++;
            markup_follows = 0;
        }
        else
            len--;
    }


    literal->str = self->str.str;
    literal->start = start;
    literal->end = start + len;

    if (!markup_follows)
        return 2;




    *field_present = 1;
    count = 1;

    start = self->str.start;



    while (self->str.start < self->str.end) {
        switch (c = ((__builtin_expect(!(((((((PyObject*)(self->str.str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check(self->str.str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self->str.str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_IS_READY(self->str.str)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start++)] : (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject *)((self->str.str)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start++)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (((PyASCIIObject*)((self->str.str)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((self->str.str)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_Check((self->str.str))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(self->str.str))->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "PyUnicode_IS_READY((self->str.str))") : (void)0), ((PyASCIIObject*)(self->str.str))->state.ascii) ? ((void*)((PyASCIIObject*)((self->str.str)) + 1)) : ((void*)((PyCompactUnicodeObject*)((self->str.str)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((self->str.str)))->data.any), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 727, "((PyUnicodeObject*)((self->str.str)))->data.any") : (void)0), ((((PyUnicodeObject *)((self->str.str)))->data.any))))))[(self->str.start++)] ) ))) {
        case '{':


            *format_spec_needs_expanding = 1;
            count++;
            break;
        case '}':
            count--;
            if (count <= 0) {

                SubString s;

                SubString_init(&s, self->str.str, start, self->str.start - 1);
                if (parse_field(&s, field_name, format_spec, conversion) == 0)
                    return 0;


                return 2;
            }
            break;
        }
    }


    PyErr_SetString(PyExc_ValueError, "unmatched '{' in format");
    return 0;
}



static PyObject *
do_conversion(PyObject *obj, Py_UCS4 conversion)
{


    switch (conversion) {
    case 'r':
        return PyObject_Repr(obj);
    case 's':
        return PyObject_Str(obj);
    case 'a':
        return PyObject_ASCII(obj);
    default:
        if (conversion > 32 && conversion < 127) {



                PyErr_Format(PyExc_ValueError,
                     "Unknown conversion specifier %c",
                     (char)conversion);
        } else
                PyErr_Format(PyExc_ValueError,
                     "Unknown conversion specifier \\x%x",
                     (unsigned int)conversion);
        return ((void *)0);
    }
}
# 799 "stringlib/unicode_format.h"
static int
output_markup(SubString *field_name, SubString *format_spec,
              int format_spec_needs_expanding, Py_UCS4 conversion,
              _PyUnicodeWriter *writer, PyObject *args, PyObject *kwargs,
              int recursion_depth, AutoNumber *auto_number)
{
    PyObject *tmp = ((void *)0);
    PyObject *fieldobj = ((void *)0);
    SubString expanded_format_spec;
    SubString *actual_format_spec;
    int result = 0;


    fieldobj = get_field_object(field_name, args, kwargs, auto_number);
    if (fieldobj == ((void *)0))
        goto done;

    if (conversion != '\0') {
        tmp = do_conversion(fieldobj, conversion);
        if (tmp == ((void *)0) || ((__builtin_expect(!(((((((PyObject*)(tmp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 818, "_PyUnicode_CHECK(tmp)") : (void)0), ((((PyASCIIObject*)tmp)->state.ready) ? 0 : _PyUnicode_Ready(tmp))) == -1)
            goto done;


        do { if ( --((PyObject*)(fieldobj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(fieldobj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(fieldobj)))); } while (0);
        fieldobj = tmp;
        tmp = ((void *)0);
    }


    if (format_spec_needs_expanding) {
        tmp = build_string(format_spec, args, kwargs, recursion_depth-1,
                           auto_number);
        if (tmp == ((void *)0) || ((__builtin_expect(!(((((((PyObject*)(tmp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 831, "_PyUnicode_CHECK(tmp)") : (void)0), ((((PyASCIIObject*)tmp)->state.ready) ? 0 : _PyUnicode_Ready(tmp))) == -1)
            goto done;




        SubString_init(&expanded_format_spec, tmp, 0, ((__builtin_expect(!(((((((PyObject*)(tmp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 837, "PyUnicode_Check(tmp)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)tmp)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 837, "PyUnicode_IS_READY(tmp)") : (void)0), ((PyASCIIObject *)(tmp))->length));
        actual_format_spec = &expanded_format_spec;
    }
    else
        actual_format_spec = format_spec;

    if (render_field(fieldobj, actual_format_spec, writer) == 0)
        goto done;

    result = 1;

done:
    do { if ((fieldobj) == ((void *)0)) ; else do { if ( --((PyObject*)(fieldobj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(fieldobj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(fieldobj)))); } while (0); } while (0);
    do { if ((tmp) == ((void *)0)) ; else do { if ( --((PyObject*)(tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(tmp)))); } while (0); } while (0);

    return result;
}







static int
do_markup(SubString *input, PyObject *args, PyObject *kwargs,
          _PyUnicodeWriter *writer, int recursion_depth, AutoNumber *auto_number)
{
    MarkupIterator iter;
    int format_spec_needs_expanding;
    int result;
    int field_present;
    SubString literal;
    SubString field_name;
    SubString format_spec;
    Py_UCS4 conversion, maxchar;
    Py_ssize_t sublen;
    int err;

    MarkupIterator_init(&iter, input->str, input->start, input->end);
    while ((result = MarkupIterator_next(&iter, &literal, &field_present,
                                         &field_name, &format_spec,
                                         &conversion,
                                         &format_spec_needs_expanding)) == 2) {
        sublen = literal.end - literal.start;
        if (sublen) {
            maxchar = _PyUnicode_FindMaxChar(literal.str,
                                             literal.start, literal.end);
            err = (((maxchar) <= (writer)->maxchar && (sublen) <= (writer)->size - (writer)->pos) ? 0 : (((sublen) == 0) ? 0 : _PyUnicodeWriter_PrepareInternal((writer), (sublen), (maxchar))));
            if (err == -1)
                return 0;
            _PyUnicode_FastCopyCharacters(writer->buffer, writer->pos,
                                          literal.str, literal.start, sublen);
            writer->pos += sublen;
        }

        if (field_present) {
            if (iter.str.start == iter.str.end)
                writer->overallocate = 0;
            if (!output_markup(&field_name, &format_spec,
                               format_spec_needs_expanding, conversion, writer,
                               args, kwargs, recursion_depth, auto_number))
                return 0;
        }
    }
    return result;
}






static PyObject *
build_string(SubString *input, PyObject *args, PyObject *kwargs,
             int recursion_depth, AutoNumber *auto_number)
{
    _PyUnicodeWriter writer;
    Py_ssize_t minlen;


    if (recursion_depth <= 0) {
        PyErr_SetString(PyExc_ValueError,
                        "Max string recursion exceeded");
        return ((void *)0);
    }

    minlen = ((__builtin_expect(!(((((((PyObject*)(input->str))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 924, "PyUnicode_Check(input->str)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)input->str)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 924, "PyUnicode_IS_READY(input->str)") : (void)0), ((PyASCIIObject *)(input->str))->length) + 100;
    _PyUnicodeWriter_Init(&writer, minlen);

    if (!do_markup(input, args, kwargs, &writer, recursion_depth,
                   auto_number)) {
        _PyUnicodeWriter_Dealloc(&writer);
        return ((void *)0);
    }

    return _PyUnicodeWriter_Finish(&writer);
}






static PyObject *
do_string_format(PyObject *self, PyObject *args, PyObject *kwargs)
{
    SubString input;





    int recursion_depth = 2;

    AutoNumber auto_number;

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 954, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    AutoNumber_Init(&auto_number);
    SubString_init(&input, self, 0, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 958, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 958, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length));
    return build_string(&input, args, kwargs, recursion_depth, &auto_number);
}

static PyObject *
do_string_format_map(PyObject *self, PyObject *obj)
{
    return do_string_format(self, ((void *)0), obj);
}
# 978 "stringlib/unicode_format.h"
typedef struct {
    PyObject ob_base;
    PyObject *str;
    MarkupIterator it_markup;
} formatteriterobject;

static void
formatteriter_dealloc(formatteriterobject *it)
{
    do { if ((it->str) == ((void *)0)) ; else do { if ( --((PyObject*)(it->str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(it->str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(it->str)))); } while (0); } while (0);
    PyObject_Free(it);
}
# 999 "stringlib/unicode_format.h"
static PyObject *
formatteriter_next(formatteriterobject *it)
{
    SubString literal;
    SubString field_name;
    SubString format_spec;
    Py_UCS4 conversion;
    int format_spec_needs_expanding;
    int field_present;
    int result = MarkupIterator_next(&it->it_markup, &literal, &field_present,
                                     &field_name, &format_spec, &conversion,
                                     &format_spec_needs_expanding);



    (__builtin_expect(!(0 <= result && result <= 2), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 1014, "0 <= result && result <= 2") : (void)0);
    if (result == 0 || result == 1)

        return ((void *)0);
    else {
        PyObject *literal_str = ((void *)0);
        PyObject *field_name_str = ((void *)0);
        PyObject *format_spec_str = ((void *)0);
        PyObject *conversion_str = ((void *)0);
        PyObject *tuple = ((void *)0);

        literal_str = SubString_new_object(&literal);
        if (literal_str == ((void *)0))
            goto done;

        field_name_str = SubString_new_object(&field_name);
        if (field_name_str == ((void *)0))
            goto done;



        format_spec_str = (field_present ?
                           SubString_new_object_or_empty :
                           SubString_new_object)(&format_spec);
        if (format_spec_str == ((void *)0))
            goto done;




        if (conversion == '\0') {
            conversion_str = (&_Py_NoneStruct);
            ( ((PyObject*)(conversion_str))->ob_refcnt++);
        }
        else
            conversion_str = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND,
                                                       &conversion, 1);
        if (conversion_str == ((void *)0))
            goto done;

        tuple = PyTuple_Pack(4, literal_str, field_name_str, format_spec_str,
                             conversion_str);
    done:
        do { if ((literal_str) == ((void *)0)) ; else do { if ( --((PyObject*)(literal_str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(literal_str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(literal_str)))); } while (0); } while (0);
        do { if ((field_name_str) == ((void *)0)) ; else do { if ( --((PyObject*)(field_name_str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(field_name_str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(field_name_str)))); } while (0); } while (0);
        do { if ((format_spec_str) == ((void *)0)) ; else do { if ( --((PyObject*)(format_spec_str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(format_spec_str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(format_spec_str)))); } while (0); } while (0);
        do { if ((conversion_str) == ((void *)0)) ; else do { if ( --((PyObject*)(conversion_str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(conversion_str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(conversion_str)))); } while (0); } while (0);
        return tuple;
    }
}

static PyMethodDef formatteriter_methods[] = {
    {((void *)0), ((void *)0)}
};

static PyTypeObject PyFormatterIter_Type = {
    { { 1, &PyType_Type }, 0 },
    "formatteriterator",
    sizeof(formatteriterobject),
    0,

    (destructor)formatteriter_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    PyObject_GenericGetAttr,
    0,
    0,
    ( 0 | (1L<<18) | 0),
    0,
    0,
    0,
    0,
    0,
    PyObject_SelfIter,
    (iternextfunc)formatteriter_next,
    formatteriter_methods,
    0,
};





static PyObject *
formatter_parser(PyObject *ignored, PyObject *self)
{
    formatteriterobject *it;

    if (!((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_Format(PyExc_TypeError, "expected str, got %s", (((PyObject*)(self))->ob_type)->tp_name);
        return ((void *)0);
    }

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 1116, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    it = ( (formatteriterobject *) _PyObject_New(&PyFormatterIter_Type) );
    if (it == ((void *)0))
        return ((void *)0);


    ( ((PyObject*)(self))->ob_refcnt++);
    it->str = self;


    MarkupIterator_init(&it->it_markup, (PyObject*)self, 0, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 1128, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 1128, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length));
    return (PyObject *)it;
}
# 1142 "stringlib/unicode_format.h"
typedef struct {
    PyObject ob_base;
    PyObject *str;
    FieldNameIterator it_field;
} fieldnameiterobject;

static void
fieldnameiter_dealloc(fieldnameiterobject *it)
{
    do { if ((it->str) == ((void *)0)) ; else do { if ( --((PyObject*)(it->str))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(it->str)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(it->str)))); } while (0); } while (0);
    PyObject_Free(it);
}







static PyObject *
fieldnameiter_next(fieldnameiterobject *it)
{
    int result;
    int is_attr;
    Py_ssize_t idx;
    SubString name;

    result = FieldNameIterator_next(&it->it_field, &is_attr,
                                    &idx, &name);
    if (result == 0 || result == 1)

        return ((void *)0);
    else {
        PyObject* result = ((void *)0);
        PyObject* is_attr_obj = ((void *)0);
        PyObject* obj = ((void *)0);

        is_attr_obj = PyBool_FromLong(is_attr);
        if (is_attr_obj == ((void *)0))
            goto done;


        if (idx != -1)
            obj = PyLong_FromSsize_t(idx);
        else
            obj = SubString_new_object(&name);
        if (obj == ((void *)0))
            goto done;


        result = PyTuple_Pack(2, is_attr_obj, obj);

    done:
        do { if ((is_attr_obj) == ((void *)0)) ; else do { if ( --((PyObject*)(is_attr_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(is_attr_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(is_attr_obj)))); } while (0); } while (0);
        do { if ((obj) == ((void *)0)) ; else do { if ( --((PyObject*)(obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(obj)))); } while (0); } while (0);
        return result;
    }
}

static PyMethodDef fieldnameiter_methods[] = {
    {((void *)0), ((void *)0)}
};

static PyTypeObject PyFieldNameIter_Type = {
    { { 1, &PyType_Type }, 0 },
    "fieldnameiterator",
    sizeof(fieldnameiterobject),
    0,

    (destructor)fieldnameiter_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    PyObject_GenericGetAttr,
    0,
    0,
    ( 0 | (1L<<18) | 0),
    0,
    0,
    0,
    0,
    0,
    PyObject_SelfIter,
    (iternextfunc)fieldnameiter_next,
    fieldnameiter_methods,
    0};
# 1244 "stringlib/unicode_format.h"
static PyObject *
formatter_field_name_split(PyObject *ignored, PyObject *self)
{
    SubString first;
    Py_ssize_t first_idx;
    fieldnameiterobject *it;

    PyObject *first_obj = ((void *)0);
    PyObject *result = ((void *)0);

    if (!((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_Format(PyExc_TypeError, "expected str, got %s", (((PyObject*)(self))->ob_type)->tp_name);
        return ((void *)0);
    }

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 1259, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    it = ( (fieldnameiterobject *) _PyObject_New(&PyFieldNameIter_Type) );
    if (it == ((void *)0))
        return ((void *)0);



    ( ((PyObject*)(self))->ob_refcnt++);
    it->str = self;



    if (!field_name_split((PyObject*)self, 0, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 1273, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "stringlib/unicode_format.h", 1273, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length),
                          &first, &first_idx, &it->it_field, ((void *)0)))
        goto done;


    if (first_idx != -1)
        first_obj = PyLong_FromSsize_t(first_idx);
    else

        first_obj = SubString_new_object(&first);
    if (first_obj == ((void *)0))
        goto done;


    result = PyTuple_Pack(2, first_obj, it);

done:
    do { if ((it) == ((void *)0)) ; else do { if ( --((PyObject*)(it))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(it)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(it)))); } while (0); } while (0);
    do { if ((first_obj) == ((void *)0)) ; else do { if ( --((PyObject*)(first_obj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(first_obj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(first_obj)))); } while (0); } while (0);
    return result;
}
# 12940 "unicodeobject.c" 2

static char format__doc__[] = "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').";





static char format_map__doc__[] = "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').";





static PyObject *
unicode__format__(PyObject* self, PyObject* args)
{
    PyObject *format_spec;
    _PyUnicodeWriter writer;
    int ret;

    if (!_PyArg_ParseTuple_SizeT(args, "U:__format__", &format_spec))
        return ((void *)0);

    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12963, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);
    _PyUnicodeWriter_Init(&writer, 0);
    ret = _PyUnicode_FormatAdvancedWriter(&writer,
                                          self, format_spec, 0,
                                          ((__builtin_expect(!(((((((PyObject*)(format_spec))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12968, "PyUnicode_Check(format_spec)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)format_spec)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12968, "PyUnicode_IS_READY(format_spec)") : (void)0), ((PyASCIIObject *)(format_spec))->length));
    if (ret == -1) {
        _PyUnicodeWriter_Dealloc(&writer);
        return ((void *)0);
    }
    return _PyUnicodeWriter_Finish(&writer);
}

static char p_format__doc__[] = "S.__format__(format_spec) -> str\n\nReturn a formatted version of S as described by format_spec.";




static PyObject *
unicode__sizeof__(PyObject *v)
{
    Py_ssize_t size;



    if ((((PyASCIIObject*)v)->state.ascii && (((PyASCIIObject*)(v))->state.compact)))
        size = sizeof(PyASCIIObject) + ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12989, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12989, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length) + 1;
    else if ((((PyASCIIObject*)(v))->state.compact))
        size = sizeof(PyCompactUnicodeObject) +
            (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12992, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12992, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length) + 1) * ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12992, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12992, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind);
    else {


        size = sizeof(PyUnicodeObject);
        if ((((PyUnicodeObject*)(v))->data.any))
            size += (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12998, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12998, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length) + 1) *
                ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12999, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 12999, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->state.kind);
    }


    if (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13003, "_PyUnicode_CHECK(v)") : (void)0), ((((PyASCIIObject*)(v))->wstr) && (!(((PyASCIIObject*)v)->state.ready) || (((PyASCIIObject*)(v))->wstr) != ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13003, "PyUnicode_Check(v)") : (void)0), (((PyASCIIObject*)(v))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13003, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13003, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? ((void*)((PyASCIIObject*)(v) + 1)) : ((void*)((PyCompactUnicodeObject*)(v) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(v))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13003, "((PyUnicodeObject*)(v))->data.any") : (void)0), ((((PyUnicodeObject *)(v))->data.any))))))))
        size += (((((PyASCIIObject*)v)->state.ascii && (((PyASCIIObject*)(v))->state.compact)) ? ((PyASCIIObject*)v)->length : ((PyCompactUnicodeObject*)v)->wstr_length) + 1) * sizeof(wchar_t);
    if (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13005, "_PyUnicode_CHECK(v)") : (void)0), (!(((PyASCIIObject*)v)->state.ascii && (((PyASCIIObject*)(v))->state.compact)) && (((PyCompactUnicodeObject*)(v))->utf8) && (((PyCompactUnicodeObject*)(v))->utf8) != ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13005, "PyUnicode_Check(v)") : (void)0), (((PyASCIIObject*)(v))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13005, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13005, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject*)v)->state.ascii) ? ((void*)((PyASCIIObject*)(v) + 1)) : ((void*)((PyCompactUnicodeObject*)(v) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(v))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13005, "((PyUnicodeObject*)(v))->data.any") : (void)0), ((((PyUnicodeObject *)(v))->data.any)))))))
        size += ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13006, "_PyUnicode_CHECK(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13006, "PyUnicode_IS_READY(v)") : (void)0), (((PyASCIIObject*)v)->state.ascii && (((PyASCIIObject*)(v))->state.compact)) ? ((PyASCIIObject*)(v))->length : (((PyCompactUnicodeObject*)(v))->utf8_length)) + 1;

    return PyLong_FromSsize_t(size);
}

static char sizeof__doc__[] = "S.__sizeof__() -> size of S in memory, in bytes";


static PyObject *
unicode_getnewargs(PyObject *v)
{
    PyObject *copy = _PyUnicode_Copy(v);
    if (!copy)
        return ((void *)0);
    return _Py_BuildValue_SizeT("(N)", copy);
}

static PyMethodDef unicode_methods[] = {
    {"encode", (PyCFunction) unicode_encode, 0x0001 | 0x0002, encode__doc__},
    {"replace", (PyCFunction) unicode_replace, 0x0001, replace__doc__},
    {"split", (PyCFunction) unicode_split, 0x0001 | 0x0002, split__doc__},
    {"rsplit", (PyCFunction) unicode_rsplit, 0x0001 | 0x0002, rsplit__doc__},
    {"join", (PyCFunction) unicode_join, 0x0008, join__doc__},
    {"capitalize", (PyCFunction) unicode_capitalize, 0x0004, capitalize__doc__},
    {"casefold", (PyCFunction) unicode_casefold, 0x0004, casefold__doc__},
    {"title", (PyCFunction) unicode_title, 0x0004, title__doc__},
    {"center", (PyCFunction) unicode_center, 0x0001, center__doc__},
    {"count", (PyCFunction) unicode_count, 0x0001, count__doc__},
    {"expandtabs", (PyCFunction) unicode_expandtabs, 0x0001, expandtabs__doc__},
    {"find", (PyCFunction) unicode_find, 0x0001, find__doc__},
    {"partition", (PyCFunction) unicode_partition, 0x0008, partition__doc__},
    {"index", (PyCFunction) unicode_index, 0x0001, index__doc__},
    {"ljust", (PyCFunction) unicode_ljust, 0x0001, ljust__doc__},
    {"lower", (PyCFunction) unicode_lower, 0x0004, lower__doc__},
    {"lstrip", (PyCFunction) unicode_lstrip, 0x0001, lstrip__doc__},
    {"rfind", (PyCFunction) unicode_rfind, 0x0001, rfind__doc__},
    {"rindex", (PyCFunction) unicode_rindex, 0x0001, rindex__doc__},
    {"rjust", (PyCFunction) unicode_rjust, 0x0001, rjust__doc__},
    {"rstrip", (PyCFunction) unicode_rstrip, 0x0001, rstrip__doc__},
    {"rpartition", (PyCFunction) unicode_rpartition, 0x0008, rpartition__doc__},
    {"splitlines", (PyCFunction) unicode_splitlines, 0x0001 | 0x0002, splitlines__doc__},
    {"strip", (PyCFunction) unicode_strip, 0x0001, strip__doc__},
    {"swapcase", (PyCFunction) unicode_swapcase, 0x0004, swapcase__doc__},
    {"translate", (PyCFunction) unicode_translate, 0x0008, translate__doc__},
    {"upper", (PyCFunction) unicode_upper, 0x0004, upper__doc__},
    {"startswith", (PyCFunction) unicode_startswith, 0x0001, startswith__doc__},
    {"endswith", (PyCFunction) unicode_endswith, 0x0001, endswith__doc__},
    {"islower", (PyCFunction) unicode_islower, 0x0004, islower__doc__},
    {"isupper", (PyCFunction) unicode_isupper, 0x0004, isupper__doc__},
    {"istitle", (PyCFunction) unicode_istitle, 0x0004, istitle__doc__},
    {"isspace", (PyCFunction) unicode_isspace, 0x0004, isspace__doc__},
    {"isdecimal", (PyCFunction) unicode_isdecimal, 0x0004, isdecimal__doc__},
    {"isdigit", (PyCFunction) unicode_isdigit, 0x0004, isdigit__doc__},
    {"isnumeric", (PyCFunction) unicode_isnumeric, 0x0004, isnumeric__doc__},
    {"isalpha", (PyCFunction) unicode_isalpha, 0x0004, isalpha__doc__},
    {"isalnum", (PyCFunction) unicode_isalnum, 0x0004, isalnum__doc__},
    {"isidentifier", (PyCFunction) unicode_isidentifier, 0x0004, isidentifier__doc__},
    {"isprintable", (PyCFunction) unicode_isprintable, 0x0004, isprintable__doc__},
    {"zfill", (PyCFunction) unicode_zfill, 0x0001, zfill__doc__},
    {"format", (PyCFunction) do_string_format, 0x0001 | 0x0002, format__doc__},
    {"format_map", (PyCFunction) do_string_format_map, 0x0008, format_map__doc__},
    {"__format__", (PyCFunction) unicode__format__, 0x0001, p_format__doc__},
    {"maketrans", (PyCFunction) unicode_maketrans,
     0x0001 | 0x0020, maketrans__doc__},
    {"__sizeof__", (PyCFunction) unicode__sizeof__, 0x0004, sizeof__doc__},





    {"__getnewargs__", (PyCFunction)unicode_getnewargs, 0x0004},
    {((void *)0), ((void *)0)}
};

static PyObject *
unicode_mod(PyObject *v, PyObject *w)
{
    if (!((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0))
        return ( ((PyObject*)((&_Py_NotImplementedStruct)))->ob_refcnt++), (&_Py_NotImplementedStruct);
    return PyUnicode_Format(v, w);
}

static PyNumberMethods unicode_as_number = {
    0,
    0,
    0,
    unicode_mod,
};

static PySequenceMethods unicode_as_sequence = {
    (lenfunc) unicode_length,
    PyUnicode_Concat,
    (ssizeargfunc) unicode_repeat,
    (ssizeargfunc) unicode_getitem,
    0,
    0,
    0,
    PyUnicode_Contains,
};

static PyObject*
unicode_subscript(PyObject* self, PyObject* item)
{
    if (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13109, "_PyUnicode_CHECK(self)") : (void)0), ((((PyASCIIObject*)self)->state.ready) ? 0 : _PyUnicode_Ready(self))) == -1)
        return ((void *)0);

    if (((item)->ob_type->tp_as_number != ((void *)0) && (item)->ob_type->tp_as_number->nb_index != ((void *)0))) {
        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);
        if (i == -1 && PyErr_Occurred())
            return ((void *)0);
        if (i < 0)
            i += ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13117, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13117, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length);
        return unicode_getitem(self, i);
    } else if (((((PyObject*)(item))->ob_type) == &PySlice_Type)) {
        Py_ssize_t start, stop, step, slicelength, cur, i;
        PyObject *result;
        void *src_data, *dest_data;
        int src_kind, dest_kind;
        Py_UCS4 ch, max_char, kind_limit;

        if (PySlice_GetIndicesEx(item, ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13126, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13126, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length),
                                 &start, &stop, &step, &slicelength) < 0) {
            return ((void *)0);
        }

        if (slicelength <= 0) {
            do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13132, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
        } else if (start == 0 && step == 1 &&
                   slicelength == ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13134, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13134, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->length)) {
            return unicode_result_unchanged(self);
        } else if (step == 1) {
            return PyUnicode_Substring(self,
                                       start, start + slicelength);
        }

        src_kind = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13141, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13141, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject *)(self))->state.kind);
        src_data = ((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13142, "PyUnicode_Check(self)") : (void)0), (((PyASCIIObject*)(self))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13142, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13142, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii) ? ((void*)((PyASCIIObject*)(self) + 1)) : ((void*)((PyCompactUnicodeObject*)(self) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(self))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13142, "((PyUnicodeObject*)(self))->data.any") : (void)0), ((((PyUnicodeObject *)(self))->data.any))));
        if (!((__builtin_expect(!(((((((PyObject*)(self))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13143, "PyUnicode_Check(self)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)self)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13143, "PyUnicode_IS_READY(self)") : (void)0), ((PyASCIIObject*)self)->state.ascii)) {
            kind_limit = kind_maxchar_limit(src_kind);
            max_char = 0;
            for (cur = start, i = 0; i < slicelength; cur += step, i++) {
                ch = ((Py_UCS4) ((src_kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(src_data))[(cur)] : ((src_kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(src_data))[(cur)] : ((const Py_UCS4 *)(src_data))[(cur)] ) ));
                if (ch > max_char) {
                    max_char = ch;
                    if (max_char >= kind_limit)
                        break;
                }
            }
        }
        else
            max_char = 127;
        result = PyUnicode_New(slicelength, max_char);
        if (result == ((void *)0))
            return ((void *)0);
        dest_kind = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13160, "PyUnicode_Check(result)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)result)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13160, "PyUnicode_IS_READY(result)") : (void)0), ((PyASCIIObject *)(result))->state.kind);
        dest_data = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13161, "PyUnicode_Check(result)") : (void)0), (((PyASCIIObject*)(result))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13161, "PyUnicode_Check(result)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)result)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13161, "PyUnicode_IS_READY(result)") : (void)0), ((PyASCIIObject*)result)->state.ascii) ? ((void*)((PyASCIIObject*)(result) + 1)) : ((void*)((PyCompactUnicodeObject*)(result) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(result))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13161, "((PyUnicodeObject*)(result))->data.any") : (void)0), ((((PyUnicodeObject *)(result))->data.any))));

        for (cur = start, i = 0; i < slicelength; cur += step, i++) {
            Py_UCS4 ch = ((Py_UCS4) ((src_kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(src_data))[(cur)] : ((src_kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(src_data))[(cur)] : ((const Py_UCS4 *)(src_data))[(cur)] ) ));
            do { switch ((dest_kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(dest_data))[(i)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(dest_data))[(i)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((dest_kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13165, "(dest_kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(dest_data))[(i)] = (Py_UCS4)(ch); } } } while (0);
        }
        (__builtin_expect(!(_PyUnicode_CheckConsistency(result, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13167, "_PyUnicode_CheckConsistency(result, 1)") : (void)0);
        return result;
    } else {
        PyErr_SetString(PyExc_TypeError, "string indices must be integers");
        return ((void *)0);
    }
}

static PyMappingMethods unicode_as_mapping = {
    (lenfunc)unicode_length,
    (binaryfunc)unicode_subscript,
    (objobjargproc)0,
};




static PyObject *
getnextarg(PyObject *args, Py_ssize_t arglen, Py_ssize_t *p_argidx)
{
    Py_ssize_t argidx = *p_argidx;
    if (argidx < arglen) {
        (*p_argidx)++;
        if (arglen < 0)
            return args;
        else
            return PyTuple_GetItem(args, argidx);
    }
    PyErr_SetString(PyExc_TypeError,
                    "not enough arguments for format string");
    return ((void *)0);
}



static int
formatfloat(PyObject *v, int flags, int prec, int type,
            PyObject **p_output, _PyUnicodeWriter *writer)
{
    char *p;
    double x;
    Py_ssize_t len;

    x = PyFloat_AsDouble(v);
    if (x == -1.0 && PyErr_Occurred())
        return -1;

    if (prec < 0)
        prec = 6;

    p = PyOS_double_to_string(x, type, prec,
                              (flags & (1<<3)) ? 0x04 : 0, ((void *)0));
    if (p == ((void *)0))
        return -1;
    len = strlen(p);
    if (writer) {
        if ((((127) <= (writer)->maxchar && (len) <= (writer)->size - (writer)->pos) ? 0 : (((len) == 0) ? 0 : _PyUnicodeWriter_PrepareInternal((writer), (len), (127)))) == -1) {
            PyMem_Free(p);
            return -1;
        }
        unicode_write_cstr(writer->buffer, writer->pos, p, len);
        writer->pos += len;
    }
    else
        *p_output = _PyUnicode_FromASCII(p, len);
    PyMem_Free(p);
    return 0;
}
# 13254 "unicodeobject.c"
static PyObject*
formatlong(PyObject *val, int flags, int prec, int type)
{
    PyObject *result = ((void *)0);
    char *buf;
    Py_ssize_t i;
    int sign;
    int len;
    Py_ssize_t llen;
    int numdigits;
    int numnondigits = 0;


    if (prec > 2147483647 -3) {
        PyErr_SetString(PyExc_OverflowError,
                        "precision too large");
        return ((void *)0);
    }

    (__builtin_expect(!(((((((PyObject*)(val))->ob_type))->tp_flags & ((1L<<24))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13273, "PyLong_Check(val)") : (void)0);

    switch (type) {
    case 'd':
    case 'u':

        if (((((PyObject*)(val))->ob_type) == &PyBool_Type))
            result = PyNumber_ToBase(val, 10);
        else
            result = (((PyObject*)(val))->ob_type)->tp_str(val);
        break;
    case 'o':
        numnondigits = 2;
        result = PyNumber_ToBase(val, 8);
        break;
    case 'x':
    case 'X':
        numnondigits = 2;
        result = PyNumber_ToBase(val, 16);
        break;
    default:
        (__builtin_expect(!(!"'type' not in [duoxX]"), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13294, "!\"'type' not in [duoxX]\"") : (void)0);
    }
    if (!result)
        return ((void *)0);

    (__builtin_expect(!(unicode_modifiable(result)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13299, "unicode_modifiable(result)") : (void)0);
    (__builtin_expect(!((((PyASCIIObject*)result)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13300, "PyUnicode_IS_READY(result)") : (void)0);
    (__builtin_expect(!(((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13301, "PyUnicode_Check(result)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)result)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13301, "PyUnicode_IS_READY(result)") : (void)0), ((PyASCIIObject*)result)->state.ascii)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13301, "PyUnicode_IS_ASCII(result)") : (void)0);


    if ((((PyObject*)(result))->ob_refcnt) != 1) {
        _PyErr_BadInternalCall("unicodeobject.c", 13305);
        return ((void *)0);
    }
    buf = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13308, "PyUnicode_Check(result)") : (void)0), (((PyASCIIObject*)(result))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13308, "PyUnicode_Check(result)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)result)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13308, "PyUnicode_IS_READY(result)") : (void)0), ((PyASCIIObject*)result)->state.ascii) ? ((void*)((PyASCIIObject*)(result) + 1)) : ((void*)((PyCompactUnicodeObject*)(result) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(result))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13308, "((PyUnicodeObject*)(result))->data.any") : (void)0), ((((PyUnicodeObject *)(result))->data.any))));
    llen = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13309, "PyUnicode_Check(result)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)result)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13309, "PyUnicode_IS_READY(result)") : (void)0), ((PyASCIIObject *)(result))->length);
    if (llen > 2147483647) {
        PyErr_SetString(PyExc_ValueError,
                        "string too large in _PyBytes_FormatLong");
        return ((void *)0);
    }
    len = (int)llen;
    sign = buf[0] == '-';
    numnondigits += sign;
    numdigits = len - numnondigits;
    (__builtin_expect(!(numdigits > 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13319, "numdigits > 0") : (void)0);


    if (((flags & (1<<3)) == 0 &&
        (type == 'o' || type == 'x' || type == 'X'))) {
        (__builtin_expect(!(buf[sign] == '0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13324, "buf[sign] == '0'") : (void)0);
        (__builtin_expect(!(buf[sign+1] == 'x' || buf[sign+1] == 'X' || buf[sign+1] == 'o'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13326, "buf[sign+1] == 'x' || buf[sign+1] == 'X' || buf[sign+1] == 'o'") : (void)0);

        numnondigits -= 2;
        buf += 2;
        len -= 2;
        if (sign)
            buf[0] = '-';
        (__builtin_expect(!(len == numnondigits + numdigits), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13332, "len == numnondigits + numdigits") : (void)0);
        (__builtin_expect(!(numdigits > 0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13333, "numdigits > 0") : (void)0);
    }


    if (prec > numdigits) {
        PyObject *r1 = PyBytes_FromStringAndSize(((void *)0),
                                numnondigits + prec);
        char *b1;
        if (!r1) {
            do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0);
            return ((void *)0);
        }
        b1 = ((__builtin_expect(!(((((((PyObject*)(r1))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13345, "PyBytes_Check(r1)") : (void)0), (((PyBytesObject *)(r1))->ob_sval));
        for (i = 0; i < numnondigits; ++i)
            *b1++ = *buf++;
        for (i = 0; i < prec - numdigits; i++)
            *b1++ = '0';
        for (i = 0; i < numdigits; i++)
            *b1++ = *buf++;
        *b1 = '\0';
        do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0);
        result = r1;
        buf = ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<27))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13355, "PyBytes_Check(result)") : (void)0), (((PyBytesObject *)(result))->ob_sval));
        len = numnondigits + prec;
    }


    if (type == 'X') {


        for (i = 0; i < len; i++)
            if (buf[i] >= 'a' && buf[i] <= 'x')
                buf[i] -= 'a'-'A';
    }
    if (!((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0) || len != ((__builtin_expect(!(((((((PyObject*)(result))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13367, "PyUnicode_Check(result)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)result)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13367, "PyUnicode_IS_READY(result)") : (void)0), ((PyASCIIObject *)(result))->length)) {
        PyObject *unicode;
        unicode = _PyUnicode_FromASCII(buf, len);
        do { if ( --((PyObject*)(result))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(result)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(result)))); } while (0);
        result = unicode;
    }
    return result;
}

static Py_UCS4
formatchar(PyObject *v)
{

    if (((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        if (((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13381, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13381, "PyUnicode_IS_READY(v)") : (void)0), ((PyASCIIObject *)(v))->length) == 1) {
            return ((__builtin_expect(!(((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check(v)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)v)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_IS_READY(v)") : (void)0), (Py_UCS4) (((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(v))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_IS_READY((v))") : (void)0), ((PyASCIIObject *)((v)))->state.kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (((PyASCIIObject*)((v)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(v))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_IS_READY((v))") : (void)0), ((PyASCIIObject*)(v))->state.ascii) ? ((void*)((PyASCIIObject*)((v)) + 1)) : ((void*)((PyCompactUnicodeObject*)((v)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((v)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "((PyUnicodeObject*)((v)))->data.any") : (void)0), ((((PyUnicodeObject *)((v)))->data.any))))))[(0)] : (((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(v))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_IS_READY((v))") : (void)0), ((PyASCIIObject *)((v)))->state.kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (((PyASCIIObject*)((v)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(v))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_IS_READY((v))") : (void)0), ((PyASCIIObject*)(v))->state.ascii) ? ((void*)((PyASCIIObject*)((v)) + 1)) : ((void*)((PyCompactUnicodeObject*)((v)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((v)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "((PyUnicodeObject*)((v)))->data.any") : (void)0), ((((PyUnicodeObject *)((v)))->data.any))))))[(0)] : ((const Py_UCS4 *)(((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (((PyASCIIObject*)((v)))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)((v)))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_Check((v))") : (void)0), (__builtin_expect(!((((PyASCIIObject*)(v))->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "PyUnicode_IS_READY((v))") : (void)0), ((PyASCIIObject*)(v))->state.ascii) ? ((void*)((PyASCIIObject*)((v)) + 1)) : ((void*)((PyCompactUnicodeObject*)((v)) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)((v)))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13382, "((PyUnicodeObject*)((v)))->data.any") : (void)0), ((((PyUnicodeObject *)((v)))->data.any))))))[(0)] ) ));
        }
        goto onError;
    }
    else {

        long x;
        x = PyLong_AsLong(v);
        if (x == -1 && PyErr_Occurred())
            goto onError;

        if (x < 0 || x > 0x10ffff) {
            PyErr_SetString(PyExc_OverflowError,
                            "%c arg not in range(0x110000)");
            return (Py_UCS4) -1;
        }

        return (Py_UCS4) x;
    }

  onError:
    PyErr_SetString(PyExc_TypeError,
                    "%c requires int or char");
    return (Py_UCS4) -1;
}

PyObject *
PyUnicode_Format(PyObject *format, PyObject *args)
{
    Py_ssize_t fmtcnt, fmtpos, arglen, argidx;
    int args_owned = 0;
    PyObject *dict = ((void *)0);
    PyObject *temp = ((void *)0);
    PyObject *second = ((void *)0);
    PyObject *uformat;
    void *fmt;
    enum PyUnicode_Kind kind, fmtkind;
    _PyUnicodeWriter writer;
    Py_ssize_t sublen;
    Py_UCS4 maxchar;

    if (format == ((void *)0) || args == ((void *)0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 13424);
        return ((void *)0);
    }
    uformat = PyUnicode_FromObject(format);
    if (uformat == ((void *)0))
        return ((void *)0);
    if (((__builtin_expect(!(((((((PyObject*)(uformat))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13430, "_PyUnicode_CHECK(uformat)") : (void)0), ((((PyASCIIObject*)uformat)->state.ready) ? 0 : _PyUnicode_Ready(uformat))) == -1) {
        do { if ( --((PyObject*)(uformat))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(uformat)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(uformat)))); } while (0);
        return ((void *)0);
    }

    fmt = ((__builtin_expect(!(((((((PyObject*)(uformat))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13435, "PyUnicode_Check(uformat)") : (void)0), (((PyASCIIObject*)(uformat))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(uformat))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13435, "PyUnicode_Check(uformat)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uformat)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13435, "PyUnicode_IS_READY(uformat)") : (void)0), ((PyASCIIObject*)uformat)->state.ascii) ? ((void*)((PyASCIIObject*)(uformat) + 1)) : ((void*)((PyCompactUnicodeObject*)(uformat) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(uformat))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13435, "((PyUnicodeObject*)(uformat))->data.any") : (void)0), ((((PyUnicodeObject *)(uformat))->data.any))));
    fmtkind = ((__builtin_expect(!(((((((PyObject*)(uformat))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13436, "PyUnicode_Check(uformat)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uformat)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13436, "PyUnicode_IS_READY(uformat)") : (void)0), ((PyASCIIObject *)(uformat))->state.kind);
    fmtcnt = ((__builtin_expect(!(((((((PyObject*)(uformat))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13437, "PyUnicode_Check(uformat)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)uformat)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13437, "PyUnicode_IS_READY(uformat)") : (void)0), ((PyASCIIObject *)(uformat))->length);
    fmtpos = 0;

    _PyUnicodeWriter_Init(&writer, fmtcnt + 100);

    if (((((((PyObject*)(args))->ob_type))->tp_flags & ((1L<<26))) != 0)) {
        arglen = PyTuple_Size(args);
        argidx = 0;
    }
    else {
        arglen = -1;
        argidx = -2;
    }
    if (PyMapping_Check(args) && !((((((PyObject*)(args))->ob_type))->tp_flags & ((1L<<26))) != 0) && !((((((PyObject*)(args))->ob_type))->tp_flags & ((1L<<28))) != 0))
        dict = args;

    while (--fmtcnt >= 0) {
        if (((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos)] : ((const Py_UCS4 *)(fmt))[(fmtpos)] ) )) != '%') {
            Py_ssize_t nonfmtpos;
            nonfmtpos = fmtpos++;
            while (fmtcnt >= 0 &&
                   ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos)] : ((const Py_UCS4 *)(fmt))[(fmtpos)] ) )) != '%') {
                fmtpos++;
                fmtcnt--;
            }
            if (fmtcnt < 0)
                fmtpos--;
            sublen = fmtpos - nonfmtpos;
            maxchar = _PyUnicode_FindMaxChar(uformat,
                                             nonfmtpos, nonfmtpos + sublen);
            if ((((maxchar) <= (&writer)->maxchar && (sublen) <= (&writer)->size - (&writer)->pos) ? 0 : (((sublen) == 0) ? 0 : _PyUnicodeWriter_PrepareInternal((&writer), (sublen), (maxchar)))) == -1)
                goto onError;

            _PyUnicode_FastCopyCharacters(writer.buffer, writer.pos,
                                          uformat, nonfmtpos, sublen);
            writer.pos += sublen;
        }
        else {

            int flags = 0;
            Py_ssize_t width = -1;
            int prec = -1;
            Py_UCS4 c = '\0';
            Py_UCS4 fill;
            int sign;
            Py_UCS4 signchar;
            int isnumok;
            PyObject *v = ((void *)0);
            void *pbuf = ((void *)0);
            Py_ssize_t pindex, len;
            Py_UCS4 bufmaxchar;
            Py_ssize_t buflen;

            fmtpos++;
            c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos)] : ((const Py_UCS4 *)(fmt))[(fmtpos)] ) ));
            if (c == '(') {
                Py_ssize_t keystart;
                Py_ssize_t keylen;
                PyObject *key;
                int pcount = 1;

                if (dict == ((void *)0)) {
                    PyErr_SetString(PyExc_TypeError,
                                    "format requires a mapping");
                    goto onError;
                }
                ++fmtpos;
                --fmtcnt;
                keystart = fmtpos;

                while (pcount > 0 && --fmtcnt >= 0) {
                    c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos)] : ((const Py_UCS4 *)(fmt))[(fmtpos)] ) ));
                    if (c == ')')
                        --pcount;
                    else if (c == '(')
                        ++pcount;
                    fmtpos++;
                }
                keylen = fmtpos - keystart - 1;
                if (fmtcnt < 0 || pcount > 0) {
                    PyErr_SetString(PyExc_ValueError,
                                    "incomplete format key");
                    goto onError;
                }
                key = PyUnicode_Substring(uformat,
                                          keystart, keystart + keylen);
                if (key == ((void *)0))
                    goto onError;
                if (args_owned) {
                    do { if ( --((PyObject*)(args))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(args)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(args)))); } while (0);
                    args_owned = 0;
                }
                args = PyObject_GetItem(dict, key);
                do { if ( --((PyObject*)(key))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(key)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(key)))); } while (0);
                if (args == ((void *)0)) {
                    goto onError;
                }
                args_owned = 1;
                arglen = -1;
                argidx = -2;
            }
            while (--fmtcnt >= 0) {
                c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos++)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos++)] : ((const Py_UCS4 *)(fmt))[(fmtpos++)] ) ));
                switch (c) {
                case '-': flags |= (1<<0); continue;
                case '+': flags |= (1<<1); continue;
                case ' ': flags |= (1<<2); continue;
                case '#': flags |= (1<<3); continue;
                case '0': flags |= (1<<4); continue;
                }
                break;
            }
            if (c == '*') {
                v = getnextarg(args, arglen, &argidx);
                if (v == ((void *)0))
                    goto onError;
                if (!((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
                    PyErr_SetString(PyExc_TypeError,
                                    "* wants int");
                    goto onError;
                }
                width = PyLong_AsSsize_t(v);
                if (width == -1 && PyErr_Occurred())
                    goto onError;
                if (width < 0) {
                    flags |= (1<<0);
                    width = -width;
                }
                if (--fmtcnt >= 0)
                    c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos++)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos++)] : ((const Py_UCS4 *)(fmt))[(fmtpos++)] ) ));
            }
            else if (c >= '0' && c <= '9') {
                width = c - '0';
                while (--fmtcnt >= 0) {
                    c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos++)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos++)] : ((const Py_UCS4 *)(fmt))[(fmtpos++)] ) ));
                    if (c < '0' || c > '9')
                        break;



                    if (width > (((Py_ssize_t)(((size_t)-1)>>1)) - ((int)c - '0')) / 10) {
                        PyErr_SetString(PyExc_ValueError,
                                        "width too big");
                        goto onError;
                    }
                    width = width*10 + (c - '0');
                }
            }
            if (c == '.') {
                prec = 0;
                if (--fmtcnt >= 0)
                    c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos++)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos++)] : ((const Py_UCS4 *)(fmt))[(fmtpos++)] ) ));
                if (c == '*') {
                    v = getnextarg(args, arglen, &argidx);
                    if (v == ((void *)0))
                        goto onError;
                    if (!((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
                        PyErr_SetString(PyExc_TypeError,
                                        "* wants int");
                        goto onError;
                    }
                    prec = _PyLong_AsInt(v);
                    if (prec == -1 && PyErr_Occurred())
                        goto onError;
                    if (prec < 0)
                        prec = 0;
                    if (--fmtcnt >= 0)
                        c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos++)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos++)] : ((const Py_UCS4 *)(fmt))[(fmtpos++)] ) ));
                }
                else if (c >= '0' && c <= '9') {
                    prec = c - '0';
                    while (--fmtcnt >= 0) {
                        c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos++)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos++)] : ((const Py_UCS4 *)(fmt))[(fmtpos++)] ) ));
                        if (c < '0' || c > '9')
                            break;
                        if (prec > (2147483647 - ((int)c - '0')) / 10) {
                            PyErr_SetString(PyExc_ValueError,
                                            "prec too big");
                            goto onError;
                        }
                        prec = prec*10 + (c - '0');
                    }
                }
            }
            if (fmtcnt >= 0) {
                if (c == 'h' || c == 'l' || c == 'L') {
                    if (--fmtcnt >= 0)
                        c = ((Py_UCS4) ((fmtkind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(fmt))[(fmtpos++)] : ((fmtkind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(fmt))[(fmtpos++)] : ((const Py_UCS4 *)(fmt))[(fmtpos++)] ) ));
                }
            }
            if (fmtcnt < 0) {
                PyErr_SetString(PyExc_ValueError,
                                "incomplete format");
                goto onError;
            }
            if (fmtcnt == 0)
                writer.overallocate = 0;

            if (c == '%') {
                if (((('%') <= (&writer)->maxchar && (1) <= (&writer)->size - (&writer)->pos) ? 0 : (((1) == 0) ? 0 : _PyUnicodeWriter_PrepareInternal((&writer), (1), ('%')))) == -1)
                    goto onError;
                do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos)] = (Py_UCS1)('%'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos)] = (Py_UCS2)('%'); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13638, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos)] = (Py_UCS4)('%'); } } } while (0);
                writer.pos += 1;
                continue;
            }

            v = getnextarg(args, arglen, &argidx);
            if (v == ((void *)0))
                goto onError;

            sign = 0;
            signchar = '\0';
            fill = ' ';
            switch (c) {

            case 's':
            case 'r':
            case 'a':
                if (((((PyObject*)(v))->ob_type) == &PyLong_Type) && width == -1 && prec == -1) {

                    if (_PyLong_FormatWriter(&writer, v, 10, flags & (1<<3)) == -1)
                        goto onError;
                    goto nextarg;
                }

                if (((((PyObject*)(v))->ob_type) == &PyUnicode_Type) && c == 's') {
                    temp = v;
                    ( ((PyObject*)(temp))->ob_refcnt++);
                }
                else {
                    if (c == 's')
                        temp = PyObject_Str(v);
                    else if (c == 'r')
                        temp = PyObject_Repr(v);
                    else
                        temp = PyObject_ASCII(v);
                }
                break;

            case 'i':
            case 'd':
            case 'u':
            case 'o':
            case 'x':
            case 'X':
                if (((((PyObject*)(v))->ob_type) == &PyLong_Type)
                    && width == -1 && prec == -1
                    && !(flags & ((1<<1) | (1<<2))))
                {

                    switch(c)
                    {
                    case 'd':
                    case 'i':
                    case 'u':
                        if (_PyLong_FormatWriter(&writer, v, 10, flags & (1<<3)) == -1)
                            goto onError;
                        goto nextarg;
                    case 'x':
                        if (_PyLong_FormatWriter(&writer, v, 16, flags & (1<<3)) == -1)
                            goto onError;
                        goto nextarg;
                    case 'o':
                        if (_PyLong_FormatWriter(&writer, v, 8, flags & (1<<3)) == -1)
                            goto onError;
                        goto nextarg;
                    default:
                        break;
                    }
                }

                isnumok = 0;
                if (PyNumber_Check(v)) {
                    PyObject *iobj=((void *)0);

                    if (((((((PyObject*)(v))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
                        iobj = v;
                        ( ((PyObject*)(iobj))->ob_refcnt++);
                    }
                    else {
                        iobj = PyNumber_Long(v);
                    }
                    if (iobj!=((void *)0)) {
                        if (((((((PyObject*)(iobj))->ob_type))->tp_flags & ((1L<<24))) != 0)) {
                            isnumok = 1;
                            sign = 1;
                            temp = formatlong(iobj, flags, prec, (c == 'i'? 'd': c));
                            do { if ( --((PyObject*)(iobj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(iobj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(iobj)))); } while (0);
                        }
                        else {
                            do { if ( --((PyObject*)(iobj))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(iobj)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(iobj)))); } while (0);
                        }
                    }
                }
                if (!isnumok) {
                    PyErr_Format(PyExc_TypeError,
                                 "%%%c format: a number is required, "
                                 "not %.200s", (char)c, (((PyObject*)(v))->ob_type)->tp_name);
                    goto onError;
                }
                if (flags & (1<<4))
                    fill = '0';
                break;

            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                if (width == -1 && prec == -1
                    && !(flags & ((1<<1) | (1<<2))))
                {

                    if (formatfloat(v, flags, prec, c, ((void *)0), &writer) == -1)
                        goto onError;
                    goto nextarg;
                }

                sign = 1;
                if (flags & (1<<4))
                    fill = '0';
                if (formatfloat(v, flags, prec, c, &temp, ((void *)0)) == -1)
                    temp = ((void *)0);
                break;

            case 'c':
            {
                Py_UCS4 ch = formatchar(v);
                if (ch == (Py_UCS4) -1)
                    goto onError;
                if (width == -1 && prec == -1) {

                    if ((((ch) <= (&writer)->maxchar && (1) <= (&writer)->size - (&writer)->pos) ? 0 : (((1) == 0) ? 0 : _PyUnicodeWriter_PrepareInternal((&writer), (1), (ch)))) == -1)
                        goto onError;
                    do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos)] = (Py_UCS1)(ch); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos)] = (Py_UCS2)(ch); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13772, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos)] = (Py_UCS4)(ch); } } } while (0);
                    writer.pos += 1;
                    goto nextarg;
                }
                temp = PyUnicode_FromOrdinal(ch);
                break;
            }

            default:
                PyErr_Format(PyExc_ValueError,
                             "unsupported format character '%c' (0x%x) "
                             "at index %zd",
                             (31<=c && c<=126) ? (char)c : '?',
                             (int)c,
                             fmtpos - 1);
                goto onError;
            }
            if (temp == ((void *)0))
                goto onError;
            (__builtin_expect(!(((((((PyObject*)(temp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13791, "PyUnicode_Check(temp)") : (void)0);

            if (width == -1 && prec == -1
                && !(flags & ((1<<1) | (1<<2))))
            {

                if (_PyUnicodeWriter_WriteStr(&writer, temp) == -1)
                    goto onError;
                goto nextarg;
            }

            if (((__builtin_expect(!(((((((PyObject*)(temp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13802, "_PyUnicode_CHECK(temp)") : (void)0), ((((PyASCIIObject*)temp)->state.ready) ? 0 : _PyUnicode_Ready(temp))) == -1) {
                do { if (temp) { PyObject *_py_tmp = (PyObject *)(temp); (temp) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
                goto onError;
            }
            kind = ((__builtin_expect(!(((((((PyObject*)(temp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13806, "PyUnicode_Check(temp)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)temp)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13806, "PyUnicode_IS_READY(temp)") : (void)0), ((PyASCIIObject *)(temp))->state.kind);
            pbuf = ((__builtin_expect(!(((((((PyObject*)(temp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13807, "PyUnicode_Check(temp)") : (void)0), (((PyASCIIObject*)(temp))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(temp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13807, "PyUnicode_Check(temp)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)temp)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13807, "PyUnicode_IS_READY(temp)") : (void)0), ((PyASCIIObject*)temp)->state.ascii) ? ((void*)((PyASCIIObject*)(temp) + 1)) : ((void*)((PyCompactUnicodeObject*)(temp) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(temp))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13807, "((PyUnicodeObject*)(temp))->data.any") : (void)0), ((((PyUnicodeObject *)(temp))->data.any))));
            len = ((__builtin_expect(!(((((((PyObject*)(temp))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13808, "PyUnicode_Check(temp)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)temp)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13808, "PyUnicode_IS_READY(temp)") : (void)0), ((PyASCIIObject *)(temp))->length);

            if (c == 's' || c == 'r' || c == 'a') {
                if (prec >= 0 && len > prec)
                    len = prec;
            }


            pindex = 0;
            if (sign) {
                Py_UCS4 ch = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(pbuf))[(pindex)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(pbuf))[(pindex)] : ((const Py_UCS4 *)(pbuf))[(pindex)] ) ));
                if (ch == '-' || ch == '+') {
                    signchar = ch;
                    len--;
                    pindex++;
                }
                else if (flags & (1<<1))
                    signchar = '+';
                else if (flags & (1<<2))
                    signchar = ' ';
                else
                    sign = 0;
            }
            if (width < len)
                width = len;



            bufmaxchar = 127;
            if (!(flags & (1<<0))) {
                if (sign) {
                    if ((width-1) > len)
                        bufmaxchar = ((bufmaxchar) | (fill));
                }
                else {
                    if (width > len)
                        bufmaxchar = ((bufmaxchar) | (fill));
                }
            }
            maxchar = _PyUnicode_FindMaxChar(temp, 0, pindex+len);
            bufmaxchar = ((bufmaxchar) | (maxchar));

            buflen = width;
            if (sign && len == width)
                buflen++;

            if ((((bufmaxchar) <= (&writer)->maxchar && (buflen) <= (&writer)->size - (&writer)->pos) ? 0 : (((buflen) == 0) ? 0 : _PyUnicodeWriter_PrepareInternal((&writer), (buflen), (bufmaxchar)))) == -1)
                goto onError;


            if (sign) {
                if (fill != ' ') {
                    do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos)] = (Py_UCS1)(signchar); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos)] = (Py_UCS2)(signchar); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13860, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos)] = (Py_UCS4)(signchar); } } } while (0);
                    writer.pos += 1;
                }
                if (width > len)
                    width--;
            }
            if ((flags & (1<<3)) && (c == 'x' || c == 'X' || c == 'o')) {
                (__builtin_expect(!(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(pbuf))[(pindex)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(pbuf))[(pindex)] : ((const Py_UCS4 *)(pbuf))[(pindex)] ) )) == '0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13867, "PyUnicode_READ(kind, pbuf, pindex) == '0'") : (void)0);
                (__builtin_expect(!(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(pbuf))[(pindex + 1)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(pbuf))[(pindex + 1)] : ((const Py_UCS4 *)(pbuf))[(pindex + 1)] ) )) == c), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13868, "PyUnicode_READ(kind, pbuf, pindex + 1) == c") : (void)0);
                if (fill != ' ') {
                    do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos)] = (Py_UCS1)('0'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos)] = (Py_UCS2)('0'); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13870, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos)] = (Py_UCS4)('0'); } } } while (0);
                    do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos+1)] = (Py_UCS1)(c); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos+1)] = (Py_UCS2)(c); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13871, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos+1)] = (Py_UCS4)(c); } } } while (0);
                    writer.pos += 2;
                    pindex += 2;
                }
                width -= 2;
                if (width < 0)
                    width = 0;
                len -= 2;
            }
            if (width > len && !(flags & (1<<0))) {
                sublen = width - len;
                do { Py_ssize_t i_ = 0; (__builtin_expect(!(writer.kind != PyUnicode_WCHAR_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13882, "writer.kind != PyUnicode_WCHAR_KIND") : (void)0); switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { unsigned char * to_ = (unsigned char *)((writer.data)) + (writer.pos); ((__builtin_object_size (to_, 0) != (size_t) -1) ? __builtin___memset_chk (to_, (unsigned char)fill, (sublen), __builtin_object_size (to_, 0)) : __inline_memset_chk (to_, (unsigned char)fill, (sublen))); break; } case PyUnicode_2BYTE_KIND: { Py_UCS2 * to_ = (Py_UCS2 *)((writer.data)) + (writer.pos); for (; i_ < (sublen); ++i_, ++to_) *to_ = (fill); break; } case PyUnicode_4BYTE_KIND: { Py_UCS4 * to_ = (Py_UCS4 *)((writer.data)) + (writer.pos); for (; i_ < (sublen); ++i_, ++to_) *to_ = (fill); break; default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13882, "0") : (void)0); } } } while (0);
                writer.pos += sublen;
                width = len;
            }
            if (fill == ' ') {
                if (sign) {
                    do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos)] = (Py_UCS1)(signchar); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos)] = (Py_UCS2)(signchar); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13888, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos)] = (Py_UCS4)(signchar); } } } while (0);
                    writer.pos += 1;
                }
                if ((flags & (1<<3)) && (c == 'x' || c == 'X' || c == 'o')) {
                    (__builtin_expect(!(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(pbuf))[(pindex)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(pbuf))[(pindex)] : ((const Py_UCS4 *)(pbuf))[(pindex)] ) )) == '0'), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13892, "PyUnicode_READ(kind, pbuf, pindex) == '0'") : (void)0);
                    (__builtin_expect(!(((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(pbuf))[(pindex+1)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(pbuf))[(pindex+1)] : ((const Py_UCS4 *)(pbuf))[(pindex+1)] ) )) == c), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13893, "PyUnicode_READ(kind, pbuf, pindex+1) == c") : (void)0);
                    do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos)] = (Py_UCS1)('0'); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos)] = (Py_UCS2)('0'); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13894, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos)] = (Py_UCS4)('0'); } } } while (0);
                    do { switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { ((Py_UCS1 *)(writer.data))[(writer.pos+1)] = (Py_UCS1)(c); break; } case PyUnicode_2BYTE_KIND: { ((Py_UCS2 *)(writer.data))[(writer.pos+1)] = (Py_UCS2)(c); break; } default: { (__builtin_expect(!((writer.kind) == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13895, "(writer.kind) == PyUnicode_4BYTE_KIND") : (void)0); ((Py_UCS4 *)(writer.data))[(writer.pos+1)] = (Py_UCS4)(c); } } } while (0);
                    writer.pos += 2;
                    pindex += 2;
                }
            }

            if (len) {
                _PyUnicode_FastCopyCharacters(writer.buffer, writer.pos,
                                              temp, pindex, len);
                writer.pos += len;
            }
            if (width > len) {
                sublen = width - len;
                do { Py_ssize_t i_ = 0; (__builtin_expect(!(writer.kind != PyUnicode_WCHAR_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13908, "writer.kind != PyUnicode_WCHAR_KIND") : (void)0); switch ((writer.kind)) { case PyUnicode_1BYTE_KIND: { unsigned char * to_ = (unsigned char *)((writer.data)) + (writer.pos); ((__builtin_object_size (to_, 0) != (size_t) -1) ? __builtin___memset_chk (to_, (unsigned char)' ', (sublen), __builtin_object_size (to_, 0)) : __inline_memset_chk (to_, (unsigned char)' ', (sublen))); break; } case PyUnicode_2BYTE_KIND: { Py_UCS2 * to_ = (Py_UCS2 *)((writer.data)) + (writer.pos); for (; i_ < (sublen); ++i_, ++to_) *to_ = (' '); break; } case PyUnicode_4BYTE_KIND: { Py_UCS4 * to_ = (Py_UCS4 *)((writer.data)) + (writer.pos); for (; i_ < (sublen); ++i_, ++to_) *to_ = (' '); break; default: (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13908, "0") : (void)0); } } } while (0);
                writer.pos += sublen;
            }

nextarg:
            if (dict && (argidx < arglen) && c != '%') {
                PyErr_SetString(PyExc_TypeError,
                                "not all arguments converted during string formatting");
                goto onError;
            }
            do { if (temp) { PyObject *_py_tmp = (PyObject *)(temp); (temp) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
        }
    }
    if (argidx < arglen && !dict) {
        PyErr_SetString(PyExc_TypeError,
                        "not all arguments converted during string formatting");
        goto onError;
    }

    if (args_owned) {
        do { if ( --((PyObject*)(args))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(args)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(args)))); } while (0);
    }
    do { if ( --((PyObject*)(uformat))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(uformat)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(uformat)))); } while (0);
    do { if ((temp) == ((void *)0)) ; else do { if ( --((PyObject*)(temp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(temp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(temp)))); } while (0); } while (0);
    do { if ((second) == ((void *)0)) ; else do { if ( --((PyObject*)(second))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(second)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(second)))); } while (0); } while (0);
    return _PyUnicodeWriter_Finish(&writer);

  onError:
    do { if ( --((PyObject*)(uformat))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(uformat)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(uformat)))); } while (0);
    do { if ((temp) == ((void *)0)) ; else do { if ( --((PyObject*)(temp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(temp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(temp)))); } while (0); } while (0);
    do { if ((second) == ((void *)0)) ; else do { if ( --((PyObject*)(second))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(second)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(second)))); } while (0); } while (0);
    _PyUnicodeWriter_Dealloc(&writer);
    if (args_owned) {
        do { if ( --((PyObject*)(args))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(args)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(args)))); } while (0);
    }
    return ((void *)0);
}

static PyObject *
unicode_subtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

static PyObject *
unicode_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *x = ((void *)0);
    static char *kwlist[] = {"object", "encoding", "errors", 0};
    char *encoding = ((void *)0);
    char *errors = ((void *)0);

    if (type != &PyUnicode_Type)
        return unicode_subtype_new(type, args, kwds);
    if (!_PyArg_ParseTupleAndKeywords_SizeT(args, kwds, "|Oss:str",
                                     kwlist, &x, &encoding, &errors))
        return ((void *)0);
    if (x == ((void *)0))
        do { do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13963, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0); return unicode_empty; } while (0);
    if (encoding == ((void *)0) && errors == ((void *)0))
        return PyObject_Str(x);
    else
        return PyUnicode_FromEncodedObject(x, encoding, errors);
}

static PyObject *
unicode_subtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *unicode, *self;
    Py_ssize_t length, char_size;
    int share_wstr, share_utf8;
    unsigned int kind;
    void *data;

    (__builtin_expect(!(PyType_IsSubtype(type, &PyUnicode_Type)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13979, "PyType_IsSubtype(type, &PyUnicode_Type)") : (void)0);

    unicode = unicode_new(&PyUnicode_Type, args, kwds);
    if (unicode == ((void *)0))
        return ((void *)0);
    (__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13984, "_PyUnicode_CHECK(unicode)") : (void)0);
    if (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13985, "_PyUnicode_CHECK(unicode)") : (void)0), ((((PyASCIIObject*)unicode)->state.ready) ? 0 : _PyUnicode_Ready(unicode))) == -1) {
        do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
        return ((void *)0);
    }

    self = type->tp_alloc(type, 0);
    if (self == ((void *)0)) {
        do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
        return ((void *)0);
    }
    kind = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13995, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13995, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind);
    length = ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13996, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 13996, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->length);

    (((PyASCIIObject *)(self))->length) = length;



    (((PyASCIIObject *)(self))->hash) = (((PyASCIIObject *)(unicode))->hash);

    (((PyASCIIObject *)(self))->state).interned = 0;
    (((PyASCIIObject *)(self))->state).kind = kind;
    (((PyASCIIObject *)(self))->state).compact = 0;
    (((PyASCIIObject *)(self))->state).ascii = (((PyASCIIObject *)(unicode))->state).ascii;
    (((PyASCIIObject *)(self))->state).ready = 1;
    (((PyASCIIObject*)(self))->wstr) = ((void *)0);
    (((PyCompactUnicodeObject*)(self))->utf8_length) = 0;
    (((PyCompactUnicodeObject*)(self))->utf8) = ((void *)0);
    (((PyCompactUnicodeObject*)(self))->wstr_length) = 0;
    (((PyUnicodeObject*)(self))->data.any) = ((void *)0);

    share_utf8 = 0;
    share_wstr = 0;
    if (kind == PyUnicode_1BYTE_KIND) {
        char_size = 1;
        if (((__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14019, "PyUnicode_IS_READY(unicode)") : (void)0), (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14019, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14019, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? (0x7f) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14019, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14019, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_1BYTE_KIND ? (0xffU) : (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14019, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14019, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject *)(unicode))->state.kind) == PyUnicode_2BYTE_KIND ? (0xffffU) : (0x10ffffU))))) < 128)
            share_utf8 = 1;
    }
    else if (kind == PyUnicode_2BYTE_KIND) {
        char_size = 2;
        if (sizeof(wchar_t) == 2)
            share_wstr = 1;
    }
    else {
        (__builtin_expect(!(kind == PyUnicode_4BYTE_KIND), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14028, "kind == PyUnicode_4BYTE_KIND") : (void)0);
        char_size = 4;
        if (sizeof(wchar_t) == 4)
            share_wstr = 1;
    }


    if (length > (((Py_ssize_t)(((size_t)-1)>>1)) / char_size - 1)) {
        PyErr_NoMemory();
        goto onError;
    }
    data = PyObject_Malloc((length + 1) * char_size);
    if (data == ((void *)0)) {
        PyErr_NoMemory();
        goto onError;
    }

    (((PyUnicodeObject*)(self))->data.any) = data;
    if (share_utf8) {
        (((PyCompactUnicodeObject*)(self))->utf8_length) = length;
        (((PyCompactUnicodeObject*)(self))->utf8) = data;
    }
    if (share_wstr) {
        (((PyCompactUnicodeObject*)(self))->wstr_length) = length;
        (((PyASCIIObject*)(self))->wstr) = (wchar_t *)data;
    }

    ((__builtin_object_size (data, 0) != (size_t) -1) ? __builtin___memcpy_chk (data, ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))), kind * (length + 1), __builtin_object_size (data, 0)) : __inline_memcpy_chk (data, ((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "PyUnicode_Check(unicode)") : (void)0), (((PyASCIIObject*)(unicode))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "PyUnicode_Check(unicode)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)unicode)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "PyUnicode_IS_READY(unicode)") : (void)0), ((PyASCIIObject*)unicode)->state.ascii) ? ((void*)((PyASCIIObject*)(unicode) + 1)) : ((void*)((PyCompactUnicodeObject*)(unicode) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(unicode))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14056, "((PyUnicodeObject*)(unicode))->data.any") : (void)0), ((((PyUnicodeObject *)(unicode))->data.any)))), kind * (length + 1)));

    (__builtin_expect(!(_PyUnicode_CheckConsistency(self, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14057, "_PyUnicode_CheckConsistency(self, 1)") : (void)0);



    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    return self;

onError:
    do { if ( --((PyObject*)(unicode))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode)))); } while (0);
    do { if ( --((PyObject*)(self))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(self)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(self)))); } while (0);
    return ((void *)0);
}

static char unicode_doc[] = "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.";
# 14082 "unicodeobject.c"
static PyObject *unicode_iter(PyObject *seq);

PyTypeObject PyUnicode_Type = {
    { { 1, &PyType_Type }, 0 },
    "str",
    sizeof(PyUnicodeObject),
    0,

    (destructor)unicode_dealloc,
    0,
    0,
    0,
    0,
    unicode_repr,
    &unicode_as_number,
    &unicode_as_sequence,
    &unicode_as_mapping,
    (hashfunc) unicode_hash,
    0,
    (reprfunc) unicode_str,
    PyObject_GenericGetAttr,
    0,
    0,
    ( 0 | (1L<<18) | 0) | (1L<<10) |
    (1L<<28),
    unicode_doc,
    0,
    0,
    PyUnicode_RichCompare,
    0,
    unicode_iter,
    0,
    unicode_methods,
    0,
    0,
    &PyBaseObject_Type,
    0,
    0,
    0,
    0,
    0,
    0,
    unicode_new,
    PyObject_Free,
};



int _PyUnicode_Init(void)
{

    Py_UCS2 linebreak[] = {
        0x000A,
        0x000D,
        0x001C,
        0x001D,
        0x001E,
        0x0085,
        0x2028,
        0x2029,
    };


    do { if (unicode_empty != ((void *)0)) ( ((PyObject*)(unicode_empty))->ob_refcnt++); else { unicode_empty = PyUnicode_New(0, 0); if (unicode_empty != ((void *)0)) { ( ((PyObject*)(unicode_empty))->ob_refcnt++); (__builtin_expect(!(_PyUnicode_CheckConsistency(unicode_empty, 1)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14145, "_PyUnicode_CheckConsistency(unicode_empty, 1)") : (void)0); } } } while (0);
    if (!unicode_empty)
        Py_FatalError("Can't create empty string");
    do { if ( --((PyObject*)(unicode_empty))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(unicode_empty)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(unicode_empty)))); } while (0);

    if (PyType_Ready(&PyUnicode_Type) < 0)
        Py_FatalError("Can't initialize 'unicode'");


    bloom_linebreak = make_bloom_mask(
        PyUnicode_2BYTE_KIND, linebreak,
        (sizeof(linebreak) / sizeof((linebreak)[0]) + (sizeof(char [1 - 2*!(!__builtin_types_compatible_p(typeof(linebreak), typeof(&(linebreak)[0])))]) - 1)));

    PyType_Ready(&EncodingMapType);

    if (PyType_Ready(&PyFieldNameIter_Type) < 0)
        Py_FatalError("Can't initialize field name iterator type");

    if (PyType_Ready(&PyFormatterIter_Type) < 0)
        Py_FatalError("Can't initialize formatter iter type");
# 14173 "unicodeobject.c"
    return 0;
}



int
PyUnicode_ClearFreeList(void)
{
    return 0;
}

void
_PyUnicode_Fini(void)
{
    int i;

    do { if (unicode_empty) { PyObject *_py_tmp = (PyObject *)(unicode_empty); (unicode_empty) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);

    for (i = 0; i < 256; i++)
        do { if (unicode_latin1[i]) { PyObject *_py_tmp = (PyObject *)(unicode_latin1[i]); (unicode_latin1[i]) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
    _PyUnicode_ClearStaticStrings();
    (void)PyUnicode_ClearFreeList();
}

void
PyUnicode_InternInPlace(PyObject **p)
{
    register PyObject *s = *p;
    PyObject *t;




    if (s == ((void *)0) || !((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0))
        return;



    if (!((((PyObject*)(s))->ob_type) == &PyUnicode_Type))
        return;
    if ((((PyASCIIObject *)(s))->state.interned))
        return;
    if (interned == ((void *)0)) {
        interned = PyDict_New();
        if (interned == ((void *)0)) {
            PyErr_Clear();
            return;
        }
    }



    do { unsigned char _old = ((PyThreadState*)__extension__ ({ __typeof__(&_PyThreadState_Current) atomic_val = &_PyThreadState_Current; __typeof__(atomic_val->_value) result; volatile __typeof__(result) *volatile_data = &atomic_val->_value; _Py_memory_order order = _Py_memory_order_relaxed; _Py_ANNOTATE_MEMORY_ORDER(atomic_val, order); ; switch(order) { case _Py_memory_order_release: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_thread_fence(_Py_memory_order_release); break; default: break; } result = *volatile_data; switch(order) { case _Py_memory_order_acquire: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_signal_fence(_Py_memory_order_acquire); break; default: break; } ; result; }))->recursion_critical; ((PyThreadState*)__extension__ ({ __typeof__(&_PyThreadState_Current) atomic_val = &_PyThreadState_Current; __typeof__(atomic_val->_value) result; volatile __typeof__(result) *volatile_data = &atomic_val->_value; _Py_memory_order order = _Py_memory_order_relaxed; _Py_ANNOTATE_MEMORY_ORDER(atomic_val, order); ; switch(order) { case _Py_memory_order_release: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_thread_fence(_Py_memory_order_release); break; default: break; } result = *volatile_data; switch(order) { case _Py_memory_order_acquire: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_signal_fence(_Py_memory_order_acquire); break; default: break; } ; result; }))->recursion_critical = 1;
    t = PyDict_GetItem(interned, s);
    ((PyThreadState*)__extension__ ({ __typeof__(&_PyThreadState_Current) atomic_val = &_PyThreadState_Current; __typeof__(atomic_val->_value) result; volatile __typeof__(result) *volatile_data = &atomic_val->_value; _Py_memory_order order = _Py_memory_order_relaxed; _Py_ANNOTATE_MEMORY_ORDER(atomic_val, order); ; switch(order) { case _Py_memory_order_release: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_thread_fence(_Py_memory_order_release); break; default: break; } result = *volatile_data; switch(order) { case _Py_memory_order_acquire: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_signal_fence(_Py_memory_order_acquire); break; default: break; } ; result; }))->recursion_critical = _old; } while(0);

        if (t) {
            ( ((PyObject*)(t))->ob_refcnt++);
            do { if ( --((PyObject*)(*p))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(*p)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(*p)))); } while (0);
            *p = t;
            return;
        }

    ((PyThreadState*)__extension__ ({ __typeof__(&_PyThreadState_Current) atomic_val = &_PyThreadState_Current; __typeof__(atomic_val->_value) result; volatile __typeof__(result) *volatile_data = &atomic_val->_value; _Py_memory_order order = _Py_memory_order_relaxed; _Py_ANNOTATE_MEMORY_ORDER(atomic_val, order); ; switch(order) { case _Py_memory_order_release: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_thread_fence(_Py_memory_order_release); break; default: break; } result = *volatile_data; switch(order) { case _Py_memory_order_acquire: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_signal_fence(_Py_memory_order_acquire); break; default: break; } ; result; }))->recursion_critical = 1;
    if (PyDict_SetItem(interned, s, s) < 0) {
        PyErr_Clear();
        ((PyThreadState*)__extension__ ({ __typeof__(&_PyThreadState_Current) atomic_val = &_PyThreadState_Current; __typeof__(atomic_val->_value) result; volatile __typeof__(result) *volatile_data = &atomic_val->_value; _Py_memory_order order = _Py_memory_order_relaxed; _Py_ANNOTATE_MEMORY_ORDER(atomic_val, order); ; switch(order) { case _Py_memory_order_release: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_thread_fence(_Py_memory_order_release); break; default: break; } result = *volatile_data; switch(order) { case _Py_memory_order_acquire: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_signal_fence(_Py_memory_order_acquire); break; default: break; } ; result; }))->recursion_critical = 0;
        return;
    }
    ((PyThreadState*)__extension__ ({ __typeof__(&_PyThreadState_Current) atomic_val = &_PyThreadState_Current; __typeof__(atomic_val->_value) result; volatile __typeof__(result) *volatile_data = &atomic_val->_value; _Py_memory_order order = _Py_memory_order_relaxed; _Py_ANNOTATE_MEMORY_ORDER(atomic_val, order); ; switch(order) { case _Py_memory_order_release: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_thread_fence(_Py_memory_order_release); break; default: break; } result = *volatile_data; switch(order) { case _Py_memory_order_acquire: case _Py_memory_order_acq_rel: case _Py_memory_order_seq_cst: _Py_atomic_signal_fence(_Py_memory_order_acquire); break; default: break; } ; result; }))->recursion_critical = 0;


    (((PyObject*)(s))->ob_refcnt) -= 2;
    (((PyASCIIObject *)(s))->state).interned = 1;
}

void
PyUnicode_InternImmortal(PyObject **p)
{
    PyUnicode_InternInPlace(p);
    if ((((PyASCIIObject *)(*p))->state.interned) != 2) {
        (((PyASCIIObject *)(*p))->state).interned = 2;
        ( ((PyObject*)(*p))->ob_refcnt++);
    }
}

PyObject *
PyUnicode_InternFromString(const char *cp)
{
    PyObject *s = PyUnicode_FromString(cp);
    if (s == ((void *)0))
        return ((void *)0);
    PyUnicode_InternInPlace(&s);
    return s;
}

void
_Py_ReleaseInternedUnicodeStrings(void)
{
    PyObject *keys;
    PyObject *s;
    Py_ssize_t i, n;
    Py_ssize_t immortal_size = 0, mortal_size = 0;

    if (interned == ((void *)0) || !((((((PyObject*)(interned))->ob_type))->tp_flags & ((1L<<29))) != 0))
        return;
    keys = PyDict_Keys(interned);
    if (keys == ((void *)0) || !((((((PyObject*)(keys))->ob_type))->tp_flags & ((1L<<25))) != 0)) {
        PyErr_Clear();
        return;
    }






    n = (((PyVarObject*)(keys))->ob_size);
    fprintf(__stderrp, "releasing %" "l" "d interned strings\n",
            n);
    for (i = 0; i < n; i++) {
        s = (((PyListObject *)(keys))->ob_item[i]);
        if (((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14295, "_PyUnicode_CHECK(s)") : (void)0), ((((PyASCIIObject*)s)->state.ready) ? 0 : _PyUnicode_Ready(s))) == -1) {
            (__builtin_expect(!(0 && "could not ready string"), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14296, "0 && \"could not ready string\"") : (void)0);
            fprintf(__stderrp, "could not ready string\n");
        }
        switch ((((PyASCIIObject *)(s))->state.interned)) {
        case 0:

            break;
        case 2:
            (((PyObject*)(s))->ob_refcnt) += 1;
            immortal_size += ((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14305, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14305, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject *)(s))->length);
            break;
        case 1:
            (((PyObject*)(s))->ob_refcnt) += 2;
            mortal_size += ((__builtin_expect(!(((((((PyObject*)(s))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14309, "PyUnicode_Check(s)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)s)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14309, "PyUnicode_IS_READY(s)") : (void)0), ((PyASCIIObject *)(s))->length);
            break;
        default:
            Py_FatalError("Inconsistent interned string state.");
        }
        (((PyASCIIObject *)(s))->state).interned = 0;
    }
    fprintf(__stderrp, "total size of all interned strings: "
            "%" "l" "d/%" "l" "d "
            "mortal/immortal\n", mortal_size, immortal_size);
    do { if ( --((PyObject*)(keys))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(keys)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(keys)))); } while (0);
    PyDict_Clear(interned);
    do { if (interned) { PyObject *_py_tmp = (PyObject *)(interned); (interned) = ((void *)0); do { if ( --((PyObject*)(_py_tmp))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(_py_tmp)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(_py_tmp)))); } while (0); } } while (0);
}




typedef struct {
    PyObject ob_base;
    Py_ssize_t it_index;
    PyObject *it_seq;
} unicodeiterobject;

static void
unicodeiter_dealloc(unicodeiterobject *it)
{
    do { PyGC_Head *g = ((PyGC_Head *)(it)-1); (__builtin_expect(!(g->gc.gc_refs != (-2)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14336, "g->gc.gc_refs != _PyGC_REFS_UNTRACKED") : (void)0); g->gc.gc_refs = (-2); g->gc.gc_prev->gc.gc_next = g->gc.gc_next; g->gc.gc_next->gc.gc_prev = g->gc.gc_prev; g->gc.gc_next = ((void *)0); } while (0);;
    do { if ((it->it_seq) == ((void *)0)) ; else do { if ( --((PyObject*)(it->it_seq))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(it->it_seq)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(it->it_seq)))); } while (0); } while (0);
    PyObject_GC_Del(it);
}

static int
unicodeiter_traverse(unicodeiterobject *it, visitproc visit, void *arg)
{
    do { if (it->it_seq) { int vret = visit((PyObject *)(it->it_seq), arg); if (vret) return vret; } } while (0);
    return 0;
}

static PyObject *
unicodeiter_next(unicodeiterobject *it)
{
    PyObject *seq, *item;

    (__builtin_expect(!(it != ((void *)0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14353, "it != NULL") : (void)0);
    seq = it->it_seq;
    if (seq == ((void *)0))
        return ((void *)0);
    (__builtin_expect(!(((((((PyObject*)(seq))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14357, "_PyUnicode_CHECK(seq)") : (void)0);

    if (it->it_index < ((__builtin_expect(!(((((((PyObject*)(seq))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14359, "PyUnicode_Check(seq)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)seq)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14359, "PyUnicode_IS_READY(seq)") : (void)0), ((PyASCIIObject *)(seq))->length)) {
        int kind = ((__builtin_expect(!(((((((PyObject*)(seq))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14360, "PyUnicode_Check(seq)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)seq)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14360, "PyUnicode_IS_READY(seq)") : (void)0), ((PyASCIIObject *)(seq))->state.kind);
        void *data = ((__builtin_expect(!(((((((PyObject*)(seq))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14361, "PyUnicode_Check(seq)") : (void)0), (((PyASCIIObject*)(seq))->state.compact) ? (((__builtin_expect(!(((((((PyObject*)(seq))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14361, "PyUnicode_Check(seq)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)seq)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14361, "PyUnicode_IS_READY(seq)") : (void)0), ((PyASCIIObject*)seq)->state.ascii) ? ((void*)((PyASCIIObject*)(seq) + 1)) : ((void*)((PyCompactUnicodeObject*)(seq) + 1))) : ((__builtin_expect(!(((PyUnicodeObject*)(seq))->data.any), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14361, "((PyUnicodeObject*)(seq))->data.any") : (void)0), ((((PyUnicodeObject *)(seq))->data.any))));
        Py_UCS4 chr = ((Py_UCS4) ((kind) == PyUnicode_1BYTE_KIND ? ((const Py_UCS1 *)(data))[(it->it_index)] : ((kind) == PyUnicode_2BYTE_KIND ? ((const Py_UCS2 *)(data))[(it->it_index)] : ((const Py_UCS4 *)(data))[(it->it_index)] ) ));
        item = PyUnicode_FromOrdinal(chr);
        if (item != ((void *)0))
            ++it->it_index;
        return item;
    }

    do { if ( --((PyObject*)(seq))->ob_refcnt != 0) ; else ( (*(((PyObject*)((PyObject *)(seq)))->ob_type)->tp_dealloc)((PyObject *)((PyObject *)(seq)))); } while (0);
    it->it_seq = ((void *)0);
    return ((void *)0);
}

static PyObject *
unicodeiter_len(unicodeiterobject *it)
{
    Py_ssize_t len = 0;
    if (it->it_seq)
        len = ((__builtin_expect(!(((((((PyObject*)(it->it_seq))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14379, "PyUnicode_Check(it->it_seq)") : (void)0), (__builtin_expect(!((((PyASCIIObject*)it->it_seq)->state.ready)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14379, "PyUnicode_IS_READY(it->it_seq)") : (void)0), ((PyASCIIObject *)(it->it_seq))->length) - it->it_index;
    return PyLong_FromSsize_t(len);
}

static char length_hint_doc[] = "Private method returning an estimate of len(list(it)).";

static PyObject *
unicodeiter_reduce(unicodeiterobject *it)
{
    if (it->it_seq != ((void *)0)) {
        return _Py_BuildValue_SizeT("N(O)n", _PyObject_GetBuiltin("iter"),
                             it->it_seq, it->it_index);
    } else {
        PyObject *u = PyUnicode_FromUnicode(((void *)0), 0);
        if (u == ((void *)0))
            return ((void *)0);
        return _Py_BuildValue_SizeT("N(N)", _PyObject_GetBuiltin("iter"), u);
    }
}

static char reduce_doc[] = "Return state information for pickling.";

static PyObject *
unicodeiter_setstate(unicodeiterobject *it, PyObject *state)
{
    Py_ssize_t index = PyLong_AsSsize_t(state);
    if (index == -1 && PyErr_Occurred())
        return ((void *)0);
    if (index < 0)
        index = 0;
    it->it_index = index;
    return ( ((PyObject*)((&_Py_NoneStruct)))->ob_refcnt++), (&_Py_NoneStruct);
}

static char setstate_doc[] = "Set state information for unpickling.";

static PyMethodDef unicodeiter_methods[] = {
    {"__length_hint__", (PyCFunction)unicodeiter_len, 0x0004,
     length_hint_doc},
    {"__reduce__", (PyCFunction)unicodeiter_reduce, 0x0004,
     reduce_doc},
    {"__setstate__", (PyCFunction)unicodeiter_setstate, 0x0008,
     setstate_doc},
    {((void *)0), ((void *)0)}
};

PyTypeObject PyUnicodeIter_Type = {
    { { 1, &PyType_Type }, 0 },
    "str_iterator",
    sizeof(unicodeiterobject),
    0,

    (destructor)unicodeiter_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    PyObject_GenericGetAttr,
    0,
    0,
    ( 0 | (1L<<18) | 0) | (1L<<14),
    0,
    (traverseproc)unicodeiter_traverse,
    0,
    0,
    0,
    PyObject_SelfIter,
    (iternextfunc)unicodeiter_next,
    unicodeiter_methods,
    0,
};

static PyObject *
unicode_iter(PyObject *seq)
{
    unicodeiterobject *it;

    if (!((((((PyObject*)(seq))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        _PyErr_BadInternalCall("unicodeobject.c", 14464);
        return ((void *)0);
    }
    if (((__builtin_expect(!(((((((PyObject*)(seq))->ob_type))->tp_flags & ((1L<<28))) != 0)), 0) ? __assert_rtn(__func__, "unicodeobject.c", 14467, "_PyUnicode_CHECK(seq)") : (void)0), ((((PyASCIIObject*)seq)->state.ready) ? 0 : _PyUnicode_Ready(seq))) == -1)
        return ((void *)0);
    it = ( (unicodeiterobject *) _PyObject_GC_New(&PyUnicodeIter_Type) );
    if (it == ((void *)0))
        return ((void *)0);
    it->it_index = 0;
    ( ((PyObject*)(seq))->ob_refcnt++);
    it->it_seq = seq;
    do { PyGC_Head *g = ((PyGC_Head *)(it)-1); if (g->gc.gc_refs != (-2)) Py_FatalError("GC object already tracked"); g->gc.gc_refs = (-3); g->gc.gc_next = _PyGC_generation0; g->gc.gc_prev = _PyGC_generation0->gc.gc_prev; g->gc.gc_prev->gc.gc_next = g; _PyGC_generation0->gc.gc_prev = g; } while (0);;
    return (PyObject *)it;
}


size_t
Py_UNICODE_strlen(const Py_UNICODE *u)
{
    int res = 0;
    while(*u++)
        res++;
    return res;
}

Py_UNICODE*
Py_UNICODE_strcpy(Py_UNICODE *s1, const Py_UNICODE *s2)
{
    Py_UNICODE *u = s1;
    while ((*u++ = *s2++));
    return s1;
}

Py_UNICODE*
Py_UNICODE_strncpy(Py_UNICODE *s1, const Py_UNICODE *s2, size_t n)
{
    Py_UNICODE *u = s1;
    while ((*u++ = *s2++))
        if (n-- == 0)
            break;
    return s1;
}

Py_UNICODE*
Py_UNICODE_strcat(Py_UNICODE *s1, const Py_UNICODE *s2)
{
    Py_UNICODE *u1 = s1;
    u1 += Py_UNICODE_strlen(u1);
    Py_UNICODE_strcpy(u1, s2);
    return s1;
}

int
Py_UNICODE_strcmp(const Py_UNICODE *s1, const Py_UNICODE *s2)
{
    while (*s1 && *s2 && *s1 == *s2)
        s1++, s2++;
    if (*s1 && *s2)
        return (*s1 < *s2) ? -1 : +1;
    if (*s1)
        return 1;
    if (*s2)
        return -1;
    return 0;
}

int
Py_UNICODE_strncmp(const Py_UNICODE *s1, const Py_UNICODE *s2, size_t n)
{
    register Py_UNICODE u1, u2;
    for (; n != 0; n--) {
        u1 = *s1;
        u2 = *s2;
        if (u1 != u2)
            return (u1 < u2) ? -1 : +1;
        if (u1 == '\0')
            return 0;
        s1++;
        s2++;
    }
    return 0;
}

Py_UNICODE*
Py_UNICODE_strchr(const Py_UNICODE *s, Py_UNICODE c)
{
    const Py_UNICODE *p;
    for (p = s; *p; p++)
        if (*p == c)
            return (Py_UNICODE*)p;
    return ((void *)0);
}

Py_UNICODE*
Py_UNICODE_strrchr(const Py_UNICODE *s, Py_UNICODE c)
{
    const Py_UNICODE *p;
    p = s + Py_UNICODE_strlen(s);
    while (p != s) {
        p--;
        if (*p == c)
            return (Py_UNICODE*)p;
    }
    return ((void *)0);
}

Py_UNICODE*
PyUnicode_AsUnicodeCopy(PyObject *unicode)
{
    Py_UNICODE *u, *copy;
    Py_ssize_t len, size;

    if (!((((((PyObject*)(unicode))->ob_type))->tp_flags & ((1L<<28))) != 0)) {
        PyErr_BadArgument();
        return ((void *)0);
    }
    u = PyUnicode_AsUnicodeAndSize(unicode, &len);
    if (u == ((void *)0))
        return ((void *)0);

    if (len > ((((Py_ssize_t)(((size_t)-1)>>1)) / sizeof(Py_UNICODE)) - 1)) {
        PyErr_NoMemory();
        return ((void *)0);
    }
    size = len + 1;
    size *= sizeof(Py_UNICODE);
    copy = PyMem_Malloc(size);
    if (copy == ((void *)0)) {
        PyErr_NoMemory();
        return ((void *)0);
    }
    ((__builtin_object_size (copy, 0) != (size_t) -1) ? __builtin___memcpy_chk (copy, u, size, __builtin_object_size (copy, 0)) : __inline_memcpy_chk (copy, u, size));
    return copy;
}




static PyMethodDef _string_methods[] = {
    {"formatter_field_name_split", (PyCFunction) formatter_field_name_split,
     0x0008, "split the argument as a field name"},
    {"formatter_parser", (PyCFunction) formatter_parser,
     0x0008, "parse the argument as a format string"},
    {((void *)0), ((void *)0)}
};

static struct PyModuleDef _string_module = {
    { { 1, ((void *)0) }, ((void *)0), 0, ((void *)0), },
    "_string",
    "string helper module",
    0,
    _string_methods,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0)
};

PyObject*
PyInit__string(void)
{
    return PyModule_Create2(&_string_module, 1013);
}
